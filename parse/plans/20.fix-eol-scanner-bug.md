# Fix: TreeSitter scanner's `scan_section_break` consuming EOL tokens

## Table of Contents

1. [Root cause analysis](#root-cause-analysis)
2. [Preconditions and assumptions](#preconditions-and-assumptions)
3. [The fix](#the-fix)
4. [Changes to `scan_section_break`](#changes-to-scan_section_break)
5. [Changes to the dispatch block](#changes-to-the-dispatch-block)
6. [Changes to C unit tests](#changes-to-c-unit-tests)
7. [Verification](#verification)
8. [To do](#to-do)

## Root cause analysis

Because TreeSitter's external scanner cannot backtrack (any `ADVANCE()` call permanently moves the cursor), `scan_section_break` in `scanner.c:1251-1272` consumes the first `\n` when checking for a blank line. If no second `\n` follows, the function returns `false` without emitting any token. The consumed newline is lost.

The dispatch order in the top-level `scan` function (line 1332 before line 1340) means `scan_section_break` is called before `scan_eol`. With GLR parsing and declared conflicts, `valid_symbols[TT_SCT_BRK]` is true even inside Tune_header/Tune_Body contexts (because it is the union across all parser stacks). After `scan_section_break` fails and returns false, `scan_eol` finds the cursor past the `\n` and also fails.

Result: single newlines are never tokenized as EOL, which breaks all cross-comparison tests (807 example_scores files, 5 token comparison tests, 22 AST comparison tests).

## Preconditions and assumptions

MARK_END semantics: When the external scanner calls `MARK_END`, the token boundary is set at that position. If `scan` returns true, the next call starts from the MARK_END position. If `scan` returns false but `MARK_END` was called, the next scan starts at the MARK_END position (not the original). If `MARK_END` was never called during the scan, the next scan starts at the same position as the current call (effectively "no progress").

Grammar structure guarantee: In `grammar.js`, `TT_SCT_BRK` only appears in `File_structure`'s choice list, which also includes `$._EOL`. Therefore, whenever `valid_symbols[TT_SCT_BRK]` is true (even via GLR union), `valid_symbols[TT_EOL]` is also true. The case "SCT_BRK valid but EOL not valid" is unreachable given the grammar's structure.

This means the `return false` path at the bottom of the new function (where MARK_END was called but neither token is emitted) is unreachable in production. The newline is consumed silently only in this theoretical case, which the dispatch guard makes impossible.

## The fix

We modify `scan_section_break` to accept the `valid_symbols` array and emit an EOL token as a fallback when only a single newline is found. The separate `scan_eol` dispatch entry and function are removed, since all newline handling is consolidated into the updated function.

## Changes to `scan_section_break`

File: `tree-sitter-abc/src/scanner.c`, lines 1251-1272

New signature:
```c
static bool scan_section_break(TSLexer *lexer, ScannerState *state, const bool *valid_symbols)
```

New body (pseudo-code):
```
if PEEK is not \n and not \r → return false

// consume first newline (\r?\n)
if PEEK == '\r' → ADVANCE
if PEEK != '\n' → return false   // bare \r without \n: no MARK_END, cursor resets on retry
ADVANCE
line_number++
MARK_END  // mark position after first newline

// only attempt section break detection if SCT_BRK is valid
if valid_symbols[TT_SCT_BRK]:
  if PEEK == '\r' → ADVANCE  // lookahead past optional \r (does not move MARK_END)
  if PEEK == '\n':
    ADVANCE
    line_number++
    MARK_END  // extend to include second newline
    EMIT(TT_SCT_BRK)

// fallback: emit EOL if valid (MARK_END is still at first newline's end)
if valid_symbols[TT_EOL]:
  EMIT(TT_EOL)

return false  // unreachable in production (see preconditions)
```

Key points about MARK_END:
- The first MARK_END is placed right after consuming the first `\n`. This is the token boundary for EOL.
- When checking for section break, any ADVANCE past `\r` or the second `\n` is "lookahead" relative to the first MARK_END. These advances do not change where the token ends.
- We only call MARK_END again (extending the token to include the second newline) immediately before emitting SCT_BRK.
- If SCT_BRK is not valid, the second-newline lookahead is skipped entirely. The second newline is left for the next scan call.
- In the EOL fallback path, the MARK_END from after the first `\n` is still in effect, so the EOL token covers only the first newline.

Behavior by case:
- Double newline, SCT_BRK valid: emits SCT_BRK covering both newlines (previous behavior preserved)
- Double newline, SCT_BRK not valid, EOL valid: emits EOL covering only the first newline (next scan sees the second `\n`)
- Single newline, EOL valid: emits EOL (the fix for the bug)
- Bare `\r` without `\n`: returns false immediately, no MARK_END called (cursor resets to start)
- Neither SCT_BRK nor EOL valid: unreachable via dispatch guard; if called directly (tests), returns false with MARK_END after first `\n`

Edge case: `\n\rA` (LF then bare CR then non-newline) with SCT_BRK valid:
1. Consume `\n`, MARK_END at position 1
2. SCT_BRK check: PEEK is `\r`, ADVANCE (lookahead to position 2). PEEK is `A`, not `\n`. SCT_BRK not emitted.
3. EOL fallback: EMIT(TT_EOL). Token spans [0,1) using the first MARK_END.
4. Next scan starts at position 1 (MARK_END). The `\rA` is re-read.

## Changes to the dispatch block

File: `tree-sitter-abc/src/scanner.c`, lines 1332 and 1340

Replace these two lines:
```c
// Line 1332:
if (valid_symbols[TT_SCT_BRK] && scan_section_break(lexer, state)) return true;
// ...
// Line 1340:
if (valid_symbols[TT_EOL] && scan_eol(lexer, state)) return true;
```

With a single combined check:
```c
if ((valid_symbols[TT_SCT_BRK] || valid_symbols[TT_EOL]) &&
    scan_section_break(lexer, state, valid_symbols)) return true;
```

Remove the `scan_eol` function (lines 108-122) entirely. Its logic is subsumed by the updated `scan_section_break`.

## Changes to C unit tests

File: `tree-sitter-abc/tests/test_whitespace.c`

### Existing `scan_eol` tests → convert to `scan_section_break` tests

The four existing `scan_eol` tests are replaced by equivalent tests through `scan_section_break`:

- `test_scan_eol_lf` → `test_scan_section_break_single_lf_emits_eol` (input `\n`, valid: EOL, assert TT_EOL and line_number==2)
- `test_scan_eol_crlf` → `test_scan_section_break_single_crlf_emits_eol` (input `\r\n`, valid: EOL, assert TT_EOL, line_number==2, pos==2)
- `test_scan_eol_invalid` → `test_scan_section_break_non_newline` (input `A`, valid: EOL+SCT_BRK, assert false, pos==0)
- `test_scan_eol_cr_alone` → `test_scan_section_break_bare_cr` (input `\rA`, valid: EOL+SCT_BRK, assert false, pos==1 consumed but no MARK_END so effectively undone by runtime)

### Updated existing `scan_section_break` tests

Add `valid_symbols` arrays. All existing double-newline tests pass `valid_symbols` with `TT_SCT_BRK = true`:

```c
void test_scan_section_break_double_newline() {
  TSLexer lexer = create_test_lexer("\n\n");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_SCT_BRK] = true;
  valid[TT_EOL] = true;
  ASSERT_TRUE(scan_section_break(&lexer, &state, valid));
  ASSERT_EQ(TT_SCT_BRK, lexer.result_symbol);
  ASSERT_EQ(3, state.line_number);
}
```

Same pattern for `test_scan_section_break_crlf_crlf`.

### New tests for the fallback behavior

1. Single `\n` with both valid → emits EOL, line_number==2:
```c
void test_scan_section_break_single_newline_emits_eol() {
  TSLexer lexer = create_test_lexer("\nA");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_SCT_BRK] = true;
  valid[TT_EOL] = true;
  ASSERT_TRUE(scan_section_break(&lexer, &state, valid));
  ASSERT_EQ(TT_EOL, lexer.result_symbol);
  ASSERT_EQ(2, state.line_number);
}
```

2. Single `\n` with only SCT_BRK valid → returns false (unreachable in production but tests edge):
```c
void test_scan_section_break_single_newline_no_eol_valid() {
  TSLexer lexer = create_test_lexer("\nA");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_SCT_BRK] = true;
  ASSERT_FALSE(scan_section_break(&lexer, &state, valid));
}
```

3. Double `\n\n` with only EOL valid → emits EOL (first newline only), line_number==2:
```c
void test_scan_section_break_double_newline_only_eol_valid() {
  TSLexer lexer = create_test_lexer("\n\n");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_EOL] = true;
  ASSERT_TRUE(scan_section_break(&lexer, &state, valid));
  ASSERT_EQ(TT_EOL, lexer.result_symbol);
  ASSERT_EQ(2, state.line_number);
}
```

4. Single CRLF with both valid → emits EOL:
```c
void test_scan_section_break_single_crlf_emits_eol() {
  TSLexer lexer = create_test_lexer("\r\nA");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_SCT_BRK] = true;
  valid[TT_EOL] = true;
  ASSERT_TRUE(scan_section_break(&lexer, &state, valid));
  ASSERT_EQ(TT_EOL, lexer.result_symbol);
  ASSERT_EQ(2, state.line_number);
}
```

5. `\n\rA` with SCT_BRK valid → emits EOL (lookahead past `\r` does not affect token):
```c
void test_scan_section_break_lf_cr_nonewline_emits_eol() {
  TSLexer lexer = create_test_lexer("\n\rA");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_SCT_BRK] = true;
  valid[TT_EOL] = true;
  ASSERT_TRUE(scan_section_break(&lexer, &state, valid));
  ASSERT_EQ(TT_EOL, lexer.result_symbol);
  ASSERT_EQ(2, state.line_number);
}
```

6. `\n` at EOF with EOL valid → emits EOL:
```c
void test_scan_section_break_lf_at_eof_emits_eol() {
  TSLexer lexer = create_test_lexer("\n");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_EOL] = true;
  ASSERT_TRUE(scan_section_break(&lexer, &state, valid));
  ASSERT_EQ(TT_EOL, lexer.result_symbol);
  ASSERT_EQ(2, state.line_number);
}
```

7. Non-newline input → returns false immediately (unchanged):
```c
void test_scan_section_break_not_newline() {
  TSLexer lexer = create_test_lexer("A");
  ScannerState state = create_test_state();
  bool valid[TT_COUNT] = {0};
  valid[TT_SCT_BRK] = true;
  valid[TT_EOL] = true;
  ASSERT_FALSE(scan_section_break(&lexer, &state, valid));
  ASSERT_EQ(0, get_current_pos());
}
```

## Verification

1. Compile and run C unit tests: `cd tree-sitter-abc/tests && gcc -o test_whitespace test_whitespace.c -I../src && ./test_whitespace`
2. Regenerate the parser: `cd tree-sitter-abc && npx tree-sitter generate`
3. Rebuild the native module: `cd tree-sitter-abc && node-gyp rebuild`
4. Rebuild the tree-sitter runtime: `cd node_modules/tree-sitter && node-gyp rebuild`
5. Run the TypeScript comparison tests: `npm run test` from the parse directory
6. Verify that cross-comparison tests pass (token_comparison.spec.ts and ast_comparison.spec.ts)
7. Run the example_scores tests to check overall pass rate

## To do

- [ ] Modify `scan_section_break` function signature to accept `const bool *valid_symbols`
- [ ] Add `MARK_END()` after consuming the first newline
- [ ] Add conditional SCT_BRK detection (only if `valid_symbols[TT_SCT_BRK]`)
- [ ] Add EOL fallback emission when second newline is not found
- [ ] Update dispatch block: merge SCT_BRK and EOL checks into single combined call
- [ ] Remove the separate `scan_eol` dispatch line
- [ ] Remove the now-dead `scan_eol` function
- [ ] Convert existing `scan_eol` unit tests to test through `scan_section_break`
- [ ] Update existing `scan_section_break` unit tests to pass `valid_symbols`
- [ ] Add new unit tests for fallback behavior (7 tests listed above)
- [ ] Compile and run C unit tests
- [ ] Regenerate TreeSitter parser and rebuild native modules
- [ ] Run cross-comparison tests to verify the fix
- [ ] Call the code review agent and address its feedback
- [ ] Commit only after the code review feedback has been fully addressed and all tests pass
