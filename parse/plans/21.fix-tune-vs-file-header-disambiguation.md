# Fix: TreeSitter grammar fails to disambiguate Tune from File_header

## Table of Contents

1. [Problem statement](#problem-statement)
2. [Root cause analysis](#root-cause-analysis)
3. [Why X: is the disambiguation key](#why-x-is-the-disambiguation-key)
4. [Proposed solution](#proposed-solution)
5. [Scanner changes](#scanner-changes)
6. [Grammar changes](#grammar-changes)
7. [Secondary issue: info line content tokenization](#secondary-issue-info-line-content-tokenization)
8. [To do](#to-do)

## Problem statement

All 807 example_scores files fail the TreeSitter vs TypeScript comparison test. The TreeSitter parser wraps entire files in a `File_header` node instead of producing the expected `Tune` nodes. The TypeScript parser correctly produces `File_structure > Tune > Tune_header + Tune_Body`, while the TreeSitter parser produces `File_structure > File_header`.

Evidence:
- `X:1\nK:C\nCDE|\n` produces Tune (the minimal case works)
- `X:1\nT:Test\nK:C\nCDE|\n` produces File_header (adding T: breaks it)
- `X:1\nQ:120\nK:C\nCDE|\n` produces Tune (numeric-only content works)
- `X:1\nM:4/4\nK:C\nCDE|\n` produces Tune (M: with numeric content works)

## Root cause analysis

The grammar defines `File_header` and `Tune_header` with identical structure:

```
File_header: $ => repeat1(choice(
  $.Info_line, $.Directive, $.Comment, $.Macro_decl, ...
))

Tune_header: $ => repeat1(choice(
  $.Info_line, $.Comment, $.Directive, $.Macro_decl, ...
))
```

Because these rules are structurally identical, the parser relies on GLR conflict resolution to choose between them. Multiple conflicts are declared:

```
[$.File_header, $.Tune_header],
[$.File_structure, $.File_header, $.Tune_header],
```

The GLR parser maintains both parse stacks until one path encounters a token that cannot be reduced. The problem arises because the scanner's dispatch order causes alphabetic characters in info line content to be tokenized as `NOTE_LETTER` or `IDENTIFIER` tokens rather than `INFO_STR`. These tokens are valid in both `_info_line_content` (via `AbsolutePitch` and `IDENTIFIER` alternatives) and in `Music_code` (via `Note > Pitch > NOTE_LETTER`). The ambiguity between these two interpretations causes TreeSitter's GLR resolver to prefer the `File_header` path.

Specifically, this is the chain of events:

1. The scanner sees `T:` at the start of a line and emits `INF_HDR`
2. After INF_HDR, the grammar expects `_info_line_content` or `WS`
3. `_info_line_content` includes `AbsolutePitch`, `IDENTIFIER`, `NUMBER`, `INFO_STR`, and others
4. For the next character (e.g., "A" in "After"), the scanner has both `NOTE_LETTER` and `INFO_STR` as valid symbols
5. Because `NOTE_LETTER` is dispatched at line 1376 in the scanner and `INFO_STR` at line 1475, `NOTE_LETTER` wins
6. The emitted `NOTE_LETTER` is valid in both the `_info_line_content` context (as AbsolutePitch) and in a potential `Music_code` context
7. This ambiguity prevents the GLR parser from disambiguating Tune from File_header, and the resolver defaults to File_header

## Why X: is the disambiguation key

In the ABC notation standard, the `X:` (reference number) field is the definitive and unique marker of a tune's start. It has these properties:

- It ONLY appears at the start of a tune, never in a file-level header
- Every tune MUST begin with an `X:` field
- It is the ONLY info line type that is exclusive to tunes

This makes `X:` the natural disambiguation point: any sequence of info lines that begins with `X:` is unambiguously a `Tune_header`, not a `File_header`.

## Proposed solution

Introduce a dedicated scanner token for the `X:` info header, and use it in the grammar to make `Tune_header` structurally distinct from `File_header`.

### Overview

1. Add a new token type `TT_X_INFO_HDR` to the scanner's token enum
2. Modify the scanner's `scan_info_header` to emit `TT_X_INFO_HDR` when it encounters `X:` (instead of `TT_INF_HDR`)
3. Add an `X_info_line` grammar rule that starts with `X_INFO_HDR`
4. Restructure `Tune_header` to require an `X_info_line` as its first element
5. Exclude `X_info_line` from `File_header`

This makes the parser unambiguously identify a Tune the moment it sees `X:`, without relying on GLR conflict resolution.

## Scanner changes

File: `tree-sitter-abc/src/scanner.c`

### Token enum

Add `TT_X_INFO_HDR` to the token enum (the position must match the grammar's `externals` list):

```c
TT_X_INFO_HDR,  // X: specifically (tune reference number)
```

### scan_info_header modification

Currently (line 456-481):
```c
static bool scan_info_header(TSLexer *lexer, const bool *valid_symbols) {
  if (!is_alpha(PEEK)) return false;
  MARK_END();
  ADVANCE();  // Consume alpha
  if (PEEK == ':') {
    ADVANCE();
    MARK_END();
    EMIT(TT_INF_HDR);
  }
  ...
}
```

The modification checks whether the consumed alpha is 'X' or 'x' and whether `TT_X_INFO_HDR` is in the valid symbols:

```
scan_info_header:
  if PEEK is not alpha -> return false
  MARK_END
  char c = PEEK
  ADVANCE
  if PEEK != ':' -> fallback to IDENTIFIER
  ADVANCE
  MARK_END
  if (c == 'X' || c == 'x') and valid_symbols[TT_X_INFO_HDR]:
    EMIT(TT_X_INFO_HDR)
  EMIT(TT_INF_HDR)
```

### Dispatch block

Add `TT_X_INFO_HDR` to the info header dispatch condition (line 1471):

```c
if ((valid_symbols[TT_INF_HDR] || valid_symbols[TT_X_INFO_HDR] || valid_symbols[TT_IDENTIFIER]) &&
    scan_info_header(lexer, valid_symbols)) return true;
```

## Grammar changes

File: `tree-sitter-abc/grammar.js`

### Externals list

Add `X_INFO_HDR` to the externals array (must match the scanner enum position):

```javascript
externals: $ => [
  // ... existing tokens ...
  $.X_INFO_HDR,
]
```

### New rule: X_info_line

An info line that specifically starts with `X:`:

```javascript
X_info_line: $ => seq(
  $.X_INFO_HDR,
  repeat(choice(
    $._info_line_content,
    $.WS
  )),
  optional($.Comment),
  optional($.EOL)
),
```

### Tune_header restructure

Change from:
```javascript
Tune_header: $ => repeat1(choice(
  $.Info_line, $.Comment, $.Directive, ...
))
```

To:
```javascript
Tune_header: $ => seq(
  $.X_info_line,
  repeat(choice(
    $.Info_line, $.Comment, $.Directive, ...
  ))
)
```

This makes `X_info_line` the REQUIRED first element of a tune header, which unambiguously distinguishes it from `File_header`.

### File_header: no changes needed

Because `File_header` uses `$.Info_line` (which starts with `$.INF_HDR`, not `$.X_INFO_HDR`), it will not match `X:` lines. The scanner emits `TT_X_INFO_HDR` for `X:`, so the `INF_HDR` token in the `Info_line` rule will never match `X:`. File_header is structurally excluded from matching tune starts without any rule changes.

### Conflicts reduction

With `X:` as an unambiguous Tune marker, several GLR conflicts can be removed or simplified:

```javascript
// These may no longer be needed:
[$.File_header, $.Tune_header],
[$.File_structure, $.File_header, $.Tune_header],
```

The remaining conflicts should be reviewed after the change to determine which are still necessary.

## Secondary issue: info line content tokenization

There is a secondary issue with how info line content is tokenized. When the grammar's `_info_line_content` rule includes `AbsolutePitch` (which uses `NOTE_LETTER`), the scanner's dispatch order causes alphabetic characters in info text (like "After" in `T:After You've Gone`) to be tokenized as individual `NOTE_LETTER` and `IDENTIFIER` tokens rather than as a single `INFO_STR`.

This is caused by:
1. `NOTE_LETTER` is dispatched at scanner line 1376
2. `INFO_STR` is dispatched at scanner line 1475
3. When both are valid, `NOTE_LETTER` wins due to dispatch order

This secondary issue does NOT block the Tune/File_header disambiguation (which is solved by the X: token approach above). However, it produces ugly parse trees where title text is fragmented into individual character tokens. This could be addressed separately by either:

- Removing `AbsolutePitch` from `_info_line_content` (info lines should not contain pitch references)
- Or reordering the scanner dispatch to check `INFO_STR` before `NOTE_LETTER` when in an info line context
- Or introducing scanner state that tracks "inside info line" and forces `INFO_STR` emission

This secondary fix is independent of the primary disambiguation fix and can be addressed in a follow-up.

## To do

- [ ] Add `TT_X_INFO_HDR` to the scanner's token enum
- [ ] Add `X_INFO_HDR` to the grammar's externals list (matching enum position)
- [ ] Modify `scan_info_header` to emit `TT_X_INFO_HDR` for `X:` and `x:`
- [ ] Update the dispatch condition to include `TT_X_INFO_HDR`
- [ ] Add `X_info_line` rule to grammar
- [ ] Restructure `Tune_header` to require `X_info_line` as its first element
- [ ] Review and remove unnecessary GLR conflicts
- [ ] Add `X_INFO_HDR` to `tsToCS.ts` token mapping
- [ ] Update C unit tests for the new token type
- [ ] Regenerate the parser and rebuild native module
- [ ] Run cross-comparison tests
- [ ] Address info line content tokenization (secondary, follow-up)
