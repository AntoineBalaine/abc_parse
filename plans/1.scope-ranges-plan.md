# Plan: Respect Pre-existing VSCode Selections in Selector Commands

## Table of Contents

1. Problem Statement
2. Solution Overview
3. Implementation Details
4. Files to Modify
5. To Do List

## 1. Problem Statement

When a user manually selects text in VSCode (e.g., selecting a line) and then runs a selector command like "abc: select notes", the selector ignores the manual selection and selects all matching elements in the entire document.

Current behavior:
- Manual selection (keyboard/mouse) clears the cursor state in `selectorCommands.ts` lines 47-60
- When the selector command runs, `getCursorNodeIds(uri)` returns an empty array
- The server receives an empty `cursorNodeIds` array and calls `createSelection(root)`, which starts from the document root
- All matching elements in the entire document are selected

Desired behavior:
- Manual selections should act as a scope constraint
- Running "select notes" after selecting a line should only select notes within that line

## 2. Solution Overview

The `selectRange` function already exists in `abct2/src/selectors/rangeSelector.ts` and can filter AST nodes by text range. The solution involves:

1. Adding a `scopeRanges` parameter to the `ApplySelectorParams` interface
2. Modifying the VSCode extension to send manual selections as `scopeRanges` when no cursor state exists
3. Modifying the server to use `selectRange` to constrain the initial selection when `scopeRanges` are provided

## 3. Implementation Details

### 3.1 Type Changes

In `abc-lsp-server/src/server.ts`, extend `ApplySelectorParams` (around line 20):

```typescript
interface ApplySelectorParams {
  uri: string;
  selector: string;
  args?: number[];
  cursorNodeIds: number[];
  scopeRanges?: Array<{           // NEW
    start: { line: number; character: number };
    end: { line: number; character: number };
  }>;
}
```

### 3.2 Server-side Changes

Add import at the top of `abc-lsp-server/src/server.ts`:

```typescript
import { selectRange } from "../../abct2/src/selectors/rangeSelector";
```

Modify the `abct2.applySelector` handler (lines 240-248):

```
current logic (lines 240-248):
  if cursorNodeIds is empty:
    selection = createSelection(root)
  else:
    selection = { root, cursors from cursorNodeIds }

new logic:
  if cursorNodeIds is empty:
    if scopeRanges provided and scopeRanges.length > 0:
      // For each range, find all nodes within it, then collect all cursors
      allCursors = []
      for each range in scopeRanges:
        baseSelection = createSelection(root)
        narrowed = selectRange(baseSelection, range.start.line, range.start.character, range.end.line, range.end.character)
        allCursors.push(...narrowed.cursors)
      if allCursors.length > 0:
        selection = { root, cursors: allCursors }
      else:
        // No nodes in ranges, return empty result
        return { ranges: [], cursorNodeIds: [] }
    else:
      selection = createSelection(root)
  else:
    selection = { root, cursors from cursorNodeIds }
```

### 3.3 VSCode Extension Changes

In `vscode-extension/src/selectorCommands.ts`, create a helper function to extract scope ranges:

```typescript
function getScopeRanges(editor: vscode.TextEditor): Array<{
  start: { line: number; character: number };
  end: { line: number; character: number };
}> | undefined {
  const nonEmptySelections = editor.selections.filter(s => !s.isEmpty);
  if (nonEmptySelections.length === 0) {
    return undefined;
  }
  return nonEmptySelections.map(s => ({
    start: { line: s.start.line, character: s.start.character },
    end: { line: s.end.line, character: s.end.character }
  }));
}
```

Modify the selector command handler (lines 112-140) to use the helper:

```
current (line 119):
  cursorNodeIds = getCursorNodeIds(uri)

new:
  cursorNodeIds = getCursorNodeIds(uri)
  scopeRanges = undefined
  if cursorNodeIds.length === 0:
    scopeRanges = getScopeRanges(editor)
```

And update the request (lines 122-126):

```typescript
const result = await client.sendRequest<ApplySelectorResult>("abct2.applySelector", {
  uri,
  selector: selectorName,
  cursorNodeIds,
  scopeRanges,  // NEW
});
```

Modify the result handling (lines 128-135) to distinguish between no-match scenarios:

```
current (lines 128-135):
  if result.cursorNodeIds.length > 0:
    setCursorNodeIds(uri, result.cursorNodeIds)
    applySelectionsToEditor(editor, result.ranges)
    updateStatusBar(statusBarItem, result.cursorNodeIds.length)
  else:
    clearCursorState(uri)
    statusBarItem.hide()

new:
  if result.cursorNodeIds.length > 0:
    setCursorNodeIds(uri, result.cursorNodeIds)
    applySelectionsToEditor(editor, result.ranges)
    updateStatusBar(statusBarItem, result.cursorNodeIds.length)
  else:
    if scopeRanges was provided:
      // Silent no-op: leave manual selection intact
      return
    else:
      clearCursorState(uri)
      statusBarItem.hide()
```

Apply the same changes to the `selectNthFromTop` handler (lines 155-164).

### 3.4 Handling Multiple Manual Selections

VSCode supports multiple selections (multi-cursor). The implementation handles this by:
- Collecting all non-empty selections from `editor.selections`
- Sending all ranges to the server
- Server applies `selectRange` for each range and collects all matching nodes
- This allows users to select multiple lines/regions and have selectors operate on all of them

### 3.5 Empty Result Behavior

When there's a manual selection but the selector finds no matching elements within it:
- The command does nothing (silent no-op)
- The original manual selection remains intact
- No "No matches found" message is shown

This is handled in the VSCode extension by checking if `result.cursorNodeIds.length === 0` and simply returning early without modifying `editor.selections` or calling `applySelectionsToEditor`.

## 4. Files to Modify

| File | Changes |
|------|---------|
| `abc-lsp-server/src/server.ts` | Add `scopeRanges` to `ApplySelectorParams`, add import for `selectRange`, modify handler |
| `abc-lsp-server/src/selectorIntegration.spec.ts` | Add tests for scopeRanges parameter |
| `vscode-extension/src/selectorCommands.ts` | Add `getScopeRanges` helper, modify both selector command handlers |

No changes needed to:
- `abct2/src/selectors/rangeSelector.ts` - already exports `selectRange`
- `cursorState.ts` - no changes to state management

## 5. To Do List

Phase 1: Server-side changes
- Add `scopeRanges` to `ApplySelectorParams` interface in `abc-lsp-server/src/server.ts`
- Add import for `selectRange` from `../../abct2/src/selectors/rangeSelector` in `abc-lsp-server/src/server.ts`
- Modify the `abct2.applySelector` handler to use `selectRange` when `scopeRanges` is provided and `cursorNodeIds` is empty
- Add integration tests in `abc-lsp-server/src/selectorIntegration.spec.ts` for the new scopeRanges parameter

Phase 2: VSCode extension changes
- Add `getScopeRanges` helper function in `vscode-extension/src/selectorCommands.ts`
- Modify the main selector command loop (lines 112-140) to:
  - Extract manual selections and send as `scopeRanges`
  - Update result handling for silent no-op when scopeRanges was provided but no matches found
- Modify the `selectNthFromTop` command handler (lines 144-177) with the same pattern

Phase 3: Verification
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
