# TreeSitter Scanner Test Infrastructure Plan

## Table of Contents
1. [Goal](#goal)
2. [Approach](#approach)
3. [Phase 1: C Unit Tests](#phase-1-c-unit-tests)
   - [1.1 Mock TSLexer Implementation](#11-mock-tslexer-implementation)
   - [1.2 Test Case Extraction from TypeScript](#12-test-case-extraction-from-typescript)
   - [1.3 Function-to-Test Mapping](#13-function-to-test-mapping)
   - [1.4 Parallelization Strategy](#14-parallelization-strategy)
   - [1.5 Build and Run](#15-build-and-run)
4. [Phase 2: Token Sequence Comparison](#phase-2-token-sequence-comparison)
5. [Phase 3: Full Parse Tree Comparison](#phase-3-full-parse-tree-comparison)
6. [Critical Files](#critical-files)
7. [Verification](#verification)

## Goal

Create a comprehensive test infrastructure for the TreeSitter external scanner that:
1. Validates each scanner sub-function in isolation (C unit tests)
2. Compares token sequences with the TypeScript scanner (JS integration tests)
3. Compares full parse trees (JS comparison tests)

## Approach

### Testing Layers (Bottom-Up)

```
Layer 3: Full Parse Tree Comparison (JS)
   Blocked until Layer 1 & 2 pass
Layer 2: Token Sequence Comparison (JS)
   Blocked until Layer 1 passes
Layer 1: Scanner Sub-Function Unit Tests (C)
   MUST PASS FIRST - Foundation for all other tests
```

Layer 1 is the foundation. If individual `scan_*` functions are broken, higher-level tests will fail unpredictably. We must:
1. Write C unit tests for all scanner sub-functions
2. Run them and fix any issues found
3. Only then proceed to Layer 2

### C Testing Fundamentals

Including `scanner.c` directly in a test file is standard practice for testing static functions:

```c
#include "scanner.c"  // Brings all static functions into scope
```

Using `assert()` from `<assert.h>` is the canonical approach for C unit tests.

## Phase 1: C Unit Tests

This phase is BLOCKING - do not proceed to Phase 2 until all tests pass and scanner bugs are fixed.

### 1.1 Mock TSLexer Implementation

Create `tree-sitter-abc/tests/test_harness.h`:

```c
#ifndef TEST_HARNESS_H
#define TEST_HARNESS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>

// Forward declare TSLexer type before including scanner
typedef struct TSLexer TSLexer;

// Include scanner.c to access static functions
#include "../src/scanner.c"

// ============================================================================
// Mock TSLexer State
// ============================================================================

typedef struct {
  const char* input;      // Input string
  size_t pos;             // Current position
  size_t length;          // Total length
  size_t mark_pos;        // Marked end position
  char consumed[1024];    // Buffer of consumed characters (for debugging)
  size_t consumed_len;    // Length of consumed buffer
} MockLexerState;

// Global state for the mock lexer (because TSLexer uses function pointers)
static MockLexerState g_mock_state;

// ============================================================================
// TSLexer Function Implementations
// ============================================================================

/**
 * Advance function: Consume current character and move to next.
 * @param lexer The TSLexer
 * @param skip If true, character is skipped (whitespace); if false, included in token
 */
static void mock_advance(TSLexer* lexer, bool skip) {
  if (g_mock_state.pos < g_mock_state.length) {
    // Track consumed characters for debugging
    if (!skip && g_mock_state.consumed_len < sizeof(g_mock_state.consumed) - 1) {
      g_mock_state.consumed[g_mock_state.consumed_len++] = g_mock_state.input[g_mock_state.pos];
      g_mock_state.consumed[g_mock_state.consumed_len] = '\0';
    }
    g_mock_state.pos++;
  }
  // Update lookahead to next character (or 0 at EOF)
  lexer->lookahead = (g_mock_state.pos < g_mock_state.length)
    ? (int32_t)(unsigned char)g_mock_state.input[g_mock_state.pos]
    : 0;
}

/**
 * Mark end function: Mark current position as the end of the token.
 * This is where the token will be considered to end if scan returns true.
 */
static void mock_mark_end(TSLexer* lexer) {
  g_mock_state.mark_pos = g_mock_state.pos;
}

/**
 * EOF function: Check if at end of input.
 */
static bool mock_eof(const TSLexer* lexer) {
  return g_mock_state.pos >= g_mock_state.length;
}

/**
 * Get column function: Return current column (simplified as position).
 */
static uint32_t mock_get_column(TSLexer* lexer) {
  return (uint32_t)g_mock_state.pos;
}

// ============================================================================
// Test Harness API
// ============================================================================

/**
 * Initialize mock lexer with input string.
 * Returns a TSLexer struct ready for use with scan_* functions.
 */
static TSLexer create_test_lexer(const char* input) {
  // Reset global state
  g_mock_state.input = input;
  g_mock_state.pos = 0;
  g_mock_state.length = strlen(input);
  g_mock_state.mark_pos = 0;
  g_mock_state.consumed_len = 0;
  g_mock_state.consumed[0] = '\0';

  // Create lexer with mock function pointers
  TSLexer lexer = {
    .lookahead = (input[0] != '\0') ? (int32_t)(unsigned char)input[0] : 0,
    .result_symbol = 0,
    .advance = mock_advance,
    .mark_end = mock_mark_end,
    .eof = mock_eof,
    .get_column = mock_get_column,
  };
  return lexer;
}

/**
 * Get the consumed text from the lexer (for verification).
 */
static const char* get_consumed_text(void) {
  return g_mock_state.consumed;
}

/**
 * Get current position in input.
 */
static size_t get_current_pos(void) {
  return g_mock_state.pos;
}

/**
 * Get marked end position.
 */
static size_t get_mark_pos(void) {
  return g_mock_state.mark_pos;
}

/**
 * Create a valid_symbols array with all symbols enabled.
 */
static void enable_all_symbols(bool* valid_symbols) {
  for (int i = 0; i < TT_COUNT; i++) {
    valid_symbols[i] = true;
  }
}

/**
 * Create a valid_symbols array with only specified symbols enabled.
 */
static void enable_symbols(bool* valid_symbols, int count, ...) {
  // First clear all
  for (int i = 0; i < TT_COUNT; i++) {
    valid_symbols[i] = false;
  }
  // Enable specified
  va_list args;
  va_start(args, count);
  for (int i = 0; i < count; i++) {
    int symbol = va_arg(args, int);
    valid_symbols[symbol] = true;
  }
  va_end(args);
}

// ============================================================================
// Test Result Macros
// ============================================================================

#define TEST_PASS() printf("PASS\n")
#define TEST_FAIL(msg) do { printf("FAIL: %s\n", msg); assert(0); } while(0)

#define ASSERT_TRUE(cond) do { \
  if (!(cond)) { \
    printf("FAIL: expected true but got false at line %d\n", __LINE__); \
    assert(0); \
  } \
} while(0)

#define ASSERT_FALSE(cond) do { \
  if (cond) { \
    printf("FAIL: expected false but got true at line %d\n", __LINE__); \
    assert(0); \
  } \
} while(0)

#define ASSERT_EQ(expected, actual) do { \
  if ((expected) != (actual)) { \
    printf("FAIL: expected %d but got %d at line %d\n", (int)(expected), (int)(actual), __LINE__); \
    assert(0); \
  } \
} while(0)

#define ASSERT_STR_EQ(expected, actual) do { \
  if (strcmp((expected), (actual)) != 0) { \
    printf("FAIL: expected \"%s\" but got \"%s\" at line %d\n", (expected), (actual), __LINE__); \
    assert(0); \
  } \
} while(0)

#endif // TEST_HARNESS_H
```

### 1.2 Test Case Extraction from TypeScript

The following TypeScript test files contain test cases to extract:

#### Source File: `parse/tests/scn_tuneBodyTokens.spec.ts` (1142 lines)

| TypeScript Function | C Function | Test Cases to Extract |
|---------------------|------------|----------------------|
| `decoration()` | `scan_decoration()` | `.A`, `~.HA`, `.z`, `~.z`, `.%` (invalid), `.` alone (invalid), `RD` (R decoration) |
| `symbol()` | `scan_symbol()` | `+symbol+`, `!symbol!`, `not a symbol` (invalid) |
| `rhythm()` | `scan_number()`, `scan_rhythm_sep()`, `scan_broken_rhythm()` | `20`, `/`, `///`, `3/4`, `>>`, `G>>A` |
| `pitch()` | `scan_note_letter()`, `scan_octave()` | `A`, `A'`, `A,`, `^A` |
| `accidental()` | `scan_accidental()` | `^`, `^^`, `^/`, `_`, `__`, `_/`, `=`, `A` (invalid) |
| `note()` | Multiple | `A`, `G2G2`, `^A`, `-A-` |
| `rest()` | `scan_rest()` | `z`, `z2`, `Z`, `A` (invalid), `zzz` sequence |
| `annotation()` | `scan_annotation()` | `"text"`, `"text with spaces"`, `"unterminated\n` (invalid), `"D\""` (escaped) |
| `symbol_line()` | `scan_symbol_header()`, `scan_symbol_star()`, `scan_symbol_text()` | `s:hello`, `s:** *`, `s:Title %comment`, `s: G * \| G` |
| `info_line()` | `scan_info_header()`, `scan_info_string()` | `T:Title`, `T:Title %comment` |
| `chord()` | `scan_chord_bracket()` | `[A]`, `[ABC]`, `["text"]`, `[CE^F]4`, `[^/a]` |
| `grace_grp()` | `scan_grace_brace()`, `scan_grace_slash()` | `{A}`, `{/A}`, `{ABC}`, `{B2c/d/}`, `{/B2}` |
| `inline_field()` | `scan_inline_field_left()`, `scan_inline_field_right()` | `[I:text]`, `[K:G]`, `[M:3/4]`, `[Q:1/4=120]`, `[K:F#m]`, `[K:Bb]` |
| `y_spacer()` | `scan_y_spacer()` | `y`, `y2`, `A` (invalid) |
| `ampersand()` | `scan_ampersand()` | `&`, `&\n`, `A` (invalid) |
| `line_continuation()` | `scan_line_continuation()` | `\\\n`, `\\ \n`, `\\  \t \n`, `\\%comment\n`, `\\` (invalid), `\\ text` (invalid) |
| `bcktck_spc()` | `scan_backtick_spacer()` | backtick, `A` (invalid) |
| `slur()` | `scan_slur()` | `(`, `)`, `A` (invalid) |
| `tuplet()` | `scan_tuplet_lparen()`, `scan_tuplet_colon()`, `scan_tuplet_p/q/r()` | `(3`, `(5`, `(3:2`, `(3:2:3`, `(3:`, `(3:2:`, `(3::`, `(5:4:6`, `(A` (invalid) |
| `barline()` | `scan_barline()` | `\|`, `\|\|`, `[\|`, `\|]`, `A` (invalid) |

#### Source File: `parse/tests/scn_tuneBody.spec.ts` (234 lines)

| Test Name | C Functions Covered | Input | Expected Tokens |
|-----------|---------------------|-------|-----------------|
| Simple music pattern | Multiple | `X:1\nA2 B` | INF_HDR, INFO_STR, EOL, NOTE_LETTER, RHY_NUMER, WS, NOTE_LETTER |
| Two tunes with section break | `scan_section_break()` | `X:1\nA B C\n\nX:2\nD E F` | ... SCT_BRK ... |
| Chords and annotations | `scan_chord_bracket()`, `scan_annotation()` | `X:1\n[CEG] "Cmaj"` | CHRD_LEFT_BRKT, NOTE_LETTER x3, CHRD_RIGHT_BRKT, WS, ANNOTATION |
| Grace notes and tuplets | `scan_grace_brace()`, `scan_tuplet_*()` | `X:1\n{/AC} (3DEF G2` | GRC_GRP_LEFT_BRACE, GRC_GRP_SLSH, ... |
| Barlines and inline fields | `scan_barline()`, `scan_inline_field_*()` | `X:1\n\| [M:3/4] A B C \|` | BARLINE, INLN_FLD_LFT_BRKT, ... |
| Comments and directives | `scan_percent_token()` | `X:1\nA B C %comment\n%%directive` | ... COMMENT, EOL, STYLESHEET_DIRECTIVE |
| Slurs and ties | `scan_slur()`, `scan_tie()` | `X:1\n(A-B) C-D` | SLUR, NOTE_LETTER, TIE, ... |

#### Source File: `parse/tests/scn_lyrics.spec.ts` (145 lines)

| Test Name | C Functions | Input | Expected |
|-----------|-------------|-------|----------|
| Simple lyric line | `scan_lyric_header()`, `scan_lyric_text()` | `w:lyrics` | LY_HDR, LY_TXT |
| Section lyric line | `scan_lyric_header()` | `W:lyrics for section` | LY_SECT_HDR |
| Lyric with hyphens | `scan_lyric_hyphen()` | `w:syll-a-ble` | LY_HDR, LY_TXT, LY_HYPH, LY_TXT, LY_HYPH, LY_TXT |
| Lyric with underscores | `scan_lyric_underscore()` | `w:time__` | LY_HDR, LY_TXT, LY_UNDR, LY_UNDR |
| Lyric with asterisk | `scan_lyric_star()` | `w:word * word` | LY_HDR, LY_TXT, LY_STAR, LY_TXT |
| Lyric with tilde | `scan_lyric_tilde()` | `w:of~the~day` | LY_HDR, LY_TXT, LY_SPS, LY_TXT, LY_SPS, LY_TXT |
| Lyric with bar | `scan_barline()` in lyric context | `w:word \| word` | LY_HDR, LY_TXT, BARLINE, LY_TXT |

#### Source File: `parse/tests/scn_repeatNumbers.spec.ts` (378 lines)

| Test Name | C Functions | Input | Expected |
|-----------|-------------|-------|----------|
| Single number | `scan_repeat_number()` | `1` | REPEAT_NUMBER |
| Multi-digit | `scan_repeat_number()` | `123` | REPEAT_NUMBER |
| List | `scan_repeat_number()`, `scan_repeat_comma()` | `1,2,3` | REPEAT_NUMBER, REPEAT_COMMA, REPEAT_NUMBER, REPEAT_COMMA, REPEAT_NUMBER |
| Range | `scan_repeat_dash()` | `1-3` | REPEAT_NUMBER, REPEAT_DASH, REPEAT_NUMBER |
| X notation | `scan_repeat_x()` | `1x2` | REPEAT_NUMBER, REPEAT_X, REPEAT_NUMBER |
| Colon barlines | `scan_barline()` | `:`, `:::`, `:\|\|`, `:\|` | Various BARLINE patterns |
| Barline-start | `scan_barline()` | `\|`, `\|\|\|`, `\|:`, `\|]`, `\| ]` | BARLINE with variations |
| Left-bracket-start | `scan_barline()` | `[`, `[1`, `[\|`, `[\|:`, `[\|]`, `[]` | BARLINE patterns |

#### Source File: `parse/tests/scn_system_break.spec.ts` (195 lines)

| Test Name | C Functions | Input | Expected |
|-----------|-------------|-------|----------|
| Standalone | `scan_system_break()` (if using $) | `!` surrounded by space | SYSTEM_BREAK |
| Between notes | `scan_system_break()` | `C ! D` | NOTE_LETTER, SYSTEM_BREAK, NOTE_LETTER |
| NOT symbol notation | Distinguishes from `scan_symbol()` | `!trill!` | SYMBOL (not SYSTEM_BREAK) |

#### Source File: `parse/tests/scn_directive.spec.ts` (469 lines)

| Test Name | C Functions | Input | Expected |
|-----------|-------------|-------|----------|
| Simple directive | `scan_percent_token()`, `scan_identifier()` | `%%scale 0.75` | STYLESHEET_DIRECTIVE, IDENTIFIER, NUMBER |
| Decimal without leading zero | | `%%scale .9` | STYLESHEET_DIRECTIVE, IDENTIFIER, NUMBER |
| String literal | `scan_annotation()` | `%%title "My Song"` | STYLESHEET_DIRECTIVE, IDENTIFIER, ANNOTATION |
| Number with unit | `scan_measurement_unit()` | `%%pagewidth 21cm` | STYLESHEET_DIRECTIVE, IDENTIFIER, NUMBER, MEASUREMENT_UNIT |
| Rational | `scan_slash()` | `%%scale 3/4` | STYLESHEET_DIRECTIVE, IDENTIFIER, NUMBER, SLASH, NUMBER |
| Assignment | `scan_equals()` | `%%transpose=2` | STYLESHEET_DIRECTIVE, IDENTIFIER, EQL, NUMBER |
| Text directive | `scan_free_text()` | `%%text This is text` | STYLESHEET_DIRECTIVE, IDENTIFIER, FREE_TXT |
| Header directive | `scan_free_text()` | `%%header Page $P` | STYLESHEET_DIRECTIVE, IDENTIFIER, FREE_TXT |

#### Source File: `parse/tests/scn_fileStructure.spec.ts` (184 lines)

| Test Name | C Functions | Input | Expected |
|-----------|-------------|-------|----------|
| File header | Multiple | `%%directive\n%comment\nT:Title\n` | STYLESHEET_DIRECTIVE, IDENTIFIER, EOL, COMMENT, EOL, INF_HDR, INFO_STR, EOL |
| Free text | `scan_free_text()` | `This is free text\n%%directive` | FREE_TXT, EOL, STYLESHEET_DIRECTIVE... |
| Tune with header and body | Multiple | `X:1\nT:Test Tune\nK:C\nABC DEF\|` | Full token sequence |

### 1.3 Function-to-Test Mapping

All 60 scanner sub-functions that need tests:

| Category | Functions | Test File |
|----------|-----------|-----------|
| Pitch/Notes | `scan_note_letter`, `scan_accidental`, `scan_octave`, `scan_rest`, `scan_tie`, `scan_decoration` | `test_pitch.c` |
| Rhythm | `scan_number`, `scan_rhythm_sep`, `scan_broken_rhythm`, `scan_rhythm_denom`, `scan_general_number` | `test_rhythm.c` |
| Barlines | `scan_barline` | `test_barline.c` |
| Tuplets | `scan_tuplet_lparen`, `scan_tuplet_colon`, `scan_tuplet_p`, `scan_tuplet_q`, `scan_tuplet_r` | `test_tuplet.c` |
| Brackets | `scan_chord_bracket`, `scan_grace_brace`, `scan_grace_slash`, `scan_inline_field_left`, `scan_inline_field_right` | `test_bracket.c` |
| Info | `scan_info_header`, `scan_info_string`, `scan_info_continuation`, `scan_percent_token` | `test_info.c` |
| Symbols | `scan_slur`, `scan_annotation`, `scan_symbol`, `scan_chord_symbol` | `test_symbol.c` |
| Whitespace | `scan_whitespace`, `scan_eol`, `scan_section_break` | `test_whitespace.c` |
| Special | `scan_ampersand`, `scan_system_break`, `scan_y_spacer`, `scan_backtick_spacer`, `scan_line_continuation`, `scan_escaped_char` | `test_special.c` |
| Lyrics | `scan_lyric_header`, `scan_lyric_text`, `scan_lyric_underscore`, `scan_lyric_hyphen`, `scan_lyric_star`, `scan_lyric_tilde` | `test_lyrics.c` |
| Symbol Line | `scan_symbol_header`, `scan_symbol_star`, `scan_symbol_text` | `test_symbol_line.c` |
| Repeat | `scan_repeat_number`, `scan_repeat_comma`, `scan_repeat_dash`, `scan_repeat_x` | `test_repeat.c` |
| User/Macro | `scan_user_symbol_header`, `scan_user_symbol`, `scan_user_symbol_invocation`, `scan_macro_header`, `scan_macro_var`, `scan_macro_string`, `scan_macro_invocation` | `test_user_macro.c` |
| Directive | `scan_identifier`, `scan_measurement_unit`, `scan_special_literal`, `scan_free_text` | `test_directive.c` |
| Punctuation | `scan_equals`, `scan_slash`, `scan_minus`, `scan_plus`, `scan_lparen`, `scan_rparen`, `scan_lbrace`, `scan_rbrace`, `scan_lbracket`, `scan_rbracket`, `scan_pipe`, `scan_voice`, `scan_reserved_char`, `scan_invalid` | `test_punctuation.c` |

### 1.4 Parallelization Strategy

Once the common mock infrastructure (`test_harness.h`) is created, test file implementation can proceed in parallel.

#### Sequential (Must Complete First)
1. Create `tree-sitter-abc/tests/test_harness.h` with mock TSLexer

#### Parallel (After test_harness.h exists)
The following test files can be created and run independently:

```
                    test_harness.h (sequential)
                           |
          +----------------+----------------+
          |                |                |
    test_pitch.c     test_rhythm.c    test_barline.c
    test_tuplet.c    test_bracket.c   test_info.c
    test_symbol.c    test_whitespace.c test_special.c
    test_lyrics.c    test_symbol_line.c test_repeat.c
    test_user_macro.c test_directive.c test_punctuation.c
```

Each test file:
- Includes `test_harness.h`
- Tests one category of functions
- Has its own `main()` that runs all tests in that category
- Returns 0 on success, non-zero on failure

#### Build Targets

```makefile
# Individual test targets (can run in parallel)
test_pitch: tests/test_pitch.c tests/test_harness.h
	$(CC) -I src -I src/tree_sitter -o tests/test_pitch tests/test_pitch.c
	./tests/test_pitch

test_rhythm: tests/test_rhythm.c tests/test_harness.h
	$(CC) -I src -I src/tree_sitter -o tests/test_rhythm tests/test_rhythm.c
	./tests/test_rhythm

# ... (similar for all test files)

# Run all tests (sequential)
test-scanner: test_pitch test_rhythm test_barline test_tuplet test_bracket \
              test_info test_symbol test_whitespace test_special test_lyrics \
              test_symbol_line test_repeat test_user_macro test_directive test_punctuation
	@echo "All scanner tests passed"
```

### 1.5 Build and Run

Add to `tree-sitter-abc/package.json`:
```json
{
  "scripts": {
    "test:c": "make -C tests test-scanner"
  }
}
```

Create `tree-sitter-abc/tests/Makefile`:
```makefile
CC = cc
CFLAGS = -I ../src -I ../src/tree_sitter -Wall -Wextra

TESTS = test_pitch test_rhythm test_barline test_tuplet test_bracket \
        test_info test_symbol test_whitespace test_special test_lyrics \
        test_symbol_line test_repeat test_user_macro test_directive test_punctuation

.PHONY: test-scanner clean $(TESTS)

test-scanner: $(TESTS)
	@echo "=== All scanner tests passed ==="

$(TESTS): %: %.c test_harness.h
	$(CC) $(CFLAGS) -o $@ $<
	./$@

clean:
	rm -f $(TESTS)
```

### Example Test File: test_pitch.c

```c
#include "test_harness.h"
#include <stdarg.h>

// ============================================================================
// scan_note_letter tests (from scn_tuneBodyTokens.spec.ts pitch/note tests)
// ============================================================================

void test_scan_note_letter_valid() {
  printf("test_scan_note_letter_valid... ");

  // From: pitch() test "should parse a simple pitch" - input "A"
  // From: note() test "should parse a simple note" - input "A"
  const char* valid[] = {"a", "b", "c", "d", "e", "f", "g", "A", "B", "C", "D", "E", "F", "G"};
  for (int i = 0; i < 14; i++) {
    TSLexer lexer = create_test_lexer(valid[i]);
    ASSERT_TRUE(scan_note_letter(&lexer));
    ASSERT_EQ(TT_NOTE_LETTER, lexer.result_symbol);
    ASSERT_EQ(1, get_current_pos());
  }

  TEST_PASS();
}

void test_scan_note_letter_invalid() {
  printf("test_scan_note_letter_invalid... ");

  // Invalid: h, H are not note letters (h-w are user symbols)
  const char* invalid[] = {"h", "H", "1", "|", " ", "y", "z", "x"};
  for (int i = 0; i < 8; i++) {
    TSLexer lexer = create_test_lexer(invalid[i]);
    ASSERT_FALSE(scan_note_letter(&lexer));
    ASSERT_EQ(0, get_current_pos());  // Should not consume anything
  }

  TEST_PASS();
}

// ============================================================================
// scan_accidental tests (from scn_tuneBodyTokens.spec.ts accidental tests)
// ============================================================================

void test_scan_accidental_sharp() {
  printf("test_scan_accidental_sharp... ");

  // From: accidental() test "should parse a sharp" - input "^"
  TSLexer lexer = create_test_lexer("^");
  ASSERT_TRUE(scan_accidental(&lexer));
  ASSERT_EQ(TT_ACCIDENTAL, lexer.result_symbol);
  ASSERT_EQ(1, get_current_pos());

  TEST_PASS();
}

void test_scan_accidental_double_sharp() {
  printf("test_scan_accidental_double_sharp... ");

  // From: accidental() test "should parse a double sharp" - input "^^"
  TSLexer lexer = create_test_lexer("^^");
  ASSERT_TRUE(scan_accidental(&lexer));
  ASSERT_EQ(TT_ACCIDENTAL, lexer.result_symbol);
  ASSERT_EQ(2, get_current_pos());

  TEST_PASS();
}

void test_scan_accidental_half_sharp() {
  printf("test_scan_accidental_half_sharp... ");

  // From: accidental() test "should parse a half sharp" - input "^/"
  TSLexer lexer = create_test_lexer("^/");
  ASSERT_TRUE(scan_accidental(&lexer));
  ASSERT_EQ(TT_ACCIDENTAL, lexer.result_symbol);
  ASSERT_EQ(2, get_current_pos());

  TEST_PASS();
}

void test_scan_accidental_flat() {
  printf("test_scan_accidental_flat... ");

  // From: accidental() test "should parse a flat" - input "_"
  TSLexer lexer = create_test_lexer("_");
  ASSERT_TRUE(scan_accidental(&lexer));
  ASSERT_EQ(TT_ACCIDENTAL, lexer.result_symbol);

  TEST_PASS();
}

void test_scan_accidental_double_flat() {
  printf("test_scan_accidental_double_flat... ");

  // From: accidental() test "should parse a double flat" - input "__"
  TSLexer lexer = create_test_lexer("__");
  ASSERT_TRUE(scan_accidental(&lexer));
  ASSERT_EQ(TT_ACCIDENTAL, lexer.result_symbol);
  ASSERT_EQ(2, get_current_pos());

  TEST_PASS();
}

void test_scan_accidental_half_flat() {
  printf("test_scan_accidental_half_flat... ");

  // From: accidental() test "should parse a half flat" - input "_/"
  TSLexer lexer = create_test_lexer("_/");
  ASSERT_TRUE(scan_accidental(&lexer));
  ASSERT_EQ(TT_ACCIDENTAL, lexer.result_symbol);

  TEST_PASS();
}

void test_scan_accidental_natural() {
  printf("test_scan_accidental_natural... ");

  // From: accidental() test "should parse a natural" - input "="
  TSLexer lexer = create_test_lexer("=");
  ASSERT_TRUE(scan_accidental(&lexer));
  ASSERT_EQ(TT_ACCIDENTAL, lexer.result_symbol);

  TEST_PASS();
}

void test_scan_accidental_invalid() {
  printf("test_scan_accidental_invalid... ");

  // From: accidental() test "should return false for non-accidental" - input "A"
  TSLexer lexer = create_test_lexer("A");
  ASSERT_FALSE(scan_accidental(&lexer));
  ASSERT_EQ(0, get_current_pos());

  TEST_PASS();
}

// ============================================================================
// scan_octave tests (from scn_tuneBodyTokens.spec.ts pitch tests)
// ============================================================================

void test_scan_octave_up() {
  printf("test_scan_octave_up... ");

  // From: pitch() test "should parse a pitch with octave up" - input "A'"
  TSLexer lexer = create_test_lexer("'");
  ASSERT_TRUE(scan_octave(&lexer));
  ASSERT_EQ(TT_OCTAVE, lexer.result_symbol);

  // Multiple octave markers
  lexer = create_test_lexer("''");
  ASSERT_TRUE(scan_octave(&lexer));
  ASSERT_EQ(2, get_current_pos());

  TEST_PASS();
}

void test_scan_octave_down() {
  printf("test_scan_octave_down... ");

  // From: pitch() test "should parse a pitch with octave down" - input "A,"
  TSLexer lexer = create_test_lexer(",");
  ASSERT_TRUE(scan_octave(&lexer));
  ASSERT_EQ(TT_OCTAVE, lexer.result_symbol);

  lexer = create_test_lexer(",,");
  ASSERT_TRUE(scan_octave(&lexer));
  ASSERT_EQ(2, get_current_pos());

  TEST_PASS();
}

void test_scan_octave_invalid() {
  printf("test_scan_octave_invalid... ");

  TSLexer lexer = create_test_lexer("A");
  ASSERT_FALSE(scan_octave(&lexer));
  ASSERT_EQ(0, get_current_pos());

  TEST_PASS();
}

// ============================================================================
// scan_rest tests (from scn_tuneBodyTokens.spec.ts rest tests)
// ============================================================================

void test_scan_rest_valid() {
  printf("test_scan_rest_valid... ");

  // From: rest() test "should parse different rest types"
  const char* valid[] = {"z", "Z", "x", "X"};
  for (int i = 0; i < 4; i++) {
    TSLexer lexer = create_test_lexer(valid[i]);
    ASSERT_TRUE(scan_rest(&lexer));
    ASSERT_EQ(TT_REST, lexer.result_symbol);
  }

  TEST_PASS();
}

void test_scan_rest_invalid() {
  printf("test_scan_rest_invalid... ");

  // From: rest() test "should return false for non-rest" - input "A"
  TSLexer lexer = create_test_lexer("A");
  ASSERT_FALSE(scan_rest(&lexer));

  TEST_PASS();
}

// ============================================================================
// scan_tie tests
// ============================================================================

void test_scan_tie() {
  printf("test_scan_tie... ");

  // From: note() test "should parse a note with tie" - input "-A-"
  TSLexer lexer = create_test_lexer("-");
  ASSERT_TRUE(scan_tie(&lexer));
  ASSERT_EQ(TT_TIE, lexer.result_symbol);

  TEST_PASS();
}

// ============================================================================
// scan_decoration tests (from scn_tuneBodyTokens.spec.ts decoration tests)
// ============================================================================

void test_scan_decoration_single() {
  printf("test_scan_decoration_single... ");

  // From: decoration() test "should parse a single decoration" - input ".A"
  TSLexer lexer = create_test_lexer(".");
  ASSERT_TRUE(scan_decoration(&lexer));
  ASSERT_EQ(TT_DECORATION, lexer.result_symbol);

  TEST_PASS();
}

void test_scan_decoration_multiple() {
  printf("test_scan_decoration_multiple... ");

  // From: decoration() test "should parse multiple decoration characters" - input "~.HA"
  TSLexer lexer = create_test_lexer("~.H");
  ASSERT_TRUE(scan_decoration(&lexer));
  ASSERT_EQ(TT_DECORATION, lexer.result_symbol);
  ASSERT_EQ(3, get_current_pos());

  TEST_PASS();
}

void test_scan_decoration_R() {
  printf("test_scan_decoration_R... ");

  // From: decoration() test "should parse R decoration (roll)" - input "RD"
  TSLexer lexer = create_test_lexer("R");
  ASSERT_TRUE(scan_decoration(&lexer));
  ASSERT_EQ(TT_DECORATION, lexer.result_symbol);

  TEST_PASS();
}

void test_scan_decoration_invalid() {
  printf("test_scan_decoration_invalid... ");

  // Characters that are not decorations
  TSLexer lexer = create_test_lexer("A");
  ASSERT_FALSE(scan_decoration(&lexer));

  TEST_PASS();
}

// ============================================================================
// Main
// ============================================================================

int main() {
  printf("\n=== Pitch/Note Scanner Tests ===\n\n");

  // Note letter
  test_scan_note_letter_valid();
  test_scan_note_letter_invalid();

  // Accidentals
  test_scan_accidental_sharp();
  test_scan_accidental_double_sharp();
  test_scan_accidental_half_sharp();
  test_scan_accidental_flat();
  test_scan_accidental_double_flat();
  test_scan_accidental_half_flat();
  test_scan_accidental_natural();
  test_scan_accidental_invalid();

  // Octave
  test_scan_octave_up();
  test_scan_octave_down();
  test_scan_octave_invalid();

  // Rest
  test_scan_rest_valid();
  test_scan_rest_invalid();

  // Tie
  test_scan_tie();

  // Decoration
  test_scan_decoration_single();
  test_scan_decoration_multiple();
  test_scan_decoration_R();
  test_scan_decoration_invalid();

  printf("\n=== All pitch/note tests passed ===\n\n");
  return 0;
}
```

## Phase 2: Token Sequence Comparison

Only start this phase after Phase 1 is complete.

Create JS tests in `tree-sitter-abc/tests/` that:
1. Parse input with TypeScript scanner
2. Parse input with TreeSitter
3. Extract terminal nodes from TreeSitter
4. Compare token sequences

## Phase 3: Full Parse Tree Comparison

Only start this phase after Phase 2 is complete.

Move existing comparison tests from `parse/tests/treesitter/` to `tree-sitter-abc/tests/` and verify AST-level parity.

## Critical Files

### Phase 1 (C Testing)
- `tree-sitter-abc/tests/test_harness.h` - Mock TSLexer and test utilities
- `tree-sitter-abc/tests/test_pitch.c` - Note/pitch tests
- `tree-sitter-abc/tests/test_rhythm.c` - Rhythm tests
- `tree-sitter-abc/tests/test_barline.c` - Barline tests
- `tree-sitter-abc/tests/test_tuplet.c` - Tuplet tests
- `tree-sitter-abc/tests/test_bracket.c` - Bracket tests
- `tree-sitter-abc/tests/test_info.c` - Info line tests
- `tree-sitter-abc/tests/test_symbol.c` - Symbol tests
- `tree-sitter-abc/tests/test_whitespace.c` - Whitespace tests
- `tree-sitter-abc/tests/test_special.c` - Special token tests
- `tree-sitter-abc/tests/test_lyrics.c` - Lyric tests
- `tree-sitter-abc/tests/test_symbol_line.c` - Symbol line tests
- `tree-sitter-abc/tests/test_repeat.c` - Repeat number tests
- `tree-sitter-abc/tests/test_user_macro.c` - User symbol/macro tests
- `tree-sitter-abc/tests/test_directive.c` - Directive tests
- `tree-sitter-abc/tests/test_punctuation.c` - Punctuation tests
- `tree-sitter-abc/tests/Makefile` - Build system
- `tree-sitter-abc/src/scanner.c` - Implementation to test and fix
- `tree-sitter-abc/src/scanner.h` - Token types and helpers

### Phase 2+ (JS Testing)
- `tree-sitter-abc/tests/token_comparison.spec.js`
- `tree-sitter-abc/tests/ast_comparison.spec.js`

## Verification

### Phase 1 Complete When:
1. All 60 scanner sub-functions have unit tests
2. All tests pass
3. Any bugs found are fixed and committed
4. `npm run test:c` exits with code 0

### Phase 2+ Criteria
- To be defined after Phase 1 completes
