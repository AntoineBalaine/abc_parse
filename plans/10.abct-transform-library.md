# ABCT Transform Function Library

## Table of Contents

1. [Overview](#overview)
2. [Function Categories](#function-categories)
3. [Abstraction Level Analysis](#abstraction-level-analysis)
4. [Implementation Strategy](#implementation-strategy)
5. [Phase 1 Functions](#phase-1-functions)
6. [Files to Create/Modify](#files-to-createmodify)
7. [Verification](#verification)

---

## Overview

Implement transform functions for ABCT that operate on ABC music parsed through the abc_parse library. These functions will be callable from ABCT expressions like:

```
src.abc | @chords |= choralis 4 | drop2
src.abc | transpose 2
src.abc | @V:melody | invert
```

---

## Function Categories

### Pitch Transforms

| Function | Description | Args |
|----------|-------------|------|
| `transpose n` | Shift all pitches by n semitones | integer |
| `invert [pivot]` | Invert around first pitch or specified pivot | optional pitch |
| `retrograde` | Reverse pitch sequence | none |
| `octave n` | Shift by n octaves | integer |

### Chord/Voicing Transforms

| Function | Description | Args |
|----------|-------------|------|
| `choralis n` | Generate n-voice voice-leading (closest path) | integer (3-6) |
| `drop2` | Drop 2nd voice down octave | none |
| `drop3` | Drop 3rd voice down octave | none |
| `drop2-4` | Drop 2nd and 4th voices down octave | none |
| `spread n` | Spread voicing across n octaves | integer |
| `close` | Collapse to close position | none |
| `chord-invert n` | Invert chord (0=root, 1=first, -1=last) | integer |
| `roots` | Extract chord roots only | none |

### Rhythm Transforms (already implemented)

| Function | Description | Status |
|----------|-------------|--------|
| `augment n` | Multiply durations by n | Done (multiply rhythm) |
| `diminish n` | Divide durations by n | Done (divide rhythm) |
| `retrograde-rhythm` | Reverse rhythm only | Low priority |

### Filtering/Selection

| Function | Description | Args |
|----------|-------------|------|
| `filter predicate` | Keep elements matching predicate | expression |
| `exclude predicate` | Remove elements matching predicate | expression |

### Voice Distribution

| Function | Description | Args |
|----------|-------------|------|
| `distribute voices` | Dispatch transform outputs to voices | list of voice refs |

---

## Abstraction Level Analysis

Based on exploration of abc_parse:

### Parser AST (Expr2.ts)
- Pitch stored as Token chains (noteLetter, alteration, octave)
- Rhythm stored as Tokens (numerator, separator, denominator)
- Preserves source formatting exactly
- RangeVisitor enables selective transforms
- Example: Transposer.ts works at this level

### Interpreter Semantic Tree (abcjs-ast.ts)
- Pitch as numbers (0=C, 1=D, ... 7=c, 8=d)
- Duration as IRational (numerator/denominator)
- Hierarchical staff/voice structure
- State tracking (key, clef, accidentals)
- No Semantic -> ABC formatter exists yet

### Key Insight: Diatonic vs Chromatic

Most voicing operations are diatonic and do not require key context:

- `drop2` on `[A,CEA]` → `[A,C,EA]` - just octave shift, no key needed
- `choralis`: Voice leading is diatonic. A is always a third from C.
- `roots`: Identify lowest note - purely syntactic
- `spread/close`: Octave shifts only

Key context (semantic tree) is needed for:
1. Chromatic operations (correct enharmonic spelling)
2. Transposing instruments (V:trumpet in Bb)
3. Post-transpose respelling (A# → Bb in F major)

### Recommended Level by Function

| Function | Recommended Level | Reason |
|----------|-------------------|--------|
| `transpose` | AST now, Semantic later | Currently AST; needs semantic for enharmonic respelling |
| `invert` | Semantic (future) | Needs key context for correct spelling |
| `octave` | AST | Simple diatonic octave shift |
| `retrograde` | AST | Sequence reversal, no pitch math |
| `augment/diminish` | Already done | Existing multiply/divide rhythm commands |
| `choralis` | AST | Diatonic voice leading, no key context needed |
| `drop2/3` | AST | Diatonic octave shifts |
| `spread/close` | AST | Diatonic octave shifts |
| `roots` | AST | Chord root = lowest note, syntactic |
| `distribute` | AST | Voice assignment, no pitch transformation |
| `filter/exclude` | AST | Selection operations |

---

## Selector/Transform Flow

The key pattern for ABCT operations:

```
file.abc | @chords |= (some_transform)
```

### Step-by-step execution:

1. Parse: `file.abc` is read and converted to AST
2. Select: `@chords` marks matching nodes
   - Stores list of expression IDs matching predicate (`isChord(node)`)
   - Does not extract nodes from tree - just marks them
3. Transform: `some_transform` operates on marked nodes
   - Receives the full AST + selection set
   - Modifies only selected nodes in place
4. Integrate: New node versions replace originals in tree
5. Output: If no following pipe, call Formatter2 to produce ABC

### Selection representation:

```typescript
interface Selection {
  ast: File_structure;          // Full AST
  selected: Set<Expr>;          // Direct references to matching nodes (not IDs)
}
```

Using direct node references instead of IDs because:
- No need to build ID-to-node lookup map
- More efficient - avoid ID lookup during transform
- Visitor pattern naturally provides node references

### Transform mutates AST in place:

```typescript
type TransformFn = (selection: Selection, args: any[]) => void;
```

Transforms follow the pattern from `Transposer.ts`:
- Walk AST using visitor pattern
- Modify only nodes in `selection.selected`
- Mutate node properties in place (e.g., `expr.pitch = newPitch`)
- Create new Token objects with correct lexemes when needed

### Chained transforms:

```
@chords |= (transpose 2 | retrograde)
```

Each transform operates sequentially on the evolving AST:
1. Selection marks structural positions (chord nodes)
2. `transpose 2` modifies pitches in selected chords
3. `retrograde` reverses content in same selected chords
4. Selection references remain valid - same nodes, modified content

### Special case: retrograde

Unlike pitch transforms, `retrograde` reorders content:
1. Collect pitch/note data from selected nodes (in sequence order)
2. Reverse the collected data
3. Write reversed data back to nodes in original positions

This preserves tree structure while reversing musical content.

---

## Implementation Strategy

### Approach: Hybrid with Bridges

Because different transforms work better at different levels, we will:

1. Define a common interface for all transform functions
2. Provide bridge utilities to convert between levels
3. Let each function choose its optimal level internally

```typescript
// Common interface
interface TransformFn {
  name: string;
  apply(input: TransformInput): TransformOutput;
}

// Input can be either level
type TransformInput =
  | { type: "ast"; value: Expr }           // Parser AST
  | { type: "semantic"; value: Tune };     // Interpreter output

// Output specifies what was produced
type TransformOutput =
  | { type: "ast"; value: Expr }
  | { type: "semantic"; value: Tune }
  | { type: "abc"; value: string };        // Direct ABC text
```

### Bridge Utilities

```typescript
// AST -> Semantic (already exists: TuneInterpreter)
function astToSemantic(ast: Expr): Tune

// Semantic -> ABC (already exists: Formatter2)
function semanticToAbc(tune: Tune): string

// AST -> ABC (already exists: Formatter2)
function astToAbc(ast: Expr): string
```

---

## Phase 1 Functions (Proof of Concept)

Focus on core transforms only. Voicing utilities require separate design work.

### Core Transforms (Phase 1)

| Function | Status | Notes |
|----------|--------|-------|
| `transpose` | Exists (Transposer.ts) | Wrap for ABCT interface |
| `octave` | Exists | Reuse Transposer with n*12 semitones |
| `retrograde` | To implement | Reverse sequence of notes/chords |
| `bass` | To implement | Extract lowest note from chords |

### Selectors (Phase 1)

| Selector | Description | Notes |
|----------|-------------|-------|
| `@chords` | Select all chord nodes | `isChord(node)` |
| `@notes` | Select all note nodes | `isNote(node)` |
| `@V:name` | Select voice by name | Filter by voice ID |
| `@M:n-m` | Select measure range | Filter by measure number |

### Deferred - Voicing Utilities (Separate Sub-task)

These require separate design decisions:
- What criteria for voice leading?
- Close, spread, open, or cluster position?
- Harmonize from melody or bass?
- Allow user chord input or infer from literals?
- Auto-fill passing chords?

| Function | Status | Notes |
|----------|--------|-------|
| `choralis` | Deferred | Complex - needs design phase |
| `drop2/drop3` | Deferred | Part of voicing utilities |
| `spread/close` | Deferred | Part of voicing utilities |
| `distribute` | Deferred | Part of voicing utilities |

### Already Implemented / Skip

| Function | Status | Notes |
|----------|--------|-------|
| `augment/diminish` | Done | Existing rhythm commands |
| `repeat/palindrome/rotate` | Skip | Text editor can do this |
| `invert` | Future | Needs semantic tree |

---

## Files to Create/Modify

### New Files in abct/ (Phase 1 only)

| File | Purpose |
|------|---------|
| `src/runtime/index.ts` | ABCT runtime - evaluates parsed expressions |
| `src/runtime/types.ts` | Selection, TransformFn interfaces |
| `src/runtime/selectors.ts` | @chords, @notes, @V:, @M: implementations |
| `src/runtime/transforms/index.ts` | Export all transform functions |
| `src/runtime/transforms/transpose.ts` | Wrap existing Transposer |
| `src/runtime/transforms/retrograde.ts` | Reverse sequence |
| `src/runtime/transforms/bass.ts` | Extract lowest note from chords |
| `tests/runtime.spec.ts` | Runtime execution tests |

### Files to Reference in abc_parse

| File | What to Use |
|------|-------------|
| `parse/Visitors/Transposer.ts` | Transpose implementation |
| `parse/Visitors/Formatter2.ts` | ABC output generation |
| `parse/types/Expr2.ts` | AST node types (Note, Chord, etc.) |
| `parse/helpers.ts` | Type guards (isNote, isChord, etc.) |

---

## Verification

1. Each transform function has unit tests with known inputs/outputs
2. Roundtrip test: `parse -> transform -> format -> parse` produces equivalent result
3. Property tests for mathematical properties:
   - `transpose 0` is identity
   - `transpose n | transpose -n` is identity
   - `octave 1` equals `transpose 12`
   - `drop2 | drop2` on 4-voice chord cycles voices
4. ABC output tests: transformed AST formats to valid ABC
5. Integration test: full ABCT expressions with transforms execute correctly

---

## Design Decisions

1. bass on single notes: Return the note unchanged (no-op)

2. retrograde scope: Reverse across entire selection (Option A). Measure-aware variant can be added later.

3. Selection inheritance: Selection carries through chain, transforms operate sequentially on evolving AST with same selection references.

---

## Review Findings (Feasibility Confirmed)

A Plan subagent reviewed the approach against the abc_parse codebase:

1. AST nodes have stable `id` fields, but using direct references (`Set<Expr>`) is simpler
2. `Transposer.ts` demonstrates the mutation pattern - transforms modify nodes in place
3. `Formatter2.ts` is ready to output modified AST to valid ABC
4. `RangeCollector.ts` shows pattern for collecting nodes matching criteria
5. Type guards in `helpers.ts` (`isChord`, `isNote`) provide selector predicates
