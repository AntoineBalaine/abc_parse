# Plan 12: ABCT Diagnostics

## Table of Contents

1. [Overview](#overview)
2. [Diagnostic Categories](#diagnostic-categories)
3. [Implementation](#implementation)
4. [Files to Modify/Create](#files-to-modifycreate)
5. [Verification](#verification)

## Related Plans

- Plan 11: ABCT Evaluation Commands
- Plan 13: ABCT Hover Documentation
- Plan 14: ABCT Auto-completion
- Plan 15: ABCT Formatter

---

## Overview

Provide real-time diagnostics for ABCT files in the editor. The LSP server validates ABCT code and reports errors/warnings as the user types.

---

## Diagnostic Categories

### 1. Parse Errors

Syntax errors from the ABCT grammar parser.

```
source = song.abc |  # Missing right operand
         ~~~~~~~~~~~^
Error: Unexpected end of input, expected expression
```

### 2. Unknown Functions/Transforms

When a transform name is not registered in the runtime.

```
song.abc | @chords |= frobulate 4
                      ~~~~~~~~~
Error: Unknown transform 'frobulate'. Did you mean 'translate'?
```

### 3. Unknown Selectors

When a selector identifier is not recognized.

```
song.abc | @widgets
           ~~~~~~~~
Error: Unknown selector '@widgets'. Available: @chords, @notes, @rests, @bars, @voices, @decorations, @measures
```

### 4. File Not Found

When a referenced ABC file does not exist.

```
missing.abc | @chords
~~~~~~~~~~~
Error: File not found: missing.abc
```

### 5. Type Errors

When arguments to transforms are of the wrong type.

```
song.abc | transpose "five"
                     ~~~~~~
Error: 'transpose' expects integer argument, got string
```

### 6. Warnings

Non-fatal issues that may indicate problems.

```
song.abc | @chords |= transpose 0
                                ~
Warning: transpose 0 has no effect
```

```
song.abc | @V:nonexistent
           ~~~~~~~~~~~~~~
Warning: Voice 'nonexistent' not found in file
```

---

## Implementation

### 1. Transform/Selector Registry

Create a registry of known transforms and selectors with metadata:

```typescript
// transformRegistry.ts
interface TransformInfo {
  name: string;
  description: string;
  args: ArgSpec[];
  examples: string[];
}

interface ArgSpec {
  name: string;
  type: "integer" | "number" | "string" | "list" | "expression";
  required: boolean;
  description: string;
}

const transformRegistry: Map<string, TransformInfo> = new Map([
  ["transpose", {
    name: "transpose",
    description: "Shift pitches by n semitones",
    args: [{ name: "n", type: "integer", required: true, description: "Semitones to shift" }],
    examples: ["transpose 2", "transpose -5"]
  }],
  // ... other transforms
]);

const selectorRegistry: Map<string, SelectorInfo> = new Map([
  ["chords", { name: "chords", shortForm: "c", description: "Select chord nodes" }],
  ["notes", { name: "notes", shortForm: "n", description: "Select note nodes" }],
  // ... other selectors
]);
```

### 2. Validation Visitor

Walk the ABCT AST and collect diagnostics:

```typescript
// abctValidator.ts
class AbctValidator {
  diagnostics: Diagnostic[] = [];

  validateProgram(ast: AbctProgram): Diagnostic[] {
    for (const stmt of ast.statements) {
      this.validateStatement(stmt);
    }
    return this.diagnostics;
  }

  validateApplication(app: Application): void {
    const fnName = getIdentifierName(app.terms[0]);
    if (fnName && !transformRegistry.has(fnName)) {
      this.addError(
        app.terms[0],
        `Unknown transform '${fnName}'`,
        this.suggestSimilar(fnName, transformRegistry)
      );
    }
    // Validate argument types...
  }

  validateSelector(sel: Selector): void {
    const id = sel.path.id;
    if (!selectorRegistry.has(id) && !isShortForm(id)) {
      this.addError(sel, `Unknown selector '@${id}'`);
    }
  }
}
```

### 3. File Existence Check

Validate file references asynchronously:

```typescript
async validateFileRef(ref: FileRef): Promise<void> {
  const fullPath = this.resolver.resolvePath(ref.path);
  if (!await fileExists(fullPath)) {
    this.addError(ref, `File not found: ${ref.path}`);
  }
}
```

### 4. Integration with Document

Run validation on document change:

```typescript
// AbctDocument.ts
class AbctDocument {
  async validate(): Promise<Diagnostic[]> {
    // 1. Parse errors from parser
    const parseResult = parse(this.content);
    if (!parseResult.success) {
      return [this.createParseDiagnostic(parseResult.error)];
    }

    // 2. Semantic validation
    const validator = new AbctValidator(this.fileResolver);
    const diagnostics = await validator.validateProgram(parseResult.value);

    return diagnostics;
  }
}
```

### 5. LSP Diagnostic Publishing

Push diagnostics to the editor:

```typescript
// server.ts
documents.onDidChangeContent(async (change) => {
  const doc = getAbctDocument(change.document.uri);
  if (doc) {
    const diagnostics = await doc.validate();
    connection.sendDiagnostics({
      uri: change.document.uri,
      diagnostics
    });
  }
});
```

---

## Files to Modify/Create

### LSP Server (`abc-lsp-server/src/`)

| File | Action | Purpose |
|------|--------|---------|
| `abct/transformRegistry.ts` | Create | Registry of transforms with metadata |
| `abct/selectorRegistry.ts` | Create | Registry of selectors with metadata |
| `abct/AbctValidator.ts` | Create | AST validation logic |
| `AbctDocument.ts` | Modify | Add validate() method |
| `server.ts` | Modify | Publish diagnostics on change |

---

## Verification

### Unit Tests

1. Parse errors produce diagnostics at correct locations
2. Unknown transform names are flagged
3. Unknown selector names are flagged
4. Missing files are detected
5. Type errors in arguments are caught
6. Similar name suggestions work correctly

### Integration Tests

1. Diagnostics appear in editor as user types
2. Diagnostics clear when errors are fixed
3. Multiple diagnostics can appear for same file

### Manual Testing

1. Type unknown transform name, verify red squiggle appears
2. Reference non-existent file, verify error shows
3. Fix error, verify diagnostic disappears
4. Check that suggestions for similar names appear in diagnostic message
