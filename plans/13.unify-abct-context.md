# Plan: Unify ABCT Scanner/Parser with Shared Context

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Target Architecture](#target-architecture)
3. [Phase 1: Create AbctContext with ErrorReporter](#phase-1-create-abctcontext-with-errorreporter)
4. [Phase 2: Update Scanner to Accept Context](#phase-2-update-scanner-to-accept-context)
5. [Phase 3: Update Parser to Accept Context](#phase-3-update-parser-to-accept-context)
6. [Phase 4: Update AbctDocument to Use Shared Context](#phase-4-update-abctdocument-to-use-shared-context)
7. [Phase 5: Update Tests](#phase-5-update-tests)
8. [Phase 6: Remove Useless Wrapper Functions](#phase-6-remove-useless-wrapper-functions)
9. [Files to Modify](#files-to-modify)
10. [Verification](#verification)
11. [Design Decisions](#design-decisions)

---

## Problem Statement

The current ABCT implementation has fundamental design flaws:

1. Scanner and parser have separate error arrays that get collected and re-mapped at each step
2. The wrapper functions in `abct/src/parser.ts` (`parse()`, `parseOrThrow()`, `parseExpr()`) are useless - they just do error format conversion
3. The parser should never throw and should never fail - there is no reason for `parseOrThrow()`

The ABC parser does it correctly:
```typescript
// AbcDocument.ts
ctx = new ABCContext()                    // shared context with errorReporter
ctx.errorReporter.resetErrors()           // reset before analysis
tokens = Scanner(source, ctx)             // errors go to ctx.errorReporter
ast = parse(tokens, ctx)                  // errors go to ctx.errorReporter
diagnostics = ctx.errorReporter.getErrors()  // retrieve all errors from one place
```

---

## Target Architecture

```
AbctDocument.analyze():
  ctx = this.ctx                          // AbctContext with errorReporter
  ctx.errorReporter.resetErrors()
  tokens = Scanner(source, ctx)           // scanner uses ctx.errorReporter
  ast = parse(tokens, ctx)                // parser uses ctx.errorReporter
  diagnostics = ctx.errorReporter.getErrors()  // all errors in one place
```

No wrapper functions. No error re-mapping. Scanner and parser share the context.

---

## Phase 1: Create AbctContext with ErrorReporter

### 1.1 Create `abct/src/context.ts`

```typescript
import { Token } from "./scanner/types";
import { Loc } from "./ast";

export interface AbctError {
  message: string;
  token?: Token;
  loc?: Loc;
  origin: "scanner" | "parser" | "validator";
}

export class AbctErrorReporter {
  private errors: AbctError[] = [];

  scannerError(message: string, line: number, column: number, offset: number): void {
    this.errors.push({
      message,
      loc: {
        start: { line, column, offset },
        end: { line, column: column + 1, offset: offset + 1 },
      },
      origin: "scanner",
    });
  }

  parserError(message: string, token: Token): void {
    this.errors.push({
      message,
      token,
      loc: {
        start: { line: token.line, column: token.column, offset: token.offset },
        end: { line: token.line, column: token.column + token.lexeme.length, offset: token.offset + token.lexeme.length },
      },
      origin: "parser",
    });
  }

  validatorError(message: string, loc: Loc): void {
    this.errors.push({ message, loc, origin: "validator" });
  }

  getErrors(): AbctError[] { return this.errors; }
  hasErrors(): boolean { return this.errors.length > 0; }
  resetErrors(): void { this.errors = []; }
}

export class AbctContext {
  public errorReporter: AbctErrorReporter;

  constructor(errorReporter?: AbctErrorReporter) {
    this.errorReporter = errorReporter ?? new AbctErrorReporter();
  }
}
```

---

## Phase 2: Update Scanner to Accept Context

### 2.1 Update `abct/src/scanner/context.ts`

Change `AbctCtx` to accept and use `AbctContext`:

```typescript
import { AbctContext } from "../context";

export class AbctCtx {
  // ... existing fields ...
  public abctContext: AbctContext;

  constructor(source: string, abctContext: AbctContext) {
    this.source = source;
    this.abctContext = abctContext;
    // ... rest of init ...
  }

  report(message: string): void {
    // Use shared error reporter instead of local array
    this.abctContext.errorReporter.scannerError(
      message,
      this.line + 1,  // convert to 1-based
      this.current - this.lineStart + 1,
      this.current
    );
  }
}
```

### 2.2 Update `abct/src/scanner/scanner.ts`

Change signature to accept context:

```typescript
import { AbctContext } from "../context";

export function scan(source: string, ctx: AbctContext): Token[] {
  const scanCtx = new AbctCtx(source, ctx);
  scanProgram(scanCtx);
  return scanCtx.tokens;
}
```

Remove the `ScanResult` interface - errors are now in the shared context.

---

## Phase 3: Update Parser to Accept Context

### 3.1 Update `abct/src/parser/context.ts`

Change `AbctParseCtx` to accept and use `AbctContext`:

```typescript
import { AbctContext } from "../context";

export class AbctParseCtx {
  public tokens: Token[];
  public current: number = 0;
  public abctContext: AbctContext;

  constructor(tokens: Token[], abctContext: AbctContext) {
    this.tokens = tokens;
    this.abctContext = abctContext;
  }

  error(message: string): void {
    this.abctContext.errorReporter.parserError(message, this.tokens[this.current]);
  }

  errorAt(token: Token, message: string): void {
    this.abctContext.errorReporter.parserError(message, token);
  }
}
```

### 3.2 Update `abct/src/parser/parser.ts`

Change signature to accept context:

```typescript
import { AbctContext } from "../context";

export function parse(tokens: Token[], ctx: AbctContext): Program {
  const parseCtx = new AbctParseCtx(tokens, ctx);
  return parseProgram(parseCtx);
}
```

Remove `parseTokens()` and `ParseResult` - just return the Program directly.

---

## Phase 4: Update AbctDocument to Use Shared Context

### 4.1 Update `abc-lsp-server/src/AbctDocument.ts`

```typescript
import { AbctContext } from "../../abct/src/context";
import { scan } from "../../abct/src/scanner";
import { parse } from "../../abct/src/parser/parser";

export class AbctDocument {
  public diagnostics: Diagnostic[] = [];
  public tokens: Token[] = [];
  public AST: Program | null = null;
  public ctx = new AbctContext();  // shared context

  analyze(): Token[] | void {
    const source = this.document.getText();

    // Reset before analysis
    this.ctx.errorReporter.resetErrors();
    this.diagnostics = [];
    this.tokens = [];
    this.AST = null;

    // Scan and parse with shared context
    this.tokens = scan(source, this.ctx);
    this.AST = parse(this.tokens, this.ctx);

    // Convert scanner/parser errors to diagnostics
    for (const e of this.ctx.errorReporter.getErrors()) {
      if (e.loc) {
        this.diagnostics.push({
          severity: DiagnosticSeverity.Error,
          range: Range.create(
            Position.create(e.loc.start.line - 1, e.loc.start.column - 1),
            Position.create(e.loc.end.line - 1, e.loc.end.column - 1)
          ),
          message: e.message,
          source: "abct",
        });
      }
    }

    // Run semantic validation (returns Diagnostic[] directly)
    if (this.AST) {
      const validator = new AbctValidator();
      const validatorDiagnostics = validator.validateProgram(this.AST);
      this.diagnostics.push(...validatorDiagnostics);
    }

    return this.tokens;
  }
}
```

Note: The `AbctValidator` remains unchanged - it returns LSP `Diagnostic[]` directly because it lives in the LSP server and produces LSP-specific output. This is a deliberate design choice to keep the validator decoupled from the core `abct` package.

---

## Phase 5: Update Tests

Update all tests that use the old API before removing the wrapper functions. This ensures we can verify the new API works correctly.

### 5.1 Update `abct/tests/*.spec.ts`

```typescript
// Before
const result = parse(source);
if (!result.success) { ... }
const ast = result.value;

// After
const ctx = new AbctContext();
const tokens = scan(source, ctx);
const ast = parse(tokens, ctx);
if (ctx.errorReporter.hasErrors()) { ... }
```

### 5.2 Test files to update

- `abct/tests/scanner.spec.ts` - update scan() calls to pass context
- `abct/tests/parser.spec.ts` - update to use new parse() signature
- `abct/tests/parser/recovery.spec.ts` - update error recovery tests
- `abct/tests/parser/expressions.spec.ts` - update expression parsing tests
- `abct/tests/parser/atoms.spec.ts` - update atom parsing tests
- `abct/tests/ast.spec.ts` - update AST tests if they use parse()
- `abct/tests/validator.spec.ts` - update validator tests

---

## Phase 6: Remove Useless Wrapper Functions

After tests pass with the new API, remove the old wrapper functions.

### 6.1 Delete `abct/src/parser.ts` entirely

This file contains only useless wrapper functions:
- `parse()` - just calls scan + parseTokens and re-maps errors
- `parseOrThrow()` - parser never throws, this is pointless
- `parseExpr()` - wrapper around parse

### 6.2 Update `abct/src/index.ts`

Export directly from scanner and parser:

```typescript
// Context
export { AbctContext, AbctErrorReporter, AbctError } from "./context";

// Scanner
export { scan } from "./scanner";
export { Token, AbctTT } from "./scanner/types";

// Parser
export { parse } from "./parser/parser";

// AST
export * from "./ast";
```

### 6.3 Update `abct/src/scanner/index.ts`

Remove `ScanResult` export since `scan()` now returns only `Token[]`.

---

## Files to Modify

| File | Action |
|------|--------|
| `abct/src/context.ts` | Create (new file) |
| `abct/src/scanner/context.ts` | Accept AbctContext, use shared errorReporter |
| `abct/src/scanner/scanner.ts` | Accept AbctContext, return only tokens |
| `abct/src/scanner/index.ts` | Update exports, remove ScanResult |
| `abct/src/parser/context.ts` | Accept AbctContext, use shared errorReporter, remove local errors array |
| `abct/src/parser/parser.ts` | Accept AbctContext, return only Program, rename parseTokens to parse |
| `abct/src/parser/expressions.ts` | Uses ctx.error() - no changes needed (already uses context method) |
| `abct/src/parser/atoms.ts` | Uses ctx.error() - no changes needed (already uses context method) |
| `abct/src/parser/utils.ts` | Uses ctx.error() - no changes needed (already uses context method) |
| `abct/src/parser/index.ts` | Update exports |
| `abct/src/parser.ts` | DELETE |
| `abct/src/index.ts` | Update exports |
| `abc-lsp-server/src/AbctDocument.ts` | Use shared context pattern |
| `abct/tests/scanner.spec.ts` | Update to new API |
| `abct/tests/parser.spec.ts` | Update to new API |
| `abct/tests/parser/recovery.spec.ts` | Update to new API |
| `abct/tests/parser/expressions.spec.ts` | Update to new API |
| `abct/tests/parser/atoms.spec.ts` | Update to new API |
| `abct/tests/ast.spec.ts` | Update to new API |
| `abct/tests/validator.spec.ts` | Update to new API |

---

## Verification

```bash
npm run test -w abct
npm run test -w abc-lsp-server
npm run build
```

After implementation of each phase, call the code-review agent with the list of modified files and line ranges to review the changes. Address any feedback before committing and moving to the next phase.

---

## Design Decisions

### Validator stays independent

The `AbctValidator` in `abc-lsp-server/src/abct/AbctValidator.ts` remains unchanged. It returns LSP `Diagnostic[]` directly because:

1. It lives in the LSP server package, not the core `abct` package
2. It produces LSP-specific output with `DiagnosticSeverity` and `Range` types
3. Keeping it decoupled allows the core `abct` package to remain LSP-agnostic

The validator is called after scanner/parser errors are collected, and its diagnostics are appended to the diagnostics array.

### Parser files using ctx.error()

The following parser files use `ctx.error()`:
- `expressions.ts`
- `atoms.ts`
- `utils.ts`

These files do not need changes because they call `ctx.error()` which is a method on `AbctParseCtx`. The implementation of that method changes (to use shared errorReporter), but the call sites remain the same.

### Phase ordering rationale

Phase 5 (Update Tests) comes before Phase 6 (Remove Wrapper Functions) because:

1. Tests verify the new API works correctly
2. Once tests pass, we have confidence to remove the old API
3. If tests fail, we can debug without having deleted the old implementation
