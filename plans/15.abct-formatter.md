# Plan 15: ABCT Formatter

## Table of Contents

1. [Overview](#overview)
2. [Formatting Rules](#formatting-rules)
3. [Implementation](#implementation)
4. [Files to Modify/Create](#files-to-modifycreate)
5. [Verification](#verification)

## Related Plans

- Plan 11: ABCT Evaluation Commands
- Plan 12: ABCT Diagnostics
- Plan 13: ABCT Hover Documentation
- Plan 14: ABCT Auto-completion

---

## Overview

Format ABCT code with consistent spacing and style. The formatter is triggered via the standard LSP document formatting request or editor format command.

---

## Formatting Rules

### 1. Operator Spacing

Add spaces around binary operators:

```
# Before
song.abc|@chords|=transpose 2

# After
song.abc | @chords |= transpose 2
```

### 2. No Space After `@`

Selectors attach directly to `@`:

```
# Before
song.abc | @ chords

# After
song.abc | @chords
```

### 3. Space After Commas in Lists

```
# Before
[V:S,V:A,V:T,V:B]

# After
[V:S, V:A, V:T, V:B]
```

### 4. No Space Inside Parentheses

```
# Before
( transpose 2 | retrograde )

# After
(transpose 2 | retrograde)
```

### 5. No Space Inside Brackets

```
# Before
[ 1, 2, 3 ]

# After
[1, 2, 3]
```

### 6. Single Space in Applications

```
# Before
transpose    2

# After
transpose 2
```

### 7. Preserve Line Breaks

Intentional line breaks are preserved:

```
# Before (preserved)
source = song.abc
result = source | @chords |= transpose 2
result
```

### 8. Blank Line Between Logical Sections

Add blank line before final expression if preceded by assignments:

```
# Before
source = song.abc
result = source | @chords
result

# After (preserved - already has separation)
source = song.abc
result = source | @chords
result
```

### 9. Comment Preservation

Comments are preserved in their original positions:

```
# This is a comment
source = song.abc  # inline comment
```

### 10. ABC Literal Preservation

Content inside `<<...>>` is not formatted (it's ABC, not ABCT):

```
song.abc | :1:5 |= <<[CEG][FAc]>>
                   ~~~~~~~~~~~~~~
                   (preserved as-is)
```

---

## Implementation

### 1. Formatter Visitor

Walk AST and produce formatted output:

```typescript
// abctFormatter.ts
class AbctFormatter {
  private output: string[] = [];
  private indent: number = 0;

  format(ast: AbctProgram): string {
    for (const stmt of ast.statements) {
      this.formatStatement(stmt);
    }
    return this.output.join("");
  }

  formatStatement(stmt: Statement): void {
    if (isAssignment(stmt)) {
      this.formatAssignment(stmt);
    } else {
      this.formatExpr(stmt);
    }
    this.output.push("\n");
  }

  formatAssignment(assign: Assignment): void {
    this.output.push(assign.id);
    this.output.push(" = ");
    this.formatExpr(assign.value);
  }

  formatPipe(pipe: Pipe): void {
    this.formatExpr(pipe.left);
    this.output.push(" | ");
    this.formatExpr(pipe.right);
  }

  formatUpdate(update: Update): void {
    this.formatSelector(update.selector);
    this.output.push(" |= ");
    this.formatExpr(update.transform);
  }

  formatApplication(app: Application): void {
    for (let i = 0; i < app.terms.length; i++) {
      if (i > 0) this.output.push(" ");
      this.formatExpr(app.terms[i]);
    }
  }

  formatSelector(sel: Selector): void {
    this.output.push("@");
    this.output.push(sel.path.id);
    if (sel.path.value !== undefined) {
      this.output.push(":");
      this.formatSelectorValue(sel.path.value);
    }
  }

  formatList(list: List): void {
    this.output.push("[");
    for (let i = 0; i < list.items.length; i++) {
      if (i > 0) this.output.push(", ");
      this.formatExpr(list.items[i]);
    }
    this.output.push("]");
  }

  formatAbcLiteral(lit: AbcLiteral): void {
    // Preserve content exactly
    this.output.push("<<");
    this.output.push(lit.content);
    this.output.push(">>");
  }
}
```

### 2. Comment Handling

Preserve comments by attaching them to AST nodes during parsing:

```typescript
interface AstNode {
  // ... existing fields
  leadingComments?: string[];
  trailingComment?: string;
}

// When formatting, emit attached comments
formatStatement(stmt: Statement): void {
  // Leading comments
  if (stmt.leadingComments) {
    for (const comment of stmt.leadingComments) {
      this.output.push(comment);
      this.output.push("\n");
    }
  }

  // Statement content
  // ...

  // Trailing comment
  if (stmt.trailingComment) {
    this.output.push("  ");
    this.output.push(stmt.trailingComment);
  }
}
```

### 3. Range Formatting

Support formatting a selection (not just whole document):

```typescript
formatRange(ast: AbctProgram, range: Range): TextEdit[] {
  // Find statements within range
  const stmts = ast.statements.filter(s =>
    overlaps(getRange(s), range)
  );

  // Format those statements
  const formatted = this.formatStatements(stmts);

  // Return as single text edit
  return [{
    range: expandToFullLines(range),
    newText: formatted
  }];
}
```

### 4. LSP Handler

```typescript
// server.ts
connection.onDocumentFormatting((params) => {
  const doc = getAbctDocument(params.textDocument.uri);
  if (!doc || !doc.ast) return [];

  const formatter = new AbctFormatter();
  const formatted = formatter.format(doc.ast);

  return [{
    range: getFullDocumentRange(doc),
    newText: formatted
  }];
});

connection.onDocumentRangeFormatting((params) => {
  const doc = getAbctDocument(params.textDocument.uri);
  if (!doc || !doc.ast) return [];

  const formatter = new AbctFormatter();
  return formatter.formatRange(doc.ast, params.range);
});

// Advertise capability
capabilities.documentFormattingProvider = true;
capabilities.documentRangeFormattingProvider = true;
```

---

## Files to Modify/Create

### LSP Server (`abc-lsp-server/src/`)

| File | Action | Purpose |
|------|--------|---------|
| `abct/AbctFormatter.ts` | Create | Formatting logic |
| `server.ts` | Modify | Register formatting handlers |

### Parser (`abct/src/`)

| File | Action | Purpose |
|------|--------|---------|
| `parser.ts` or grammar | Modify | Attach comments to AST nodes |

---

## Verification

### Unit Tests

1. Spaces added around `|` and `|=`
2. No space after `@`
3. Spaces after commas in lists
4. No spaces inside parentheses/brackets
5. Single space in applications
6. Comments preserved
7. ABC literals not modified
8. Line breaks preserved

### Roundtrip Tests

1. Parse, format, parse again - ASTs are equivalent
2. Format twice - output is identical (idempotent)

### Integration Tests

1. Format on save works (if enabled)
2. Format selection works
3. Format document works
4. Formatting preserves semantics

### Manual Testing

1. Open poorly formatted .abct file
2. Run "Format Document" command
3. Verify proper spacing applied
4. Verify comments not lost
5. Verify ABC literals unchanged
6. Run format again, verify no changes
