# ABCT Preview and Editable Output Implementation Plan

## Table of Contents

1. [Overview](#1-overview)
2. [Setup](#2-setup)
3. [Feature 1: ABCT Preview](#3-feature-1-abct-preview)
4. [Feature 2: Editable Evaluated Output](#4-feature-2-editable-evaluated-output)
5. [Implementation Phases](#5-implementation-phases)
6. [File Changes Summary](#6-file-changes-summary)

---

## 1. Overview

Two features for ABCT files in the VS Code extension:

**Feature 1: ABCT Preview (Read-Only Webview)**
Display evaluated ABCT output in the existing preview panel using abcjs.

**Feature 2: Editable Evaluated Output (Virtual Document)**
Open evaluated ABC in an editable text document. On save, generate ABC literal patch expressions and append to ABCT file.

---

## 2. Setup

Create a new worktree from `feature/abct-grammar`:

```
cd /workspace/abc_parse
git worktree add ../worktrees/abct-virtual-doc-preview abct-grammar-fixes
```

All work happens in `/workspace/worktrees/abct-virtual-doc-preview/`.

---

## 3. Feature 1: ABCT Preview

### 3.1 Design

**Flow:**
```
ABCT file change event
  -> call abct.evaluate LSP request
  -> receive ABC string
  -> send to webview for rendering
```

**Partial Output on Error:**
```
evaluateAbctForPreview(uri)
  result = await client.sendRequest("abct.evaluate", { uri })
  hasErrors = result.diagnostics.some(d => d.severity === 1)

  if not hasErrors
    return result.abc

  // On error, evaluate up to the line before the first error
  // Note: LSP diagnostics use 0-based lines, evaluateToLine expects 1-based
  firstError = result.diagnostics.find(d => d.severity === 1)
  errorLine = firstError.range.start.line  // 0-based

  if errorLine > 0
    // Convert: 0-based line N becomes 1-based line N (evaluates lines 1..N)
    partialResult = await client.sendRequest("abct.evaluateToLine", {
      uri,
      line: errorLine  // 1-based, evaluates up to but not including error line
    })
    return partialResult.abc
  else
    return ""  // Error on first line (line 0), no partial output possible
```

This approach:
- Shows complete output when there are no errors
- Shows partial output up to the error line when evaluation fails
- Shows nothing when error is on the first line

### 3.2 Files to Modify

- `vscode-extension/src/renderer/AbcRenderer.ts`
- `vscode-extension/src/renderer/rendererCommands.ts`
- `vscode-extension/src/extension.ts`

---

## 4. Feature 2: Editable Evaluated Output

### 4.1 Design

**Command:** `abct.openEvaluatedOutput`

**Flow:**
```
User invokes command on ABCT file
  -> evaluate ABCT via LSP
  -> create virtual document with abct-eval:// URI
  -> open in editor (editable)

User edits and saves virtual document
  -> compute character-level diff vs original
  -> generate ABC literal patches with location selectors
  -> append patches to source ABCT file
```

**Virtual Document URI Scheme:**
```
abct-eval://<source-uri-base64>/<unix-timestamp>.abc
```
- Source URI is Base64-encoded to avoid path separator issues
- Unix timestamp in milliseconds ensures uniqueness
- `.abc` extension enables VS Code ABC language mode

**Patch Expression Format:**
```
// Single-line change:
<source-expr> | :<line>:<startCol>-<endCol> |= <<modified content>>

// Multi-line change:
<source-expr> | :<startLine>:<startCol>-<endLine>:<endCol> |= <<modified content>>
```

**Source Expression:**
The `<source-expr>` is determined by finding the last top-level statement in the ABCT file:
- If it is an expression statement (not an assignment), use that expression's text
- If it is an assignment (`x = expr`), use the identifier `x`
- This requires parsing the ABCT document to find the last statement

Example: For ABCT file containing:
```
a = file.abc
b = a | transpose 2
b
```
The source-expr is `b` (the last expression statement).

**Virtual Document Auto-Update:**
- If document is clean (no unsaved edits): auto-update on source ABCT change
- If document is dirty (has unsaved edits): show notification, don't update
- Provide "Refresh" command to manually re-evaluate

### 4.2 Character-Level Diff Algorithm

```
diffChars(original: string, modified: string): Change[]

interface Position { line: number; column: number }  // 1-based

interface Change {
  type: "insert" | "delete" | "replace"
  originalStart: Position   // line, column in original (1-based)
  originalEnd: Position     // inclusive end position
  newContent: string        // for insert/replace (empty for delete)
}

Algorithm:
1. Convert strings to character arrays with position tracking
2. Compute LCS (Longest Common Subsequence) on characters
3. Walk through LCS to identify change regions
4. Merge adjacent changes of same type
5. Convert flat character offsets to line:column positions (1-based)
6. For multi-line changes, originalStart and originalEnd will have different line values
```

**Edge Cases:**
- Empty original: all content is "insert" at position 1:1
- Empty modified: all content is "delete"
- No changes: return empty array (skip patch generation)
- Unicode: use string code points, not UTF-16 code units

### 4.3 Patch Generation

```
generatePatches(changes: Change[], sourceExpr: string): string[]

For each change (sorted by position, descending):
  start = change.originalStart
  end = change.originalEnd

  if start.line === end.line
    // Single-line selector
    selector = `:${start.line}:${start.column}-${end.column}`
  else
    // Multi-line selector
    selector = `:${start.line}:${start.column}-${end.line}:${end.column}`

  if change.type is "delete"
    patch = `${sourceExpr} | ${selector} |= <<>>`
  else
    // Escape >> in content by doubling: >> becomes >>>>
    escapedContent = change.newContent.replace(/>>/g, ">>>>")
    patch = `${sourceExpr} | ${selector} |= <<${escapedContent}>>`

Return array of patch expressions
```

**Note:** Patches are sorted descending by position so that applying them in order does not shift positions of subsequent patches.

### 4.4 Files to Create/Modify

- `vscode-extension/src/abct/AbctEvalDocProvider.ts` (new - FileSystemProvider)
- `vscode-extension/src/abct/diffToPatches.ts` (new - diff algorithm)
- `vscode-extension/src/abctCommands.ts` (modify - add command)
- `vscode-extension/package.json` (modify - register provider and command)

---

## 5. Implementation Phases

### Phase 1: Preview Infrastructure

**Goal:** Add ABCT evaluation support to AbcRenderer

**Changes to `AbcRenderer.ts`:**
1. Add module-level state:
   - `_client: LanguageClient | undefined`
2. Add `AbctEvalResult` interface
3. Add `evaluateAbctForPreview(uri): Promise<string>` with partial output logic:
   - Call `abct.evaluate`
   - If errors, call `abct.evaluateToLine` with line before first error
4. Make `getCurrentEditorContent()` async
5. Update `updatePreview()` to be async and support "abct" language

**Testing Phase 1:**
- Unit test: `evaluateAbctForPreview` with mock client
  - Test successful evaluation returns full output
  - Test error calls evaluateToLine with correct line number conversion
  - Test error on first line (line 0) returns empty string
  - Test warnings only (no errors) returns full output
  - Test LSP request failure returns empty string gracefully
- Manual test: Open ABCT file, invoke preview

**Commit after Phase 1 tests pass.**

---

### Phase 2: LSP Client Integration

**Goal:** Wire up LSP client to renderer

**Changes:**
1. `rendererCommands.ts`: Accept and pass `LanguageClient`
2. `extension.ts`: Pass client to `registerRendererCommands`

**Testing Phase 2:**
- Integration test: Preview updates on ABCT file change
- Manual test:
  - Open ABCT file, invoke preview, verify rendered output
  - Edit ABCT, verify preview updates
  - Introduce syntax error, verify partial output shows
  - Fix error, verify full output restored

**Commit after Phase 2 tests pass.**

---

### Phase 3: FileSystemProvider for Virtual Documents

**Goal:** Create editable virtual document infrastructure

**New file `AbctEvalDocProvider.ts`:**
```
class AbctEvalDocProvider implements FileSystemProvider

  // Storage
  documents: Map<string, {
    originalContent: string
    currentContent: string
    sourceUri: string
    sourceExpr: string
    evaluatedAt: number
  }>

  // Required methods
  stat(uri): FileStat
  readFile(uri): Uint8Array
  writeFile(uri, content, options): void
  watch(uri): Disposable

  // Helper methods
  createDocument(sourceUri, content, sourceExpr): Uri
  getDocument(uri): DocumentState | undefined
```

**Testing Phase 3:**
- Unit test: FileSystemProvider methods
  - `readFile` returns stored content
  - `writeFile` updates current content
  - `stat` returns correct file type
- Unit test: `createDocument` generates correct URI

**Commit after Phase 3 tests pass.**

---

### Phase 4: Diff Algorithm

**Goal:** Implement character-level diff

**New file `diffToPatches.ts`:**
```
interface Position { line: number; column: number }

interface Change {
  type: "insert" | "delete" | "replace"
  originalStart: Position
  originalEnd: Position
  newContent: string
}

function diffChars(original: string, modified: string): Change[]

// Uses LCS (Longest Common Subsequence) for character comparison
// Converts flat character indices to line:column positions
```

**Testing Phase 4:**
- Unit test: `diffChars` with various inputs
  - Single character insert
  - Single character delete
  - Word replacement
  - Multi-line changes (verify line numbers in Change objects)
  - No changes (returns empty array)
  - Complete replacement
  - Empty original string
  - Empty modified string
  - Change at very beginning of file
  - Change at very end of file
  - Unicode characters (emoji, accented chars)

**Commit after Phase 4 tests pass.**

---

### Phase 5: Patch Generation

**Goal:** Convert diffs to ABC literal expressions

**Add to `diffToPatches.ts`:**
```
function generatePatches(
  changes: Change[],
  sourceExpr: string
): string[]

// Generates expressions like:
// sourceExpr | :5:10-15 |= <<new content>>
```

**Testing Phase 5:**
- Unit test: `generatePatches`
  - Single change produces single patch
  - Multiple changes produce multiple patches
  - Delete produces empty literal
  - Insert at end of line

**Commit after Phase 5 tests pass.**

---

### Phase 6: Command Integration

**Goal:** Wire everything together with the `abct.openEvaluatedOutput` command

**Changes to `abctCommands.ts`:**
```
registerCommand("abct.openEvaluatedOutput", async () => {
  editor = getActiveAbctEditor()
  result = await client.sendRequest("abct.evaluate", { uri })

  // Get the source expression for patches
  sourceExpr = await getLastExpression(editor.document.uri)

  docUri = evalDocProvider.createDocument(
    editor.document.uri,
    result.abc,
    sourceExpr
  )

  await vscode.window.showTextDocument(docUri)
})
```

**getLastExpression implementation:**
```
// New LSP request to get the source expression for patches
async function getLastExpression(uri: string): Promise<string> {
  // Option A: Add new LSP request "abct.getLastExpression"
  // The server parses the ABCT file and returns the text of the last
  // top-level statement (or identifier if it's an assignment)

  // Option B: Parse client-side using the ABCT parser
  // This requires importing the parser into the extension

  // Recommended: Option A (server-side) to keep the extension light
  return await client.sendRequest("abct.getLastExpression", { uri })
}
```

**Server-side handler (add to server.ts):**
```
connection.onRequest("abct.getLastExpression", async (params) => {
  doc = abcDocuments.get(params.uri)
  if not doc or not doc.AST
    return null

  statements = doc.AST.statements
  if statements.length === 0
    return null

  lastStmt = statements[statements.length - 1]
  if lastStmt is Assignment
    return lastStmt.id.name  // Return the identifier
  else
    // Return the expression text from source
    return doc.source.substring(lastStmt.loc.start.offset, lastStmt.loc.end.offset)
})
```

**On save handler:**
```
onDidSaveTextDocument(doc) {
  if doc.uri.scheme !== "abct-eval" return

  state = evalDocProvider.getDocument(doc.uri)
  changes = diffChars(state.originalContent, state.currentContent)

  // No changes? Skip silently
  if changes.length === 0
    return

  patches = generatePatches(changes, state.sourceExpr)

  // Verify source file still exists and is writable
  try {
    sourceDoc = await workspace.openTextDocument(state.sourceUri)
  } catch {
    showError("Source ABCT file no longer exists")
    return
  }

  // Append patches to source ABCT file
  edit = new WorkspaceEdit()
  edit.insert(sourceDoc.uri, endOfFile, "\n" + patches.join("\n"))

  success = await workspace.applyEdit(edit)
  if not success
    showError("Failed to apply patches to source file")
    return

  // Update original content to new state (changes are now applied)
  state.originalContent = state.currentContent
  showInfo(`Applied ${patches.length} patch(es) to source file`)
}
```

**Changes to `package.json`:**
- Add `abct.openEvaluatedOutput` command
- Register `abct-eval` file system provider

**Testing Phase 6:**
- Integration test: Full workflow
  - Open ABCT file
  - Invoke command
  - Verify virtual document opens with evaluated content
  - Make edit, save
  - Verify patches appended to ABCT file
- Manual test: End-to-end workflow

**Commit after Phase 6 tests pass.**

---

### Phase 7: Auto-Update and Refresh

**Goal:** Handle source ABCT changes while virtual document is open

**Add to `AbctEvalDocProvider.ts`:**
```
// Track source file changes
onSourceChanged(sourceUri: string, newContent: string) {
  for each virtual doc linked to sourceUri:
    if doc is dirty (has unsaved edits):
      showWarning("Source file changed. Refresh to see new output.")
    else:
      update doc with newContent
      fire onDidChangeFile event
}

// Refresh command
registerCommand("abct.refreshEvaluatedOutput", async () => {
  doc = activeEditor.document
  if doc.uri.scheme !== "abct-eval" return

  state = evalDocProvider.getDocument(doc.uri)
  result = await client.sendRequest("abct.evaluate", { uri: state.sourceUri })

  evalDocProvider.updateDocument(doc.uri, result.abc)
})
```

**Testing Phase 7:**
- Unit test: `onSourceChanged` logic
  - Clean doc gets updated
  - Dirty doc shows warning
- Integration test: Source change triggers update
- Manual test: Full refresh workflow

**Commit after Phase 7 tests pass.**

---

## 6. File Changes Summary

| Phase | File | Change Type |
|-------|------|-------------|
| 1 | `vscode-extension/src/renderer/AbcRenderer.ts` | Modify - add ABCT eval with partial output |
| 2 | `vscode-extension/src/renderer/rendererCommands.ts` | Modify - accept LanguageClient |
| 2 | `vscode-extension/src/extension.ts` | Modify - pass client to renderer |
| 3 | `vscode-extension/src/abct/AbctEvalDocProvider.ts` | Create - FileSystemProvider |
| 4-5 | `vscode-extension/src/abct/diffToPatches.ts` | Create - diff algorithm and patch gen |
| 6 | `vscode-extension/src/abctCommands.ts` | Modify - add openEvaluatedOutput command |
| 6 | `abc-lsp-server/src/server.ts` | Modify - add getLastExpression handler |
| 6 | `vscode-extension/package.json` | Modify - register command and provider |
| 7 | `vscode-extension/src/abct/AbctEvalDocProvider.ts` | Modify - add auto-update logic |
| 7 | `vscode-extension/src/extension.ts` | Modify - add deactivation cleanup |

---

## Workflow Reminder

For each phase:
1. Implement the changes
2. Write/run tests
3. Run `npm run test` to verify all tests pass
4. Run `npm run build` from repo root to verify build succeeds
5. Run code review agent
6. Address any feedback
7. Commit changes
8. Proceed to next phase

## Cleanup on Extension Deactivation

In `extension.ts` deactivate function:
- Clear all virtual document state from AbctEvalDocProvider
- Dispose of any active subscriptions
