# ABCT Integration Tests Plan

## Table of Contents

1. [Overview](#overview)
2. [Problem Statement](#problem-statement)
3. [Integration Test Categories](#integration-test-categories)
4. [Implementation Details](#implementation-details)
5. [Critical Files](#critical-files)
6. [Verification](#verification)

---

## Overview

Add integration tests to the ABCT codebase to ensure consistency across layers. The goal is to prevent bugs like the missing `@bass` registry entry, where a feature is implemented in one layer (runtime) but not another (registry).

---

## Problem Statement

The ABCT system has multiple layers that must stay synchronized:

| Layer | Location | Purpose |
|-------|----------|---------|
| Runtime | `abct/src/runtime/` | Selector/transform implementations |
| Registry | `abct/src/registry.ts` | Metadata for validation, completions, hover |
| Validator | `abc-lsp-server/src/abct/AbctValidator.ts` | Uses registry to validate programs |
| Evaluator | `abc-lsp-server/src/abctEvaluator.ts` | Uses runtime to execute programs |
| Completions | `abc-lsp-server/src/abct/AbctCompletionProvider.ts` | Uses registry for suggestions |
| Hover | `abc-lsp-server/src/abct/AbctHoverProvider.ts` | Uses registry for documentation |

Bug discovered: `@bass` selector was implemented in runtime but not registered, causing "Unknown selector" errors from validator while evaluator worked fine.

---

## Integration Test Categories

### 1. Runtime-Registry Consistency

Ensure all selectors/transforms in runtime are registered in registry.

```typescript
describe("Runtime-Registry consistency", () => {
  it("all runtime selectors should be in selectorRegistry", () => {
    const runtimeSelectors = ["chords", "notes", "voices", "measures", "bass"];
    for (const sel of runtimeSelectors) {
      expect(getSelectorInfo(sel), `Selector '${sel}' missing from registry`).to.not.be.undefined;
    }
  });

  it("all runtime selector short forms should work", () => {
    for (const [name, info] of selectorRegistry) {
      if (info.shortForm) {
        // Short form should resolve to same selector
        expect(() => applySelector(testAst, info.shortForm)).to.not.throw();
      }
    }
  });

  it("all runtime transforms should be in transformRegistry", () => {
    const runtimeTransforms = ["transpose", "octave", "retrograde", "bass", "filter"];
    for (const t of runtimeTransforms) {
      expect(getTransformInfo(t), `Transform '${t}' missing from registry`).to.not.be.undefined;
    }
  });

  it("applySelector and applyScopedSelector should support same selectors", () => {
    const selectors = ["chords", "notes", "bass"];
    for (const sel of selectors) {
      // Top-level
      expect(() => applySelector(testAst, sel)).to.not.throw();
      // Scoped (nested context)
      expect(() => applyScopedSelector(testSelection, sel)).to.not.throw();
    }
  });
});
```

### 2. Validator-Evaluator Consistency

Ensure programs that pass validation can be evaluated without errors.

```typescript
describe("Validator-Evaluator consistency", () => {
  const validPrograms = [
    "src.abc | @chords",
    "src.abc | @bass",
    "src.abc | @notes | transpose 2",
    "src.abc | @chords |= (@bass | transpose -12)",
    "src.abc | @notes | filter (pitch > C4)",
    "src.abc | :2 | transpose 1",
  ];

  for (const prog of validPrograms) {
    it(`valid program should evaluate: ${prog}`, async () => {
      const diagnostics = validate(prog);
      expect(diagnostics.filter(d => d.severity === DiagnosticSeverity.Error)).to.be.empty;

      // Should also evaluate without throwing
      await expect(evaluate(prog, testAbcContent)).to.not.be.rejected;
    });
  }
});
```

### 3. LSP-Registry Consistency

Ensure LSP features (completions, hover) cover all registered items.

```typescript
describe("LSP-Registry consistency", () => {
  it("completion provider should offer all registered selectors", () => {
    const completions = getCompletions("src.abc | @", cursorPosition);
    const selectorNames = Array.from(selectorRegistry.keys());

    for (const name of selectorNames) {
      const info = selectorRegistry.get(name)!;
      const hasFullForm = completions.some(c => c.label === name);
      const hasShortForm = info.shortForm && completions.some(c => c.label === info.shortForm);

      expect(hasFullForm || hasShortForm, `Selector '${name}' missing from completions`).to.be.true;
    }
  });

  it("completion provider should offer all registered transforms", () => {
    const completions = getCompletions("src.abc | @notes | ", cursorPosition);
    const transformNames = Array.from(transformRegistry.keys());

    for (const name of transformNames) {
      expect(completions.some(c => c.label === name), `Transform '${name}' missing from completions`).to.be.true;
    }
  });

  it("hover provider should return info for all registered selectors", () => {
    for (const [name] of selectorRegistry) {
      const hover = getHoverForSelector(name);
      expect(hover, `No hover for selector '${name}'`).to.not.be.null;
    }
  });

  it("hover provider should return info for all registered transforms", () => {
    for (const [name] of transformRegistry) {
      const hover = getHoverForTransform(name);
      expect(hover, `No hover for transform '${name}'`).to.not.be.null;
    }
  });
});
```

### 4. Parser-Formatter Round-trip

Ensure parsing and formatting are consistent.

```typescript
describe("Parser-Formatter round-trip", () => {
  const programs = [
    "src.abc | @chords |= transpose 2",
    "src.abc | @bass | retrograde",
    "x = src.abc\nx | @notes | filter (pitch > C4)",
    "a.abc + b.abc | @chords",
  ];

  for (const prog of programs) {
    it(`should round-trip: ${prog}`, () => {
      const ast1 = parse(prog);
      const formatted = format(ast1);
      const ast2 = parse(formatted);

      // ASTs should be structurally equivalent
      expect(astEqual(ast1, ast2)).to.be.true;
    });
  }

  it("property: formatting should be idempotent", () => {
    fc.assert(
      fc.property(programArb, (prog) => {
        const formatted1 = format(parse(prog));
        const formatted2 = format(parse(formatted1));
        return formatted1 === formatted2;
      })
    );
  });
});
```

### 5. End-to-End Pipeline Tests

Test complete program execution from source to output.

```typescript
describe("End-to-end pipeline", () => {
  it("should execute complete ABCT program", async () => {
    const abctSource = `
      input = test.abc
      input | @chords |= transpose 2
    `;
    const abcContent = "X:1\nK:C\n[CEG]";

    // Full pipeline: parse → validate → evaluate
    const result = await executeAbct(abctSource, { "test.abc": abcContent });

    expect(result.diagnostics).to.be.empty;
    expect(result.output).to.include("[EG^B]"); // Transposed chord
  });
});
```

---

## Implementation Details

### Test File Location

Create new file: `abct/tests/integration.spec.ts`

### Required Imports

```typescript
import { expect } from "chai";
import * as fc from "fast-check";
import { ABCContext } from "../../parse/parsers/Context";
import { Scanner } from "../../parse/parsers/scan2";
import { parseAbcContent } from "../../parse/parsers/parse2";
import { parse } from "../src/parser";
import { format } from "../src/formatter";
import { validate } from "../../abc-lsp-server/src/abct/AbctValidator";
import { AbctEvaluator } from "../../abc-lsp-server/src/abctEvaluator";
import {
  applySelector,
  selectAll,
  transforms,
  getTransform,
} from "../src/runtime";
import {
  selectorRegistry,
  transformRegistry,
  getSelectorInfo,
  getTransformInfo,
} from "../src/registry";
```

### Helper Functions

```typescript
// Create test ABC AST
function createTestAst(abc: string = "X:1\nK:C\n[CEG] [FAc] D E F") {
  const ctx = new ABCContext();
  const tokens = Scanner(abc, ctx);
  return parseAbcContent(tokens, ctx);
}

// Create test selection
function createTestSelection(abc?: string) {
  const ast = createTestAst(abc);
  return selectAll(ast);
}

// Compare ASTs structurally (ignore locations)
function astEqual(a: Expr, b: Expr): boolean {
  // Implementation: deep compare ignoring loc fields
}
```

### Test Data

```typescript
// Known runtime selectors (source of truth)
const RUNTIME_SELECTORS = ["chords", "notes", "voices", "measures", "bass"];

// Known runtime transforms (source of truth)
const RUNTIME_TRANSFORMS = ["transpose", "octave", "retrograde", "bass", "filter"];

// Valid ABCT programs for validation-evaluation consistency
const VALID_PROGRAMS = [
  "src.abc | @chords",
  "src.abc | @notes",
  "src.abc | @bass",
  "src.abc | @notes | transpose 2",
  "src.abc | @chords |= bass",
  "src.abc | @chords |= (@bass | transpose -12)",
  "src.abc | @notes | filter (pitch > C4)",
  "src.abc | @chords | filter (size >= 3)",
];
```

---

## Critical Files

| File | Purpose |
|------|---------|
| `abct/tests/integration.spec.ts` | New integration test file (create) |
| `abct/src/registry.ts` | Registry being tested |
| `abct/src/runtime/index.ts` | Runtime being tested |
| `abc-lsp-server/src/abctEvaluator.ts` | Evaluator being tested |
| `abc-lsp-server/src/abct/AbctValidator.ts` | Validator being tested |
| `abc-lsp-server/src/abct/AbctCompletionProvider.ts` | Completion provider being tested |
| `abc-lsp-server/src/abct/AbctHoverProvider.ts` | Hover provider being tested |

---

## Verification

After implementation:

1. Run tests: `cd /workspace/abc_parse && npm run test`
2. Verify all new integration tests pass
3. Intentionally break consistency (e.g., remove a selector from registry) and verify tests catch it
4. Check that tests cover all 5 categories listed above

### Expected Test Count

Approximately 20-30 new test cases:
- Runtime-Registry: ~8 tests
- Validator-Evaluator: ~8 tests (one per valid program)
- LSP-Registry: ~4 tests
- Parser-Formatter: ~5 tests
- End-to-End: ~2 tests
