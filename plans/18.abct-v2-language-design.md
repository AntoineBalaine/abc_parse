# ABCt v2 Language Design

---

URGENT: DESIGN GAP - NO SURFACE SYNTAX FOR NESTED SELECTORS

The internal API supports selector composition via function nesting: `selectNotes(selectChords(sel))`. However, there is no surface syntax to express arbitrary selector nesting in a single expression. The `@selector` syntax only works as arguments to verbs (e.g., `transpose @chords 2`), and passing multiple selectors like `@chords @notes` narrows the same implicit input independently rather than nesting.

Current workarounds:
- Use `over` for scoped nesting: `over @chords (transpose @notes 2)`
- Pre-composed selector primitives: `selectChordNotes`, `selectNonChordNotes`

This is insufficient for arbitrary composition. We need a surface syntax for expressing nested selection (e.g., "notes within chords within tune 1") without requiring `over` or pre-defined compound selectors.

---

## Table of Contents

- [ABCt v2 Language Design](#abct-v2-language-design)
  - [Table of Contents](#table-of-contents)
  - [Design Exploration: How We Got Here](#design-exploration-how-we-got-here)
    - [The Problem with v1](#the-problem-with-v1)
    - [The Pipe Metaphor is Dishonest](#the-pipe-metaphor-is-dishonest)
    - [Comparison with Existing Systems](#comparison-with-existing-systems)
    - [The Extraction Model](#the-extraction-model)
    - [Verb-First Syntax](#verb-first-syntax)
    - [The Write-Back Problem and `over`](#the-write-back-problem-and-over)
    - [User-Defined Transforms and Pattern Matching](#user-defined-transforms-and-pattern-matching)
    - [Voice Assignment as Header-Only Declaration](#voice-assignment-as-header-only-declaration)
    - [A Scheme-Inspired Core Without the Scheme Runtime](#a-scheme-inspired-core-without-the-scheme-runtime)
    - [The Child-Sibling Tree](#the-child-sibling-tree)
  - [Language Specification](#language-specification)
    - [Core Semantics](#core-semantics)
    - [Surface Syntax Constructs](#surface-syntax-constructs)
    - [Desugaring Rules](#desugaring-rules)
    - [Core IR](#core-ir)
    - [Values](#values)
    - [Built-in Primitives](#built-in-primitives)
    - [Tree Representation](#tree-representation)
    - [Transform Pipeline](#transform-pipeline)

---

## Design Exploration: How We Got Here

### The Problem with v1

The v1 implementation of ABCt (see `plans/9.abct-language-spec.md`) was built around pipes and selectors operating on the ABC parser's AST. While it had a working language server with autocompletion, hover, formatting, preview, and partial evaluation, the design itself felt wrong in practice:

- The pipes don't represent data flow. The notation `@chords | transpose 2` looks like data flows from the selector to the transform, but what actually happens is that `@chords` marks nodes in a shared mutable tree and `transpose` mutates those marked nodes. This is a side-effecting command pattern disguised as functional programming.
- The system has two pipe operators (`|` and `|=`) whose distinction is fundamental but visually subtle. The `|` extracts, the `|=` updates in context. Because both look like pipes, the user must constantly remember which "mode" they are in.
- Selectors don't produce output. They mark nodes for later mutation, which means they can't be composed independently of transforms.
- The runtime mutates the AST in place via a `Selection` object that pairs the full tree with a `Set<Expr>` of "selected" nodes. Because transforms fire on a mutable shared tree, the order of operations matters in non-obvious ways, and composing transforms is fragile.

### The Pipe Metaphor is Dishonest

The fundamental tension in v1 is that Unix-style pipes model linear data flow (stream in, stream out), but ABCt operates on a tree structure. These paradigms conflict:

- In Unix pipes, each stage genuinely receives data from the previous stage and produces data for the next.
- In v1's pipes, nothing actually flows. The system operates on a mutable shared tree via side effects, and the pipe notation merely sequences those effects.

We needed a design where pipes are honest: each `|` means "take the output of the left, feed it as input to the right." Genuine function composition, not sequenced mutation.

### Comparison with Existing Systems

We examined several existing tree-processing systems:

- `jq`: Gets the pipe-over-tree model right by committing fully to immutability. Every filter is a function from value to value(s). The pipe is genuine function composition. The `|=` operator returns a new tree with the focused part updated. However, jq's selector-as-filter model (`.field` produces values) doesn't map directly to our needs because our selectors are arguments to verbs, not standalone filters.
- XSLT/XPath: Cleanly separates "what to match" (XPath) from "what to produce" (templates). Output is always a new tree. Declarative processing model. However, the verbosity and push-based processing model aren't appropriate for an arranging language.
- Stratego: Transformations are rewrite rules (pattern -> replacement), and strategies control where rules are applied (topdown, bottomup, etc.). The separation of "what to do" (rules) from "where to do it" (strategies) is powerful and directly applicable.
- Opus Modus (OMN): Decomposes music into independent parameter lists (pitch, rhythm, dynamics) that can be transformed and recomposed. This is powerful for algorithmic composition but not for arranging, which is primarily structural (extract parts, transform, route to instruments).

### The Extraction Model

The use case is arranging: we have a source score and want to derive multiple parts by extracting, transforming, and routing material to instruments. The operations are:

1. Extract a subset of the score (a voice, a measure range, a type of element)
2. Transform it (transpose, voice-lead, augment, etc.)
3. Route the result to an instrument/voice in the output

This is fundamentally an extraction-and-routing model. Everything the pipe produces is extracted content — a new immutable value, not a mutation of the source.

We decided that extraction is the default pipe behavior. If you want to modify something within a larger context and get the whole thing back, you need to be explicit about it (see the `over` section below).

### Verb-First Syntax

Through working with examples, we discovered a preference for verb-first syntax: `transpose @chords 2` rather than `@chords | transpose 2`. This feels Lisp-like (the verb/function comes first, followed by its arguments) but with the subject implicit (the pipeline value).

The consequence is that selectors are not standalone pipeline stages. They always appear as arguments to a verb. The pipe `|` feeds the implicit input to the next verb in the chain.

```
source | transpose @chords 2 | retrograde @notes
```

Each verb receives the pipeline value as its implicit first input, applies its operation to the selected subset, and passes the result forward.

### The Write-Back Problem and `over`

Because pipes are extraction-only, we needed a construct for "modify a part within a larger context and return the whole thing." We examined several approaches:

- A postfix `|=` operator: ambiguous because it needs to "reach back" past the grouped expression to find the context.
- A `within { }` block: syntactically heavy.
- An `at` keyword: doesn't clearly indicate the write-back semantics.

We settled on `over`, borrowed from Haskell's lens vocabulary. A lens is a pair of operations: a getter (extract a subpart from a whole) and a setter (produce a new whole with the subpart replaced). The `over` verb is the setter:

```
source | over :M:5-8 (transpose @chords 2)
```

This reads: "over measures 5-8 of source, transpose the chords up 2 semitones, return the whole source with that region replaced by the result." The parenthesized pipeline is the transform to apply within the focused region.

The rule is simple: pipes extract, `over` writes back. One mechanism for each direction, no ambiguity.

### User-Defined Transforms and Pattern Matching

We needed user-defined transforms that can express logic beyond what built-in primitives offer. We considered three options:

1. Pipelines only (no pattern matching): simple but limited. The language is closed — if no built-in does what you want, you're stuck.
2. Full pattern matching with manual recursion: powerful but forces the user to understand and manually traverse the tree structure.
3. Pattern matching with strategy-based traversal: the user provides per-node rules (what to do with specific node shapes), and a strategy combinator handles the recursion.

We chose option 3. The user writes rules that match on node tags:

```
fn my_voicing = match {
  chord |c| if (c | select @notes | length) >= 4 =>
    c | over @notes drop2_logic
}

source | topdown my_voicing
```

The Zig-style capture `|c|` binds the matched node to a variable. The guard uses the same pipeline language. The right side of `=>` produces the replacement. Unmatched nodes pass through unchanged. Nestable selectors handle tree traversal.

Because selectors handle traversal, the user never writes manual `next`-pointer traversal. They only write the interesting cases.

### Voice Assignment as Header-Only Declaration

We initially considered a content-block syntax for voice assignment (`add_voice "Trumpet" { melody | transpose 2 }`). We rejected this because it conflates two concerns: declaring that a voice exists and producing the content for that voice.

In ABC, a voice is declared with a `V:` line in the tune header (before the K: line). The body content for each voice is a separate concern — the composer produces it by transforming and formatting selections. The `add-voice` operation handles only the declaration:

```
source | over X:1 (
  add_vx {name="Trumpet", clef=treble, id="trp"}
  | insert :8:0 `[v:trp] abcde | gefa ||`
)
```

This inserts `V:trp name="Trumpet" clef=treble` in the tune header before the K: line. It does not modify the tune body. after that, we perform an insert at line 8, char 0, containing the rest.

For multi-voice arrangement, we chain multiple `add-voice` calls (each returning a new Selection with the added declaration), then format each voice's body independently.

We also rejected a `score` constructor abstraction. ABC tunes are just an `X:<number>` followed by optional info lines and a body. The only value in providing abstractions is autocompletion for info line arguments and stylesheet directive arguments, which are complex and can't be memorized.

### A Scheme-Inspired Core Without the Scheme Runtime

We considered whether the language should be built on Scheme. The Racket `#lang` model is appealing: design a surface syntax, desugar it to a well-understood core, evaluate the core.

However, embedding an actual Scheme runtime (Scheme inside TypeScript inside V8) adds unnecessary layers. The insight from Racket is about design methodology, not runtime architecture.

The architecture is:

```
ABCt surface syntax → parser + desugarer → Core IR → evaluator (TypeScript) → result
```

The core IR is a minimal functional language — just enough to express the operations the surface syntax needs. The evaluator is a straightforward recursive TypeScript interpreter. No Scheme runtime, no extra layers.

### The Child-Sibling Tree

The ABC parser produces a deeply-nested AST with heterogeneous container arrays (`tune_body.sequence: Array<Array<Expr|Token>>`, `Beam.contents`, `Chord.contents`). Traversing siblings in these arrays requires knowing the parent container and the current index, which makes traversal code verbose and error-prone.

The child-sibling tree is an intermediate representation that wraps the existing AST Expr instances with uniform navigation pointers (`firstChild`, `nextSibling`). Transforms operate on this tree for structural changes (removing nodes, reordering siblings) and mutate the wrapped Expr instances directly for value changes (pitch, rhythm). The tree is then converted back to the AST format (rebuilding the container arrays from the remaining sibling chains) before formatting.

Key decisions:
- Each CS node wraps a reference to the original AST Expr instance. The Expr's `id` field is used for selection lookups.
- No parent pointers: operations that need to splice use re-traversal from the root to locate predecessors.
- Mutable with cloning for isolation: before any mutating operation, the AST is deep-cloned. The clone preserves node IDs so that Selection sets remain valid.
- Source locations preserved: each node carries token-level source positions (via the wrapped Expr) for language server integration.
- Conversion functions bridge the two representations: `fromAst()` builds the CS tree from the parser's AST, and `toAst()` converts back by collecting sibling chains into arrays.

The node structure:
```
CSNode {
  id: number           -- same as the wrapped Expr's id
  expr: Expr | Token   -- reference to the original AST node
  firstChild: CSNode | null
  nextSibling: CSNode | null
}
```

There are no parent pointers. Because parent pointers become stale when nodes are moved or spliced, operations that need to locate a node's predecessor re-traverse from the root instead.

The transform pipeline is:

```
Parser AST → clone → fromAst() → child-sibling tree → operations (mutate) → toAst() → Formatter
```

---

## Language Specification

### Core Semantics

- Every expression evaluates to a value. Operations clone before mutating, so the caller's input is never modified (isolation via cloning, not structural sharing).
- The pipe `|` is function composition with reversed argument order: `a | b` means `b(a)`.
- All operations are extraction by default: the pipe produces a new value, not a mutation of the input.
- `over` is the only construct for modifying a part within a larger context and returning the whole.
- Selectors compose by narrowing: each selector takes a Selection and produces a narrower Selection. Composition is natural nesting: `select-top(select-chords(sel))`.
- The Selection type pairs an AST with a set of selected node IDs (`Set<number>`). IDs are stable across cloning.
- Higher-level transforms (drop-2, legato-fill, chord-top-note) are recipes composed from generic selectors and operations, not primitives.
- User-defined functions are closures. Transforms are just functions from music-tree to music-tree.

### Surface Syntax Constructs

- Binding: `name = expr` — names an intermediate result.
- Pipeline: `expr | expr` — feeds the left value as implicit input to the right verb.
- Location: `:M:5-8`, `:10:5`, `:10:5-15:20` — focuses on a specific range by measure or line:col.
- Selector: `@chords`, `@notes`, `@V:name`, `select-top`, `select-all-but-top`, `select-siblings-after` — all are composable narrowing functions (`Selection -> Selection`). No categorical distinction in the API. Chord note ordering is ASSUMED to be positional (first = lowest, last = highest).
- Transform call: `transpose @chords 2` — verb-first, selector as argument, additional args follow.
- Over: `over <selector-or-location> (<pipeline>)` — apply pipeline to focused region, return the whole.
- ABC literal: `` `CEG A2 B2` `` — inline music fragment, parsed into a tree node.
- List: `[a, b, c]` — collection of values.
- Group: `(expr)` — precedence grouping.
- Comparison: `pitch > C4`, `length >= 4` — used in filter predicates and guards.
- Logical: `and`, `or`, `not` — combine predicates.
- Filter: `filter (pitch > C4)` — verb that filters selected elements by predicate.
- User-defined function: `fn name(params) { body }` — named, parameterized pipeline.
- Pattern-matching function: `fn name = match { pattern |capture| guard => replacement }` — tag-match with Zig-style captures.
- Record literal: `{name="Trumpet", clef=treble, transpose=-2}` — field=value pairs for voice properties and other structured data.
- File load: `load "file.abc"` — reads an ABC file, parses it, returns a tree value.
- Tune selector: `X:1`, `X:2` — selects a specific tune from a multi-tune file.
- Voice declaration: `add-voice <id> [name] [clef]` — inserts a V: declaration in the tune header (before K: line). Does not touch the body.
- Remove: `remove` — removes selected nodes from the tree (splices the sibling chain).
- To-rest: `to-rest` — converts selected nodes (Note or Chord) to Rest, preserving rhythm.
- Unwrap: `unwrap-single` — replaces single-note Chords with their bare Note.
- Rhythm operations: `set-rhythm`, `sum-rhythm`, `add-to-rhythm` — rational-valued rhythm manipulation on selected nodes.

### Desugaring Rules

| Surface syntax               | Desugars to                                                                               |
| ---------------------------- | ----------------------------------------------------------------------------------------- |
| `a \| b`                     | `b(a)` — reversed application                                                             |
| `a \| b \| c`                | `c(b(a))` — nested application                                                            |
| `name = expr`                | `let name = expr`                                                                         |
| `fn name(x, y) { body }`     | `let name = fn(x, y) => body`                                                             |
| `transpose @chords 2`        | `prim_transpose(prim_select_chords(input), 2)` — selector narrows, then operation applies |
| `over :M:5-8 (pipeline)`     | `prim_over(input, location(M, 5, 8), fn(x) => pipeline(x))`                               |
| `source \| select @V:melody` | `prim_select_voice(source, "melody")`                                                     |
| `@chords`                    | a selector function (Selection -> Selection)                                              |
| `:10:5-15`                   | a location value                                                                          |
| `` `CEG A2` ``               | parsed ABC literal (tree node)                                                            |

### Core IR

The surface syntax desugars into a minimal functional core:

```
e ::= x                        -- variable reference
    | e(e, ...)                 -- function application
    | fn(x, ...) => e           -- function value (closure)
    | let x = e; e              -- sequential binding
    | if e then e else e        -- conditional
    | [e, e, ...]               -- list
    | n | "s" | `abc`           -- literals (number, string, parsed ABC)
    | prim(e, ...)              -- built-in primitive call
```

### Values

The evaluator produces values of these types:

- Selection: an AST (`File_structure`) paired with a set of selected node IDs (`Set<number>`). This is the primary value type for music operations — it carries both the full tree and the focused subset.
- MusicTree: a child-sibling tree built from the AST by wrapping Expr instances with navigation pointers. This is the internal representation during operation execution, not exposed to the user.
- Closure: a function + its captured environment.
- Selector: a function `Selection -> Selection` that narrows the selected set.
- Location: an address into a tree (line:col range or measure range).
- Number: numeric value (integer or fraction).
- String: text value.
- List: ordered collection of values.
- Record: key-value map (for voice properties, etc.).

### Built-in Primitives

The language's primitives are organized into four categories: selectors (narrow a selection), operations (mutate selected nodes), score operations (file and voice management), and control (traversal strategies). Higher-level transforms like drop-2 or legato-fill are not primitives — they are recipes composed from these building blocks.

Composable selectors (each is a predicate function `Selection -> Selection`, no categorical distinction in the API):

- `select-tune <n>` — narrow to the nth tune in the file.
- `select-system <n>` — narrow to the nth system in the tune body.
- `select-range <startLine> <startCol> <endLine> <endCol>` — narrow to nodes whose tokens fall within the source range.
- `@chords` / `select-chords` — narrow to Chord nodes.
- `@notes` / `select-notes` — narrow to all Note nodes (both standalone and inside chords).
- `select-non-chord-notes` — narrow to standalone Note nodes only (skips notes inside chords).
- `select-chord-notes` — narrow to Note nodes that are children of a Chord.
- `@rests` / `select-rests` — narrow to Rest nodes. Rests never appear inside chords.
- `@V:name` — narrow to nodes belonging to a specific voice.
- `select-top` — for each selected Chord, select its last Note (highest by convention).
- `select-bottom` — for each selected Chord, select its first Note (lowest by convention).
- `select-nth-from-top <n>` — for each selected Chord, select `contents[length - 1 - n]`.
- `select-all-but-top` — for each selected Chord, select all Notes except the last.
- `select-all-but-bottom` — for each selected Chord, select all Notes except the first.
- `select-siblings-after <predicate>` — for each selected node, collect its nextSibling chain while the predicate holds (stops at bar lines or when predicate fails).

Pitch ordering convention: the chord's `contents` array is assumed to be ordered from lowest to highest pitch (the formatter enforces this). No pitch calculation is needed — selectors use positional indexing.

Generic operations (each takes a Selection, clones before mutating, returns a new Selection):
- `remove` — remove selected nodes from the tree (splice sibling chain).
- `transpose <semitones>` — shift pitch of selected Notes by N semitones.
- `to-rest` — convert selected nodes (Note or Chord) to Rest, preserving rhythm.
- `set-rhythm <rational>` — set the rhythm of selected nodes to the given value.
- `sum-rhythm` — return the sum of all selected nodes' rhythms (does not mutate).
- `add-to-rhythm <rational>` — add a rational value to each selected node's rhythm.
- `unwrap-single` — replace single-note Chords with their bare Note (rhythm inherited from Chord if the Note has none).

Score operations:
- `load "file.abc"` — read and parse an ABC file.
- `add-voice <id> [name] [clef]` — insert a V: declaration into the tune header (before the K: line). Does not modify the tune body.
- `X:n` — select a specific tune from a multi-tune file.

Control:
- `over <focus> (<pipeline>)` — apply pipeline to focused region, return the whole.
- `filter (predicate)` — keep only elements matching the predicate.

Predicates:
- `is-rest?` — returns true if a node is a Rest instance.
- `is-note?` — returns true if a node is a Note instance.
- `is-chord?` — returns true if a node is a Chord instance.

Inspection:
- `pitch` — extract pitch value from a note.
- `length` — number of elements in a collection or chord.

Note: Stringify operations are not primitives. The evaluator produces a Selection value, which the runtime converts back to ABC using `toAst()` followed by the ABC parser's `AbcFormatter`.

### Tree Representation

The child-sibling tree wraps the existing AST Expr instances rather than creating a separate tagged-union tree. THIS IS A TEMPORARY DECISION THAT MIGHT BE REVISED AT A LATER TIME, SHOULD WE CONSIDER THAT USING A SELF-CONTAINED CSTREE IS MORE PERTINENT. Each CS node has:
- `id`: the wrapped Expr's numeric ID (used for selection lookups)
- `expr`: a reference to the original AST node (Note, Chord, Rest, Beam, etc.)
- `firstChild`: pointer to the first child node (or null)
- `nextSibling`: pointer to the next sibling (or null)

There are no parent pointers. Operations that need to splice re-traverse from the root to find predecessors.

Source location tokens are preserved because they live on the original Expr instances.

The conversion from the parser's AST to the CS tree works as follows:
- Each inner array in the AST (e.g., `Beam.contents`, `Chord.contents`, `system[i]`) becomes a sibling chain: the first element is `parent.firstChild`, and each subsequent element is linked via `nextSibling`.
- Container nodes (Beam, Chord, Tune, System) become parent nodes with their contents as children.
- The back-conversion (`toAst`) walks the sibling chains and collects the remaining Expr references back into arrays. Because operations mutate the wrapped Expr instances directly (pitch, rhythm changes) and only use the CS tree for structural changes (removing nodes from sibling chains), the back-conversion simply rebuilds the arrays from whatever nodes remain.

Because we wrap existing instances rather than copying them into a separate tree, there is no data duplication — the CS tree is a lightweight navigation overlay on the existing AST.

### Transform Pipeline

```
ABC source
    | [ABC Parser]
    v
Deeply-nested AST (File_structure)
    | [deepCloneAst()] -- each operation clones before mutating
    v
Cloned AST (same node IDs, new instances)
    | [fromAst()]
    v
Child-sibling tree (mutable navigation overlay)
    | [Selector → narrows Selection.selected set]
    | [Operation → mutates Expr instances / splices sibling chains]
    v
Modified child-sibling tree
    | [toAst()] -- rebuild container arrays from sibling chains
    v
Modified AST
    | [Formatter]
    v
ABC output string
```

The deep clone uses constructor-based reconstruction (not `structuredClone` or lodash) because prototype chains must be preserved — the formatter and selectors use `instanceof` checks and the `accept()` visitor method on AST nodes.
