# ABCt v2 Scheme Prototype Plan

## Table of Contents

1. [Goal](#goal)
2. [File Structure](#file-structure)
3. [Phase 1: Scheme Interpreter Integration](#phase-1-scheme-interpreter-integration)
4. [Phase 2: Child-Sibling Tree](#phase-2-child-sibling-tree)
5. [Phase 3: Composable Selectors](#phase-3-composable-selectors)
6. [Phase 4: Generic Operations](#phase-4-generic-operations)
7. [Phase 5: Recipes](#phase-5-recipes)
8. [Phase 6: Voice Insertion](#phase-6-voice-insertion)
9. [Phase 7: Scheme Built-ins Registration](#phase-7-scheme-built-ins-registration)
10. [Phase 8: LSP Integration](#phase-8-lsp-integration)
11. [Build Integration](#build-integration)
12. [Integration Test Scenario](#integration-test-scenario)
13. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are building a prototype that uses an existing TypeScript Scheme interpreter to validate the "arranging-by-extraction" model before implementing the full ABCt v2 language. The prototype must be hooked into the evaluation commands so the user can see the preview of the output score.

The test scenario: take a lead sheet with melody notes and inline chords, and produce a 3-voice arrangement (melody, harmony with drop-2 voicing and legato fill, bass from chord roots transposed down an octave).

The original language design of abct2 is found in plans/18.abct-v2-language-design.md

---

## File Structure

Because the prototype needs access to the ABC parser/formatter and needs to integrate with the LSP server, we place it as a workspace package at the repo root.

Extension for prototype files: `.abcs` (abc-scheme).

```
abc_parse/
  scheme-proto/
    package.json
    tsconfig.json
    src/
      index.ts
      scheme/
        vendor/
          scm.ts               -- vendored little-scheme-in-typescript (adapted for Node)
          arith.ts             -- vendored arithmetic module
        interpreter.ts         -- interpreter adapter functions
        types.ts               -- SchemeValue, SelectionWrapper, wrap/unwrap, reselect
        builtins.ts            -- register all Scheme primitives
      csTree/
        types.ts               -- CSNode interface definition
        fromAst.ts             -- AST → child-sibling tree conversion
        toAst.ts               -- child-sibling tree → AST conversion (rebuild arrays)
      selectors/
        index.ts               -- all selector functions (unified predicate model)
        predicates.ts          -- built-in predicates: is-rest?, is-note?, is-chord?
      operations/
        remove.ts              -- remove selected nodes (splice sibling chain)
        transpose.ts           -- shift pitch by N semitones
        toRest.ts              -- convert selected nodes to Rest (with rhythm rules)
        setRhythm.ts           -- set the rhythm of selected nodes
        sumRhythm.ts           -- compute sum of rhythms of selected nodes (returns IRational)
        addToRhythm.ts         -- add a rational value to selected nodes' rhythm
        unwrapSingle.ts        -- replace single-note Chords with their bare Note
      clone.ts                 -- deepCloneAst (visitor-based AST deep copy)
      rhythm.ts                -- rhythmToRational, rationalToRhythm (standalone functions)
      stringify.ts              -- stringify, stringify-header, stringify-body utilities
      assembly/
        addVoice.ts            -- insert V: declaration into tune header
    tests/
      csTree.spec.ts
      selectors.spec.ts
      operations.spec.ts
      clone.spec.ts
      addVoice.spec.ts
      integration.spec.ts
  abc-lsp-server/src/
    AbcLspServer.ts            -- modified: add .abcs document routing
    SchemeDocument.ts          -- new: document class for .abcs files
    server.ts                  -- modified: add scheme.evaluate handler
  vscode-extension/
    src/abctCommands.ts        -- modified: accept .abcs files for evaluation
    package.json               -- modified: register .abcs language
```

---

## Phase 1: Scheme Interpreter Integration

### 1.1 Vendor the source

We copy `scm.ts` and `arith.ts` from [nukata/little-scheme-in-typescript](https://github.com/nukata/little-scheme-in-typescript) into `scheme-proto/src/scheme/vendor/`. The interpreter is ~800 lines.

Because the original targets Deno, we adapt:
- Replace Deno I/O primitives (`readLine`, `write`, `readStringFrom`) with Node equivalents
- Replace Deno file loading with `fs.readFileSync`
- The core evaluation logic is pure and needs no changes

### 1.2 Interpreter adapter: `scheme-proto/src/scheme/interpreter.ts`

Because there is no reason to wrap the vendored interpreter in a class (it has no meaningful lifecycle beyond a single evaluation), we expose it as a set of functions that operate on an interpreter context object:

```typescript
interface InterpreterContext {
  env: Environment
  output: string[]
}

function createInterpreter(): InterpreterContext
function registerBuiltin(ctx: InterpreterContext, name: string, arity: number, fn: (...args: any[]) => any): void
async function evaluate(ctx: InterpreterContext, source: string): Promise<any>
function getOutput(ctx: InterpreterContext): string
```

### 1.3 Type bridge: `scheme-proto/src/scheme/types.ts`

The Scheme interpreter passes values as opaque JS objects. We define a wrapper interface with a discriminant `type` field so that Selections are identifiable:

```typescript
type SchemeValue = SelectionWrapper | string | number | Cell | null | boolean

interface SelectionWrapper {
  type: "selection"
  value: Selection
}

function wrapSelection(s: Selection): SelectionWrapper
function unwrapSelection(v: SchemeValue): Selection
function isSelectionWrapper(v: unknown): v is SelectionWrapper
```

The `Selection` interface uses node IDs (not object references) for robustness:

```typescript
interface Selection {
  ast: File_structure
  selected: Set<number>      // node IDs, not object references
}
```

Because the existing codebase uses `Set<Expr>` (in `abct/src/runtime/types.ts:19`), we define our own Selection type in scheme-proto that uses IDs instead. This avoids brittleness when data structures are refactored — IDs are stable identifiers whereas object pointers break if the tree is restructured.

### 1.4 Tests for Phase 1

Since the vendored Scheme interpreter comes from a repo with its own test suite, we adapt those tests for Node rather than writing new property-based tests for the core evaluation. We only add tests for our adapter layer:

- Example: `createInterpreter()` produces a context with a populated env
- Example: `registerBuiltin` makes a function callable from Scheme
- Example: `evaluate(ctx, "(+ 1 2)")` returns 3
- Example: `evaluate(ctx, "(display \"hello\")")` populates ctx.output
- Example: evaluate with a syntax error throws

---

## Phase 2: Child-Sibling Tree

### 2.1 Motivation

The AST produced by the parser uses heterogeneous container arrays (`tune_body.sequence: Array<Array<Expr|Token>>`, `Beam.contents`, `Chord.contents`). Traversing siblings requires knowing the parent container and the current index, which makes traversal code verbose and error-prone.

The child-sibling tree is an intermediate representation that wraps the existing AST nodes with uniform navigation pointers. Transforms operate on this tree (using `firstChild`/`nextSibling` for traversal), and the tree is then converted back to the AST format (rebuilding the container arrays) before formatting.

### 2.2 Node structure: `scheme-proto/src/csTree/types.ts`

Each CS node wraps a reference to the original AST Expr instance. The Expr's `id` field is used for selection lookups.

```typescript
interface CSNode {
  id: number                 // same as the wrapped Expr's id
  expr: Expr | Token         // reference to the original AST node (for reading type, rhythm, pitch)
  firstChild: CSNode | null  // pointer to first child
  nextSibling: CSNode | null // pointer to next sibling
}
```

There are no parent pointers. Because parent pointers become stale when nodes are moved or spliced during a transform, operations that need to locate a node's predecessor (e.g., `remove`) re-traverse from the root or a known ancestor instead of relying on stored back-references.

Transforms mutate the referenced Expr instances (changing rhythm, pitch, etc.) and splice the sibling/child chains for structural changes (removing nodes, reordering).

Note: the wrapper approach (CSNode wrapping Expr) is a prototype decision. The final language should port to typed CS node variants that enforce valid parent-child relationships (e.g., a CSChord can only have CSNote children, a CSBeam can only have CSNote/CSChord/CSRest children). This ensures the same type safety the current parser AST provides.

### 2.3 Conversion: AST to CS tree (`fromAst.ts`)

The conversion walks the AST and builds the CS tree. The mapping is:

```
File_structure → root CSNode
  Tune → child of root
    tune_header fields → children of Tune node (in order)
    tune_body.sequence → each system is a child of Tune_Body node
      system[0], system[1], ... → siblings
        Beam.contents → children of Beam node (linked as siblings)
        Chord.contents → children of Chord node (linked as siblings)
        Grace_group.notes → children of Grace_group node
```

Each inner array element becomes a sibling. The first element becomes `parent.firstChild`, and subsequent elements are linked via `nextSibling`.

### 2.4 Conversion: CS tree to AST (`toAst.ts`)

The back-conversion walks the CS tree and rebuilds the container arrays from the sibling chains:

```
for each container node (Beam, Chord, System, etc.):
  collect sibling chain starting from node.firstChild
  assign collected nodes' .expr values back to the container's array
```

Because transforms mutate the Expr instances in place (and only use the CS tree for structural changes like removal), the back-conversion simply collects the remaining nodes' Expr references into arrays.

### 2.5 Tests for Phase 2

- Property: for any valid AST, converting to CS tree and back produces the same formatter output
- Property: every CSNode.id matches its wrapped Expr.id
- Property: the sibling count at each level matches the original array length
- Example: a Beam with 4 notes → 4 siblings under the Beam CSNode
- Example: removing a sibling (splicing the chain) and converting back produces a shorter array

---

## Phase 3: Composable Selectors

Selectors produce a `Selection` (AST + set of node IDs). They compose by narrowing: each selector takes a Selection and returns a narrower Selection. There is no fundamental distinction between different "kinds" of selectors — they are all predicate functions applied to nodes within the current selection.

Selectors can select nodes from any part of the AST (tune header, tune body, etc.), not only the tune body.

### 3.1 Unified selector model

Every selector is a function `Selection -> Selection` that filters the current `.selected` set by applying a predicate to each node. When a selector receives a raw AST (wrapped as a Selection with all nodes selected), it operates on everything. Composition is natural nesting:

```scheme
(select-all-but-top (select-chords (select-range source 3 10 3 20)))
```

This means: from the source, narrow to the range [line 3, col 10 to line 3, col 20], then within that range select chords, then within those chords select all notes except the top one.

The TypeScript representation:

```typescript
type SelectorFn = (input: Selection) => Selection

function compose(...selectors: SelectorFn[]): SelectorFn {
  return (input) => selectors.reduce((sel, fn) => fn(sel), input);
}
```

### 3.2 Selector table

All selectors live in `scheme-proto/src/selectors/`. The file split is purely organizational.

| Selector                | Args                                        | Behavior                                                                    |
| ----------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| `select-tune`           | (sel, n)                                    | Narrow to the nth Tune in the AST                                           |
| `select-system`         | (sel, n)                                    | Narrow to the nth system in the tune body                                   |
| `select-range`          | (sel, startLine, startCol, endLine, endCol) | Narrow to nodes whose tokens fall within the source range                   |
| `select-chords`          | (sel)                                       | Narrow to Chord nodes                                                       |
| `select-notes`           | (sel)                                       | Narrow to all Note nodes (both standalone and inside chords)                |
| `select-non-chord-notes` | (sel)                                       | Narrow to standalone Note nodes only (skips notes inside chords)            |
| `select-chord-notes`     | (sel)                                       | Narrow to Note nodes that are children of a Chord                           |
| `select-rests`           | (sel)                                       | Narrow to Rest nodes (rests never appear inside chords)                     |
| `select-top`            | (sel)                                       | For each selected Chord, select its last Note (highest by convention)       |
| `select-bottom`         | (sel)                                       | For each selected Chord, select its first Note (lowest by convention)       |
| `select-nth-from-top`   | (sel, n)                                    | For each selected Chord, select `contents[contents.length - 1 - n]`         |
| `select-all-but-top`    | (sel)                                       | For each selected Chord, select all Notes except the last                   |
| `select-all-but-bottom` | (sel)                                       | For each selected Chord, select all Notes except the first                  |
| `select-siblings-after` | (sel, predicate)                            | For each selected node, collect its nextSibling chain while predicate holds |

Pitch ordering convention: the chord's `contents` array is assumed to be ordered from lowest to highest pitch (the formatter enforces this). There is no need for `toMidiPitch` — `select-top` simply takes the last element, `select-bottom` takes the first, etc.

The `select-siblings-after` predicate is a function `(CSNode) => boolean`. For the prototype, we provide `is-rest?` (checks if the node's Expr is a Rest instance). The sibling walk stops at the first node that fails the predicate (or at a bar line).

### 3.3 Selector implementation details

Every selector receives a `Selection { ast, selected: Set<number> }` and returns a new Selection with a narrower (or drilled-down) `.selected` set. The AST reference stays the same — selectors never modify the tree.

The traversal algorithm for most selectors is a recursive walk over the AST:

```
narrowByPredicate(selection, predicate):
  result = new Set<number>()
  walk(node):
    if node.id in selection.selected AND predicate(node):
      result.add(node.id)
    for each child array of node:
      for each child in array:
        walk(child)
  walk(selection.ast)
  return { ast: selection.ast, selected: result }
```

Each selector type provides its own predicate and traversal strategy. Because rests never appear inside chords, `select-rests` uses the generic walk. For notes, we provide three selectors with different traversal:

- `select-notes`: walks all nodes including chord children, selects all Notes.
- `select-non-chord-notes`: skips chord children, selecting only standalone Notes.
- `select-chord-notes`: only selects Notes that are children of a Chord.

The `select-non-chord-notes` variant prevents operations like `to-rest(select-non-chord-notes(sel))` from destroying chord members:

```
narrowByPredicateSkipChordChildren(selection, predicate):
  result = new Set<number>()
  walk(node, insideChord):
    if node.id in selection.selected AND predicate(node) AND NOT insideChord:
      result.add(node.id)
    if node instanceof Chord:
      for each child in node.contents:
        walk(child, true)
    else:
      for each child array of node:
        for each child in array:
          walk(child, false)
  walk(selection.ast, false)
  return { ast: selection.ast, selected: result }
```

For `select-chord-notes`, the inverse logic applies — it only selects notes when `insideChord` is true:

```
narrowByPredicateOnlyChordChildren(selection, predicate):
  result = new Set<number>()
  walk(node, insideChord):
    if node.id in selection.selected AND predicate(node) AND insideChord:
      result.add(node.id)
    if node instanceof Chord:
      for each child in node.contents:
        walk(child, true)
    else:
      for each child array of node:
        for each child in array:
          walk(child, false)
  walk(selection.ast, false)
  return { ast: selection.ast, selected: result }
```

Selector predicates:
- `select-chords`: `node instanceof Chord` (uses generic `narrowByPredicate`)
- `select-notes`: `node instanceof Note` (uses generic `narrowByPredicate`, walks into chords)
- `select-non-chord-notes`: `node instanceof Note` (uses `narrowByPredicateSkipChordChildren`)
- `select-chord-notes`: `node instanceof Note` (uses `narrowByPredicateOnlyChordChildren`)
- `select-rests`: `node instanceof Rest` (uses generic `narrowByPredicate`, rests never appear inside chords)
- `select-tune n`: `node instanceof Tune AND node is the nth tune`
- `select-system n`: `node is the nth system array`

For `select-range`, the predicate checks the node's source position against the requested range. Each Expr node carries tokens with `line` and `col` fields (set by the scanner). A node is considered "within range" if its first token's position is at or after the range start and at or before the range end:

```
selectRange(selection, startLine, startCol, endLine, endCol):
  result = new Set<number>()
  walk(node):
    if node.id in selection.selected:
      pos = getTokenPosition(node)  // first token's line and col
      if positionInRange(pos, startLine, startCol, endLine, endCol):
        result.add(node.id)
    for each child array of node:
      for each child in array: walk(child)
  walk(selection.ast)
  return { ast: selection.ast, selected: result }

positionInRange(pos, startLine, startCol, endLine, endCol):
  afterStart = pos.line > startLine OR (pos.line == startLine AND pos.col >= startCol)
  beforeEnd = pos.line < endLine OR (pos.line == endLine AND pos.col <= endCol)
  return afterStart AND beforeEnd
```

For intra-chord selectors, the traversal drills into children. Because the output contains Note IDs (children of the selected Chords), the result is not a strict subset of the input — it is a set of IDs that live inside the input's selected nodes:

```
selectAllButTop(selection):
  result = new Set<number>()
  walk(node):
    if node instanceof Chord AND node.id in selection.selected:
      notes = node.contents.filter(isNote)
      // all except the last (highest by convention)
      for i in 0..notes.length-2:
        result.add(notes[i].id)
    for each child array of node:
      for each child in array: walk(child)
  walk(selection.ast)
  return { ast: selection.ast, selected: result }
```

For `select-siblings-after`, the CS tree is required because the AST has no sibling pointers. The implementation builds the CS tree, locates the selected nodes within it, and walks their sibling chains:

```
selectSiblingsAfter(selection, predicate):
  csTree = fromAst(selection.ast)
  result = new Set<number>()
  for each node in csTree where node.id in selection.selected:
    cursor = node.nextSibling
    while cursor != null AND predicate(cursor):
      result.add(cursor.id)
      cursor = cursor.nextSibling
  return { ast: selection.ast, selected: result }
```

Note that the CS tree is built read-only here — `select-siblings-after` does not modify the tree, it only traverses it to discover sibling relationships.

### 3.4 Tests for Phase 3

- Property: `select-chords` on any AST produces a selection containing only Chord node IDs
- Property: `select-all-but-top` followed by `remove` on a chord with N notes leaves exactly 1 note
- Property: `select-nth-from-top 0` is equivalent to `select-top`
- Property: composing two type/region selectors narrows (the result is a subset of the first selector's output). Intra-chord selectors drill down (the result contains child IDs, not a subset of the input).
- Example: `(select-notes source)` on `[CEG]2 C2 D2` selects C, E, G (inside chord) AND C2, D2 (standalone) — all 5 notes
- Example: `(select-non-chord-notes source)` on `[CEG]2 C2 D2` selects only C2 and D2 (standalone), not C, E, G inside the chord
- Example: `(select-chord-notes source)` on `[CEG]2 C2 D2` selects only C, E, G (inside the chord)
- Example: `(select-all-but-top (select-chords source))` on `[CEG]` selects C and E (not G, since G is last = top)
- Example: `(select-siblings-after chord is-rest?)` on `[CEG]z z C` selects the two z's, stops at C

---

## Phase 4: Generic Operations

Operations are immutable: each operation clones the input Selection's AST, performs its mutation on the clone (via the CS tree), and returns a new Selection. The caller's input is never modified. After the operation is done, the CS tree is converted back to AST for the returned Selection.

### 4.1 Operation table

| Operation       | Args             | Behavior                                                                                                                                                        |
| --------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `remove`        | (sel)            | Remove selected nodes from the CS tree (splice sibling chain)                                                                                                   |
| `transpose`     | (sel, semitones) | Shift pitch of selected Notes by N semitones                                                                                                                    |
| `to-rest`       | (sel)            | Convert selected nodes (Note or Chord) to Rest. Rhythm rules: if node has rhythm, copy it; if Chord has no rhythm but first note does, copy first note's rhythm |
| `set-rhythm`    | (sel, rational)  | Set the rhythm of selected nodes to the given rational value                                                                                                    |
| `sum-rhythm`    | (sel)            | Returns the sum of all selected nodes' rhythms as an IRational. If a node has no explicit rhythm, it defaults to 1/1 (one unit length)                          |
| `add-to-rhythm` | (sel, rational)  | Add a rational value to each selected node's existing rhythm                                                                                                    |

### 4.2 Remove operation details

Because the CS tree has no parent pointers, `remove` traverses the tree to locate each selected node's parent and predecessor before splicing:

```
for each selected node:
  (parent, prev) = findParentAndPrev(root, node)
  if prev == null:
    // node is the first child of its parent
    parent.firstChild = node.nextSibling
  else:
    prev.nextSibling = node.nextSibling
```

`findParentAndPrev(root, target)` walks the tree depth-first, tracking each node's parent. When it finds `target` in a sibling chain, it returns the parent node and the preceding sibling (or null if the target is the firstChild).

When converting back to AST, removed nodes are simply absent from the sibling chain and therefore omitted from the rebuilt arrays.

### 4.3 Rhythm utilities (`rhythm.ts`)

Standalone functions adapted from `parse/Visitors/RhythmTransform.ts:458-532`:

- `rhythmToRational(rhythm: Rhythm | undefined): IRational` — converts a Rhythm node to a rational. When rhythm is undefined, returns `createRational(1, 1)` (one unit length). Broken rhythms (`>`, `<`) are already handled as part of the Rhythm expression.
- `rationalToRhythm(rational: IRational, ctx: ABCContext): Rhythm` — creates a new Rhythm node from a rational value, using `ctx` to generate token IDs.

### 4.4 Tests for Phase 4

- Property: after `remove`, the returned Selection's CS tree has fewer nodes by the count of selected nodes
- Property: after any operation, the input Selection formats identically to before the call (immutability)
- Property: `to-rest` on a Note produces a Rest with the same rhythm
- Property: `to-rest` on a Chord with rhythm `2` produces a Rest with rhythm `2`
- Property: `transpose` by 0 returns a Selection that formats identically to the input
- Property: `transpose` by 12 then by -12 returns a Selection that formats identically to the input
- Property: `sum-rhythm` on N rests each with rhythm 1 returns N/1
- Example: `remove` on the middle sibling — returned Selection has correct re-linking, input is untouched
- Example: `to-rest` on a Chord without rhythm but first note rhythm `3` → returned Rest with rhythm `3`
- Example: `add-to-rhythm` on a chord with rhythm 2/8, adding 6/8, produces 8/8 = 1 in the returned Selection

---

## Phase 5: Recipes

Recipes are Scheme functions that compose selectors and operations to achieve higher-level transforms. They are not primitives — they are defined in the `.abcs` file (or in a prelude loaded by the interpreter).

Because operations are immutable (each returns a new Selection), recipes must thread return values through the pipeline. The `reselect` utility transplants an ID set from one Selection onto a different Selection's AST — this is needed when an operation changes the tree structure (e.g., `remove` deletes nodes) and you need to locate previously-selected nodes in the new tree.

### 5.1 chord-top-note

Replaces each selected chord with its top note (bare Note, not single-note chord). Because `remove` returns a new Selection, we re-select chords in the result before calling `unwrap-single`:

```scheme
(define (chord-top-note sel)
  (let* ((non-top (select-all-but-top (select-chords sel)))
         (after-remove (remove non-top))
         (remaining-chords (select-chords after-remove)))
    (unwrap-single remaining-chords)))
```

After `remove`, the chord nodes contain only 1 note each. `unwrap-single` replaces each single-note Chord with its bare Note (handling rhythm inheritance).

### 5.2 chord-bottom-note

```scheme
(define (chord-bottom-note sel)
  (let* ((non-bottom (select-all-but-bottom (select-chords sel)))
         (after-remove (remove non-bottom))
         (remaining-chords (select-chords after-remove)))
    (unwrap-single remaining-chords)))
```

### 5.3 drop-2 voicing

```scheme
(define (drop2 sel)
  (let* ((chords (select-chords sel))
         (second-top (select-nth-from-top chords 1)))
    (transpose second-top -12)))
```

Because `transpose` clones internally and returns a new Selection, the result contains the modified AST with the second-from-top note transposed down an octave.

### 5.4 legato-fill

For each selected chord, sum the durations of following rests (stopping at non-rest / bar), remove those rests, and add the sum to the chord's duration. Because `remove` returns a new tree, we use `reselect` to find the chords in the post-removal AST:

```scheme
(define (legato-fill sel)
  (let* ((chords (select-chords sel))
         (rests (select-siblings-after chords is-rest?))
         (rest-dur (sum-rhythm rests))
         (after-remove (remove rests))
         ;; The chords still exist in the new tree (only rests were removed).
         ;; We transplant the chord IDs onto the new AST.
         (new-chords (reselect after-remove chords)))
    (add-to-rhythm new-chords rest-dur)))
```

Note: this simplified version assumes a single chord. For multiple chords, the `select-siblings-after` + `sum-rhythm` + `remove` + `add-to-rhythm` sequence must be applied per-chord. The prototype implementation may iterate over the selected chords individually.

### 5.5 The `reselect` utility

`reselect` creates a new Selection that pairs one Selection's AST with another Selection's ID set. Because all trees are cloned from a common source (and cloning preserves node IDs), the IDs from one tree are valid references in any tree cloned from the same origin — provided the referenced nodes were not removed.

```typescript
function reselect(target: Selection, idsFrom: Selection): Selection {
  return { ast: target.ast, selected: idsFrom.selected };
}
```

This is safe because:
- Both `target` and `idsFrom` were produced from the same original AST (via a chain of clone-and-mutate operations)
- If a node referenced in `idsFrom.selected` was removed in `target`'s tree, it simply won't be found during traversal — operations and selectors skip IDs that don't match any node

### 5.6 Known limitations of recipes

- Tuplet markers affect duration computation but are deferred for the prototype.
- Ties across bar lines are deferred.
- The `legato-fill` recipe stops at bar lines (because `is-rest?` is false for bar tokens).
- `unwrap-single-note-chords` needs rhythm inheritance rules (same as the chord-to-rest rhythm rules).

### 5.7 Tests for Phase 5

- Example: `chord-top-note` on `[CEG]2` produces `G2`
- Example: `chord-bottom-note` on `[CEG]2` produces `C2`
- Example: `drop2` on `[CEG]` transposes E down 12 semitones
- Example: `legato-fill` on `[CEG]2 z2 z2 z2|` produces `[CEG]8|`
- Example: `legato-fill` stops at bar line: `[CEG]2 z2|z2` → `[CEG]4|z2`
- Example: immutability — `sel` is unchanged after `(chord-top-note sel)`

---

## Phase 6: Voice Insertion

Location: `scheme-proto/src/assembly/addVoice.ts`

### 6.1 Purpose

The `addVoice` function inserts a `V:` declaration into the tune header (before the K: line). It does not modify the tune body. The composer is responsible for the body content of each voice — this function only declares that a voice exists.

### 6.2 Interface

```typescript
function addVoice(
  selection: Selection,
  params: { id: string, name?: string, clef?: string }
): Selection
```

Named parameters: `id` is required, `name` and `clef` are optional. Like all operations, this function clones the AST internally, inserts the V: declaration into the clone, and returns a new Selection. The input is never modified.

### 6.3 Algorithm

```
tune = first Tune in selection.ast.contents
kLine = find K: info line in tune.tune_header

vString = "V:" + id
if name: vString += ' name="' + name + '"'
if clef: vString += " clef=" + clef

vDecl = createInfoLine(vString)
insertBefore(tune.tune_header, kLine, vDecl)
```

### 6.4 Tests for Phase 6

- Property: after addVoice, the tune header contains a V: line with the given id
- Property: the K: line remains the last info line in the header
- Property: the tune body is unmodified
- Example: `addVoice(sel, {id: "trp", name: "Trumpet", clef: "treble"})` inserts `V:trp name="Trumpet" clef=treble`
- Example: `addVoice(sel, {id: "bass"})` inserts `V:bass` (no name or clef)
- Example: calling addVoice twice inserts both V: lines before K:

---

## Phase 7: Scheme Built-ins Registration

Location: `scheme-proto/src/scheme/builtins.ts`

### 7.1 Registration function

```typescript
function registerAllBuiltins(ctx: InterpreterContext, fileResolver: FileResolver): void
```

`FileResolver` is imported from `abc-lsp-server/src/abctEvaluator.ts`. It provides `resolve(relativePath: string): string` for loading files relative to the document's directory.

### 7.2 Built-in table

Selectors:

| Scheme name             | Arity | Implementation                                                |
| ----------------------- | ----- | ------------------------------------------------------------- |
| `load-abc`              | 1     | Load file, parse, return Selection with all nodes             |
| `clone`                 | 1     | Fork: deep clone AST, return independent Selection for separate arrangement |
| `select-chords`          | 1     | Narrow to Chord nodes                                         |
| `select-notes`           | 1     | Narrow to all Notes (both standalone and inside chords)       |
| `select-non-chord-notes` | 1     | Narrow to standalone Notes only (skips chord internals)       |
| `select-chord-notes`     | 1     | Narrow to Notes inside chords only                            |
| `select-rests`           | 1     | Narrow to Rest nodes (rests never appear inside chords)       |
| `select-range`          | 5     | Narrow by source range (startLine, startCol, endLine, endCol) |
| `select-top`            | 1     | Last note in chord (highest by convention)                    |
| `select-bottom`         | 1     | First note in chord (lowest by convention)                    |
| `select-nth-from-top`   | 2     | contents[length - 1 - n]                                      |
| `select-all-but-top`    | 1     | All notes except the last                                     |
| `select-all-but-bottom` | 1     | All notes except the first                                    |
| `select-siblings-after` | 2     | Sibling chain while predicate holds                           |

Operations:

| Scheme name     | Arity | Implementation                               |
| --------------- | ----- | -------------------------------------------- |
| `remove`        | 1     | Remove selected nodes from CS tree           |
| `transpose`     | 2     | Shift pitch by N semitones                   |
| `to-rest`       | 1     | Convert selected to Rest (with rhythm rules) |
| `set-rhythm`    | 3     | Set rhythm to num/den rational               |
| `sum-rhythm`    | 1     | Return sum of selected rhythms as rational   |
| `add-to-rhythm` | 3     | Add num/den rational to selected rhythms     |
| `unwrap-single` | 1     | Replace single-note chords with their note   |

Utilities:

| Scheme name        | Arity | Implementation                                                                        |
| ------------------ | ----- | ------------------------------------------------------------------------------------- |
| `add-voice`        | 1-3   | Insert V: declaration (id required, name/clef optional). Clones internally, returns new Selection. |
| `reselect`         | 2     | Pairs first arg's AST with second arg's selected IDs. Returns new Selection.          |
| `stringify`        | 1     | Convert AST to string (full output: header + body)                                    |
| `stringify-header` | 1     | Stringify only the tune header (X: through K:, including V: declarations)             |
| `stringify-body`   | 1     | Stringify only the tune body (no header info lines). Used for voice body assembly.    |
| `display`          | 1     | Push to output buffer                                                                 |
| `is-rest?`         | 1     | Predicate: returns true if node is a Rest                                             |

### 7.3 Immutability semantics

Operations are immutable: each operation clones the AST internally, performs its mutation on the clone, and returns a new Selection. The caller's input Selection is never modified. This mirrors the DSL's "pipes extract" semantics — the `over` keyword in the DSL is the only construct that performs write-back.

The user must thread return values through the pipeline. Discarding an operation's return value means losing the modification:

```scheme
;; CORRECT: threading the return value
(define result (transpose (select-chords sel) 2))

;; WRONG: discarding the return — sel is unchanged
(transpose (select-chords sel) 2)
sel  ;; still the original, unmodified tree
```

Implementation pattern for operation built-ins:

```typescript
registerBuiltin(ctx, "remove", 1, (sel) => {
  const s = unwrapSelection(sel);
  const cloned = cloneSelection(s);   // deep clone AST, preserve node IDs in selected set
  const csTree = fromAst(cloned.ast);
  removeNodes(csTree, cloned.selected);
  cloned.ast = toAst(csTree);
  return wrapSelection(cloned);
});
```

The `cloneSelection` function deep-clones the AST. Because the clone preserves node IDs, the `selected` set remains valid in the new tree.

The explicit `clone` built-in is for forking: when the user wants to produce multiple independent arrangements from the same source (e.g., melody AND harmony from one lead sheet), they clone to create separate trees. This is orthogonal to the immutability of operations — `clone` is about intent ("I want two independent copies to work on"), not about protecting inputs.

### 7.4 Deep clone (`clone.ts`)

Because `structuredClone` and lodash's `_.cloneDeep()` do not preserve prototype chains (the cloned objects fail `instanceof Note`, `instanceof Chord`, etc. and lack the `accept()` visitor method), we implement a custom `deepCloneAst` that reconstructs each node via its constructor. Node IDs are preserved so that the `selected` set remains valid.

### 7.5 Tests for Phase 7

- Example: `(remove (select-all-but-top (select-chords sel)))` returns a Selection with single-note chords
- Example: `(transpose (select-nth-from-top (select-chords sel) 1) -12)` returns a Selection with drop-2 voicing
- Example: immutability — after `(define result (remove (select-chords sel)))`, `sel` formats identically to before the call
- Example: immutability — after `(define r (transpose (select-notes sel) 5))`, `sel` is unchanged and `r` has transposed notes
- Example: `(reselect a b)` returns a Selection with `a`'s AST and `b`'s selected IDs
- Example: `(stringify sel)` returns a string that re-parses to the same AST
- Example: `(stringify-header sel)` returns only X:/T:/M:/L:/V:/K: lines (no body content)
- Example: `(stringify-body sel)` returns only the music content, no X:/T:/M:/L:/K: lines
- Example: `(string-append (stringify-header sel) (stringify-body sel))` equals `(stringify sel)`

---

## Phase 8: LSP Integration

### 8.1 `SchemeDocument` class

Location: `abc-lsp-server/src/SchemeDocument.ts`

Follows the same interface as `AbctDocument`:

```typescript
class SchemeDocument {
  document: TextDocument
  diagnostics: Diagnostic[]

  constructor(document: TextDocument)

  analyze(): void {
    this.diagnostics = [];
  }

  async evaluate(): Promise<{ abc: string, diagnostics: Diagnostic[] }> {
    const source = this.document.getText();
    const dirPath = path.dirname(URI.parse(this.document.uri).fsPath);
    const fileResolver = new FileResolver(dirPath);
    const ctx = createInterpreter();
    registerAllBuiltins(ctx, fileResolver);
    try {
      const result = await evaluate(ctx, source);
      let abc: string;
      if (isSelectionWrapper(result)) {
        abc = stringifySelection(unwrapSelection(result));
      } else if (typeof result === "string") {
        abc = result;
      } else {
        abc = getOutput(ctx);
      }
      return { abc, diagnostics: this.diagnostics };
    } catch (e) {
      this.diagnostics.push({
        severity: DiagnosticSeverity.Error,
        range: { start: { line: 0, character: 0 }, end: { line: 0, character: 0 } },
        message: e.message
      });
      return { abc: "", diagnostics: this.diagnostics };
    }
  }
}
```

### 8.2 Server modifications

In `abc-lsp-server/src/server.ts`:

```typescript
connection.onRequest("scheme.evaluate", async (params: { uri: string }) => {
  const textDoc = documents.get(params.uri);
  if (!textDoc) return { abc: "", diagnostics: [] };
  const doc = new SchemeDocument(textDoc);
  doc.analyze();
  return await doc.evaluate();
});
```

In `abc-lsp-server/src/AbcLspServer.ts`:
1. Add `isAbcsFile(uri: string)` utility.
2. In `onDidChangeContent`, branch for `.abcs` files → `SchemeDocument`.
3. Add `SchemeDocument` to the `DocumentType` union.

### 8.3 Extension modifications

In `vscode-extension/package.json`, add to `contributes.languages`:
```json
{ "id": "abcs", "extensions": [".abcs"], "aliases": ["ABC Scheme"] }
```

In `vscode-extension/src/abctCommands.ts`, extend evaluation to handle `.abcs` → `scheme.evaluate`.
In `vscode-extension/src/renderer/AbcRenderer.ts`, extend preview to handle `.abcs`.

### 8.4 Tests for Phase 8

- Example: SchemeDocument.evaluate() with valid source returns a non-empty ABC string
- Example: SchemeDocument.evaluate() with a syntax error returns a diagnostic

---

## Build Integration

### Root `package.json` modifications

Add `"scheme-proto"` to the workspaces array.

Add to scripts:
```json
"build:scheme": "npm run build -w scheme-proto",
```

Insert `build:scheme` into the main `build` script after `build:abct` and before `build:lsp`.

### `scheme-proto/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "../out/scheme-proto",
    "rootDir": ".",
    "composite": true,
    "strict": true,
    "esModuleInterop": true,
    "declaration": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "tests"],
  "references": [
    { "path": "../parse" },
    { "path": "../abct" }
  ]
}
```

Add `{ "path": "../scheme-proto" }` to `abc-lsp-server/tsconfig.json` references.

### `scheme-proto/package.json`

```json
{
  "name": "scheme-proto",
  "version": "0.0.1",
  "private": true,
  "main": "../out/scheme-proto/src/index.js",
  "scripts": {
    "build": "tsc -b",
    "test": "mocha -r ts-node/register 'tests/**/*.spec.ts'"
  }
}
```

---

## Integration Test Scenario

The integration test (`scheme-proto/tests/integration.spec.ts`) exercises the full pipeline with inline ABC source. The `FileResolver` is mocked to return the inline string when `"lead-sheet.abc"` is requested.

### Input ABC

```abc
X:1
T:Test Lead Sheet
M:4/4
L:1/8
K:C
[CEG]2 C2 D2 E2|[FAc]2 F2 G2 A2|[GBd]2 G2 A2 B2|[CEG]8|
```

### Scheme program

Every operation returns a new Selection. The program threads return values throughout — no mutation of previously-bound variables occurs.

```scheme
(define source (load-abc "lead-sheet.abc"))

;; --- Harmony: drop-2 voicing + legato fill ---
;; 1. Convert standalone notes to rests (keeping chords intact)
;; 2. Apply drop-2 (transpose 2nd-from-top note down one octave)
;; 3. Legato-fill: absorb following rests into chord duration
(define h1 (to-rest (select-non-chord-notes (clone source))))
(define h2 (transpose (select-nth-from-top (select-chords h1) 1) -12))
(define harmony
  (let* ((chords (select-chords h2))
         (rests (select-siblings-after chords is-rest?))
         (rest-dur (sum-rhythm rests))
         (after-remove (remove rests))
         (new-chords (reselect after-remove chords)))
    (add-to-rhythm new-chords rest-dur)))

;; --- Bass: bottom note, legato fill, octave down ---
;; 1. Convert standalone notes to rests (keeping chords as bass holders)
;; 2. Remove all but bottom note from each chord
;; 3. Unwrap single-note chords to bare notes
;; 4. Legato-fill (bass notes absorb following rests)
;; 5. Transpose down one octave
(define b1 (to-rest (select-non-chord-notes (clone source))))
(define b2 (remove (select-all-but-bottom (select-chords b1))))
(define b3 (unwrap-single (select-chords b2)))
(define bass-part
  (let* ((notes (select-notes b3))
         (rests (select-siblings-after notes is-rest?))
         (rest-dur (sum-rhythm rests))
         (after-remove (remove rests))
         (new-notes (reselect after-remove notes)))
    (transpose (select-notes (add-to-rhythm new-notes rest-dur)) -12)))

;; --- Melody: keep top note of each chord, unwrap ---
(define m1 (remove (select-all-but-top (select-chords (clone source)))))
(define melody (unwrap-single (select-chords m1)))

;; --- Assemble: header with voice declarations + voice bodies ---
(define header
  (add-voice
    (add-voice
      (add-voice (clone source) "mel" "Melody" "treble")
      "harm" "Harmony" "treble")
    "bass" "Bass" "bass"))

;; Output: header (X: through K:, with V: declarations) + per-voice bodies
(display (string-append
  (stringify-header header) "\n"
  "V:mel\n" (stringify-body melody) "\n"
  "V:harm\n" (stringify-body harmony) "\n"
  "V:bass\n" (stringify-body bass-part) "\n"))
```

### Properties to verify

- The formatted output re-parses into a valid `File_structure`
- The tune header contains 3 V: declarations (mel, harm, bass)
- The total number of bar lines per voice equals the original (4 bars)
- Harmony chords have correct drop-2 pitches and extended durations (whole notes)
- Bass notes are the lowest pitch from each original chord, transposed -12
- Melody notes are the highest pitch from each original chord
- Immutability: `source` is unchanged after the entire program runs

---

## Implementation Checklist

1. Create all directories and empty files in a single batch
2. Vendor little-scheme-in-typescript, adapt for Node
3. Implement interpreter adapter functions, pass adapted upstream tests
4. Implement types.ts (SelectionWrapper, Selection with ID-based set, reselect utility)
5. Implement CSNode types, fromAst, toAst with roundtrip tests
6. Implement region selectors with tests
7. Implement type selectors with tests
8. Implement intra-chord selectors with tests
9. Implement sibling selector with tests
10. Implement deepCloneAst in clone.ts with tests (preserves node IDs, prototype chains)
11. Implement remove operation with tests (verify immutability: input unchanged after call)
12. Implement transpose operation with tests (verify immutability)
13. Implement to-rest operation with tests (verify immutability)
14. Implement rhythm utilities (rhythmToRational, rationalToRhythm)
15. Implement set-rhythm, sum-rhythm, add-to-rhythm with tests (verify immutability)
16. Implement unwrap-single-note-chords with tests (verify immutability)
17. Implement addVoice (header-only) with tests (verify immutability)
18. Implement stringify, stringify-header, and stringify-body in stringify.ts
19. Implement builtins.ts — register all primitives including reselect, clone, stringify, stringify-header, stringify-body
20. Write integration test with the full Scheme scenario (verify return-value threading, source immutability)
21. Add SchemeDocument.ts to abc-lsp-server
22. Modify AbcLspServer.ts, server.ts for .abcs routing
23. Modify vscode-extension for .abcs support
24. Update tsconfig references and root package.json
25. Run full test suite: `npm run test`
26. Verify end-to-end in VS Code
27. Code review agent, address feedback
28. Commit once: build passes, tests pass, review addressed

---

## Critical Files

- `parse/types/Expr2.ts` — AST node definitions (Note, Rest, Chord, Beam, Rhythm, Pitch, with `id` fields)
- `parse/Visitors/Formatter2.ts` — AbcFormatter.stringify(), sortNotes (enforces lowest-to-highest ordering convention)
- `parse/Visitors/RhythmTransform.ts:458` — rhythmToRational, rationalToRhythm (reference implementations)
- `parse/Visitors/fmt2/rational.ts` — IRational, addRational, createRational, subtractRational
- `abct/src/runtime/types.ts:19` — existing Selection interface (for reference; scheme-proto defines its own with IDs)
- `abct/src/runtime/selectors.ts` — existing selectors (for reference patterns)
- `abct/src/runtime/transforms/transpose.ts` — transposePitch, fromMidiPitch (reference implementation)
- `abct/src/runtime/transforms/bass.ts` — bass transform (reference implementation)
- `abc-lsp-server/src/AbcLspServer.ts` — document routing pattern
- `abc-lsp-server/src/AbctDocument.ts` — pattern for SchemeDocument
- `abc-lsp-server/src/server.ts` — LSP request handler registration
- `abc-lsp-server/src/abctEvaluator.ts` — FileResolver class
- `abc-lsp-server/tsconfig.json` — must add scheme-proto reference
- `vscode-extension/src/abctCommands.ts` — evaluate command
- `vscode-extension/src/renderer/AbcRenderer.ts` — evaluateAbctForPreview
