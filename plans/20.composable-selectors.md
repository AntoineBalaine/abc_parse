# Composable Selectors

## Table of Contents

1. [Goal](#goal)
2. [Placement and Package Setup](#placement-and-package-setup)
3. [Selection Type](#selection-type)
4. [Child-Sibling Tree](#child-sibling-tree)
5. [Selector Functions](#selector-functions)
6. [Tests](#tests)
7. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are implementing composable selectors that operate on the existing ABC parser's AST. Selectors follow a multi-cursor model inspired by Kakoune: every match produces an independent cursor, and selectors compose by operating within each existing cursor (Kakoune's "select within selection" pattern).

A `Selection` carries a CS tree root and an array of cursors. Each cursor is a `Set<number>` containing scope-root IDs — the IDs of the nodes that define the cursor's scope boundary. Selectors fan out: each match within a cursor's scope becomes a new cursor. This means `selectChords` on a tree with 3 chords produces 3 cursors, each containing 1 chord ID.

Composition works naturally:
```
sel = createSelection(fromAst(ast))
selectNthFromTop(selectChords(selectTune(sel)), 1)
```
- `selectTune(sel)` → N cursors (one per tune, each containing just that tune's ID)
- `selectChords` → M cursors (one per chord found within any tune cursor)
- `selectNthFromTop` → M cursors (one per chord's 2nd-from-top note)

This plan covers:
- The `Selection` type (CS tree root + cursor array)
- The child-sibling tree (read-only navigation overlay, foundational infrastructure)
- The fan-out traversal mechanism
- All selector functions that walk the CS tree
- A test suite that exercises the multi-cursor composition model

This plan does not cover: sibling navigation (selectSiblingsAfter, deferred to a later plan), operations (transpose, remove, to-rest, etc.), immutability/cloning, or LSP integration.

---

## Placement and Package Setup

We create a new workspace package at `abc_parse/abct2/`.

```
abc_parse/
  abct2/
    package.json
    tsconfig.json
    src/
      selection.ts             -- Selection interface, Cursor type, createSelection factory
      csTree/
        types.ts               -- CSNode interface, tag constants, predicates
        fromAst.ts             -- generic AST → child-sibling tree conversion (Visitor-based)
      selectors/
        fanOut.ts              -- generic fan-out traversal (each match → new cursor)
        typeSelectors.ts       -- selectChords, selectNotes, selectNonChordNotes, selectChordNotes, selectRests
        chordSelectors.ts      -- selectTop, selectBottom, selectNthFromTop, selectAllButTop, selectAllButBottom
        structureSelectors.ts  -- selectTune
    tests/
      csTree.spec.ts
      typeSelectors.spec.ts
      chordSelectors.spec.ts
      structureSelectors.spec.ts
      composition.spec.ts
      helpers.ts               -- parseAbc helper (inline string → AST)
```

### `abct2/package.json`

```json
{
  "name": "abct2",
  "version": "0.0.1",
  "private": true,
  "main": "../out/abct2/src/selection.js",
  "scripts": {
    "build": "tsc -b",
    "test": "mocha -r ts-node/register 'tests/**/*.spec.ts'"
  },
  "devDependencies": {
    "fast-check": "^3.0.0"
  }
}
```

### `abct2/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "../out/abct2",
    "rootDir": ".",
    "composite": true,
    "strict": true,
    "esModuleInterop": true,
    "declaration": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "tests"],
  "references": [
    { "path": "../parse" }
  ]
}
```

### Root `package.json` changes

Add `"abct2"` to the `workspaces` array. Add `"build:abct2": "npm run build -w abct2"` to scripts. Insert `build:abct2` into the main `build` script after `build:abct`.

---

## Selection Type

Location: `abct2/src/selection.ts`

```typescript
import { CSNode } from "./csTree/types";

type Cursor = Set<number>

interface Selection {
  root: CSNode
  cursors: Cursor[]
}

function createSelection(root: CSNode): Selection {
  return { root, cursors: [new Set([root.id])] }
}
```

A `Cursor` is a `Set<number>` containing scope-root IDs — the IDs of the nodes that define the cursor's scope boundary. The fan-out walk enters scope when it encounters a node whose ID is in the cursor, and from that point all descendants are candidates for matching. An empty `cursors` array means nothing is selected.

The initial selection is created via `createSelection(fromAst(ast))`, which produces a single cursor containing the root's ID. Because the walk enters scope at the root, all nodes in the tree become candidates for the first selector.

We use node IDs (numbers) rather than object references because IDs remain valid across cloning — when we later implement immutable operations, the cloned tree preserves IDs, so cursors remain meaningful on a different copy of the same tree.

All selectors accept a `Selection`. The pipeline is:

```
sel = createSelection(fromAst(ast))
selectChords(selectTune(sel))
```

The CS tree is the primary navigation structure. Selectors walk it via `firstChild`/`nextSibling` pointers rather than introspecting AST fields, which gives a uniform traversal regardless of node type.

---

## Child-Sibling Tree

### Motivation

The child-sibling tree is a read-only navigation overlay on the AST. It provides uniform `firstChild`/`nextSibling` pointers for every node (Expr and Token) in the tree. Although sibling navigation (selectSiblingsAfter) is deferred to a later plan, the CS tree is foundational infrastructure that we build now — it enables future operations like walking forward from a node to its neighbors without requiring parent-array lookups.

### CSNode: `abct2/src/csTree/types.ts`

```typescript
interface CSNode {
  tag: string                  // hardcoded discriminant (e.g., "Note", "Chord", "Rest", "Beam", "Token")
  id: number                   // the wrapped node's id (both Expr and Token have numeric ids)
  node: Expr | Token           // reference to the original AST node
  firstChild: CSNode | null
  nextSibling: CSNode | null
}
```

Design decisions:

- Both Expr and Token nodes produce CSNodes. Tokens carry `id`, `line`, and `position` fields, which are necessary for tracing location ranges back to the source text.
- The `tag` field is a hardcoded string. For Expr nodes, it matches the subclass name (e.g., "Note", "Chord"). For Token nodes, the tag is `"Token"`. We do not use `constructor.name` because it is unreliable in minified builds. Instead, `fromAst` sets the tag explicitly via a lookup table for Expr nodes, and checks `instanceof Token` for the Token case.
- There are no parent pointers. Upward navigation is not needed for the current use cases.

### Tag constants

Because tags are hardcoded strings, we define them as constants for reliability:

```typescript
const TAGS: Record<string, string> = {
  File_structure: "File_structure",
  Tune: "Tune",
  Tune_header: "Tune_header",
  Tune_Body: "Tune_Body",
  Info_line: "Info_line",
  Note: "Note",
  Pitch: "Pitch",
  Rhythm: "Rhythm",
  Rest: "Rest",
  Chord: "Chord",
  Beam: "Beam",
  Grace_group: "Grace_group",
  BarLine: "BarLine",
  Decoration: "Decoration",
  Annotation: "Annotation",
  Inline_field: "Inline_field",
  MultiMeasureRest: "MultiMeasureRest",
  YSPACER: "YSPACER",
  SystemBreak: "SystemBreak",
  Symbol: "Symbol",
  Tuplet: "Tuplet",
  Music_code: "Music_code",
  Voice_overlay: "Voice_overlay",
  Line_continuation: "Line_continuation",
  Comment: "Comment",
  Directive: "Directive",
  Measurement: "Measurement",
  Rational: "Rational",
  File_header: "File_header",
  SymbolLine: "SymbolLine",
  Lyric_section: "Lyric_section",
  AbsolutePitch: "AbsolutePitch",
  Lyric_line: "Lyric_line",
  Macro_decl: "Macro_decl",
  Macro_invocation: "Macro_invocation",
  User_symbol_decl: "User_symbol_decl",
  User_symbol_invocation: "User_symbol_invocation",
  KV: "KV",
  Binary: "Binary",
  Unary: "Unary",
  Grouping: "Grouping",
  ChordSymbol: "ChordSymbol",
  ErrorExpr: "ErrorExpr",
  Token: "Token",
}
```

The tag for each node is determined by checking `instanceof Token` first (→ `"Token"`), then `instanceof` against each Expr subclass (→ the corresponding string). This is done once at CSNode creation time (in `fromAst`), so the cost is paid during tree construction, not during navigation.

### Predicates

Also in `csTree/types.ts`, we define predicates for querying CSNode types by tag:

```typescript
function isRest(node: CSNode): boolean      // node.tag === TAGS.Rest
function isNote(node: CSNode): boolean      // node.tag === TAGS.Note
function isChord(node: CSNode): boolean     // node.tag === TAGS.Chord
function isBarLine(node: CSNode): boolean   // node.tag === TAGS.BarLine
function isBeam(node: CSNode): boolean      // node.tag === TAGS.Beam
```

These are the ergonomic API for type discrimination on CSNodes. They check the hardcoded `tag` string rather than using `instanceof` on the wrapped `expr`.

### Conversion: `fromAst.ts`

```typescript
function fromAst(node: Expr | Token): CSNode
```

The function takes any Expr or Token node and builds a CS tree rooted at it. It uses the Visitor pattern (the established AST traversal mechanism in this codebase) to discover each node's children in the correct order.

Algorithm:

```
function fromAst(node):
  tag = resolveTag(node)          // instanceof Token → "Token", else Expr subclass lookup
  csNode = CSNode { tag, id: node.id, node, firstChild: null, nextSibling: null }
  children = node.accept(childrenVisitor)    // returns Array<Expr | Token>
  if children is non-empty:
    csNode.firstChild = fromAst(children[0])
    current = csNode.firstChild
    for i in 1..children.length-1:
      current.nextSibling = fromAst(children[i])
      current = current.nextSibling
  return csNode
```

The `childrenVisitor` implements the Visitor interface. Each `visit*` method returns the ordered list of children (Expr and Token nodes) for that node type. For example:

```
visitChordExpr(chord):     return [...chord.contents, chord.rhythm, chord.tie].filter(notNull)
visitBeamExpr(beam):       return beam.contents           // Array<Beam_contents>
visitNoteExpr(note):       return [note.pitch, note.rhythm, note.tie].filter(notNull)
visitTuneExpr(tune):       return [tune.tune_header, tune.tune_body].filter(notNull)
visitTuneBodyExpr(body):   return body.sequence.flat()    // flatten Array<Array<tune_body_code>>
visitBarLineExpr(bar):     return [...bar.barline, ...(bar.repeatNumbers ?? [])]
visitToken(token):         return []                      // Tokens are leaves
```

Because the visitor explicitly lists each node type's children, the ordering is deterministic and matches the source-order semantics of the AST. There is no reliance on `Object.keys` or property introspection.

---

## Selector Functions

### Two categories of selectors

All selectors return a `Selection` with the same `root` CSNode. They differ in what they match:

1. Fan-out selectors: for each input cursor, walk the CS tree starting from root, enter scope when encountering a node whose ID is in the cursor, and match descendants within that scope. Each match becomes a new cursor in the output.

2. Structure selectors (selectTune): for each input cursor, find structural units (Tune CSNodes) that are within scope. Each matching structural unit becomes a new cursor containing just that unit's ID.

### Fan-out traversal: `fanOut.ts`

The generic fan-out mechanism walks the CS tree and produces one new cursor per match:

```typescript
function fanOutByPredicate(
  input: Selection,
  predicate: (node: CSNode) => boolean,
  walkStrategy: WalkStrategy
): Selection

type WalkStrategy = "all" | "skipChordChildren" | "onlyChordNotes"
```

Algorithm:

```
output_cursors = []
for each cursor in input.cursors:
  walk(node, inScope, parentIsChord):
    nowInScope = inScope OR (node.id in cursor)
    shouldMatch = (strategy === "onlyChordNotes") ? (parentIsChord AND nowInScope) : nowInScope
    if shouldMatch AND predicate(node):
      output_cursors.push(new Set([node.id]))
    if strategy === "skipChordChildren" AND node.tag === TAGS.Chord:
      // skip firstChild, only continue to sibling
    else:
      if node.firstChild:
        walk(node.firstChild, nowInScope, node.tag === TAGS.Chord)
    if node.nextSibling:
      walk(node.nextSibling, inScope, parentIsChord)
  walk(input.root, false, false)
return { root: input.root, cursors: output_cursors }
```

Key recursion rules:
- `firstChild` inherits `nowInScope` (children are inside the current node's scope).
- `nextSibling` inherits the original `inScope` (siblings are peers, not descendants — scope does not bleed sideways).
- `parentIsChord` is set to true when recursing into a Chord's children, and is passed unchanged to siblings.

The walk always recurses into children (unless blocked by the walk strategy) regardless of whether the current node matched — it never stops early. The scope-entry check (`node.id in cursor`) determines when the walk has reached a cursor's boundary node; from that point, all descendants are candidates.

The three walk strategies control recursion and matching at Chord boundaries (identified by `node.tag === TAGS.Chord`):

- `"all"`: walks all nodes including chord children and beam children. All in-scope nodes can match.
- `"skipChordChildren"`: walks all nodes but does not recurse into Chord nodes' `firstChild` — only standalone nodes can match.
- `"onlyChordNotes"`: recurses into all containers (Beams, etc.) to find Chord nodes, but only allows matching when `parentIsChord` is true — standalone nodes are excluded even if in scope.

### Structure selectors: `structureSelectors.ts`

Structure selectors scope the selection to a structural subtree. The resulting cursor contains just the structural unit's ID — subsequent selectors will enter scope at that node and match within its descendants.

```typescript
function selectTune(input: Selection): Selection
```

`selectTune` uses the same scope-entry walk as fan-out selectors, with the predicate `node.tag === TAGS.Tune`. Each matched Tune produces a cursor containing just `{tune.id}`. Subsequent selectors enter scope at that Tune and can match anything within its subtree.

```
output_cursors = []
for each cursor in input.cursors:
  walk(node, inScope):
    nowInScope = inScope OR (node.id in cursor)
    if nowInScope AND node.tag === TAGS.Tune:
      output_cursors.push(new Set([node.id]))
    if node.firstChild:  walk(node.firstChild, nowInScope)
    if node.nextSibling: walk(node.nextSibling, inScope)
  walk(input.root, false)
return { root: input.root, cursors: output_cursors }
```

### Type selectors: `typeSelectors.ts`

Each match produces a single-ID cursor:

| Function                   | Walk strategy         | Predicate       |
| -------------------------- | --------------------- | --------------- |
| `selectChords(sel)`        | `"all"`               | `isChord(node)` |
| `selectNotes(sel)`         | `"all"`               | `isNote(node)`  |
| `selectNonChordNotes(sel)` | `"skipChordChildren"` | `isNote(node)`  |
| `selectChordNotes(sel)`    | `"onlyChordNotes"`    | `isNote(node)`  |
| `selectRests(sel)`         | `"all"`               | `isRest(node)`  |

Because rests never appear inside chords, `selectRests` uses `"all"`.

### Chord-internal selectors: `chordSelectors.ts`

These drill into Chord nodes that are found in any input cursor. For each chord, they match specific notes by position. Each matched note becomes its own cursor (uniform fan-out).

```typescript
function selectTop(input: Selection): Selection
function selectBottom(input: Selection): Selection
function selectNthFromTop(input: Selection, n: number): Selection
function selectAllButTop(input: Selection): Selection
function selectAllButBottom(input: Selection): Selection
```

Implementation pattern (using `selectAllButTop`):

```
output_cursors = []
for each cursor in input.cursors:
  walk(node, inScope):
    nowInScope = inScope OR (node.id in cursor)
    if nowInScope AND node.tag === TAGS.Chord:
      notes = collect children of node where child.tag === TAGS.Note
      for i in 0..notes.length - 2:     // all except last (= top)
        output_cursors.push(new Set([notes[i].id]))
    if node.firstChild:  walk(node.firstChild, nowInScope)
    if node.nextSibling: walk(node.nextSibling, inScope)
  walk(input.root, false)
return { root: input.root, cursors: output_cursors }
```

Pitch ordering convention: the Chord CSNode's children are in the same order as the original `Chord.contents` array, which is sorted lowest-to-highest (the formatter enforces this). `selectTop` takes the last Note child, `selectBottom` takes the first.

Out-of-bounds: `selectNthFromTop(sel, n)` with `n >= notes.length` produces no cursor for that chord. A chord with fewer than 2 notes produces no cursors for `selectAllButTop` / `selectAllButBottom`.

---

## Tests

All tests parse inline ABC strings — there are no fixture files. Each test subsection lists two kinds of tests that must both be implemented:

- Properties: invariants that hold for any valid input. These are implemented as property-based tests using `fast-check` (generating random valid ABC strings or random CS trees and asserting the invariant holds for all of them).
- Examples: specific inputs with known expected results. These are standard unit tests with hardcoded assertions.

### Helper: `tests/helpers.ts`

```typescript
import { Scanner } from "../../parse/parsers/scan2";
import { parse } from "../../parse/parsers/parse2";
import { ABCContext } from "../../parse/parsers/Context";
import { fromAst } from "../src/csTree/fromAst";
import { CSNode } from "../src/csTree/types";
import { createSelection, Selection } from "../src/selection";

function toCSTree(source: string): CSNode {
  const ctx = new ABCContext();
  const tokens = Scanner(source, ctx);
  const ast = parse(tokens, ctx);
  return fromAst(ast);
}

function toSelection(source: string): Selection {
  return createSelection(toCSTree(source));
}
```

### `csTree.spec.ts`

Properties:
- For any valid ABC string, `fromAst(ast)` produces a tree where every CSNode has a tag that matches one of the entries in the TAGS constant.
- For any CSNode, `node.id === node.node.id`.
- For any container node whose visitor returns N children, the corresponding CSNode's sibling chain (starting from firstChild, following nextSibling) has exactly N nodes.
- Token CSNodes are always leaves (firstChild is null).

Examples:
- `[CEG]2 C2 D2|` — the root CSNode (File_structure) has a Tune child. The Tune has Tune_header and Tune_Body children. The Tune_Body CSNode's children include the Chord, standalone Notes, Token nodes (whitespace), and the BarLine. The Chord CSNode has Note children (C, E, G) linked as siblings.
- `CDEF GABc|` — the parser produces Beam nodes. Each Beam CSNode has its contents as children (Note CSNodes and any intervening Token nodes). The Tune_Body children include both Beam CSNodes and the BarLine.
- `X:1\nK:C\nCDE|\n\nX:2\nK:G\nGAB|` — the root CSNode has 2 Tune children linked as siblings.
- A Note CSNode's tag is `"Note"`. A Chord's tag is `"Chord"`. A Rest's tag is `"Rest"`. A Beam's tag is `"Beam"`. A whitespace node's tag is `"Token"`.
- Token CSNodes have `firstChild === null` (they are always leaves).
- `fromAst(chordNode)` where chordNode is a Chord Expr — produces a CSNode rooted at that Chord with its children. The function works on any Expr or Token, not just File_structure.

### `typeSelectors.spec.ts`

Properties:
- For any selection, every cursor in `selectChords(sel).cursors` contains exactly 1 ID, and that ID belongs to a CSNode with `tag === TAGS.Chord`.
- For any selection, every cursor in `selectNotes(sel).cursors` contains exactly 1 ID belonging to a CSNode with `tag === TAGS.Note`.
- For any selection, `selectNonChordNotes(sel).cursors` and `selectChordNotes(sel).cursors` are disjoint (no ID appears in both), and their union equals the IDs in `selectNotes(sel).cursors`.
- For any selection, the cursor count of `selectChords(sel)` equals the number of Chord CSNodes in the tree.
- For any two type selectors A and B where A and B select disjoint types, `A(B(sel))` produces zero cursors (because each B-cursor contains one ID of type B, and A's predicate rejects it).
- Idempotence: `selectChords(selectChords(sel))` equals `selectChords(sel)` (each chord cursor is re-matched as a chord, producing the same cursors).

Examples:
- `[CEG]2 C2 D2 E2|` — `selectChords` produces 1 cursor `{chordId}`. `selectNotes` produces 6 cursors (3 for notes inside the chord + 3 for standalone C, D, E). `selectNonChordNotes` produces 3 cursors. `selectChordNotes` produces 3 cursors.
- `C2 z2 [DF]2 z2|` — `selectRests` produces 2 cursors. `selectChords` produces 1 cursor. `selectNonChordNotes` produces 1 cursor (standalone C).
- `CDEF|` (beamed) — `selectNotes` produces 4 cursors (walks into Beam children via firstChild/nextSibling).
- `selectChords(selectNotes(sel))` on any input produces zero cursors.

### `chordSelectors.spec.ts`

Properties:
- For any chord with N notes, `selectTop(chordCursor)` produces 1 cursor, `selectAllButTop(chordCursor)` produces N-1 cursors, and their IDs are disjoint.
- `selectNthFromTop(sel, 0)` produces the same cursors as `selectTop(sel)`.
- Each cursor from `selectAllButTop` or `selectAllButBottom` contains exactly 1 ID.

Examples:
- `[CEG]2|` — `selectTop(selectChords(sel))` produces 1 cursor `{G.id}`. `selectBottom(...)` produces 1 cursor `{C.id}`. `selectAllButTop(...)` produces 2 cursors `{C.id}`, `{E.id}`. `selectAllButBottom(...)` produces 2 cursors `{E.id}`, `{G.id}`.
- `[CEG]2|` — `selectNthFromTop(..., 1)` produces 1 cursor `{E.id}`.
- `[CG]2|` (2-note chord) — `selectAllButTop(...)` produces 1 cursor `{C.id}`.
- `[C]2|` (single-note chord) — `selectAllButTop(...)` produces zero cursors.
- `[CEGc]2|` — `selectNthFromTop(..., 5)` produces zero cursors.
- `[CEG]2 [FAc]2|` (two chords) — `selectAllButTop(selectChords(sel))` produces 4 cursors: `{C.id}`, `{E.id}`, `{F.id}`, `{A.id}`.

### `structureSelectors.spec.ts`

Properties:
- For any multi-tune selection, `selectTune(sel)` produces one cursor per Tune CSNode. Each cursor contains just that Tune's ID.
- Subsequent selectors enter scope at the Tune node and match within its subtree.

Examples:
- `X:1\nT:A\nK:C\nCDE|\n\nX:2\nT:B\nK:G\nGAB|` — `selectTune(sel)` produces 2 cursors: `{tune1.id}` and `{tune2.id}`.
- `X:1\nK:C\nCDE|` (single tune) — `selectTune(sel)` produces 1 cursor `{tune.id}`.
- Composition: `selectChords(selectTune(sel))` on a two-tune input produces one chord cursor per chord across both tunes, because the walk enters scope at each tune and finds chords within.

### `composition.spec.ts`

Properties:
- For any input, the returned `root` reference is the same CSNode as the input's root (selectors never copy or modify the tree).
- For any input, applying any selector sequence does not mutate the input Selection's `cursors` array or any cursor Set within it.

Examples:
- `[CEG]2 z2 [FAc]2 z2|` — `selectTop(selectChords(sel))` produces 2 cursors: `{G.id}` and `{c.id}`.
- `[CEG]2 C2 D2|` — `selectNonChordNotes(selectTune(sel))` produces 2 cursors: `{C.id}`, `{D.id}` (standalone notes only; E is inside the chord).
- `[CEGc]2 C2|` — `selectNthFromTop(selectChords(sel), 1)` produces 1 cursor `{G.id}` (second from top in a 4-note chord).
- Three-deep: `selectAllButTop(selectChords(selectTune(sel)))` on `[CEG]2 C2 [FAc]2 F2|` — produces 4 cursors: `{C.id}`, `{E.id}` (from first chord) and `{F.id}`, `{A.id}` (from second chord).
- Empty propagation: `selectChords(selectRests(sel))` on any input produces zero cursors (rests are never chords).

---

## Implementation Checklist

1. Create all directories and files in a single batch (`abct2/src/...`, `abct2/tests/...`)
2. Add `abct2` to root `package.json` workspaces and build scripts
3. Write `abct2/package.json` and `abct2/tsconfig.json`
4. Implement `selection.ts`: Selection interface, Cursor type (`Set<number>`), createSelection factory
5. Implement `csTree/types.ts`: CSNode interface, TAGS constant with all Expr subclass names, predicates (isRest, isNote, isChord, isBarLine, isBeam)
6. Implement `csTree/fromAst.ts`: fromAst function (Visitor-based children discovery, resolveTag via instanceof chain)
7. Write `csTree.spec.ts`
8. Implement `selectors/fanOut.ts`: generic fan-out traversal with scope-entry walk and walk strategies
9. Implement `selectors/typeSelectors.ts`: selectChords, selectNotes, selectNonChordNotes, selectChordNotes, selectRests
10. Write `typeSelectors.spec.ts`
11. Implement `selectors/chordSelectors.ts`: selectTop, selectBottom, selectNthFromTop, selectAllButTop, selectAllButBottom
12. Write `chordSelectors.spec.ts`
13. Implement `selectors/structureSelectors.ts`: selectTune (scope-entry walk with tag predicate)
14. Write `structureSelectors.spec.ts`
15. Write `composition.spec.ts`
16. Verify: `npm run build` from root succeeds
17. Verify: `npm run test` from root succeeds (including abct2 tests)
18. Run the code review agent, address feedback
19. Commit once build and tests pass

---

## Critical Files (existing codebase references)

- `parse/types/Expr2.ts` — AST node classes (Note, Rest, Chord, Beam, Tune, Tune_Body, File_structure). Each Expr has an `id: number` field.
- `parse/helpers.ts` — type guards: `isNote()`, `isChord()`, `isBeam()`, `isGraceGroup()`, `isToken()`
- `parse/parsers/parse2.ts` — `parse(tokens, ctx)` returns a `File_structure`
- `parse/parsers/scan2.ts` — `Scanner(source, ctx)` returns token array
- `parse/parsers/Context.ts` — `ABCContext` class (required by Scanner and parse)
- `parse/Visitors/Formatter2.ts` — `AbcFormatter.stringify(ast)` for verification
- `abct/src/runtime/selectors.ts` — existing v1 selectors (reference only, not imported)
