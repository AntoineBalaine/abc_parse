# Selector Commands for VS Code

## Table of Contents

1. [Goal](#goal)
2. [Architecture Overview](#architecture-overview)
3. [LSP Server: Selection State Manager](#lsp-server-selection-state-manager)
4. [LSP Server: Range Resolution](#lsp-server-range-resolution)
5. [LSP Server: Request Handlers](#lsp-server-request-handlers)
6. [Extension: Command Registration](#extension-command-registration)
7. [Extension: Selection Application](#extension-selection-application)
8. [Build Integration](#build-integration)
9. [Tests](#tests)
10. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are adding VS Code commands that expose the abct2 composable selectors to the user. Each selector is its own command in the command palette (e.g., "ABC: Select Chords", "ABC: Select Top Note"). Running a command applies the corresponding selector to the current selection state, and the resulting cursors are converted to VS Code multi-selections in the editor.

The selection state is maintained on the LSP server side (because the server already holds the parsed AST). Commands compose: running "ABC: Select Chords" followed by "ABC: Select Top Note" produces the top note of each chord. A "Reset Selection" command returns to the initial state (all nodes in scope).

This plan covers `.abc` files only. ABCT integration is deferred.

---

## Architecture Overview

```
Extension                          LSP Server
─────────                          ──────────
Command palette                    Per-document SelectionState
  │                                  │
  ├─ user runs "Select Chords" ─────►├─ applies selectChords to current state
  │                                  ├─ resolves cursor IDs → Range[]
  │◄─── returns Range[] ────────────┤
  │                                  │
  ├─ sets editor.selections          │
  │   from returned ranges           │
```

Data flow:

1. User triggers a selector command from the command palette.
2. The extension sends an `abct2.applySelector` request to the LSP server with the document URI and the selector name.
3. The LSP server retrieves the per-document `SelectionState`, applies the selector, stores the new state, and resolves each cursor to a source range using the `RangeVisitor`.
4. The LSP server returns the array of `Range` objects.
5. The extension converts those ranges to `vscode.Selection` objects and sets them on the active editor.

---

## LSP Server: Selection State Manager

Location: `abc-lsp-server/src/selectionState.ts`

The server maintains a `SelectionState` per document URI. The state holds the CS tree root and the current `Selection` (from abct2). Because the state depends on the parsed AST, it is invalidated whenever the document changes.

```typescript
import { CSNode } from "abct2/src/csTree/types";
import { Selection, createSelection } from "abct2/src/selection";
import { fromAst } from "abct2/src/csTree/fromAst";
import { File_structure } from "parse/types/Expr2";

interface SelectionState {
  ast: File_structure        // the parsed AST (kept for range resolution)
  selection: Selection       // the current abct2 Selection
}

class SelectionStateManager {
  states: Map<string, SelectionState>   // keyed by document URI

  getOrCreate(uri: string, ast: File_structure): SelectionState
    // if states.has(uri), return existing
    // else: root = fromAst(ast), sel = createSelection(root), store and return

  reset(uri: string, ast: File_structure): SelectionState
    // always recreates: root = fromAst(ast), sel = createSelection(root), store and return

  update(uri: string, selection: Selection): void
    // replaces the current selection in the existing state

  invalidate(uri: string): void
    // removes the state for this URI (called on document change)
}
```

### Invalidation

In `AbcLspServer.ts`, the `onDidChangeContent` handler already re-parses the document. After re-parsing, we call `selectionStateManager.invalidate(uri)` to discard stale state. The next selector command will trigger `getOrCreate`, which rebuilds the CS tree from the fresh AST.

---

## LSP Server: Range Resolution

Location: `abc-lsp-server/src/selectionRangeResolver.ts`

Given a `SelectionState` and the current `Selection`, we need to convert each cursor (a `Set<number>` containing a single scope-root ID) to a source `Range`. Because each cursor produced by a fan-out selector contains exactly one node ID, we look up the corresponding CSNode and use the existing `RangeVisitor` to compute its source range.

```typescript
import { RangeVisitor } from "parse/Visitors/RangeVisitor";
import { getTokenRange } from "parse/helpers";
import { isToken } from "parse/helpers";
import { CSNode } from "abct2/src/csTree/types";
import { Selection } from "abct2/src/selection";
import { Range } from "parse/types/types";

function resolveSelectionRanges(selection: Selection): Range[]
```

Algorithm:

```
rangeVisitor = new RangeVisitor()
ranges = []
for each cursor in selection.cursors:
  id = first element of cursor       // cursors from fan-out contain exactly 1 ID
  csNode = findNodeById(selection.root, id)
  if csNode is null: continue
  if isToken(csNode.node):
    range = getTokenRange(csNode.node)
  else:
    range = csNode.node.accept(rangeVisitor)
  ranges.push(range)
return ranges
```

### `findNodeById`

A depth-first walk of the CS tree to locate a CSNode by its `id` field:

```
function findNodeById(root: CSNode, targetId: number): CSNode | null
  if root.id === targetId: return root
  if root.firstChild:
    found = findNodeById(root.firstChild, targetId)
    if found: return found
  if root.nextSibling:
    found = findNodeById(root.nextSibling, targetId)
    if found: return found
  return null
```

Performance note: for files with many cursors, the repeated tree walks could be expensive. As an optimization, we can build an `id → CSNode` index once per state creation. This is deferred — the naive approach is sufficient for the prototype.

---

## LSP Server: Request Handlers

Location: modifications to `abc-lsp-server/src/server.ts`

### Request: `abct2.applySelector`

Parameters:

```typescript
interface ApplySelectorParams {
  uri: string
  selector: string           // selector function name (e.g., "selectChords", "selectTop")
  args?: number[]            // optional numeric arguments (for selectNthFromTop)
}
```

Response:

```typescript
interface ApplySelectorResult {
  ranges: Range[]            // one range per cursor
  cursorCount: number        // total number of cursors in the new selection
}
```

Handler implementation:

```
connection.onRequest("abct2.applySelector", (params: ApplySelectorParams) => {
  doc = server.getAbcDocument(params.uri)
  if doc is null: return { ranges: [], cursorCount: 0 }

  ast = doc.ast
  state = selectionStateManager.getOrCreate(params.uri, ast)

  selectorFn = lookupSelector(params.selector)     // maps string → function
  if selectorFn is null: return error "unknown selector"

  newSelection = selectorFn(state.selection, ...(params.args ?? []))
  selectionStateManager.update(params.uri, newSelection)

  ranges = resolveSelectionRanges(newSelection)
  return { ranges, cursorCount: newSelection.cursors.length }
})
```

### Request: `abct2.resetSelection`

Parameters:

```typescript
interface ResetSelectionParams {
  uri: string
}
```

Response: `ApplySelectorResult` (the initial selection's ranges — typically the full file range).

Handler:

```
connection.onRequest("abct2.resetSelection", (params: ResetSelectionParams) => {
  doc = server.getAbcDocument(params.uri)
  if doc is null: return { ranges: [], cursorCount: 0 }

  state = selectionStateManager.reset(params.uri, doc.ast)
  ranges = resolveSelectionRanges(state.selection)
  return { ranges, cursorCount: state.selection.cursors.length }
})
```

### Selector lookup table

Location: `abc-lsp-server/src/selectorLookup.ts`

```typescript
import { Selection } from "abct2/src/selection";
import {
  selectChords, selectNotes, selectNonChordNotes,
  selectChordNotes, selectRests
} from "abct2/src/selectors/typeSelectors";
import { selectTune } from "abct2/src/selectors/structureSelectors";
import {
  selectTop, selectBottom, selectNthFromTop,
  selectAllButTop, selectAllButBottom
} from "abct2/src/selectors/chordSelectors";

type SelectorFn = (sel: Selection, ...args: number[]) => Selection

const SELECTOR_MAP: Record<string, SelectorFn> = {
  selectChords:        (sel) => selectChords(sel),
  selectNotes:         (sel) => selectNotes(sel),
  selectNonChordNotes: (sel) => selectNonChordNotes(sel),
  selectChordNotes:    (sel) => selectChordNotes(sel),
  selectRests:         (sel) => selectRests(sel),
  selectTune:          (sel) => selectTune(sel),
  selectTop:           (sel) => selectTop(sel),
  selectBottom:        (sel) => selectBottom(sel),
  selectNthFromTop:    (sel, n) => selectNthFromTop(sel, n),
  selectAllButTop:     (sel) => selectAllButTop(sel),
  selectAllButBottom:  (sel) => selectAllButBottom(sel),
}

function lookupSelector(name: string): SelectorFn | null {
  return SELECTOR_MAP[name] ?? null
}
```

---

## Extension: Command Registration

Location: new file `vscode-extension/src/selectorCommands.ts`

### Command list

| Command ID                      | Label in palette              | Selector name      | Args |
| ------------------------------- | ----------------------------- | ------------------ | ---- |
| `abc.resetSelection`            | ABC: Reset Selection          | (reset)            | --   |
| `abc.selectChords`              | ABC: Select Chords            | selectChords       | --   |
| `abc.selectNotes`               | ABC: Select Notes             | selectNotes        | --   |
| `abc.selectNonChordNotes`       | ABC: Select Non-Chord Notes   | selectNonChordNotes| --   |
| `abc.selectChordNotes`          | ABC: Select Chord Notes       | selectChordNotes   | --   |
| `abc.selectRests`               | ABC: Select Rests             | selectRests        | --   |
| `abc.selectTune`                | ABC: Select Tune              | selectTune         | --   |
| `abc.selectTop`                 | ABC: Select Top Note          | selectTop          | --   |
| `abc.selectBottom`              | ABC: Select Bottom Note       | selectBottom       | --   |
| `abc.selectNthFromTop`          | ABC: Select Nth From Top      | selectNthFromTop   | [n]  |
| `abc.selectAllButTop`           | ABC: Select All But Top       | selectAllButTop    | --   |
| `abc.selectAllButBottom`        | ABC: Select All But Bottom    | selectAllButBottom | --   |

### Registration function

```typescript
import * as vscode from "vscode";
import { LanguageClient } from "vscode-languageclient/node";

function registerSelectorCommands(context: vscode.ExtensionContext, client: LanguageClient): void
```

Each command follows the same pattern:

```typescript
context.subscriptions.push(
  vscode.commands.registerCommand("abc.selectChords", async () => {
    const editor = vscode.window.activeTextEditor;
    if (!editor || editor.document.languageId !== "abc") return;

    const result = await client.sendRequest<ApplySelectorResult>("abct2.applySelector", {
      uri: editor.document.uri.toString(),
      selector: "selectChords",
    });

    applySelectionsToEditor(editor, result.ranges);
  })
);
```

For `abc.selectNthFromTop`, the command first prompts for a number via `vscode.window.showInputBox`:

```typescript
vscode.commands.registerCommand("abc.selectNthFromTop", async () => {
  const editor = vscode.window.activeTextEditor;
  if (!editor || editor.document.languageId !== "abc") return;

  const input = await vscode.window.showInputBox({
    prompt: "Enter n (0 = top, 1 = second from top, ...)",
    validateInput: (v) => isNaN(Number(v)) ? "Must be a number" : null,
  });
  if (input === undefined) return;

  const result = await client.sendRequest<ApplySelectorResult>("abct2.applySelector", {
    uri: editor.document.uri.toString(),
    selector: "selectNthFromTop",
    args: [Number(input)],
  });

  applySelectionsToEditor(editor, result.ranges);
});
```

For `abc.resetSelection`, the command sends `abct2.resetSelection` instead.

### Integration in `extension.ts`

Add a call to `registerSelectorCommands(context, client)` in the activation function, after the client is started (because the commands depend on the client being ready).

---

## Extension: Selection Application

Location: within `vscode-extension/src/selectorCommands.ts`

The `applySelectionsToEditor` function converts the returned `Range[]` (from the parse module's `Range` type: `{ start: Position, end: Position }` where `Position` is `{ line: number, character: number }`) to VS Code `Selection` objects:

```typescript
function applySelectionsToEditor(editor: vscode.TextEditor, ranges: Range[]): void {
  if (ranges.length === 0) {
    vscode.window.showInformationMessage("No matches found.");
    return;
  }

  editor.selections = ranges.map((r) => {
    const start = new vscode.Position(r.start.line, r.start.character);
    const end = new vscode.Position(r.end.line, r.end.character);
    return new vscode.Selection(start, end);
  });

  // Reveal the first selection in the viewport
  editor.revealRange(editor.selections[0], vscode.TextEditorRevealType.InCenterIfOutsideViewport);
}
```

### Status bar indicator

To provide feedback about the current selector state, we add a status bar item that shows the number of active cursors:

```typescript
const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
statusBarItem.command = "abc.resetSelection";

function updateStatusBar(cursorCount: number): void {
  if (cursorCount > 0) {
    statusBarItem.text = `$(selection) ${cursorCount} cursor${cursorCount > 1 ? "s" : ""}`;
    statusBarItem.tooltip = "Click to reset selection";
    statusBarItem.show();
  } else {
    statusBarItem.hide();
  }
}
```

The status bar item is updated after each command completes. It is hidden when there are no active cursors (after reset or when no `.abc` file is open).

---

## Build Integration

### `abc-lsp-server/tsconfig.json`

Add a project reference to abct2 so the LSP server can import from it:

```json
"references": [
  { "path": "../parse" },
  { "path": "../abct" },
  { "path": "../abct2" }
]
```

### `abc-lsp-server/package.json`

Because both packages are workspace siblings, no dependency entry is needed — the TypeScript project reference handles compilation, and the workspace resolution handles runtime imports.

### `vscode-extension/package.json`

Add command contributions to the `contributes.commands` array:

```json
{ "command": "abc.resetSelection", "title": "ABC: Reset Selection", "category": "ABC" },
{ "command": "abc.selectChords", "title": "ABC: Select Chords", "category": "ABC" },
{ "command": "abc.selectNotes", "title": "ABC: Select Notes", "category": "ABC" },
{ "command": "abc.selectNonChordNotes", "title": "ABC: Select Non-Chord Notes", "category": "ABC" },
{ "command": "abc.selectChordNotes", "title": "ABC: Select Chord Notes", "category": "ABC" },
{ "command": "abc.selectRests", "title": "ABC: Select Rests", "category": "ABC" },
{ "command": "abc.selectTune", "title": "ABC: Select Tune", "category": "ABC" },
{ "command": "abc.selectTop", "title": "ABC: Select Top Note", "category": "ABC" },
{ "command": "abc.selectBottom", "title": "ABC: Select Bottom Note", "category": "ABC" },
{ "command": "abc.selectNthFromTop", "title": "ABC: Select Nth From Top", "category": "ABC" },
{ "command": "abc.selectAllButTop", "title": "ABC: Select All But Top", "category": "ABC" },
{ "command": "abc.selectAllButBottom", "title": "ABC: Select All But Bottom", "category": "ABC" }
```

Add a `when` clause to the menus/keybindings so the commands only appear when the active editor's language is `abc`:

```json
"menus": {
  "commandPalette": [
    { "command": "abc.selectChords", "when": "editorLangId == abc" },
    ...
  ]
}
```

### Root `package.json`

The `build:lsp` script already depends on `build:abct2` (from plan 20's ordering in the build sequence). No changes needed to root build scripts.

---

## Tests

### LSP server tests

Location: `abc-lsp-server/src/selectionState.spec.ts`

- `SelectionStateManager.getOrCreate` returns a valid `SelectionState` with a CS tree root and initial selection.
- `SelectionStateManager.invalidate` removes the state; subsequent `getOrCreate` rebuilds from scratch.
- `SelectionStateManager.update` replaces the selection in the existing state.
- Calling `getOrCreate` twice with the same URI returns the same state object (no rebuild).

Location: `abc-lsp-server/src/selectionRangeResolver.spec.ts`

- `resolveSelectionRanges` on an initial selection (single cursor with root ID) returns a single range spanning the entire file.
- `resolveSelectionRanges` after `selectChords` returns one range per chord, each spanning from the opening bracket to the closing bracket (including rhythm).
- `resolveSelectionRanges` after `selectNotes` returns one range per note, spanning from the pitch to the rhythm.
- `resolveSelectionRanges` after `selectTop(selectChords(...))` returns ranges for the top note of each chord only.
- `findNodeById` returns null for an ID that does not exist in the tree.

### Integration test (end-to-end via LSP)

Location: `abc-lsp-server/src/selectorIntegration.spec.ts`

- Send `abct2.applySelector` with `selector: "selectChords"` on a document containing `[CEG]2 C2 D2|`. Verify the response contains 1 range matching the chord's position.
- Send `abct2.applySelector` with `selector: "selectChords"` followed by `selector: "selectTop"`. Verify the second response contains 1 range matching G's position (composition works).
- Send `abct2.resetSelection` after applying selectors. Verify the state is reset (subsequent `selectChords` returns fresh results).
- Send `abct2.applySelector` with an unknown selector name. Verify an error response is returned.
- Modify the document content, then send `abct2.applySelector`. Verify the state was invalidated and rebuilt from the new AST.

---

## Implementation Checklist

1. Create all new files in a single batch:
   - `abc-lsp-server/src/selectionState.ts`
   - `abc-lsp-server/src/selectionRangeResolver.ts`
   - `abc-lsp-server/src/selectorLookup.ts`
   - `abc-lsp-server/src/selectionState.spec.ts`
   - `abc-lsp-server/src/selectionRangeResolver.spec.ts`
   - `abc-lsp-server/src/selectorIntegration.spec.ts`
   - `vscode-extension/src/selectorCommands.ts`
2. Add `{ "path": "../abct2" }` to `abc-lsp-server/tsconfig.json` references
3. Implement `selectionState.ts`: SelectionStateManager class
4. Implement `selectionRangeResolver.ts`: resolveSelectionRanges and findNodeById
5. Implement `selectorLookup.ts`: SELECTOR_MAP and lookupSelector
6. Add request handlers to `server.ts`: `abct2.applySelector` and `abct2.resetSelection`
7. Add `selectionStateManager.invalidate(uri)` call in `AbcLspServer.ts` onDidChangeContent handler
8. Write `selectionState.spec.ts`
9. Write `selectionRangeResolver.spec.ts`
10. Implement `selectorCommands.ts`: registerSelectorCommands, applySelectionsToEditor, status bar indicator
11. Add command contributions to `vscode-extension/package.json` (commands array + commandPalette when clause)
12. Call `registerSelectorCommands(context, client)` in `extension.ts` activation
13. Write `selectorIntegration.spec.ts`
14. Verify: `npm run build` from root succeeds
15. Verify: `npm run test` from root succeeds
16. Run the code review agent, address feedback
17. Commit once build and tests pass

---

## Critical Files (existing codebase references)

- `parse/Visitors/RangeVisitor.ts` — computes the source Range of any Expr node via the Visitor pattern
- `parse/helpers.ts:311` — `reduceRanges` helper, `getTokenRange` helper
- `parse/types/types.ts:92` — `Range` type definition (`{ start: Position, end: Position }`)
- `abct2/src/selection.ts` — `Selection`, `Cursor`, `createSelection`
- `abct2/src/csTree/types.ts` — `CSNode` interface
- `abct2/src/csTree/fromAst.ts` — `fromAst` function
- `abct2/src/selectors/typeSelectors.ts` — selectChords, selectNotes, etc.
- `abct2/src/selectors/chordSelectors.ts` — selectTop, selectBottom, etc.
- `abct2/src/selectors/structureSelectors.ts` — selectTune
- `abc-lsp-server/src/server.ts:164-175` — existing custom request handler registration pattern
- `abc-lsp-server/src/AbcLspServer.ts` — document management, onDidChangeContent handler
- `abc-lsp-server/src/AbcDocument.ts` — `ast` property (holds the parsed `File_structure`)
- `vscode-extension/src/extension.ts` — activation function, client setup
- `vscode-extension/src/extensionCommands.ts` — existing command registration pattern (sendRequest + apply TextEdits)
- `vscode-extension/src/abctCommands.ts` — existing ABCT command pattern (sendRequest for evaluation)
- `vscode-extension/package.json` — contributes.commands array
