# ABCt2 Transforms (Revised for Independent CS Tree)

## Table of Contents

1. [Goal](#goal)
2. [Context and Prerequisites](#context-and-prerequisites)
3. [The toAst/fromAst Bridge Pattern](#the-toastfromast-bridge-pattern)
4. [File Structure](#file-structure)
5. [Phase 1: Transform Infrastructure](#phase-1-transform-infrastructure)
6. [Phase 2: Tree Manipulation Utilities](#phase-2-tree-manipulation-utilities)
7. [Phase 3: Rhythm Utilities](#phase-3-rhythm-utilities)
8. [Phase 4: remove](#phase-4-remove)
9. [Phase 5: transpose](#phase-5-transpose)
10. [Phase 6: to-rest](#phase-6-to-rest)
11. [Phase 7: set-rhythm](#phase-7-set-rhythm)
12. [Phase 8: sum-rhythm](#phase-8-sum-rhythm)
13. [Phase 9: add-to-rhythm](#phase-9-add-to-rhythm)
14. [Phase 10: unwrap-single](#phase-10-unwrap-single)
15. [Test Infrastructure](#test-infrastructure)
16. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are implementing the 7 generic operations from the ABCt2 language design (plan 18). These operations take a `Selection` (a CS tree root + cursors), mutate the tree in place, and return the same `Selection` for chaining. The plan also covers the rhythm and tree manipulation utilities that the transforms depend on.

Transforms are pure mutating operations. Cloning is the pipeline's responsibility (in the ABCt language layer), not the transforms'. Each transform iterates over each cursor independently (Kakoune-style: cursors are processed separately, not merged).

The transforms are:
- `remove` -- splice selected nodes out of the sibling chain
- `transpose` -- shift pitch of selected Notes by N semitones
- `to-rest` -- convert selected Note or Chord nodes to Rest, preserving rhythm
- `set-rhythm` -- set the rhythm of selected nodes to a given rational value
- `sum-rhythm` -- return the sum of selected nodes' rhythms (non-mutating, returns `IRational[]`)
- `add-to-rhythm` -- add a rational value to each selected node's rhythm
- `unwrap-single` -- replace single-note Chords with their bare Note

---

## Context and Prerequisites

### Current state (after plan 23)

The `abct2` module (on the `abct2` branch) has an independent CS tree where nodes carry data payloads instead of wrapping AST references:

- `CSNode` interface with `tag`, `id`, `data: NodeData`, `firstChild`, `nextSibling`
- `NodeData` = `TokenData | GraceGroupData | EmptyData`
- Token leaf nodes carry `{ type: "token", lexeme, tokenType, line, position }`
- All compound nodes (Note, Pitch, Rhythm, Rest, Chord, Beam, etc.) carry `{ type: "empty" }` -- their meaning comes from their tag + children structure
- `fromAst(node: Expr | Token): CSNode` -- builds the CS tree from the parser's AST
- `toAst(node: CSNode): Expr | Token` -- reconstructs a fresh AST from the CS tree
- `Selection` type: `{ root: CSNode, cursors: Cursor[] }` where `Cursor = Set<number>`
- All composable selectors (type, chord-internal, structure)
- Fan-out mechanism with walk strategies
- Test infrastructure with `fast-check` generators (`genAbcTune`, `genAbcWithChords`, `genAbcMultiTune`)
- Test helpers: `toCSTree`, `toSelection`, `collectAll`, `findByTag`, `findById`, `siblingCount`, `roundtrip`, `formatAst`

### Key architectural constraint

Because compound CSNodes carry `EmptyData`, transforms cannot read or write Expr fields like `expr.rhythm` or `expr.pitch`. Instead, the tree structure IS the data: a Note's pitch is its Pitch child, whose own children are Token nodes for accidental, note letter, and octave. A Note's rhythm is its Rhythm child, whose children are Token nodes for numerator, separator, and denominator.

Transforms mutate the tree by:
1. Splicing nodes in/out of sibling chains (remove, unwrap-single)
2. Replacing subtrees with new subtrees computed via the toAst/fromAst bridge (transpose, rhythm operations)
3. Changing a node's `tag` and restructuring its children (to-rest)

### CS tree child ordering by node type

- Note: `[Pitch, Rhythm?, Tie?]`
- Rest: `[REST_TOKEN, Rhythm?]`
- Chord: `[...contents, Rhythm?, Tie?]`
- Pitch: `[Alteration?, NoteLetter, Octave?]`
- Rhythm: `[Numerator?, Separator?, Denominator?, Broken?]`

### ID generation and the ABCContext

Transforms that create new nodes (transpose, toRest, setRhythm, addToRhythm) need unique IDs that do not collide with existing IDs in the tree. Because `ABCContext` starts its internal `IdGenerator` counter from 0, a fresh `new ABCContext()` would produce IDs that collide with the parser-generated IDs already in the CS tree.

The solution: the `ABCContext` used during parsing must be passed through to the transforms. The `Selection` type does not currently carry a context, so the transforms accept `ctx: ABCContext` as a parameter. The caller (the ABCt2 language layer) is responsible for passing the same `ABCContext` instance that was used to parse the source, ensuring the ID counter is already past all existing IDs.

For tests, the `toCSTree` helper already creates an `ABCContext` for parsing. We update the test helpers to also return this context so that transforms can use it.

### Key imports from `parse/`

| Utility | Location | Purpose |
| --- | --- | --- |
| `IRational`, `createRational`, `addRational` | `parse/Visitors/fmt2/rational.ts` | Rational arithmetic for rhythm operations |
| `toMidiPitch` | `parse/Visitors/Formatter2.ts` | Convert Pitch Expr to MIDI value |
| `fromMidiPitch` | `parse/Visitors/Transposer.ts` | Convert MIDI value back to Pitch Expr |
| `ABCContext` | `parse/parsers/Context.ts` | Token ID generation for new nodes |
| `Token`, `TT` (TokenType) | `parse/parsers/scan2.ts` | Token creation for rhythm/rest tokens |
| `Pitch`, `Rhythm`, `Rest` | `parse/types/Expr2.ts` | AST node classes (used in bridge conversions) |

### Key imports from `abct2/`

| Utility | Location | Purpose |
| --- | --- | --- |
| `CSNode`, `TAGS`, `createCSNode`, `isTokenNode`, `getTokenData` | `abct2/src/csTree/types.ts` | CS tree types and helpers |
| `fromAst` | `abct2/src/csTree/fromAst.ts` | Expr to CSNode conversion (bridge) |
| `toAst` | `abct2/src/csTree/toAst.ts` | CSNode to Expr conversion (bridge) |
| `Selection`, `Cursor` | `abct2/src/selection.ts` | Selection type |

---

## The toAst/fromAst Bridge Pattern

Because the existing codebase has well-tested utility functions that operate on Expr instances (e.g., `toMidiPitch`, `fromMidiPitch`, `rhythmToRational`), the transforms use a bridge pattern rather than reimplementing those computations at the CSNode level:

```
// Reading a value from the CS tree:
csNode → toAst(csNode) → Expr → use existing utility

// Writing a computed value back to the CS tree:
computed Expr → fromAst(computedExpr) → CSNode subtree → splice into tree
```

This pattern keeps the transforms simple and avoids duplicating logic that already exists in the parser's visitor layer.

---

## File Structure

```
abct2/
  src/
    transforms/
      types.ts                   -- TransformFn type, findNodesById utility
      treeUtils.ts               -- findChildByTag, replaceChild, removeChild, insertBefore, appendChild, findParent, findRhythmChild, findTieChild, replaceRhythm
      rhythm.ts                  -- rhythmToRational, rationalToRhythm, extractBrokenToken, getNodeRhythm (bridge-based)
      remove.ts                  -- remove operation
      transpose.ts               -- transpose operation
      toRest.ts                  -- to-rest operation
      setRhythm.ts               -- set-rhythm operation
      sumRhythm.ts               -- sum-rhythm operation (non-mutating)
      addToRhythm.ts             -- add-to-rhythm operation
      unwrapSingle.ts            -- unwrap-single operation
      index.ts                   -- re-exports all transforms
  tests/
    treeUtils.spec.ts            -- tree manipulation utility tests
    rhythm.spec.ts               -- rhythm utility tests
    remove.spec.ts               -- remove tests
    transpose.spec.ts            -- transpose tests
    toRest.spec.ts               -- to-rest tests
    setRhythm.spec.ts            -- set-rhythm tests
    sumRhythm.spec.ts            -- sum-rhythm tests
    addToRhythm.spec.ts          -- add-to-rhythm tests
    unwrapSingle.spec.ts         -- unwrap-single tests
```

All new files are created in a single batch before any editing begins.

---

## Phase 1: Transform Infrastructure

### 1.1 Location

`abct2/src/transforms/types.ts`

### 1.2 TransformFn type

```typescript
import { Selection } from "../selection";
import { IRational } from "../../../parse/Visitors/fmt2/rational";

type TransformFn = (selection: Selection, ...args: any[]) => Selection;

// For sum-rhythm which returns data rather than a modified tree:
type InspectionFn = (selection: Selection) => IRational[];
```

### 1.3 The per-cursor iteration pattern

Every mutating transform follows this pattern:

```
transformX(selection, ...args):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      // apply the operation to csNode
  return selection
```

The transform mutates the tree in place and returns the same `Selection` reference. This allows chaining: `transpose(remove(sel, ...), 5)`.

### 1.4 Finding nodes by ID in the CS tree

```typescript
function findNodesById(root: CSNode, ids: Set<number>): CSNode[]
```

This walks the tree depth-first and collects all nodes whose `id` appears in the set.

---

## Phase 2: Tree Manipulation Utilities

### 2.1 Location

`abct2/src/transforms/treeUtils.ts`

### 2.2 Purpose

Because several transforms need to find, replace, remove, or insert children in a node's sibling chain, we extract these operations into reusable utilities. These utilities operate on the `firstChild`/`nextSibling` linked list structure.

### 2.3 Functions

```typescript
// Finds a child of `parent` whose tag matches the given tag.
// Returns the child and its predecessor in the sibling chain (null if the child is firstChild).
function findChildByTag(parent: CSNode, tag: string): { node: CSNode; prev: CSNode | null } | null

// Removes a child from the parent's sibling chain.
// `prev` is the node preceding `child` in the chain (null if child is firstChild).
function removeChild(parent: CSNode, prev: CSNode | null, child: CSNode): void

// Replaces `oldChild` with `newChild` in the parent's sibling chain.
// `prev` is the node preceding `oldChild` (null if oldChild is firstChild).
function replaceChild(parent: CSNode, prev: CSNode | null, oldChild: CSNode, newChild: CSNode): void

// Inserts `newChild` before `beforeNode` in the parent's sibling chain.
// `prev` is the node preceding `beforeNode` (null if beforeNode is firstChild).
function insertBefore(parent: CSNode, prev: CSNode | null, beforeNode: CSNode, newChild: CSNode): void

// Appends `newChild` at the end of the parent's sibling chain.
function appendChild(parent: CSNode, newChild: CSNode): void

// Collects all children of a node into an array.
function collectChildren(node: CSNode): CSNode[]

// Finds the parent of a target node by walking the tree from the root.
// Returns { parent, prev } where prev is the predecessor of target in the parent's child chain
// (null if target is the parent's firstChild). Returns null if the target is the root or not found.
function findParent(root: CSNode, target: CSNode): { parent: CSNode; prev: CSNode | null } | null
```

### 2.4 Rhythm and tie-specific helpers

Because rhythm replacement is needed by multiple transforms (setRhythm, addToRhythm, toRest, unwrapSingle), and tie handling is needed by unwrapSingle, we provide higher-level helpers:

```typescript
// Finds the Rhythm child of a Note, Rest, or Chord CSNode.
// Returns { node, prev } or null if no Rhythm child exists.
function findRhythmChild(parent: CSNode): { node: CSNode; prev: CSNode | null } | null

// Finds the Tie Token child of a Note or Chord CSNode.
// Returns { node, prev } or null if no Tie child exists.
function findTieChild(parent: CSNode): { node: CSNode; prev: CSNode | null } | null

// Replaces the Rhythm child in the parent's sibling chain.
// If newRhythm is null, the existing Rhythm child is removed.
// If no Rhythm child exists and newRhythm is not null, it is inserted
// before the Tie child (if present) or appended at the end.
function replaceRhythm(parent: CSNode, newRhythm: CSNode | null): void
```

### 2.5 Algorithms

```
findChildByTag(parent, tag):
  prev = null
  current = parent.firstChild
  while current != null:
    if current.tag == tag:
      return { node: current, prev }
    prev = current
    current = current.nextSibling
  return null

removeChild(parent, prev, child):
  if prev == null:
    parent.firstChild = child.nextSibling
  else:
    prev.nextSibling = child.nextSibling
  child.nextSibling = null

replaceChild(parent, prev, oldChild, newChild):
  newChild.nextSibling = oldChild.nextSibling
  if prev == null:
    parent.firstChild = newChild
  else:
    prev.nextSibling = newChild
  oldChild.nextSibling = null

insertBefore(parent, prev, beforeNode, newChild):
  newChild.nextSibling = beforeNode
  if prev == null:
    parent.firstChild = newChild
  else:
    prev.nextSibling = newChild

appendChild(parent, newChild):
  newChild.nextSibling = null
  if parent.firstChild == null:
    parent.firstChild = newChild
    return
  current = parent.firstChild
  while current.nextSibling != null:
    current = current.nextSibling
  current.nextSibling = newChild

collectChildren(node):
  result = []
  current = node.firstChild
  while current != null:
    result.push(current)
    current = current.nextSibling
  return result

findParent(node, target):
  prev = null
  current = node.firstChild
  while current != null:
    if current === target:
      return { parent: node, prev }
    // Recurse into children
    result = findParent(current, target)
    if result != null:
      return result
    prev = current
    current = current.nextSibling
  return null

findRhythmChild(parent):
  return findChildByTag(parent, TAGS.Rhythm)

findTieChild(parent):
  prev = null
  current = parent.firstChild
  while current != null:
    if isTokenNode(current) AND getTokenData(current).tokenType == TT.TIE:
      return { node: current, prev }
    prev = current
    current = current.nextSibling
  return null

replaceRhythm(parent, newRhythm):
  existing = findRhythmChild(parent)
  if existing:
    if newRhythm:
      replaceChild(parent, existing.prev, existing.node, newRhythm)
    else:
      removeChild(parent, existing.prev, existing.node)
    return

  // No existing rhythm. If newRhythm is null, nothing to do.
  if newRhythm == null: return

  // Insert before Tie token (if present) or at end.
  // Tie is a Token with tokenType == TT.TIE.
  prev = null
  current = parent.firstChild
  while current != null:
    if isTokenNode(current) AND getTokenData(current).tokenType == TT.TIE:
      insertBefore(parent, prev, current, newRhythm)
      return
    prev = current
    current = current.nextSibling

  // No Tie found: append at end.
  appendChild(parent, newRhythm)
```

### 2.6 Tests (`treeUtils.spec.ts`)

Example-based:
- `findChildByTag` on a Note finds the Rhythm child (if present)
- `findChildByTag` returns null when no matching child exists
- `removeChild` on the first child updates `parent.firstChild`
- `removeChild` on a middle child updates `prev.nextSibling`
- `replaceChild` preserves the rest of the sibling chain
- `appendChild` on an empty parent sets `firstChild`
- `appendChild` on a non-empty parent sets the last sibling's `nextSibling`
- `findParent` returns the parent and prev of a node found in the tree
- `findParent` returns null when the target is the root
- `findParent` returns prev=null when the target is the parent's firstChild
- `findTieChild` on a Note with a tie returns the Tie token and its predecessor
- `findTieChild` on a Note without a tie returns null
- `replaceRhythm` with an existing Rhythm replaces it in place
- `replaceRhythm` with null removes the existing Rhythm
- `replaceRhythm` with no existing Rhythm inserts before Tie
- `replaceRhythm` with no existing Rhythm and no Tie appends at end

---

## Phase 3: Rhythm Utilities

### 3.1 Location

`abct2/src/transforms/rhythm.ts`

### 3.2 Purpose

Bridge-based rhythm conversion functions. These use `toAst`/`fromAst` to convert between the CSNode representation and the Expr-based utilities that already exist in the codebase.

### 3.3 Functions

```typescript
import { IRational, createRational } from "../../../parse/Visitors/fmt2/rational";
import { CSNode, TAGS } from "../csTree/types";
import { toAst } from "../csTree/toAst";
import { fromAst } from "../csTree/fromAst";
import { Rhythm } from "../../../parse/types/Expr2";
import { Token, TT } from "../../../parse/parsers/scan2";
import { ABCContext } from "../../../parse/parsers/Context";

function rhythmToRational(rhythmNode: CSNode): IRational
function rationalToRhythm(rational: IRational, ctx: ABCContext, brokenToken?: CSNode): CSNode | null
function extractBrokenToken(rhythmNode: CSNode): CSNode | null
function getNodeRhythm(parent: CSNode): IRational
```

### 3.4 Broken rhythm preservation

The Rhythm CSNode's child ordering is `[Numerator?, Separator?, Denominator?, Broken?]`. The Broken token (`>`, `<`, `>>`, `<<`) is a rhythmic annotation that modifies the duration relationship between adjacent notes. Because it is context-dependent (it depends on the adjacent note), it cannot be expressed as a rational value. However, transforms must never discard it.

The approach: the rhythm utilities treat the broken token as a pass-through. `rhythmToRational` computes the rational from the numerator/separator/denominator only (ignoring the broken token). `rationalToRhythm` accepts an optional broken token and appends it to the output CSNode. The callers (setRhythm, addToRhythm) extract the broken token from the existing rhythm before replacement and pass it through to the new rhythm.

### 3.5 extractBrokenToken

Finds and returns the Broken token child of a Rhythm CSNode, or null if none exists:

```
extractBrokenToken(rhythmNode):
  current = rhythmNode.firstChild
  while current != null:
    if isTokenNode(current) AND getTokenData(current).tokenType == TT.RHY_BRKN:
      return current
    current = current.nextSibling
  return null
```

### 3.6 rhythmToRational

Converts a Rhythm CSNode to an IRational by using the toAst bridge. The broken token is ignored for the rational computation:

```
rhythmToRational(rhythmNode):
  // Use toAst to reconstruct the Rhythm Expr from the CS tree
  rhythmExpr = toAst(rhythmNode) as Rhythm

  // Apply the same logic as RhythmTransform.rhythmToRational:
  numerator = 1
  denominator = 1

  if rhythmExpr.numerator:
    numerator = parseInt(rhythmExpr.numerator.lexeme)

  if rhythmExpr.separator:
    slashCount = rhythmExpr.separator.lexeme.length
    if rhythmExpr.denominator:
      denominator = parseInt(rhythmExpr.denominator.lexeme)
    else:
      denominator = 2^slashCount

  return createRational(numerator, denominator)
```

### 3.7 rationalToRhythm

Creates a Rhythm CSNode subtree from a rational value, optionally preserving a broken token. Returns null when the rational is 1/1 AND no broken token is provided (meaning "remove the rhythm entirely, use default note length"). If a broken token is provided but the rational is 1/1, the Rhythm CSNode contains only the broken token (because the broken annotation must be preserved even when the base duration is the default).

If the rational has a numerator <= 0, the value is clamped to 1/1 (default note length). This handles edge cases where `addToRhythm` with a large negative delta would produce a nonsensical result.

```
rationalToRhythm(rational, ctx, brokenToken?):
  { numerator, denominator } = rational

  // Clamp non-positive results to default note length
  if numerator <= 0:
    numerator = 1
    denominator = 1

  if numerator == 1 AND denominator == 1 AND brokenToken == null:
    return null  // Caller should remove the Rhythm child entirely

  // Build the Rhythm Expr tokens:
  numToken = null
  sepToken = undefined
  denToken = undefined

  if numerator != 1 OR denominator != 1:
    // We need actual rhythm tokens (not just the broken annotation)
    if denominator == 1:
      numToken = new Token(TT.RHY_NUMER, numerator.toString(), ctx.generateId())
    else:
      if numerator != 1:
        numToken = new Token(TT.RHY_NUMER, numerator.toString(), ctx.generateId())
      sepToken = new Token(TT.RHY_SEP, "/", ctx.generateId())
      if denominator != 2:
        denToken = new Token(TT.RHY_DENOM, denominator.toString(), ctx.generateId())

  // Build the Rhythm Expr (broken token is handled at the CSNode level, not in the Expr)
  rhythmExpr = new Rhythm(ctx.generateId(), numToken, sepToken, denToken)

  // Convert to CSNode subtree
  rhythmCSNode = fromAst(rhythmExpr)

  // Append the broken token at the end of the Rhythm's child chain (if provided)
  if brokenToken:
    brokenToken.nextSibling = null
    appendChild(rhythmCSNode, brokenToken)

  return rhythmCSNode
```

### 3.8 Helper: getNodeRhythm

Because multiple transforms need to read the rhythm of a Note/Rest/Chord as an IRational, we provide a convenience function:

```typescript
function getNodeRhythm(parent: CSNode): IRational
```

```
getNodeRhythm(parent):
  rhythmChild = findRhythmChild(parent)
  if rhythmChild == null:
    return createRational(1, 1)  // Default note length
  return rhythmToRational(rhythmChild.node)
```

### 3.9 Tests (`rhythm.spec.ts`)

Property-based:
- For any Rhythm CSNode without a broken token in a parsed CS tree, `rhythmToRational` followed by `rationalToRhythm` followed by `toAst` followed by format produces the same string as the original Rhythm's format (roundtrip via rationals). Rhythms with broken tokens are excluded because the broken annotation is a pass-through, not part of the rational value.
- For any Rhythm CSNode with a broken token, `rationalToRhythm(rhythmToRational(node), ctx, extractBrokenToken(node))` produces a Rhythm whose formatted output matches the original.
- `getNodeRhythm` on a Note without a Rhythm child returns `{1, 1}`

Example-based:
- Rhythm `2` (numerator only): `rhythmToRational` returns `{2, 1}`
- Rhythm `/` (separator only): returns `{1, 2}`
- Rhythm `3/4`: returns `{3, 4}`
- Rhythm `//` (two slashes): returns `{1, 4}`
- Rhythm `2>` (broken): `rhythmToRational` returns `{2, 1}`, `extractBrokenToken` returns the `>` token
- `rationalToRhythm({3, 4}, ctx)`: produces a CSNode whose toAst formats as `3/4`
- `rationalToRhythm({1, 1}, ctx)`: returns null
- `rationalToRhythm({1, 1}, ctx, brokenToken)`: produces a CSNode containing only the broken token
- `rationalToRhythm({2, 1}, ctx)`: produces a CSNode whose toAst formats as `2`
- `rationalToRhythm({2, 1}, ctx, brokenToken)`: produces `2>` (broken preserved)
- `rationalToRhythm({1, 2}, ctx)`: produces a CSNode whose toAst formats as `/`
- `rationalToRhythm({0, 1}, ctx)`: returns null (clamped to 1/1)
- `rationalToRhythm({-1, 2}, ctx)`: returns null (clamped to 1/1)
- `rationalToRhythm({0, 1}, ctx, brokenToken)`: produces only the broken token (clamped to 1/1, but broken preserved)

---

## Phase 4: remove

### 4.1 Location

`abct2/src/transforms/remove.ts`

### 4.2 Interface

```typescript
function remove(selection: Selection): Selection
```

### 4.3 Algorithm

This transform only manipulates `firstChild`/`nextSibling` pointers. The walk logic is a standalone function that receives `selectedIds` as a parameter (no nested functions):

```
remove(selection):
  for each cursor in selection.cursors:
    if selection.root.firstChild:
      walkAndSplice(selection.root, selection.root.firstChild, cursor)
  return selection

walkAndSplice(parent, startNode, selectedIds):
  prev = null
  current = startNode
  while current != null:
    next = current.nextSibling
    if current.id in selectedIds:
      // Splice this node out
      if prev == null:
        parent.firstChild = next
      else:
        prev.nextSibling = next
      // Do not recurse into removed nodes
    else:
      // Recurse into this node's children
      if current.firstChild:
        walkAndSplice(current, current.firstChild, selectedIds)
      prev = current
    current = next
```

### 4.4 Tests

Property-based:
- Snapshot `collectAll(root).length` before removal. After `remove`, the new count equals `countBefore - sum(subtreeSize(node) for each removed node)`, where subtree sizes are computed before the removal.
- After `remove`, no node in the resulting tree has an ID from the removed set
- Removing zero nodes (empty cursors) returns a tree that roundtrips identically to the input

Example-based:
- Remove the middle note from `C D E`: result formats as `C E`
- Remove a note inside a Chord `[CEG]`: result formats as `[CG]` (E removed)
- Remove all notes from a Beam: result is an empty Beam
- Removing a node that doesn't exist (ID not in tree): tree is unchanged
- Two cursors selecting different notes (`C` in cursor 1, `E` in cursor 2): both are removed, result is `D`

---

## Phase 5: transpose

### 5.1 Location

`abct2/src/transforms/transpose.ts`

### 5.2 Interface

```typescript
function transpose(selection: Selection, semitones: number, ctx: ABCContext): Selection
```

### 5.3 Algorithm

The transform uses the toAst/fromAst bridge to leverage the existing `toMidiPitch` and `fromMidiPitch` utilities:

```
transpose(selection, semitones, ctx):
  if semitones == 0: return selection

  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      if csNode.tag == TAGS.Note:
        transposePitchChild(csNode, semitones, ctx)
      else if csNode.tag == TAGS.Chord:
        // Transpose each Note child within the chord
        current = csNode.firstChild
        while current != null:
          if current.tag == TAGS.Note:
            transposePitchChild(current, semitones, ctx)
          current = current.nextSibling
  return selection

transposePitchChild(noteNode, semitones, ctx):
  // Find the Pitch child of the Note
  pitchResult = findChildByTag(noteNode, TAGS.Pitch)
  if pitchResult == null: return

  pitchCSNode = pitchResult.node

  // Bridge: convert CSNode Pitch to Expr Pitch
  pitchExpr = toAst(pitchCSNode) as Pitch

  // Use existing utilities to compute transposition
  midiPitch = toMidiPitch(pitchExpr)
  newMidi = midiPitch + semitones
  newPitchExpr = fromMidiPitch(newMidi, ctx)

  // Bridge: convert computed Pitch Expr back to CSNode subtree
  newPitchCSNode = fromAst(newPitchExpr)

  // Replace the old Pitch child with the new one
  replaceChild(noteNode, pitchResult.prev, pitchCSNode, newPitchCSNode)
```

### 5.4 Tests

Because `fromMidiPitch` always produces sharps (never flats, double-sharps, double-flats, or naturals), a transpose roundtrip cannot produce identical formatted text for all inputs. For instance, `_E` (Eb) transposed by +1 then -1 gives `^D` (D#, enharmonic equivalent). The property tests must account for this by comparing MIDI values rather than formatted strings.

Property-based:
- `transpose(sel, n, ctx)` followed by `transpose(result, -n, ctx)` produces notes whose MIDI values (via toMidiPitch on the toAst bridge) equal the original MIDI values. We compare MIDI values, not formatted text, because `fromMidiPitch` normalizes all accidentals to sharps.
- `transpose(sel, 0, ctx)` produces formatted output identical to the input (zero transposition is a no-op, no normalization occurs)
- `transpose(sel, 12, ctx)` shifts all selected notes up by exactly one octave (each note's MIDI value increases by 12)

Example-based:
- Transpose `C` by 2 semitones: result is `D`
- Transpose `B` by 1 semitone: result is `c` (crosses octave boundary)
- Transpose a chord `[CEG]` by 7 semitones: result is `[GBd]`
- Transpose with cursor selecting only one note in `C D E`: only that note changes
- Two cursors selecting different notes: both are transposed independently
- Transpose preserves rhythm: `C2` transposed by 2 gives `D2`

---

## Phase 6: to-rest

### 6.1 Location

`abct2/src/transforms/toRest.ts`

### 6.2 Interface

```typescript
function toRest(selection: Selection, ctx: ABCContext): Selection
```

### 6.3 Algorithm

Because a Rest's CS tree structure is `[REST_TOKEN, Rhythm?]`, converting a Note or Chord to a Rest means:
1. Changing the node's tag
2. Rebuilding the child chain with a rest Token and optionally preserving the rhythm
3. Discarding any Tie token (rests cannot be tied in standard ABC notation)

```
toRest(selection, ctx):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      if csNode.tag == TAGS.Note:
        noteToRest(csNode, ctx)
      else if csNode.tag == TAGS.Chord:
        chordToRest(csNode, ctx)
  return selection

noteToRest(csNode, ctx):
  // Preserve rhythm if present (including any broken token within the Rhythm subtree)
  rhythmResult = findRhythmChild(csNode)
  rhythmNode = rhythmResult ? rhythmResult.node : null

  // Create rest Token CSNode
  restToken = createCSNode(TAGS.Token, ctx.generateId(), {
    type: "token", lexeme: "z", tokenType: TT.REST, line: 0, position: 0
  })

  // Rebuild child chain: [REST_TOKEN, Rhythm?]
  csNode.tag = TAGS.Rest
  csNode.firstChild = restToken
  if rhythmNode:
    rhythmNode.nextSibling = null
    restToken.nextSibling = rhythmNode
  else:
    restToken.nextSibling = null

chordToRest(csNode, ctx):
  // Resolve rhythm: chord's own Rhythm child takes precedence.
  // If absent, we use the first Note child's rhythm as a best-effort heuristic.
  // Individual note rhythms inside chords are non-standard in ABC, so taking
  // the first Note's rhythm is an acceptable approximation.
  rhythmNode = null
  rhythmResult = findRhythmChild(csNode)
  if rhythmResult:
    rhythmNode = rhythmResult.node
  else:
    // Look for rhythm in the first Note child
    current = csNode.firstChild
    while current != null:
      if current.tag == TAGS.Note:
        noteRhythm = findRhythmChild(current)
        if noteRhythm:
          rhythmNode = noteRhythm.node
        break
      current = current.nextSibling

  // Create rest Token CSNode
  restToken = createCSNode(TAGS.Token, ctx.generateId(), {
    type: "token", lexeme: "z", tokenType: TT.REST, line: 0, position: 0
  })

  // Rebuild child chain: [REST_TOKEN, Rhythm?]
  csNode.tag = TAGS.Rest
  csNode.firstChild = restToken
  if rhythmNode:
    rhythmNode.nextSibling = null
    restToken.nextSibling = rhythmNode
  else:
    restToken.nextSibling = null
```

### 6.4 Tests

Property-based:
- After `to-rest`, every selected node has tag `TAGS.Rest`
- After `to-rest`, the resulting Rest's rhythm (when present) equals the original Note's or Chord's rhythm (via `getNodeRhythm` comparison before/after)
- After `to-rest`, the resulting tree has no Note/Chord nodes at the selected IDs

Example-based:
- `to-rest` on Note `C2`: result is `z2`
- `to-rest` on Note `C` (no rhythm): result is `z`
- `to-rest` on Note `C-` (note with tie): result is `z` (tie discarded)
- `to-rest` on Note `C2-` (note with rhythm and tie): result is `z2` (rhythm preserved, tie discarded)
- `to-rest` on Note `C2>` (note with broken rhythm): result is `z2>` (broken rhythm preserved within the Rhythm subtree)
- `to-rest` on Chord `[CEG]2`: result is `z2`
- `to-rest` on Chord `[CEG]` where first Note has rhythm `3`: result is `z3`
- `to-rest` on Chord `[CEG]` with no rhythms at all: result is `z`
- `to-rest` on Chord `[CEG]-` (chord with tie): result is `z` (tie discarded)
- Two cursors selecting different notes: both are converted to rests

---

## Phase 7: set-rhythm

### 7.1 Location

`abct2/src/transforms/setRhythm.ts`

### 7.2 Interface

```typescript
function setRhythm(selection: Selection, rational: IRational, ctx: ABCContext): Selection
```

### 7.3 Algorithm

The broken token from the existing rhythm is preserved through the replacement:

```
setRhythm(selection, rational, ctx):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      if csNode.tag == TAGS.Note OR csNode.tag == TAGS.Rest OR csNode.tag == TAGS.Chord:
        // Extract broken token from existing rhythm (if any)
        existingRhythm = findRhythmChild(csNode)
        brokenToken = existingRhythm ? extractBrokenToken(existingRhythm.node) : null
        newRhythm = rationalToRhythm(rational, ctx, brokenToken)
        replaceRhythm(csNode, newRhythm)
  return selection
```

### 7.4 Tests

Property-based:
- After `set-rhythm`, every selected node's rhythm equals the given rational (via `getNodeRhythm` comparison)
- `set-rhythm` with `{1, 1}` on a node without a broken token removes the Rhythm child entirely
- `set-rhythm` preserves the broken token: for any node with a broken rhythm, the broken token appears in the result

Example-based:
- `set-rhythm({3, 4})` on Note `C2`: result is `C3/4`
- `set-rhythm({2, 1})` on Rest `z`: result is `z2`
- `set-rhythm({1, 1})` on Note `C4`: result is `C` (rhythm removed)
- `set-rhythm` on a Chord `[CEG]2`: result is `[CEG]3/4`
- `set-rhythm({3, 4})` on Note `C2>`: result is `C3/4>` (broken token preserved)
- `set-rhythm({1, 1})` on Note `C2>`: result is `C>` (base rhythm removed, broken preserved)
- Two cursors selecting different notes: both get the new rhythm independently

---

## Phase 8: sum-rhythm

### 8.1 Location

`abct2/src/transforms/sumRhythm.ts`

### 8.2 Interface

```typescript
function sumRhythm(selection: Selection): IRational[]
```

This is a non-mutating inspection function. It returns one `IRational` per cursor -- the sum of all selected nodes' rhythms within that cursor.

### 8.3 Algorithm

```
sumRhythm(selection):
  results = []
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    sum = createRational(0, 1)
    for each csNode in nodes:
      if csNode.tag == TAGS.Note OR csNode.tag == TAGS.Rest OR csNode.tag == TAGS.Chord:
        sum = addRational(sum, getNodeRhythm(csNode))
    results.push(sum)
  return results
```

### 8.4 Tests

Property-based:
- `sum-rhythm` on N nodes each with rhythm `{1, 1}` returns `{N, 1}` for that cursor
- `sum-rhythm` does not modify the input (roundtrip before/after is identical)
- `sum-rhythm` returns one entry per cursor

Example-based:
- `C2 D2 E2` with one cursor selecting all 3 notes: result is `[{6, 1}]`
- `C/ D/ E/` (each is 1/2): result is `[{3, 2}]`
- Two cursors, first selecting `C2`, second selecting `D3`: result is `[{2, 1}, {3, 1}]`
- Empty cursor (no matching nodes): result is `[{0, 1}]`

---

## Phase 9: add-to-rhythm

### 9.1 Location

`abct2/src/transforms/addToRhythm.ts`

### 9.2 Interface

```typescript
function addToRhythm(selection: Selection, rational: IRational, ctx: ABCContext): Selection
```

### 9.3 Algorithm

The broken token from the existing rhythm is preserved through the replacement:

```
addToRhythm(selection, rational, ctx):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      if csNode.tag == TAGS.Note OR csNode.tag == TAGS.Rest OR csNode.tag == TAGS.Chord:
        existingRhythm = findRhythmChild(csNode)
        brokenToken = existingRhythm ? extractBrokenToken(existingRhythm.node) : null
        current = getNodeRhythm(csNode)
        newRational = addRational(current, rational)
        newRhythm = rationalToRhythm(newRational, ctx, brokenToken)
        replaceRhythm(csNode, newRhythm)
  return selection
```

Note: if `addRational(current, rational)` produces a result with numerator <= 0, `rationalToRhythm` clamps it to {1, 1} (default note length). This prevents producing invalid ABC notation.

### 9.4 Tests

Property-based:
- `add-to-rhythm({0, 1})` produces formatted output identical to the input (adding zero is identity)
- After `add-to-rhythm(r)`, each selected node's rhythm equals `original + r` (via `getNodeRhythm` comparison), clamped to a minimum of {1, 1}
- `add-to-rhythm({a, b})` followed by `add-to-rhythm({-a, b})` produces the same formatted output as the original (roundtrip identity). The generated `a/b` must be constrained so that `a/b` is less than or equal to the minimum rhythm in the selection, ensuring no intermediate negative values.
- `add-to-rhythm` preserves the broken token: for any node with a broken rhythm, the broken token appears in the result

Example-based:
- `add-to-rhythm({2, 1})` on Note `C2`: result is `C4` (2 + 2 = 4)
- `add-to-rhythm({1, 2})` on Rest `z/`: result is `z` (1/2 + 1/2 = 1, rhythm removed)
- `add-to-rhythm({6, 8})` on Chord `[CEG]2`: result is `[CEG]11/4` (2 + 6/8 = 11/4)
- `add-to-rhythm({2, 1})` on Note `C2>`: result is `C4>` (broken preserved)
- `add-to-rhythm({-3, 1})` on Note `C2`: result is `C` (clamped to {1, 1}, rhythm removed)
- Two cursors: each cursor's nodes get the addition independently

---

## Phase 10: unwrap-single

### 10.1 Location

`abct2/src/transforms/unwrapSingle.ts`

### 10.2 Interface

```typescript
function unwrapSingle(selection: Selection): Selection
```

### 10.3 Purpose

Replaces single-note Chords (chords whose content children contain exactly one Note) with their bare Note. Any non-Note content children (annotations, chord symbols) are promoted to become siblings of the unwrapped Note in the parent container, preserving their order. This is used after operations like `remove(selectAllButTop(...))` which leave chords with a single note.

Rhythm inheritance: if the Chord has a Rhythm child and the Note does not, the Note inherits the Chord's Rhythm. If both have rhythm, the Chord's takes precedence. If neither has rhythm, the Note remains without rhythm.

Tie inheritance: if the Chord has a Tie token child, the unwrapped Note inherits it (appended at the end of the child chain). If the Note already has a tie, the Chord's tie takes precedence.

### 10.4 Algorithm

Because annotations cannot be children of a bare Note in the CS tree, they are promoted to become preceding siblings of the unwrapped Note in the parent's child chain. For example, `["Am"C]` becomes `"Am" C` (the annotation is a sibling before the Note in the parent container). This requires finding the parent of the chord node using `findParent`.

```
unwrapSingle(selection):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      if csNode.tag != TAGS.Chord: continue

      // Collect content children (everything that is not Rhythm and not Tie)
      contentChildren = []
      current = csNode.firstChild
      while current != null:
        isRhythm = current.tag == TAGS.Rhythm
        isTie = isTokenNode(current) AND getTokenData(current).tokenType == TT.TIE
        if NOT isRhythm AND NOT isTie:
          contentChildren.push(current)
        current = current.nextSibling

      // Only unwrap if there is exactly one Note among the content children
      noteChildren = contentChildren.filter(c => c.tag == TAGS.Note)
      if noteChildren.length != 1: continue

      singleNoteChild = noteChildren[0]
      nonNoteChildren = contentChildren.filter(c => c.tag != TAGS.Note)

      // Save chord-level rhythm and tie before restructuring
      chordRhythm = findRhythmChild(csNode)
      chordTie = findTieChild(csNode)

      // Promote non-Note content children (annotations, etc.) as siblings
      // before the chord in the parent's child chain
      if nonNoteChildren.length > 0:
        parentResult = findParent(selection.root, csNode)
        if parentResult:
          // Insert each non-Note child before csNode in the parent's chain.
          // After each insertion, the inserted node becomes the new prev of csNode.
          prev = parentResult.prev
          for each child in nonNoteChildren:
            child.nextSibling = null
            insertBefore(parentResult.parent, prev, csNode, child)
            prev = child  // the inserted child is now prev of csNode

      // Change tag to Note
      csNode.tag = TAGS.Note

      // Promote the Note child's children as this node's children
      csNode.firstChild = singleNoteChild.firstChild

      // Handle rhythm inheritance: chord's rhythm takes precedence
      if chordRhythm:
        replaceRhythm(csNode, chordRhythm.node)

      // Handle tie inheritance: chord's tie is appended at the end
      if chordTie:
        // Remove any existing tie from the promoted children (chord's takes precedence)
        existingTie = findTieChild(csNode)
        if existingTie:
          removeChild(csNode, existingTie.prev, existingTie.node)
        chordTie.node.nextSibling = null
        appendChild(csNode, chordTie.node)

  return selection
```

The `findTieChild` and `findParent` functions used above are defined in `treeUtils.ts` (section 2.4 and 2.3).

### 10.5 Tests

Property-based:
- `unwrap-single` on a single-note chord produces a Note (not a Chord) at that position
- After `unwrap-single`, the resulting Note's rhythm matches the chord's rhythm (if the chord had one)
- Chords with more than one Note are left unchanged by `unwrap-single`
- `unwrap-single` preserves the total number of Annotation nodes in the tree (they are promoted, not discarded)

Example-based:
- `[C]2` (single-note chord with rhythm 2): result is `C2`
- `[C2]` (single-note chord, note has rhythm 2, chord has no rhythm): result is `C2`
- `[C]` (single-note chord, no rhythm anywhere): result is `C`
- `[C2]4` (chord has rhythm 4, note has rhythm 2): result is `C4` (chord rhythm takes precedence)
- `[C]-` (single-note chord with tie): result is `C-` (tie preserved)
- `[C-]` (single-note chord, note has tie, chord does not): result is `C-` (note tie kept)
- `[C-]2-` (chord has rhythm 2 and tie, note has tie): result is `C2-` (chord rhythm and chord tie take precedence)
- `["Am"C]` (single-note chord with annotation): result is `"Am"C` (annotation promoted to preceding sibling)
- `["Am""Dm"C]2` (chord with two annotations, rhythm): result is `"Am""Dm"C2` (both annotations promoted, rhythm inherited)
- `[CEG]2` (multi-note chord): result is unchanged `[CEG]2`
- Two cursors selecting different single-note chords: both are unwrapped

---

## Test Infrastructure

### Existing generators (from `abct2/tests/helpers.ts`)

- `genAbcTune`: generates a single-tune ABC string with random notes, rests, chords
- `genAbcWithChords`: generates ABC with at least some chords
- `genAbcMultiTune`: generates multi-tune ABC strings

### New helpers needed

We add the following to `abct2/tests/helpers.ts`:

```typescript
// Updated toCSTree that also returns the ABCContext (for passing to transforms)
function toCSTreeWithContext(source: string): { root: CSNode; ctx: ABCContext } {
  const ctx = new ABCContext();
  const tokens = Scanner(source, ctx);
  const ast = parse(tokens, ctx);
  return { root: fromAst(ast), ctx };
}

// Format a Selection's tree to an ABC string via the toAst bridge.
// Note: toAst can return Token for a leaf root, but stringify handles both Expr and Token.
function formatSelection(sel: Selection): string {
  const ast = toAst(sel.root);
  return new AbcFormatter(new ABCContext()).stringify(ast);
}

// Generate an IRational within reasonable bounds
const genRational: fc.Arbitrary<IRational>  // numerator in [1,16], denominator in [1,16]

// Generate a transpose distance
const genSemitones: fc.Arbitrary<number>  // range [-24, 24]
```

### Test configuration

All property-based tests use `fast-check` with at least `numRuns: 1000`. Example-based tests use standard Mocha/Chai assertions.

Tests for transforms that accept `ctx: ABCContext` should use `toCSTreeWithContext` so that the returned context's ID counter is already past all existing tree IDs.

---

## Implementation Checklist

1. Create all new directories and empty files in a single batch: `abct2/src/transforms/types.ts`, `abct2/src/transforms/treeUtils.ts`, `abct2/src/transforms/rhythm.ts`, `abct2/src/transforms/remove.ts`, `abct2/src/transforms/transpose.ts`, `abct2/src/transforms/toRest.ts`, `abct2/src/transforms/setRhythm.ts`, `abct2/src/transforms/sumRhythm.ts`, `abct2/src/transforms/addToRhythm.ts`, `abct2/src/transforms/unwrapSingle.ts`, `abct2/src/transforms/index.ts`, `abct2/tests/treeUtils.spec.ts`, `abct2/tests/rhythm.spec.ts`, `abct2/tests/remove.spec.ts`, `abct2/tests/transpose.spec.ts`, `abct2/tests/toRest.spec.ts`, `abct2/tests/setRhythm.spec.ts`, `abct2/tests/sumRhythm.spec.ts`, `abct2/tests/addToRhythm.spec.ts`, `abct2/tests/unwrapSingle.spec.ts`
2. Implement transform infrastructure (`types.ts`: TransformFn, findNodesById). No separate tests needed.
3. Implement tree manipulation utilities (`treeUtils.ts`) with tests. Run tests: `npm run test -w abct2`
4. Implement rhythm utilities (`rhythm.ts`: rhythmToRational, rationalToRhythm, getNodeRhythm) with tests. Run tests.
5. Implement `remove` with tests. Run tests.
6. Implement `transpose` with tests. Run tests.
7. Implement `toRest` with tests. Run tests.
8. Implement `setRhythm` with tests. Run tests.
9. Implement `sumRhythm` with tests. Run tests.
10. Implement `addToRhythm` with tests. Run tests.
11. Implement `unwrapSingle` with tests. Run tests.
12. Add `index.ts` re-exports for all transforms.
13. Run full test suite from root: `npm run test`
14. Run build: `npm run build`
15. Call the code review agent on all new files. Address any feedback.
16. Commit once build passes and all tests pass.

Copy the plan file into the plans directory, and once you are done with the implementation of each of the phases of the plan, make sure to call the code review agent on the current phase and address any feedback that the code review agent might have. After you are done with the feedback and all the tests are passing, commit the changes and then move onto the next phase. Do this until finished.

---

## Critical Files

- `abct2/src/csTree/types.ts` -- CSNode interface, TAGS, predicate functions, createCSNode, isTokenNode, getTokenData
- `abct2/src/csTree/fromAst.ts` -- AST to CS tree conversion (used by bridge pattern)
- `abct2/src/csTree/toAst.ts` -- CS tree to AST reconstruction (used by bridge pattern)
- `abct2/src/selection.ts` -- Selection type, Cursor type, createSelection
- `abct2/src/selectors/fanOut.ts` -- fan-out mechanism (uses firstChild/nextSibling traversal)
- `abct2/tests/helpers.ts` -- test helpers and fast-check generators
- `parse/types/Expr2.ts` -- AST node classes (Pitch:409, Note:455, Rest:442, Chord:522, Rhythm:479)
- `parse/parsers/scan2.ts` -- Token class, TT (TokenType) enum
- `parse/parsers/Context.ts` -- ABCContext (generateId for new tokens)
- `parse/Visitors/fmt2/rational.ts` -- IRational, createRational, addRational
- `parse/Visitors/Formatter2.ts` -- AbcFormatter.stringify(), toMidiPitch
- `parse/Visitors/Transposer.ts:339` -- fromMidiPitch
