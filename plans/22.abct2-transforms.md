# ABCt2 Transforms

## Table of Contents

1. [Goal](#goal)
2. [Context and Prerequisites](#context-and-prerequisites)
3. [File Structure](#file-structure)
4. [Phase 1: toAst (CS tree to AST back-conversion)](#phase-1-toast-cs-tree-to-ast-back-conversion)
5. [Phase 2: Transform Infrastructure](#phase-2-transform-infrastructure)
6. [Phase 3: remove](#phase-3-remove)
7. [Phase 4: transpose](#phase-4-transpose)
8. [Phase 5: to-rest](#phase-5-to-rest)
9. [Phase 6: Rhythm Utilities](#phase-6-rhythm-utilities)
10. [Phase 7: set-rhythm](#phase-7-set-rhythm)
11. [Phase 8: sum-rhythm](#phase-8-sum-rhythm)
12. [Phase 9: add-to-rhythm](#phase-9-add-to-rhythm)
13. [Phase 10: unwrap-single](#phase-10-unwrap-single)
14. [Test Infrastructure](#test-infrastructure)
15. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are implementing the 7 generic operations from the ABCt2 language design (plan 18). These operations take a `Selection` (a CS tree root + cursors), mutate the tree in place, and return the same `Selection` for chaining. The plan also covers the infrastructure prerequisite that the transforms depend on: `toAst` (converting the CS tree back to the parser's AST format).

Transforms are pure mutating operations. Cloning is the pipeline's responsibility (in the ABCt language layer), not the transforms'. Each transform iterates over each cursor independently (Kakoune-style: cursors are processed separately, not merged).

The transforms are:
- `remove` — splice selected nodes out of the sibling chain
- `transpose` — shift pitch of selected Notes by N semitones
- `to-rest` — convert selected Note or Chord nodes to Rest, preserving rhythm
- `set-rhythm` — set the rhythm of selected nodes to a given rational value
- `sum-rhythm` — return the sum of selected nodes' rhythms (non-mutating, returns `IRational[]`)
- `add-to-rhythm` — add a rational value to each selected node's rhythm
- `unwrap-single` — replace single-note Chords with their bare Note

---

## Context and Prerequisites

### Current state

The `abct2` module (on the `abct2` branch) already has:
- `CSNode` type with `tag`, `id`, `node` (the wrapped Expr/Token), `firstChild`, `nextSibling`
- `fromAst(node: Expr | Token): CSNode` — builds the CS tree from the parser's AST
- `Selection` type: `{ root: CSNode, cursors: Cursor[] }` where `Cursor = Set<number>`
- All composable selectors (type, chord-internal, structure)
- Fan-out mechanism with walk strategies
- Test infrastructure with `fast-check` generators (`genAbcTune`, `genAbcWithChords`, `genAbcMultiTune`)
- Test helpers: `toCSTree`, `toSelection`, `collectAll`, `findByTag`, `findById`, `siblingCount`

### What is missing

- `toAst`: converting the CS tree back to the parser's AST format (rebuilding container arrays from sibling chains)
- All 7 transforms listed above

### Per-cursor processing semantics

Each cursor in `Selection.cursors` is processed independently (Kakoune-style). For each transform, we iterate over the cursors array and, for each cursor, locate the CS nodes whose IDs are in that cursor's set, then apply the operation to those nodes.

Because cursors do not overlap (each cursor identifies a distinct set of node IDs), the per-cursor iteration is equivalent to processing them in any order. The iteration pattern is:

```
for each cursor in selection.cursors:
  nodes = findNodesById(selection.root, cursor)
  // apply operation to nodes
return selection
```

For `sum-rhythm` (non-mutating), we compute one `IRational` per cursor: the sum of all rhythms of nodes whose IDs appear in that cursor.

### Key imports from `parse/`

| Utility                                            | Location                          | Purpose                                         |
| -------------------------------------------------- | --------------------------------- | ----------------------------------------------- |
| `IRational`, `createRational`, `addRational`       | `parse/Visitors/fmt2/rational.ts` | Rational arithmetic for rhythm operations       |
| `toMidiPitch`                                      | `parse/Visitors/Formatter2.ts`    | Convert Pitch to MIDI value                     |
| `fromMidiPitch`                                    | `parse/Visitors/Transposer.ts`    | Convert MIDI value back to Pitch                |
| `ABCContext`                                       | `parse/parsers/Context.ts`        | Token ID generation for new Rhythm/Pitch tokens |
| `Token`, `TT` (TokenType)                          | `parse/parsers/scan2.ts`          | Token creation for Rest, Rhythm                 |
| `Note`, `Rest`, `Chord`, `Pitch`, `Rhythm`, `Expr` | `parse/types/Expr2.ts`            | AST node classes                                |
| `isNote`, `isChord`, `isPitch`                     | `parse/helpers.ts`                | Type guard predicates                           |
| `AbcFormatter`                                     | `parse/Visitors/Formatter2.ts`    | Stringify AST to ABC text (for test assertions) |

---

## File Structure

```
abct2/
  src/
    csTree/
      toAst.ts                   -- CS tree -> AST back-conversion
    transforms/
      types.ts                   -- TransformFn type, findNodesById utility
      remove.ts                  -- remove operation
      transpose.ts               -- transpose operation
      toRest.ts                  -- to-rest operation
      rhythm.ts                  -- rhythmToRational, rationalToRhythm standalone functions
      setRhythm.ts               -- set-rhythm operation
      sumRhythm.ts               -- sum-rhythm operation (non-mutating)
      addToRhythm.ts             -- add-to-rhythm operation
      unwrapSingle.ts            -- unwrap-single operation
      index.ts                   -- re-exports all transforms
  tests/
    toAst.spec.ts                -- toAst tests
    remove.spec.ts               -- remove tests
    transpose.spec.ts            -- transpose tests
    toRest.spec.ts               -- to-rest tests
    rhythm.spec.ts               -- rhythm utility tests
    setRhythm.spec.ts            -- set-rhythm tests
    sumRhythm.spec.ts            -- sum-rhythm tests
    addToRhythm.spec.ts          -- add-to-rhythm tests
    unwrapSingle.spec.ts         -- unwrap-single tests
```

All new files are created in a single batch before any editing begins.

---

## Phase 1: toAst (CS tree to AST back-conversion)

### 1.1 Purpose

After a transform operates on the CS tree (splicing sibling chains, removing nodes), we need to rebuild the original AST's container arrays from the remaining sibling chains. Because transforms also mutate the wrapped Expr instances directly (pitch, rhythm changes), the back-conversion only needs to rebuild structural containers — the Expr instances themselves are already up to date.

### 1.2 Location

`abct2/src/csTree/toAst.ts`

### 1.3 Interface

```typescript
function toAst(root: CSNode): File_structure
```

Because `root.node` is the original `File_structure` reference, the function mutates the wrapped Expr instances' container arrays in place (reassigning `.contents`, `.sequence`, `.notes`, etc.) and returns the root's `.node` cast to `File_structure`.

### 1.4 Algorithm

The function walks the CS tree depth-first. For each CSNode, it collects the sibling chain starting from `firstChild` into an array, then assigns that array to the appropriate property on the wrapped Expr.

```
toAst(root):
  walk(csNode):
    children = collectSiblingChain(csNode.firstChild)
    for each child in children:
      walk(child)   // recurse depth-first
    rebuildContainer(csNode, children)
  walk(root)
  return root.node as File_structure

collectSiblingChain(start):
  result = []
  current = start
  while current != null:
    result.push(current)
    current = current.nextSibling
  return result

rebuildContainer(csNode, children):
  expr = csNode.node
  childExprs = children.map(c => c.node)
  switch csNode.tag:
    case TAGS.Chord:
      // fromAst appends Rhythm and Tie CSNodes after the contents.
      // We only rebuild .contents (the container array) because .rhythm and .tie
      // are individual fields that transforms modify directly — rebuilding them
      // from children would clobber those mutations.
      // Rhythm is identified by tag (TAGS.Rhythm). Tie is a Token, identified
      // by reference identity with the chord's existing .tie field.
      chord = expr as Chord
      contentsChildren = children.filter(c =>
        c.tag != TAGS.Rhythm && c.node !== chord.tie
      )
      chord.contents = contentsChildren.map(c => c.node)
    // Note and Rest are leaf nodes — their properties (pitch, rhythm, tie)
    // are individual fields modified directly by transforms. We do not rebuild
    // them from CS tree children, because that would clobber direct mutations
    // made by setRhythm, addToRhythm, transpose, etc.
    case TAGS.Beam:
      (expr as Beam).contents = childExprs
    case TAGS.Grace_group:
      (expr as Grace_group).notes = childExprs
    case TAGS.Music_code:
      (expr as Music_code).contents = childExprs
    case TAGS.Tune_Body:
      // Because the CS tree flattened the 2D sequence array,
      // we must re-segment by EOL tokens:
      (expr as Tune_Body).sequence = resegmentSystems(childExprs)
    case TAGS.File_structure:
      (expr as File_structure).contents = childExprs
    case TAGS.Tune:
      // fromAst creates exactly 2 children: [Tune_header, Tune_Body].
      // Each has already been rebuilt by the recursive walk.
      (expr as Tune).tune_header = children[0].node as Tune_header
      if children.length > 1:
        (expr as Tune).tune_body = children[1].node as Tune_Body
      else:
        (expr as Tune).tune_body = undefined
    case TAGS.Tune_header:
      (expr as Tune_header).info_lines = childExprs
    case TAGS.File_header:
      (expr as File_header).contents = childExprs
    // Leaf nodes and tokens: no container to rebuild
```

### 1.5 The system segmentation problem

The `Tune_Body.sequence` field is `Array<Array<Expr | Token>>`. Each inner array is a "system" (a line of music). In `fromAst`, these inner arrays were flattened into a single sibling chain. During back-conversion, we need to re-segment them.

We use EOL tokens as delimiters. The parser always produces one system per physical line, and each system includes the terminating EOL token. The EOL belongs to the system it terminates (matching the parser's behavior in `parseNoVoices` which pushes the EOL into `curSystem` before closing it). EOF tokens may also appear in the stream but are treated as regular elements (they don't trigger a system break because the final `if current.length > 0` clause handles any trailing content without a terminating EOL).

```
resegmentSystems(flatChildren):
  systems = []
  current = []
  for each child in flatChildren:
    current.push(child)
    if child is Token AND child.type == TT.EOL:
      systems.push(current)
      current = []
  if current.length > 0:
    systems.push(current)
  return systems
```

### 1.6 Tests

Property-based (using `genAbcTune` and `genAbcWithChords`):
- `fromAst(parse(source))` followed by `toAst` produces an AST that formats identically to the original source
- The roundtrip preserves node count: `collectAll(fromAst(ast)).length` equals the number of Expr/Token nodes in the original AST
- After removing a sibling from the CS tree and calling `toAst`, the resulting AST's container array is shorter by 1

Example-based:
- A Beam with 4 notes: `fromAst -> toAst` produces `Beam.contents.length === 4`
- A Chord with 3 notes: `fromAst -> toAst` produces `Chord.contents.length === 3`
- A tune body with 2 systems: `fromAst -> toAst` produces `sequence.length === 2`
- Splicing a sibling out of a Beam: `toAst` produces `Beam.contents.length === 3` (was 4)

---

## Phase 2: Transform Infrastructure

### 2.1 Location

`abct2/src/transforms/types.ts`

### 2.2 TransformFn type

```typescript
import { Selection } from "../selection";
import { IRational } from "../../../parse/Visitors/fmt2/rational";

type TransformFn = (selection: Selection, ...args: any[]) => Selection;

// For sum-rhythm which returns data rather than a modified tree:
type InspectionFn = (selection: Selection) => IRational[];
```

### 2.3 The per-cursor iteration pattern

Every mutating transform follows this pattern:

```
transformX(selection, ...args):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      // apply the operation to csNode
  return selection
```

The transform mutates the tree in place and returns the same `Selection` reference. This allows chaining: `transpose(remove(sel, ...), 5)`.

### 2.4 Finding nodes by ID in the CS tree

Many operations need to locate specific CSNodes by their ID. We provide a utility:

```typescript
function findNodesById(root: CSNode, ids: Set<number>): CSNode[]
```

This walks the tree depth-first and collects all nodes whose `id` appears in the set.

---

## Phase 3: remove

### 3.1 Location

`abct2/src/transforms/remove.ts`

### 3.2 Interface

```typescript
function remove(selection: Selection): Selection
```

### 3.3 Algorithm

```
remove(selection):
  for each cursor in selection.cursors:
    spliceSelected(selection.root, cursor)
  return selection

spliceSelected(root, selectedIds):
  // We need to handle two cases:
  // (a) the node is the firstChild of its parent -> parent.firstChild = node.nextSibling
  // (b) the node is a nextSibling of another node -> prev.nextSibling = node.nextSibling

  walkAndSplice(parent, node):
    // Process the sibling chain starting at node
    prev = null
    current = node
    while current != null:
      next = current.nextSibling
      if current.id in selectedIds:
        // Splice this node out
        if prev == null:
          parent.firstChild = next
        else:
          prev.nextSibling = next
        // Do not recurse into removed nodes
      else:
        // Recurse into this node's children
        if current.firstChild:
          walkAndSplice(current, current.firstChild)
        prev = current
      current = next

  if root.firstChild:
    walkAndSplice(root, root.firstChild)
```

### 3.4 Tests

Property-based:
- After `remove`, the total node count in the tree decreases by the number of removed nodes (using `collectAll`)
- After `remove`, no node in the resulting tree has an ID from the removed set
- Removing zero nodes (empty cursors) returns a tree that formats identically to the input

Example-based:
- Remove the middle note from `C D E`: result formats as `C E`
- Remove a note inside a Chord `[CEG]`: result formats as `[CG]` (E removed)
- Remove all notes from a Beam: result is an empty Beam (or Beam removed if implementation removes empty containers)
- Removing a node that doesn't exist (ID not in tree): tree is unchanged
- Two cursors selecting different notes (`C` in cursor 1, `E` in cursor 2): both are removed, result is `D`

---

## Phase 4: transpose

### 4.1 Location

`abct2/src/transforms/transpose.ts`

### 4.2 Interface

```typescript
function transpose(selection: Selection, semitones: number): Selection
```

### 4.3 Algorithm

```
transpose(selection, semitones):
  if semitones == 0: return selection  // No-op

  ctx = new ABCContext()
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      expr = csNode.node
      if isNote(expr):
        transposePitch(expr, semitones, ctx)
      if isChord(expr):
        for each child in collectSiblingChain(csNode.firstChild):
          if isNote(child.node):
            transposePitch(child.node, semitones, ctx)
  return selection

transposePitch(note, semitones, ctx):
  pitch = note.pitch
  midiPitch = toMidiPitch(pitch)
  newMidi = midiPitch + semitones
  note.pitch = fromMidiPitch(newMidi, ctx)
```

We reuse `toMidiPitch` from `parse/Visitors/Formatter2.ts` and `fromMidiPitch` from `parse/Visitors/Transposer.ts`.

### 4.4 Tests

Property-based:
- `transpose(sel, n)` followed by `transpose(result, -n)` produces the same formatter output as the original (roundtrip identity)
- `transpose(sel, 12)` shifts all selected note letters to the same letter class (C stays C, D stays D, etc.) one octave higher
- `transpose(sel, 0)` produces formatter output identical to the input

Example-based:
- Transpose `C` by 2 semitones: result is `D`
- Transpose `B` by 1 semitone: result is `c` (crosses octave boundary from uppercase to lowercase in ABC notation)
- Transpose a chord `[CEG]` by 7 semitones: result is `[GBd]`
- Transpose with cursor selecting only one note in `C D E`: only that note changes
- Two cursors selecting different notes: both are transposed independently

---

## Phase 5: to-rest

### 5.1 Location

`abct2/src/transforms/toRest.ts`

### 5.2 Interface

```typescript
function toRest(selection: Selection): Selection
```

### 5.3 Algorithm

Converting a Note or Chord to a Rest means replacing the CSNode's wrapped Expr with a new `Rest` instance. Because the CSNode is a mutable wrapper, we replace `csNode.node` and update `csNode.tag`.

Rhythm rules:
- If the node is a Note with a rhythm: the Rest inherits that rhythm.
- If the node is a Note without a rhythm: the Rest has no rhythm (inherits the default note length from context).
- If the node is a Chord with a rhythm: the Rest inherits the chord's rhythm.
- If the node is a Chord without a rhythm but whose first Note has a rhythm: the Rest inherits that first Note's rhythm.
- If the node is a Chord without rhythm and no notes have rhythm: the Rest has no rhythm.

When replacing a Chord, we also remove its children from the sibling chain (because a Rest has no children).

```
toRest(selection):
  ctx = new ABCContext()
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      expr = csNode.node
      if isNote(expr):
        rhythm = expr.rhythm
        restToken = new Token(TT.REST, "z", ctx.generateId())
        csNode.node = new Rest(csNode.id, restToken, rhythm)
        csNode.tag = TAGS.Rest
        csNode.firstChild = null  // Rest has no children
      else if isChord(expr):
        rhythm = resolveChordRhythm(expr)
        restToken = new Token(TT.REST, "z", ctx.generateId())
        csNode.node = new Rest(csNode.id, restToken, rhythm)
        csNode.tag = TAGS.Rest
        csNode.firstChild = null  // Remove all chord children
  return selection

resolveChordRhythm(chord):
  if chord.rhythm: return chord.rhythm
  notes = chord.contents.filter(isNote)
  if notes.length > 0 AND notes[0].rhythm:
    return notes[0].rhythm
  return undefined
```

### 5.4 Tests

Property-based:
- After `to-rest`, every selected node has tag `TAGS.Rest`
- After `to-rest`, the resulting Rest's rhythm (when present) equals the original Note's or Chord's rhythm (via `rhythmToRational` comparison)
- After `to-rest`, the resulting tree has no more Note/Chord nodes at the selected IDs

Example-based:
- `to-rest` on Note `C2`: result is `z2`
- `to-rest` on Note `C` (no rhythm): result is `z`
- `to-rest` on Chord `[CEG]2`: result is `z2`
- `to-rest` on Chord `[CEG]` where first Note has rhythm `3`: result is `z3`
- `to-rest` on Chord `[CEG]` with no rhythms at all: result is `z`
- Two cursors selecting different notes: both are converted to rests

---

## Phase 6: Rhythm Utilities

### 6.1 Location

`abct2/src/transforms/rhythm.ts`

### 6.2 Purpose

Standalone rhythm-conversion functions adapted from `parse/Visitors/RhythmTransform.ts:458-532`. These are extracted as module-level functions (not class methods) because the transforms need to call them without instantiating the RhythmTransform visitor.

### 6.3 Functions

```typescript
function rhythmToRational(rhythm: Rhythm | undefined): IRational
function rationalToRhythm(rational: IRational, ctx: ABCContext): Rhythm | undefined
```

### 6.4 rhythmToRational

```
rhythmToRational(rhythm):
  if rhythm is undefined: return createRational(1, 1)  // default unit length

  numerator = 1
  denominator = 1

  if rhythm.numerator:
    numerator = parseInt(rhythm.numerator.lexeme)

  if rhythm.separator:
    slashCount = rhythm.separator.lexeme.length
    if rhythm.denominator:
      denominator = parseInt(rhythm.denominator.lexeme)
    else:
      denominator = 2^slashCount

  return createRational(numerator, denominator)
```

### 6.5 rationalToRhythm

Creates a new `Rhythm` instance from rational values. Uses `ABCContext.generateId()` for token IDs.

```
rationalToRhythm(rational, ctx):
  { numerator, denominator } = rational

  if numerator == 1 AND denominator == 1:
    // Unit length: rhythm should be removed entirely from the node.
    return undefined

  id = ctx.generateId()
  numToken = null
  sepToken = undefined
  denToken = undefined

  if denominator == 1:
    // Whole number: just the numerator token
    numToken = new Token(TT.RHY_NUMER, numerator.toString(), ctx.generateId())
    return new Rhythm(id, numToken)

  // Fraction
  if numerator != 1:
    numToken = new Token(TT.RHY_NUMER, numerator.toString(), ctx.generateId())

  sepToken = new Token(TT.RHY_SEP, "/", ctx.generateId())

  // For power-of-2 denominators, ABC allows omitting the denominator when it is 2
  // (a single "/" means /2). For all others, we spell out the denominator.
  if denominator != 2:
    denToken = new Token(TT.RHY_NUMER, denominator.toString(), ctx.generateId())

  return new Rhythm(id, numToken, sepToken, denToken)
```

### 6.6 Tests

Property-based:
- For any Rhythm node in a parsed AST, `rationalToRhythm(rhythmToRational(rhythm), ctx)` produces a Rhythm whose rational equals the original (roundtrip via rationals)
- `rhythmToRational(undefined)` always returns `{1, 1}`

Example-based:
- Rhythm `2` (numerator only): rational is `{2, 1}`
- Rhythm `/` (separator only): rational is `{1, 2}`
- Rhythm `3/4`: rational is `{3, 4}`
- Rhythm `//` (two slashes): rational is `{1, 4}`
- `rationalToRhythm({3, 4}, ctx)`: produces tokens `"3"`, `"/"`, `"4"`
- `rationalToRhythm({1, 1}, ctx)`: returns `undefined` (rhythm removed)
- `rationalToRhythm({2, 1}, ctx)`: produces only numerator token `"2"`
- `rationalToRhythm({1, 2}, ctx)`: produces only separator token `"/"`

---

## Phase 7: set-rhythm

### 7.1 Location

`abct2/src/transforms/setRhythm.ts`

### 7.2 Interface

```typescript
function setRhythm(selection: Selection, rational: IRational): Selection
```

### 7.3 Algorithm

```
setRhythm(selection, rational):
  ctx = new ABCContext()
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      expr = csNode.node
      newRhythm = rationalToRhythm(rational, ctx)
      if isNote(expr):
        expr.rhythm = newRhythm
      else if isRest(expr):
        expr.rhythm = newRhythm
      else if isChord(expr):
        expr.rhythm = newRhythm
  return selection
```

### 7.4 Tests

Property-based:
- After `set-rhythm`, every selected node's rhythm is equal to the given rational (via `rhythmToRational` comparison)
- `set-rhythm` with `{1, 1}` followed by `rhythmToRational` returns `{1, 1}` for all selected nodes

Example-based:
- `set-rhythm({3, 4})` on Note `C2`: result is `C3/4`
- `set-rhythm({2, 1})` on Rest `z`: result is `z2`
- `set-rhythm({1, 1})` on Note `C4`: result is `C` (rhythm removed entirely, `expr.rhythm = undefined`)
- `set-rhythm` on a Chord `[CEG]2`: result is `[CEG]3/4` (chord-level rhythm replaced)
- Two cursors selecting different notes: both get the new rhythm independently

---

## Phase 8: sum-rhythm

### 8.1 Location

`abct2/src/transforms/sumRhythm.ts`

### 8.2 Interface

```typescript
function sumRhythm(selection: Selection): IRational[]
```

This is a non-mutating inspection function. It returns one `IRational` per cursor — the sum of all selected nodes' rhythms within that cursor.

### 8.3 Algorithm

```
sumRhythm(selection):
  results = []
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    sum = createRational(0, 1)
    for each csNode in nodes:
      expr = csNode.node
      rhythm = extractRhythm(expr)
      sum = addRational(sum, rhythmToRational(rhythm))
    results.push(sum)
  return results

extractRhythm(expr):
  if isNote(expr): return expr.rhythm
  if isRest(expr): return expr.rhythm
  if isChord(expr): return resolveChordRhythm(expr)
  return undefined  // nodes without rhythm contribute 1/1 (the default)
```

### 8.4 Tests

Property-based:
- `sum-rhythm` on N nodes each with rhythm `{1, 1}` returns `{N, 1}` for that cursor
- `sum-rhythm` does not modify the input (format before/after is identical)
- `sum-rhythm` returns one entry per cursor

Example-based:
- `C2 D2 E2` with one cursor selecting all 3 notes: result is `[{6, 1}]`
- `C/ D/ E/` (each is 1/2): result is `[{3, 2}]`
- Two cursors, first selecting `C2`, second selecting `D3`: result is `[{2, 1}, {3, 1}]`
- Empty cursor (no matching nodes): result is `[{0, 1}]`

---

## Phase 9: add-to-rhythm

### 9.1 Location

`abct2/src/transforms/addToRhythm.ts`

### 9.2 Interface

```typescript
function addToRhythm(selection: Selection, rational: IRational): Selection
```

### 9.3 Algorithm

```
addToRhythm(selection, rational):
  ctx = new ABCContext()
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      expr = csNode.node
      if isNote(expr):
        current = rhythmToRational(expr.rhythm)
        expr.rhythm = rationalToRhythm(addRational(current, rational), ctx)
      else if isRest(expr):
        current = rhythmToRational(expr.rhythm)
        expr.rhythm = rationalToRhythm(addRational(current, rational), ctx)
      else if isChord(expr):
        current = rhythmToRational(expr.rhythm)
        expr.rhythm = rationalToRhythm(addRational(current, rational), ctx)
  return selection
```

### 9.4 Tests

Property-based:
- `add-to-rhythm({0, 1})` produces formatter output identical to the input (adding zero is identity)
- After `add-to-rhythm(r)`, each selected node's rhythm equals `original + r` (via rational comparison)
- `add-to-rhythm({a, b})` followed by `add-to-rhythm({-a, b})` produces the same formatter output as the original (roundtrip identity)

Example-based:
- `add-to-rhythm({2, 1})` on Note `C2`: result is `C4` (2 + 2 = 4)
- `add-to-rhythm({1, 2})` on Rest `z/`: result is `z` (1/2 + 1/2 = 1)
- `add-to-rhythm({6, 8})` on Chord `[CEG]2`: result is `[CEG]11/4` (2/1 + 6/8 = 16/8 + 6/8 = 22/8 = 11/4)
- Two cursors: each cursor's nodes get the addition independently

---

## Phase 10: unwrap-single

### 10.1 Location

`abct2/src/transforms/unwrapSingle.ts`

### 10.2 Interface

```typescript
function unwrapSingle(selection: Selection): Selection
```

### 10.3 Purpose

Replaces single-note Chords (chords whose `contents` array has exactly one Note) with their bare Note. This is used after operations like `remove(selectAllButTop(...))` which leave chords with a single note.

Rhythm inheritance: if the Chord has a rhythm and the Note does not, the Note inherits the Chord's rhythm. If both have rhythm, the Chord's takes precedence. If neither has rhythm, the Note remains without rhythm.

### 10.4 Algorithm

```
unwrapSingle(selection):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      expr = csNode.node
      if NOT isChord(expr): continue
      notes = (expr as Chord).contents.filter(isNote)
      if notes.length != 1: continue

      singleNote = notes[0]

      // Rhythm inheritance: chord's rhythm takes precedence
      if (expr as Chord).rhythm:
        singleNote.rhythm = (expr as Chord).rhythm

      // Replace the CSNode's wrapped expr and tag
      csNode.node = singleNote
      csNode.tag = TAGS.Note

      // Promote the single Note's CSNode children to be this node's children.
      // We find the Note CSNode among the chord's child chain and use its firstChild.
      noteCSNode = findNoteChild(csNode)
      csNode.firstChild = noteCSNode ? noteCSNode.firstChild : null
  return selection

findNoteChild(chordCSNode):
  current = chordCSNode.firstChild
  while current != null:
    if current.tag == TAGS.Note:
      return current
    current = current.nextSibling
  return null
```

### 10.5 Tests

Property-based:
- `unwrap-single` on a single-note chord produces a Note (not a Chord) at that position
- After `unwrap-single`, the resulting Note's rhythm matches the chord's rhythm (if the chord had one)
- Chords with more than one note are left unchanged by `unwrap-single`

Example-based:
- `[C]2` (single-note chord with rhythm 2): result is `C2`
- `[C2]` (single-note chord, note has rhythm 2, chord has no rhythm): result is `C2`
- `[C]` (single-note chord, no rhythm anywhere): result is `C`
- `[C2]4` (chord has rhythm 4, note has rhythm 2): result is `C4` (chord rhythm takes precedence)
- `[CEG]2` (multi-note chord): result is unchanged `[CEG]2`
- Two cursors selecting different single-note chords: both are unwrapped

---

## Test Infrastructure

### Existing generators (from `abct2/tests/helpers.ts`)

- `genAbcTune`: generates a single-tune ABC string with random notes, rests, chords
- `genAbcWithChords`: generates ABC with at least some chords
- `genAbcMultiTune`: generates multi-tune ABC strings

### New generators needed

We add the following to `abct2/tests/helpers.ts`:

```typescript
// Generate a Selection where specific node types are selected via cursors
function selectAndBuild(source: string, selectorFn: (sel: Selection) => Selection): Selection

// Generate an IRational within reasonable bounds
const genRational: fc.Arbitrary<IRational>  // numerator in [1,16], denominator in [1,16]

// Generate a transpose distance
const genSemitones: fc.Arbitrary<number>  // range [-24, 24]
```

### Test configuration

All property-based tests use `fast-check` with at least `numRuns: 1000`. Example-based tests use standard Mocha/Chai assertions.

### Assertion utilities

```typescript
// Format a Selection's tree to an ABC string (for comparison)
function formatSelection(sel: Selection): string
  // calls toAst(sel.root), then AbcFormatter.stringify()

// Compare two Selections by their formatted output
function assertFormatsEqual(a: Selection, b: Selection): void
```

---

## Implementation Checklist

1. Create all new directories and empty files in a single batch (`abct2/src/csTree/toAst.ts`, `abct2/src/transforms/types.ts`, `abct2/src/transforms/remove.ts`, `abct2/src/transforms/transpose.ts`, `abct2/src/transforms/toRest.ts`, `abct2/src/transforms/rhythm.ts`, `abct2/src/transforms/setRhythm.ts`, `abct2/src/transforms/sumRhythm.ts`, `abct2/src/transforms/addToRhythm.ts`, `abct2/src/transforms/unwrapSingle.ts`, `abct2/src/transforms/index.ts`, `abct2/tests/toAst.spec.ts`, `abct2/tests/remove.spec.ts`, `abct2/tests/transpose.spec.ts`, `abct2/tests/toRest.spec.ts`, `abct2/tests/rhythm.spec.ts`, `abct2/tests/setRhythm.spec.ts`, `abct2/tests/sumRhythm.spec.ts`, `abct2/tests/addToRhythm.spec.ts`, `abct2/tests/unwrapSingle.spec.ts`)
2. Implement `toAst` with property-based and example tests. Run tests: `npm run test -w abct2`
3. Implement transform infrastructure (`types.ts`, `findNodesById`). No separate tests needed (tested through individual transforms).
4. Implement `remove` with tests. Run tests.
5. Implement `transpose` with tests. Run tests.
6. Implement `toRest` with tests. Run tests.
7. Implement rhythm utilities (`rhythmToRational`, `rationalToRhythm`) with tests. Run tests.
8. Implement `setRhythm` with tests. Run tests.
9. Implement `sumRhythm` with tests. Run tests.
10. Implement `addToRhythm` with tests. Run tests.
11. Implement `unwrapSingle` with tests. Run tests.
12. Add `index.ts` re-exports for all transforms.
13. Run full test suite from root: `npm run test`
14. Run build: `npm run build`
15. Call the code review agent on all new files. Address any feedback.
16. Commit once build passes and all tests pass.

---

## Critical Files

- `abct2/src/csTree/types.ts` — CSNode interface, TAGS, predicate functions (isNote, isChord, isRest, etc.)
- `abct2/src/csTree/fromAst.ts` — AST to CS tree conversion (reference for `toAst`)
- `abct2/src/selection.ts` — Selection type, Cursor type, createSelection
- `abct2/src/selectors/fanOut.ts` — fan-out mechanism (uses firstChild/nextSibling traversal)
- `abct2/tests/helpers.ts` — test helpers and fast-check generators
- `parse/types/Expr2.ts` — AST node classes (Note:455, Rest:442, Chord:522, Pitch, Rhythm)
- `parse/parsers/scan2.ts` — Token class, TT (TokenType) enum
- `parse/parsers/Context.ts` — ABCContext (generateId for new tokens)
- `parse/Visitors/fmt2/rational.ts` — IRational, createRational, addRational
- `parse/Visitors/RhythmTransform.ts:458-532` — reference rhythmToRational/rationalToRhythm implementations
- `parse/Visitors/Formatter2.ts` — AbcFormatter.stringify(), toMidiPitch
- `parse/Visitors/Transposer.ts:339` — fromMidiPitch
- `parse/helpers.ts` — isNote, isChord, isPitch type guards
- `abct/src/runtime/transforms/transpose.ts` — reference transpose implementation for abct v1
