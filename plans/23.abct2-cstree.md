# Independent CS Tree (Data Payloads)

## Table of Contents

1. [Goal](#goal)
2. [Design Principles](#design-principles)
3. [New CSNode Interface](#new-csnode-interface)
4. [Data Payload Types](#data-payload-types)
5. [Phase 1: CSNode Redesign](#phase-1-csnode-redesign)
6. [Phase 2: Updated fromAst](#phase-2-updated-fromast)
7. [Phase 3: AST Reconstruction (toAst)](#phase-3-ast-reconstruction-toast)
8. [Phase 4: Updated Test Helpers](#phase-4-updated-test-helpers)
9. [Phase 5: Selector Verification](#phase-5-selector-verification)
10. [Tests](#tests)
11. [Implementation Checklist](#implementation-checklist)
12. [Critical Files](#critical-files)
13. [Future Work](#future-work-out-of-scope-for-this-plan)

---

## Goal

We are redesigning the CS tree so it owns its data rather than wrapping AST nodes by reference. Currently, `CSNode.node: Expr | Token` holds a direct reference to the parser's AST, creating a dual-representation problem: transforms that mutate the Expr's fields conflict with the CS tree's structural representation, requiring a fragile synchronization layer (`toAst`).

The fix: remove the `node` reference. Each CSNode carries a data payload appropriate to its type. Token leaf nodes store their lexeme and token type. Compound nodes are purely structural (their meaning comes from their tag + children). The tree becomes self-contained — serialization walks the tree and produces ABC text without needing the original AST.

---

## Design Principles

1. The tree structure IS the data. Children appear in serialization order via the firstChild/nextSibling chain.

2. Only Token leaf nodes carry data payloads (lexeme + type). Compound nodes are structural — their tag identifies what they are, their children provide the content.

3. Special fields that are not in a contents array but appear in ABC text at a specific position (like Chord.rhythm, Note.tie) are represented as children in the sibling chain, in the order they appear in the source text.

4. Syntactic delimiters discarded by the parser (Chord brackets, Grace_group braces, Inline_field brackets, Tuplet prefix/separators, Grouping parentheses, Macro/UserSymbol `=`) are NOT stored as Token children because they do not exist in the AST. The existing Formatter2 already reconstructs these delimiters during formatting. Because the output pipeline goes through `toAst` → Formatter2, no special delimiter handling is needed in the CS tree layer.

5. Compound nodes with metadata that cannot be represented as children carry a minimal typed data payload. The only known case is `Grace_group.isAccacciatura: boolean` (the `/` token is discarded by the parser and only the flag remains in the AST).

6. Selectors work unchanged — they use `tag` and tree structure (firstChild/nextSibling), never the `node` field.

---

## New CSNode Interface

```typescript
interface CSNode {
  tag: string;
  id: number;
  data: NodeData;                 // type-specific payload
  firstChild: CSNode | null;
  nextSibling: CSNode | null;
}
```

The `data` field replaces `node: Expr | Token`. Its type is a discriminated union keyed by tag.

---

## Data Payload Types

### Token nodes (leaves)

All Token CSNodes (tag === TAGS.Token) carry:

```typescript
interface TokenData {
  type: "token";
  lexeme: string;
  tokenType: TT;
  line: number;
  position: number;
}
```

Because downstream consumers (language server, editor extension) may rely on Token positions from the reconstructed AST, we store `line` and `position` as primitive values copied at construction time. This preserves position information without introducing shared references.

This covers all lexemes: note letters, accidentals, octave marks, rhythm digits, separators, barlines, whitespace, EOL, comments, rest symbols, ties, decorations, annotations, chord symbols, etc.

### Grace_group nodes

Grace_group is the only compound node that needs metadata beyond its children:

```typescript
interface GraceGroupData {
  type: "grace_group";
  isAccacciatura: boolean;
}
```

Because the parser discards the `/` token and only stores the boolean flag, we must preserve it in the CSNode's data.

### All other compound nodes

All other compound nodes (Note, Pitch, Rhythm, Rest, Chord, Beam, Music_code, Tune_Body, Tune, Tune_header, File_structure, File_header, Info_line, Inline_field, BarLine, Decoration, Annotation, etc.) carry no data — they are purely structural:

```typescript
interface EmptyData {
  type: "empty";
}
```

### Union type

```typescript
type NodeData = TokenData | GraceGroupData | EmptyData;
```

---

## Phase 1: CSNode Redesign

### 1.1 Location

`abct2/src/csTree/types.ts`

### 1.2 Changes

1. Replace `node: Expr | Token` with `data: NodeData`
2. Add the `NodeData` type union (TokenData, GraceGroupData, EmptyData)
3. Add helpers to check and access token data (using TypeScript type predicates for proper narrowing):

```typescript
function isTokenNode(node: CSNode): node is CSNode & { data: TokenData } {
  return node.data.type === "token";
}

function getTokenData(node: CSNode): TokenData {
  if (node.data.type !== "token") throw new Error("getTokenData called on non-token node");
  return node.data as TokenData;
}
```

4. Add a factory function for creating CSNodes:

```typescript
function createCSNode(tag: string, id: number, data: NodeData): CSNode {
  return { tag, id, data, firstChild: null, nextSibling: null };
}
```

5. The existing predicate functions (`isRest`, `isNote`, `isChord`, `isBarLine`, `isBeam`) remain unchanged — they check `node.tag`, not `node.node`.

---

## Phase 2: Updated fromAst

### 2.1 Location

`abct2/src/csTree/fromAst.ts`

### 2.2 Changes

The structure of fromAst remains the same (visitor pattern, recursive child linking). The difference: instead of storing `node: expr` on the CSNode, we extract data into the appropriate payload.

### 2.3 Algorithm

```
fromAst(astNode: Expr | Token): CSNode
  tag = resolveTag(astNode)
  id = astNode.id
  data = extractData(astNode, tag)
  csNode = createCSNode(tag, id, data)

  if astNode is Token:
    return csNode   // Tokens are leaves, no children

  children = astNode.accept(childrenVisitor)
  // Link children into firstChild/nextSibling chain
  linkChildren(csNode, children.map(child => fromAst(child)))

  return csNode
```

### 2.4 extractData function

```
extractData(astNode, tag):
  if astNode is Token:
    return { type: "token", lexeme: astNode.lexeme, tokenType: astNode.type,
             line: astNode.line, position: astNode.position }
  if tag == TAGS.Grace_group:
    return { type: "grace_group", isAccacciatura: (astNode as Grace_group).isAccacciatura }
  return { type: "empty" }
```

### 2.5 childrenVisitor

The children visitor is mostly unchanged, with two bug fixes required for correct serialization order:

1. `visitAbsolutePitch`: The current implementation returns `[alteration?, noteLetter, octave?]`, but the source text order (and Formatter2 output) is `noteLetter, alteration?, octave?`. We must fix this to:
```
visitAbsolutePitch(expr: AbsolutePitch): ChildList {
  const children: ChildList = [expr.noteLetter];
  if (expr.alteration) children.push(expr.alteration);
  if (expr.octave) children.push(expr.octave);
  return children;
}
```

2. `visitInlineFieldExpr`: The current implementation returns `[expr.field, ...expr.text]`, but `expr.text` already contains `expr.field` as its first element (see `parseInlineField` at `parse2.ts:754`). This causes the field token to appear twice. We must fix this to:
```
visitInlineFieldExpr(expr: Inline_field): ChildList {
  return [...expr.text];
}
```

### 2.6 resolveTag

Unchanged — same instanceof checks mapping Expr/Token to TAGS strings.

---

## Phase 3: AST Reconstruction (toAst)

### 3.1 Location

`abct2/src/csTree/toAst.ts`

### 3.2 Interface

```typescript
function toAst(root: CSNode): Expr | Token
```

Reconstructs a fresh AST from the CS tree's data payloads. Because the CS tree is independent (no shared references), this is a pure conversion — transforms mutate the CS tree, and `toAst` produces a clean AST that the existing Formatter2 can format.

The output pipeline is: `CS tree → toAst → AST → Formatter2 → ABC text`.

### 3.3 Algorithm

The function dispatches on `node.tag` to construct the appropriate Expr subclass. For Token nodes, it creates a new Token from the data payload. For compound nodes, it recursively converts children and passes them to the Expr constructor.

```typescript
function toAst(node: CSNode): Expr | Token {
  if (isTokenNode(node)) {
    const data = getTokenData(node);
    const token = new Token(data.tokenType, data.lexeme, node.id);
    token.line = data.line;
    token.position = data.position;
    return token;
  }
  const children = collectChildren(node).map(toAst);
  return buildExpr(node, children);
}

function collectChildren(node: CSNode): CSNode[] {
  const result: CSNode[] = [];
  let child = node.firstChild;
  while (child !== null) {
    result.push(child);
    child = child.nextSibling;
  }
  return result;
}
```

### 3.4 buildExpr dispatch

The `buildExpr` function maps each tag to the corresponding Expr constructor. Every compound node type must have an entry here.

```typescript
function buildExpr(node: CSNode, children: Array<Expr | Token>): Expr {
  switch (node.tag) {
    case TAGS.Note:
      return buildNote(node.id, children);
    case TAGS.Chord:
      return buildChord(node.id, children);
    case TAGS.Pitch:
      return buildPitch(node.id, children);
    case TAGS.AbsolutePitch:
      return buildAbsolutePitch(node.id, children);
    case TAGS.Rest:
      return buildRest(node.id, children);
    case TAGS.BarLine:
      return buildBarLine(node.id, children);
    case TAGS.Tuplet:
      return buildTuplet(node.id, children);
    case TAGS.Grace_group:
      return buildGraceGroup(node, children);
    case TAGS.Inline_field:
      return buildInlineField(node.id, children);
    case TAGS.Directive:
      return buildDirective(node.id, children);
    case TAGS.Music_code:
      return buildMusicCode(node.id, children);
    case TAGS.Beam:
      return buildBeam(node.id, children);
    case TAGS.Tune_Body:
      return buildTuneBody(node.id, children);
    case TAGS.Decoration:
      return buildDecoration(node.id, children);
    case TAGS.Annotation:
      return buildAnnotation(node.id, children);
    case TAGS.Info_line:
      return buildInfoLine(node.id, children);
    case TAGS.Tune:
      return buildTune(node.id, children);
    case TAGS.Tune_header:
      return buildTuneHeader(node.id, children);
    case TAGS.File_structure:
      return buildFileStructure(node.id, children);
    case TAGS.File_header:
      return buildFileHeader(node.id, children);
    case TAGS.Rhythm:
      return buildRhythm(node.id, children);
    // ... remaining tags follow the same patterns
  }
}
```

### 3.5 Builder functions

Each builder maps the flat children list back to the constructor's parameter signature. The functions are grouped by pattern.

#### Single-child wrappers

Decoration, Annotation, Comment, and Symbol each wrap a single Token:

```typescript
function buildDecoration(id: number, children: Array<Expr | Token>): Decoration {
  return new Decoration(id, children[0] as Token);
}

function buildAnnotation(id: number, children: Array<Expr | Token>): Annotation {
  return new Annotation(id, children[0] as Token);
}
```

#### Array containers

Music_code, Beam, File_header, and Tune_header take a flat array of children:

```typescript
function buildMusicCode(id: number, children: Array<Expr | Token>): Music_code {
  return new Music_code(id, children as tune_body_code[]);
}

function buildBeam(id: number, children: Array<Expr | Token>): Beam {
  return new Beam(id, children as Beam_contents[]);
}

function buildTuneHeader(id: number, children: Array<Expr | Token>): Tune_header {
  return new Tune_header(id, children as Array<Info_line | Comment | Macro_decl | User_symbol_decl | Directive>);
}

function buildFileHeader(id: number, children: Array<Expr | Token>): File_header {
  return new File_header(id, children as Info_line[]);
}
```

#### Note (pitch + optional rhythm and tie)

Children appear in order: `[Pitch, Rhythm?, Token(TIE)?]`. We discriminate the optional trailing children by type:

```typescript
function buildNote(id: number, children: Array<Expr | Token>): Note {
  const pitch = children[0] as Pitch;
  let rhythm: Rhythm | undefined;
  let tie: Token | undefined;
  for (let i = 1; i < children.length; i++) {
    if (children[i] instanceof Rhythm) rhythm = children[i] as Rhythm;
    else if (children[i] instanceof Token) tie = children[i] as Token;
  }
  return new Note(id, pitch, rhythm, tie);
}
```

#### Chord (contents + optional rhythm and tie)

The Chord's brackets are not stored as children (they are reconstructed by Formatter2). Children are a mix of Note, Token, and Annotation nodes (the chord contents), followed by optional Rhythm and tie Token. We discriminate by checking `instanceof Rhythm` and `token.type === TT.TIE`:

```typescript
function buildChord(id: number, children: Array<Expr | Token>): Chord {
  const contents: Array<Note | Token | Annotation> = [];
  let rhythm: Rhythm | undefined;
  let tie: Token | undefined;
  for (const child of children) {
    if (child instanceof Rhythm) rhythm = child;
    else if (child instanceof Token && child.type === TT.TIE) tie = child;
    else contents.push(child as Note | Token | Annotation);
  }
  return new Chord(id, contents, rhythm, tie);
}
```

#### Pitch (destructured object constructor)

The Pitch constructor takes `{ alteration?, noteLetter, octave? }` as a destructured object. The childrenVisitor emits children in ABC source order `[alteration?, noteLetter, octave?]` (accidentals precede the note letter in tune-body notation, e.g., `^C`). Because the children may appear in any subset, we discriminate by token type:

```typescript
function buildPitch(id: number, children: Array<Expr | Token>): Pitch {
  let alteration: Token | undefined;
  let noteLetter: Token | undefined;
  let octave: Token | undefined;
  for (const child of children) {
    const token = child as Token;
    switch (token.type) {
      case TT.NOTE_LETTER: noteLetter = token; break;
      case TT.ACCIDENTAL: alteration = token; break;
      case TT.OCTAVE: octave = token; break;
    }
  }
  return new Pitch(id, { alteration, noteLetter: noteLetter!, octave });
}
```

#### AbsolutePitch (positional constructor)

AbsolutePitch uses positional parameters `(id, noteLetter, alteration?, octave?)`. The same token-type discrimination applies:

```typescript
function buildAbsolutePitch(id: number, children: Array<Expr | Token>): AbsolutePitch {
  let alteration: Token | undefined;
  let noteLetter: Token | undefined;
  let octave: Token | undefined;
  for (const child of children) {
    const token = child as Token;
    switch (token.type) {
      case TT.NOTE_LETTER: noteLetter = token; break;
      case TT.ACCIDENTAL: alteration = token; break;
      case TT.OCTAVE: octave = token; break;
    }
  }
  return new AbsolutePitch(id, noteLetter!, alteration, octave);
}
```

#### Rest (rest token + optional rhythm)

```typescript
function buildRest(id: number, children: Array<Expr | Token>): Rest {
  const rest = children[0] as Token;
  const rhythm = children.length > 1 ? children[1] as Rhythm : undefined;
  return new Rest(id, rest, rhythm);
}
```

#### BarLine (barline tokens + optional repeat numbers)

The `fromAst` childrenVisitor emits barline tokens followed by repeat number tokens. We discriminate by token type — repeat numbers have type `TT.REPEAT_NUMBER`:

```typescript
function buildBarLine(id: number, children: Array<Expr | Token>): BarLine {
  const barline: Token[] = [];
  const repeatNumbers: Token[] = [];
  for (const child of children) {
    const token = child as Token;
    if (token.type === TT.REPEAT_NUMBER) {
      repeatNumbers.push(token);
    } else {
      barline.push(token);
    }
  }
  return new BarLine(id, barline, repeatNumbers.length > 0 ? repeatNumbers : undefined);
}
```

#### Tuplet (p, q?, r? tokens)

All children are Tokens. We assign them to p, q, r based on token type:

```typescript
function buildTuplet(id: number, children: Array<Expr | Token>): Tuplet {
  const p = children[0] as Token;
  const q = children.length > 1 && (children[1] as Token).type === TT.TUPLET_Q
    ? children[1] as Token : undefined;
  const r = children[children.length - 1] as Token;
  const rToken = r.type === TT.TUPLET_R ? r : undefined;
  return new Tuplet(id, p, q, rToken);
}
```

#### Grace_group (uses data payload for isAccacciatura flag)

The Grace_group constructor accepts `isAccacciatura` as its third parameter, so we pass it directly:

```typescript
function buildGraceGroup(node: CSNode, children: Array<Expr | Token>): Grace_group {
  const data = node.data as GraceGroupData;
  return new Grace_group(node.id, children as Note[], data.isAccacciatura);
}
```

#### Inline_field (text-based, value2 left undefined)

Because the CS tree stores raw tokens from `expr.text` as children, and the Formatter2 falls back to the text-based formatting path when `value2` is undefined, we reconstruct the Inline_field using only the token list. The first child is the field token (`K:`, `M:`, etc.), and all children form the `text` array:

```typescript
function buildInlineField(id: number, children: Array<Expr | Token>): Inline_field {
  const field = children[0] as Token;
  const text = children as Token[];
  return new Inline_field(id, field, text);
}
```

The `value2` parameter is omitted (left undefined). The Formatter2 uses the text-based fallback path, which concatenates the raw token lexemes — this faithfully reproduces the original source text.

#### Directive (key + heterogeneous values)

Because `toAst` recursively converts each child to the correct Expr/Token type before we reach `buildDirective`, the children array already contains properly typed values. We pass them through:

```typescript
function buildDirective(id: number, children: Array<Expr | Token>): Directive {
  const key = children[0] as Token;
  const values = children.slice(1);
  return new Directive(id, key, values as Array<Token | Rational | Pitch | KV | Measurement | Annotation>);
}
```

#### Info_line (single token array)

The Info_line constructor takes `(id, tokens: Token[])` as a single combined array, where `tokens[0]` is internally extracted as the `key` and `tokens.slice(1)` becomes `value`. The childrenVisitor emits `[key, ...value]`, so we pass the full children array directly:

```typescript
function buildInfoLine(id: number, children: Array<Expr | Token>): Info_line {
  return new Info_line(id, children as Token[]);
}
```

#### Tune_Body (children become a single flat system)

Because `fromAst` flattens `expr.sequence` (the 2D systems array) into a single child list, the reconstruction places all children into one system. The formatter handles line breaks via EOL tokens within the content:

```typescript
function buildTuneBody(id: number, children: Array<Expr | Token>): Tune_Body {
  return new Tune_Body(id, [children as tune_body_code[]]);
}
```

#### Tune (header + body)

```typescript
function buildTune(id: number, children: Array<Expr | Token>): Tune {
  const header = children[0] as Tune_header;
  const body = children.length > 1 ? children[1] as Tune_Body : undefined;
  return new Tune(id, header, body);
}
```

#### File_structure (optional file_header + contents)

Because the childrenVisitor only pushes `file_header` when it is non-null, we discriminate the first child by tag to determine whether a File_header is present. The `contents` array is typed `Array<Tune | Token>` because section-break tokens can appear between tunes:

```typescript
function buildFileStructure(id: number, children: Array<Expr | Token>): File_structure {
  let fileHeader: File_header | null = null;
  let contentsStart = 0;
  if (children.length > 0 && children[0] instanceof File_header) {
    fileHeader = children[0] as File_header;
    contentsStart = 1;
  }
  const contents = children.slice(contentsStart) as Array<Tune | Token>;
  return new File_structure(id, fileHeader, contents);
}
```

#### Rhythm (individual token params, discriminated by token type)

The Rhythm constructor takes `(id, numerator, separator?, denominator?, broken?)` as individual Token parameters. The childrenVisitor emits them in strict order `[numerator?, separator?, denominator?, broken?]`, so we discriminate by token type:

```typescript
function buildRhythm(id: number, children: Array<Expr | Token>): Rhythm {
  let numerator: Token | null = null;
  let separator: Token | undefined;
  let denominator: Token | null = null;
  let broken: Token | null = null;
  for (const child of children) {
    const token = child as Token;
    switch (token.type) {
      case TT.RHY_NUMER: numerator = token; break;
      case TT.RHY_SEP: separator = token; break;
      case TT.RHY_DENOM: denominator = token; break;
      case TT.RHY_BRKN: broken = token; break;
    }
  }
  return new Rhythm(id, numerator, separator, denominator, broken);
}
```

### 3.6 Key differences from the old wrapper toAst

The old wrapper's `toAst` operated on shared references (CSNode.node pointed to the same Expr). This caused clobbering: rebuilding container arrays from the sibling chain would overwrite transform mutations on individual fields.

The new `toAst` builds a fresh AST from independent data payloads. There is no shared state — the CS tree's Token lexemes and structural children are the sole source of truth. No clobbering is possible.

---

## Phase 4: Updated Test Helpers

### 4.1 Location

`abct2/tests/helpers.ts`

### 4.2 Changes

The `toCSTree` and `toSelection` helpers remain the same (they call `fromAst` which now produces the new format).

Add a new helper for roundtrip testing (parse → fromAst → toAst → format). Because the output pipeline goes through `toAst` to produce an AST and then through the existing Formatter2, the helper uses the same formatter infrastructure as the rest of the codebase:

```typescript
function roundtrip(source: string): string {
  const csTree = fromAst(parse(source));
  const ast = toAst(csTree);
  return new AbcFormatter(new ABCContext()).stringify(ast as Expr);
}
```

Update `collectAll`, `findByTag`, `findById`, `siblingCount` — these only use `tag`, `id`, `firstChild`, `nextSibling`, so they need no changes (they never accessed `node`).

### 4.3 Existing tests that access `node.node`

Two property-based tests in `abct2/tests/csTree.spec.ts` access `node.node` directly:
- Line 30: `if (node.id !== node.node.id) return false;` — this test verifies id consistency between CSNode and AST node. Because the redesign copies the id during construction, this property is trivially true. Remove this test (it is now a tautology).
- Line 56: `const expectedCount = csNode.node.accept(childrenVisitor).length;` — this test verifies child count matches the AST visitor's output. Replace with a roundtrip-based test: verify that `roundtrip(source) === new AbcFormatter(new ABCContext()).stringify(parse(source))`.

---

## Phase 5: Selector Verification

### 5.1 No code changes expected

All selectors (typeSelectors, chordSelectors, structureSelectors, fanOut) use only:
- `node.tag` — unchanged
- `node.id` — unchanged
- `node.firstChild` / `node.nextSibling` — unchanged

They never access `node.node`. So they should work without modification.

### 5.2 Verification

Run all existing selector tests after the redesign. They should pass without changes. If any test accesses `node.node` directly (e.g., for assertions), update it to use the new data payload or serialization.

---

## Tests

### Roundtrip semantics

The roundtrip property is: `roundtrip(source) === format(parse(source))`. We compare the CS tree path's output against the direct formatter output — they must produce the same result. We do NOT compare against the raw source text because the Formatter2 performs normalization:

- Info_line: the fallback formatting path (used when `value2` is undefined) strips whitespace tokens and inserts single spaces between remaining tokens
- Tune_header: the formatter joins info lines with `\n`
- Tune: the formatter inserts `\n` between header and body
- File_structure: the formatter joins tunes with `\n\n`

Because both paths (direct format and CS-tree-based format) go through the same Formatter2, the roundtrip property holds as long as `toAst` reconstructs an equivalent AST. The formatter's normalization is consistent in both paths.

### Property-based (roundtrip)

Using existing generators (`genAbcTune`, `genAbcWithChords`, `genAbcMultiTune`):

- `roundtrip(source) === new AbcFormatter(new ABCContext()).stringify(parse(source))` — the CS tree path produces the same output as formatting the AST directly
- `collectAll(fromAst(parse(source))).length` is stable (same node count as before the redesign)
- After modifying a Token node's lexeme in the CS tree, calling `toAst` and formatting should reflect the change in the output

### Example-based

For each case, verify that `roundtrip(source) === new AbcFormatter(new ABCContext()).stringify(parse(source))`:

- Simple note `C`
- Note with all components `^^C''3/4>-`
- Chord `[CEG]2-` (brackets reconstructed by formatter)
- Grace group `{/CDE}` (braces and slash reconstructed by formatter)
- Acciaccatura flag: `{CDE}` (no slash)
- Inline field `[K:Am]` (brackets reconstructed by formatter)
- Barlines: `|`, `||`, `|]`, `[|`, `:|`
- Rest with rhythm: `z3/4`
- Beam contents: notes within a beam
- Decorations: `!mf!`
- Annotations: `"Am"`
- Tuplet `(3`, `(3:2`, `(3:2:3` (paren and colons reconstructed by formatter)
- Grouping in info line `L:1/(2+3)` (parentheses reconstructed by formatter)
- AbsolutePitch `K:G#m` (noteLetter-alteration order correct)
- Macro declaration `m:var=content` (`=` reconstructed by formatter)
- ErrorExpr (malformed input)

Note: `(3::2` (Tuplet with q=undefined, r=2) is excluded from the roundtrip tests because the Formatter2 only outputs `r` when `q` is also present. This is a pre-existing formatter limitation.

### Selector tests

- All existing selector tests pass unchanged (they don't use `node.node`)

---

## Implementation Checklist

1. Create new file `abct2/src/csTree/toAst.ts` (empty initially)
2. Update `abct2/src/csTree/types.ts`:
   - Add `NodeData` union type (TokenData, GraceGroupData, EmptyData)
   - Replace `node: Expr | Token` with `data: NodeData` on CSNode interface
   - Add `isTokenNode`, `getTokenData`, `createCSNode` helpers
   - Keep existing predicate functions unchanged
3. Update `abct2/src/csTree/fromAst.ts`:
   - Add `extractData` function
   - Change CSNode creation to use `createCSNode` with extracted data instead of storing the Expr/Token reference
   - Keep `resolveTag` unchanged
   - Fix `visitAbsolutePitch` in childrenVisitor: reorder to `[noteLetter, alteration?, octave?]` (section 2.5)
   - Fix `visitInlineFieldExpr` in childrenVisitor: return `[...expr.text]` instead of `[expr.field, ...expr.text]` (section 2.5)
4. Implement `toAst` in `abct2/src/csTree/toAst.ts`:
   - Token reconstruction from data payload (lexeme, tokenType, line, position)
   - `collectChildren` utility (walks firstChild/nextSibling chain)
   - `buildExpr` dispatch (tag → builder function)
   - Builder functions for each node type (section 3.5):
     - Single-child wrappers: `buildDecoration`, `buildAnnotation`
     - Array containers: `buildMusicCode`, `buildBeam`, `buildTuneHeader`, `buildFileHeader`
     - Token-type discrimination: `buildPitch` (destructured obj), `buildAbsolutePitch` (positional)
     - Optional trailing fields: `buildNote`, `buildChord`
     - Token-only builders: `buildRest`, `buildBarLine`, `buildTuplet`, `buildRhythm`
     - Data payload: `buildGraceGroup` (passes isAccacciatura directly to constructor)
     - Text-based: `buildInlineField` (value2 left undefined)
     - Passthrough: `buildDirective`, `buildInfoLine`
     - Structural: `buildTuneBody` (single system), `buildTune`, `buildFileStructure`
5. Update `abct2/tests/helpers.ts`:
   - Add `roundtrip` helper (parse → fromAst → toAst → format via AbcFormatter with ABCContext)
   - Update any assertions that accessed `node.node`
6. Write roundtrip property-based tests (CS tree path output === direct formatter output)
7. Write example-based tests for each node type
8. Run existing selector tests — verify they pass without changes
9. Run full test suite: `npm run test -w abct2`
10. Run build: `npm run build`
11. Call the code review agent on all modified files. Address feedback.
12. Commit once build passes and all tests pass.

---

## Critical Files

- `abct2/src/csTree/types.ts` — CSNode interface, TAGS, predicates (to be modified)
- `abct2/src/csTree/fromAst.ts` — AST to CS tree conversion (to be modified)
- `abct2/src/csTree/toAst.ts` — new AST reconstruction function
- `abct2/src/selectors/` — all selector files (unchanged, to be verified)
- `abct2/tests/helpers.ts` — test utilities (to be updated)
- `parse/parsers/scan2.ts` — Token class, TT enum (read-only reference)
- `parse/types/Expr2.ts` — AST node classes (reference for toAst builder functions)
- `parse/Visitors/Formatter2.ts` — used in test helpers for formatting the reconstructed AST

---

## Future Work (out of scope for this plan)

These items are not addressed by this plan but should be tackled in follow-up work:

1. Fix the parser to preserve delimiter tokens (Chord `[]`, Grace_group `{}`, Inline_field `[]`, Tuplet `(` and `:`, Grouping `()`, Macro/UserSymbol `=`). Because the parser currently discards these tokens, they cannot appear as selectable nodes in the CS tree. Selectors cannot target them. Once the parser preserves them, these tokens would appear as Token children in the CS tree and could be selected/transformed like any other token.

2. Preserve the Grace_group `/` token as a child node instead of discarding it and storing a boolean flag. This would eliminate the need for `GraceGroupData` — Grace_group would become a purely structural node like all others.

3. Implement transforms that operate on the independent CS tree (covered by a separate plan).
