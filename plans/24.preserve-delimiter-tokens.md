# Preserving Discarded Delimiter Tokens

## Table of Contents

1. [Goal](#goal)
2. [Design Approach](#design-approach)
3. [Phase 1: Expr Class Updates](#phase-1-expr-class-updates)
4. [Phase 2: Scanner Update (Macro/UserSymbol =)](#phase-2-scanner-update)
5. [Phase 3: Parser Updates](#phase-3-parser-updates)
6. [Phase 4: Formatter Updates](#phase-4-formatter-updates)
7. [Phase 5: fromAst childrenVisitor Updates](#phase-5-fromast-childrenvisitor-updates)
8. [Phase 6: toAst Builder Updates](#phase-6-toast-builder-updates)
9. [Phase 7: GraceGroupData Removal](#phase-7-gracegroupdata-removal)
10. [Tests](#tests)
11. [Implementation Checklist](#implementation-checklist)
12. [Critical Files](#critical-files)

---

## Goal

The parser currently discards 7 categories of syntactic delimiter tokens during parsing. These tokens are consumed (via `ctx.match()` or `ctx.advance()`) but never stored on the resulting Expr nodes. The Formatter2 reconstructs them with hardcoded string literals. This prevents the CS tree from including these tokens as selectable/transformable children.

We are modifying the parser to preserve all delimiter tokens as explicit fields on their respective Expr classes. The Formatter2 will use the stored token's lexeme when available, falling back to hardcoded strings for backward compatibility with programmatically-constructed Exprs.

Once preserved, these tokens will appear as Token children in the CS tree (via the fromAst childrenVisitor), making them selectable and transformable like any other token.

---

## Design Approach

1. Each delimiter token is stored as an optional field on its Expr class (e.g., `Chord.leftBracket?: Token`). Because the fields are optional, existing code that constructs Exprs without providing delimiters (tests, interpreters, programmatic construction) continues to work unchanged.

2. The parser stores the consumed tokens instead of discarding them. Because `ctx.match()` returns a boolean and advances the cursor, we use `ctx.previous()` to retrieve the consumed token after a successful match.

3. The Formatter2 uses `expr.leftBracket?.lexeme ?? "["` pattern — stored token when available, hardcoded fallback when undefined. This preserves backward compatibility.

4. The fromAst childrenVisitor emits delimiter tokens in serialization order (the order they appear in the source text). For example, Chord children become: `[leftBracket, ...contents, rightBracket, rhythm?, tie?]`.

5. The toAst builders no longer need the Formatter2 to reconstruct delimiters — the tokens exist as children and are assigned back to the correct Expr fields during reconstruction.

---

## Phase 1: Expr Class Updates

### 1.1 Location

`parse/types/Expr2.ts`

### 1.2 New fields per class

#### Chord (line 522)

```typescript
export class Chord extends Expr {
  leftBracket?: Token;
  rightBracket?: Token;
  contents: Array<Note | Token | Annotation>;
  rhythm?: Rhythm;
  tie?: Token;
  constructor(id: number, contents: Array<Note | Token | Annotation>, rhythm?: Rhythm, tie?: Token,
              leftBracket?: Token, rightBracket?: Token) {
    super(id);
    this.contents = contents;
    this.rhythm = rhythm;
    this.tie = tie;
    this.leftBracket = leftBracket;
    this.rightBracket = rightBracket;
  }
}
```

#### Grace_group (line 494)

```typescript
export class Grace_group extends Expr {
  leftBrace?: Token;
  rightBrace?: Token;
  acciaccaturaSlash?: Token;
  notes: Array<Note | Token>;
  isAccacciatura?: boolean;  // kept for backward compat, derived from acciaccaturaSlash presence
  constructor(id: number, notes: Array<Note | Token>, isAccacciatura?: boolean,
              leftBrace?: Token, rightBrace?: Token, acciaccaturaSlash?: Token) {
    super(id);
    this.notes = notes;
    this.isAccacciatura = isAccacciatura;
    this.leftBrace = leftBrace;
    this.rightBrace = rightBrace;
    this.acciaccaturaSlash = acciaccaturaSlash;
  }
}
```

#### Inline_field (line 507)

```typescript
export class Inline_field extends Expr {
  leftBracket?: Token;
  rightBracket?: Token;
  field: Token;
  text: Array<Token>;
  value2?: Array<Expr>;
  constructor(id: number, field: Token, text: Array<Token>, value2?: Array<Expr>,
              leftBracket?: Token, rightBracket?: Token) {
    super(id);
    this.field = field;
    this.text = text;
    this.value2 = value2;
    this.leftBracket = leftBracket;
    this.rightBracket = rightBracket;
  }
}
```

#### Tuplet (line 427)

```typescript
export class Tuplet extends Expr {
  leftParen?: Token;
  firstColon?: Token;
  secondColon?: Token;
  p: Token;
  q?: Token;
  r?: Token;
  constructor(id: number, p: Token, q?: Token, r?: Token,
              leftParen?: Token, firstColon?: Token, secondColon?: Token) {
    super(id);
    this.p = p;
    this.q = q;
    this.r = r;
    this.leftParen = leftParen;
    this.firstColon = firstColon;
    this.secondColon = secondColon;
  }
}
```

#### Grouping (line 829)

```typescript
export class Grouping extends Expr {
  leftParen?: Token;
  rightParen?: Token;
  expression: Expr;
  constructor(id: number, expression: Expr, leftParen?: Token, rightParen?: Token) {
    super(id);
    this.expression = expression;
    this.leftParen = leftParen;
    this.rightParen = rightParen;
  }
}
```

#### Macro_decl (line 700)

```typescript
export class Macro_decl extends Expr {
  header: Token;
  variable: Token;
  equals?: Token;
  content: Token;
  constructor(id: number, header: Token, variable: Token, content: Token, equals?: Token) {
    super(id);
    this.header = header;
    this.variable = variable;
    this.content = content;
    this.equals = equals;
  }
}
```

#### User_symbol_decl (line 730)

```typescript
export class User_symbol_decl extends Expr {
  header: Token;
  variable: Token;
  equals?: Token;
  symbol: Token;
  constructor(id: number, header: Token, variable: Token, symbol: Token, equals?: Token) {
    super(id);
    this.header = header;
    this.variable = variable;
    this.symbol = symbol;
    this.equals = equals;
  }
}
```

---

## Phase 2: Scanner Update

### 2.1 Location

`parse/parsers/scan2.ts`

### 2.2 Problem

The macro and user-symbol scanners (functions `macro_decl` at line 461 and `user_symbol_decl` at line 403) consume the `=` character with `advance(ctx)` during tokenization. The scanner produces `[MACRO_HDR, MACRO_VAR, MACRO_STR]` but the `=` between MACRO_VAR and MACRO_STR is lost.

### 2.3 Change

Instead of silently advancing past the `=`, the scanner should emit a token for it. The token stream becomes `[MACRO_HDR, MACRO_VAR, EQL, MACRO_STR]` (and `[USER_SY_HDR, USER_SY, EQL, SYMBOL]` for user symbols).

The scanner's token emission API works as follows: `advance(ctx)` moves `ctx.current` forward, expanding the lexeme boundary. Then `ctx.push(TT.XXX)` creates a token whose lexeme is `source[ctx.start:ctx.current]` and resets `ctx.start = ctx.current`.

In `macro_decl` (around line 489-498), the current code is:

```
case Expect.EQUALS:
  if ctx.test("="):
    advance(ctx)
    ctx.start = ctx.current   // manually resets start (skipping the =)
    state = Expect.CONTENT
```

The fix replaces the manual `ctx.start` reset with `ctx.push`, which both emits the token and resets `ctx.start`:

```
case Expect.EQUALS:
  if ctx.test("="):
    advance(ctx)              // move ctx.current past the =
    ctx.push(TT.EQL)         // emit = token (lexeme = "="), resets ctx.start
    state = Expect.CONTENT
  else:
    collectInvalidInfoLn(ctx, "expected `=` sign")
```

The same change applies in `user_symbol_decl` (around line 427-430).

### 2.4 Token lookback offset fix

Both `macro_decl` (line 506) and `user_symbol_decl` (line 442) retrieve the variable token using array index arithmetic:

```typescript
const variable = ctx.tokens[ctx.tokens.length - 2];
```

Because inserting the EQL token shifts the variable one position earlier in the array, the offset must change from `-2` to `-3`:

```typescript
const variable = ctx.tokens[ctx.tokens.length - 3];
```

The content/symbol token at `ctx.tokens[ctx.tokens.length - 1]` remains correct.

### 2.5 Impact on the parser

The parser (`prsMacroDecl` and `prsUserSymbolDecl` in parse2.ts) currently advances from MACRO_VAR directly to MACRO_STR. After this change, there is an EQL token between them that the parser must consume before checking for MACRO_STR.

---

## Phase 3: Parser Updates

### 3.1 Location

`parse/parsers/parse2.ts` (lines 569-693, 748-784)
`parse/parsers/infoLines/parseInfoLine2.ts` (lines 102-128)

### 3.2 Changes per function

#### parseChord (parse2.ts:569-613)

Store the bracket tokens after consuming them:

```
function parseChord(ctx, prnt_arr):
  if !ctx.match(TT.CHRD_LEFT_BRKT): return null
  leftBracket = ctx.previous()          // ← store the consumed [

  // ... parse contents unchanged ...

  let rightBracket: Token | undefined
  if ctx.match(TT.CHRD_RIGHT_BRKT):
    rightBracket = ctx.previous()        // ← store the consumed ]
  else:
    ctx.report("Unterminated chord")

  // ... parse rhythm, tie unchanged ...

  return new Chord(id, contents, rhythm, tie, leftBracket, rightBracket)
```

#### parseGraceGroup (parse2.ts:616-656)

Store braces and slash:

```
function parseGraceGroup(ctx, prnt_arr):
  if !ctx.match(TT.GRC_GRP_LEFT_BRACE): return null
  leftBrace = ctx.previous()             // ← store the consumed {

  let acciaccaturaSlash: Token | undefined
  let isAccacciatura = false
  if ctx.match(TT.GRC_GRP_SLSH):
    acciaccaturaSlash = ctx.previous()   // ← store the consumed /
    isAccacciatura = true

  // ... parse notes unchanged ...

  let rightBrace: Token | undefined
  if ctx.match(TT.GRC_GRP_RGHT_BRACE):
    rightBrace = ctx.previous()          // ← store the consumed }
  else:
    ctx.report("Unterminated grace group")

  return new Grace_group(id, notes, isAccacciatura, leftBrace, rightBrace, acciaccaturaSlash)
```

#### parseInlineField (parse2.ts:748-784)

Store brackets:

```
function parseInlineField(ctx, prnt_arr):
  if !ctx.match(TT.INLN_FLD_LFT_BRKT): return null
  leftBracket = ctx.previous()           // ← store the consumed [

  // ... parse field, tokens, expressions unchanged ...

  let rightBracket: Token | undefined
  if !ctx.isAtEnd():
    ctx.advance()                        // consume ]
    rightBracket = ctx.previous()        // ← store the consumed ]

  return new Inline_field(id, field, tokens, expressions, leftBracket, rightBracket)
```

#### parseTuplet (parse2.ts:659-693)

Store paren and colons:

```
function parseTuplet(ctx, prnt_arr):
  if ctx.match(TT.TUPLET_LPAREN):
    leftParen = ctx.previous()           // ← store the consumed (

    // ... parse p unchanged ...

    let firstColon: Token | undefined
    let secondColon: Token | undefined
    if ctx.match(TT.TUPLET_COLON):
      firstColon = ctx.previous()        // ← store the consumed :
      // ... parse q unchanged ...
      if ctx.match(TT.TUPLET_COLON):
        secondColon = ctx.previous()     // ← store the consumed :
        // ... parse r unchanged ...

    return new Tuplet(id, p, q, r, leftParen, firstColon, secondColon)
```

#### parsePrimary (parseInfoLine2.ts:102-128)

Store grouping parens. Note: this changes error recovery behavior. The current code returns `null` when the closing `)` is missing, which aborts the parse. The new code returns a Grouping with `rightParen = undefined`, which allows partial results to propagate. This is intentional — a missing closing paren should still produce a valid (though incomplete) Grouping node that can be formatted and round-tripped:

```
function parsePrimary(ctx):
  // ... unary handling unchanged ...

  if ctx.match(TT.LPAREN):
    leftParen = ctx.previous()           // ← store the consumed (
    expr = prsBinaryExpr(ctx)
    // ...
    let rightParen: Token | undefined
    if ctx.match(TT.RPAREN):
      rightParen = ctx.previous()        // ← store the consumed )
    else:
      ctx.report("Expected ')' after expression")
    return new Grouping(id, expr, leftParen, rightParen)
```

#### prsMacroDecl (parse2.ts:927-951)

After the scanner change (Phase 2), an EQL token appears between MACRO_VAR and MACRO_STR. The parser must consume it between the variable and content checks. The existing parser uses the `ctx.check()` + `ctx.advance()` pattern (not `ctx.match()`), so we follow the same style:

```
function prsMacroDecl(ctx, prnt_arr):
  // ... parse header unchanged ...
  // ... parse variable unchanged (ctx.check(TT.MACRO_VAR), ctx.advance()) ...

  // NEW: consume the EQL token (inserted between MACRO_VAR and MACRO_STR by the scanner)
  let equals: Token | undefined
  if ctx.check(TT.EQL):
    equals = ctx.advance()               // ← store the consumed =

  // ... parse content unchanged (ctx.check(TT.MACRO_STR), ctx.advance()) ...

  return new Macro_decl(id, header, variable, content, equals)
```

#### prsUserSymbolDecl (parse2.ts)

Same pattern as prsMacroDecl — consume and store the EQL token between the variable and symbol checks.

---

## Phase 4: Formatter Updates

### 4.1 Location

`parse/Visitors/Formatter2.ts`

### 4.2 Pattern

Each formatter method uses the stored token's lexeme when available, with a fallback to the hardcoded string:

```
token?.lexeme ?? "<hardcoded>"
```

### 4.3 Changes per method

#### visitChordExpr (line 224)

Before: `` return `[${str}]${rhythm}${tie}` ``
After: `` return `${expr.leftBracket?.lexeme ?? "["}${str}${expr.rightBracket?.lexeme ?? "]"}${rhythm}${tie}` ``

#### visitGraceGroupExpr (lines 251, 253)

Before:
```
if (expr.isAccacciatura) return `{/${fmt}}`;
else return `{${fmt}}`;
```

After:
```
const lb = expr.leftBrace?.lexeme ?? "{";
const rb = expr.rightBrace?.lexeme ?? "}";
const slash = expr.acciaccaturaSlash?.lexeme ?? (expr.isAccacciatura ? "/" : "");
return `${lb}${slash}${fmt}${rb}`;
```

#### visitInlineFieldExpr (lines 297, 306)

Before: `` return `[${field.lexeme}${...}]` ``
After: `` return `${expr.leftBracket?.lexeme ?? "["}${field.lexeme}${...}${expr.rightBracket?.lexeme ?? "]"}` ``

Applied to both the value2 path (line 297) and the fallback path (line 306).

#### visitTupletExpr (lines 430, 434, 438)

Before:
```
let result = "(" + expr.p.lexeme;
if (expr.q) result += ":" + expr.q.lexeme;
  if (expr.r) result += ":" + expr.r.lexeme;
```

After (uses stored colon tokens as the output trigger, fixing the pre-existing bug where `(3::2` would lose the colons and `r`):
```
let result = (expr.leftParen?.lexeme ?? "(") + expr.p.lexeme;
if (expr.firstColon) {
  result += expr.firstColon.lexeme;
  if (expr.q) result += expr.q.lexeme;
  if (expr.secondColon) {
    result += expr.secondColon.lexeme;
    if (expr.r) result += expr.r.lexeme;
  }
}
```

This fixes the pre-existing formatter limitation: `(3::2` (where `q` is absent but colons and `r` are present) now formats correctly because the output is driven by the presence of colon tokens rather than the presence of `q`/`r` values.

#### visitGrouping (line 506)

Before: `` return "(" + expr.expression.accept(this) + ")" ``
After: `` return (expr.leftParen?.lexeme ?? "(") + expr.expression.accept(this) + (expr.rightParen?.lexeme ?? ")") ``

#### visitMacroDeclExpr (line 456)

Before: `` return expr.header.lexeme + expr.variable.lexeme + "=" + expr.content.lexeme ``
After: `` return expr.header.lexeme + expr.variable.lexeme + (expr.equals?.lexeme ?? "=") + expr.content.lexeme ``

#### visitUserSymbolDeclExpr (line 464)

Before: `` return expr.header.lexeme + expr.variable.lexeme + "=" + expr.symbol.lexeme ``
After: `` return expr.header.lexeme + expr.variable.lexeme + (expr.equals?.lexeme ?? "=") + expr.symbol.lexeme ``

---

## Phase 5: fromAst childrenVisitor Updates

### 5.1 Location

`abct2/src/csTree/fromAst.ts`

### 5.2 Changes

The childrenVisitor must emit delimiter tokens as children in serialization order. Because these fields are optional, we only push them when present.

#### visitChordExpr

Before:
```
return [...expr.contents, expr.rhythm, expr.tie].filter(Boolean)
```

After (serialization order: `[`, contents, `]`, rhythm, tie):
```
visitChordExpr(expr: Chord): ChildList {
  const children: ChildList = [];
  if (expr.leftBracket) children.push(expr.leftBracket);
  children.push(...expr.contents);
  if (expr.rightBracket) children.push(expr.rightBracket);
  if (expr.rhythm) children.push(expr.rhythm);
  if (expr.tie) children.push(expr.tie);
  return children;
}
```

#### visitGraceGroupExpr

Before:
```
return [...expr.notes]
```

After (serialization order: `{`, `/`?, notes, `}`):
```
visitGraceGroupExpr(expr: Grace_group): ChildList {
  const children: ChildList = [];
  if (expr.leftBrace) children.push(expr.leftBrace);
  if (expr.acciaccaturaSlash) children.push(expr.acciaccaturaSlash);
  children.push(...expr.notes);
  if (expr.rightBrace) children.push(expr.rightBrace);
  return children;
}
```

#### visitInlineFieldExpr

Before (after the fix from plan 23):
```
return [...expr.text]
```

After (serialization order: `[`, text tokens, `]`):
```
visitInlineFieldExpr(expr: Inline_field): ChildList {
  const children: ChildList = [];
  if (expr.leftBracket) children.push(expr.leftBracket);
  children.push(...expr.text);
  if (expr.rightBracket) children.push(expr.rightBracket);
  return children;
}
```

Note: `expr.value2` (parsed expressions) is not emitted as children. As established in plan 23, the CS tree uses only the raw token representation (`text`), and the Formatter2 falls back to the text-based path when `value2` is undefined on the reconstructed AST.

#### visitTupletExpr

Before:
```
return [expr.p, expr.q, expr.r].filter(Boolean)
```

After (serialization order: `(`, p, `:`, q?, `:`, r?):
```
visitTupletExpr(expr: Tuplet): ChildList {
  const children: ChildList = [];
  if (expr.leftParen) children.push(expr.leftParen);
  children.push(expr.p);
  if (expr.firstColon) children.push(expr.firstColon);
  if (expr.q) children.push(expr.q);
  if (expr.secondColon) children.push(expr.secondColon);
  if (expr.r) children.push(expr.r);
  return children;
}
```

#### visitGrouping

Before:
```
return [expr.expression]
```

After (serialization order: `(`, expression, `)`):
```
visitGrouping(expr: Grouping): ChildList {
  const children: ChildList = [];
  if (expr.leftParen) children.push(expr.leftParen);
  children.push(expr.expression);
  if (expr.rightParen) children.push(expr.rightParen);
  return children;
}
```

#### visitMacroDeclExpr

Before:
```
return [expr.header, expr.variable, expr.content]
```

After (serialization order: header, variable, `=`, content):
```
visitMacroDeclExpr(expr: Macro_decl): ChildList {
  const children: ChildList = [expr.header, expr.variable];
  if (expr.equals) children.push(expr.equals);
  children.push(expr.content);
  return children;
}
```

#### visitUserSymbolDeclExpr

Same pattern as visitMacroDeclExpr: emit `[header, variable, equals?, symbol]`.

---

## Phase 6: toAst Builder Updates

### 6.1 Location

`abct2/src/csTree/toAst.ts`

### 6.2 Changes

Because delimiter tokens now appear as children in the CS tree, the builder functions must identify them and assign them to the correct Expr fields during reconstruction.

#### buildChord

Children arrive in order: `[leftBracket?, ...contents, rightBracket?, rhythm?, tie?]`. We discriminate delimiters by token type:

```typescript
function buildChord(id: number, children: Array<Expr | Token>): Chord {
  let leftBracket: Token | undefined;
  let rightBracket: Token | undefined;
  const contents: Array<Note | Token | Annotation> = [];
  let rhythm: Rhythm | undefined;
  let tie: Token | undefined;

  for (const child of children) {
    if (child instanceof Token && child.type === TT.CHRD_LEFT_BRKT) {
      leftBracket = child;
    } else if (child instanceof Token && child.type === TT.CHRD_RIGHT_BRKT) {
      rightBracket = child;
    } else if (child instanceof Rhythm) {
      rhythm = child;
    } else if (child instanceof Token && child.type === TT.TIE) {
      tie = child;
    } else {
      contents.push(child as Note | Token | Annotation);
    }
  }
  return new Chord(id, contents, rhythm, tie, leftBracket, rightBracket);
}
```

#### buildGraceGroup

Children arrive in order: `[leftBrace?, acciaccaturaSlash?, ...notes, rightBrace?]`. We discriminate by token type:

```typescript
function buildGraceGroup(node: CSNode, children: Array<Expr | Token>): Grace_group {
  let leftBrace: Token | undefined;
  let rightBrace: Token | undefined;
  let acciaccaturaSlash: Token | undefined;
  const notes: Array<Note | Token> = [];

  for (const child of children) {
    if (child instanceof Token && child.type === TT.GRC_GRP_LEFT_BRACE) {
      leftBrace = child;
    } else if (child instanceof Token && child.type === TT.GRC_GRP_RGHT_BRACE) {
      rightBrace = child;
    } else if (child instanceof Token && child.type === TT.GRC_GRP_SLSH) {
      acciaccaturaSlash = child;
    } else {
      notes.push(child as Note | Token);
    }
  }

  const isAccacciatura = acciaccaturaSlash !== undefined;
  return new Grace_group(node.id, notes, isAccacciatura, leftBrace, rightBrace, acciaccaturaSlash);
}
```

#### buildInlineField

Children arrive in order: `[leftBracket?, ...text, rightBracket?]`. We discriminate by token type:

```typescript
function buildInlineField(id: number, children: Array<Expr | Token>): Inline_field {
  let leftBracket: Token | undefined;
  let rightBracket: Token | undefined;
  const text: Token[] = [];

  for (const child of children) {
    const token = child as Token;
    if (token.type === TT.INLN_FLD_LFT_BRKT) {
      leftBracket = token;
    } else if (token.type === TT.INLN_FLD_RGT_BRKT) {
      rightBracket = token;
    } else {
      text.push(token);
    }
  }

  const field = text[0];
  return new Inline_field(id, field, text, undefined, leftBracket, rightBracket);
}
```

#### buildTuplet

Children arrive in order: `[leftParen?, p, firstColon?, q?, secondColon?, r?]`. We discriminate by token type:

```typescript
function buildTuplet(id: number, children: Array<Expr | Token>): Tuplet {
  let leftParen: Token | undefined;
  let firstColon: Token | undefined;
  let secondColon: Token | undefined;
  let p: Token | undefined;
  let q: Token | undefined;
  let r: Token | undefined;

  let colonCount = 0;
  for (const child of children) {
    const token = child as Token;
    switch (token.type) {
      case TT.TUPLET_LPAREN: leftParen = token; break;
      case TT.TUPLET_COLON:
        if (colonCount === 0) { firstColon = token; colonCount++; }
        else { secondColon = token; }
        break;
      case TT.TUPLET_P: p = token; break;
      case TT.TUPLET_Q: q = token; break;
      case TT.TUPLET_R: r = token; break;
    }
  }
  return new Tuplet(id, p!, q, r, leftParen, firstColon, secondColon);
}
```

#### buildGrouping

Children arrive in order: `[leftParen?, expression, rightParen?]`. We discriminate by token type:

```typescript
function buildGrouping(id: number, children: Array<Expr | Token>): Grouping {
  let leftParen: Token | undefined;
  let rightParen: Token | undefined;
  let expression: Expr | undefined;

  for (const child of children) {
    if (child instanceof Token && child.type === TT.LPAREN) {
      leftParen = child;
    } else if (child instanceof Token && child.type === TT.RPAREN) {
      rightParen = child;
    } else {
      expression = child as Expr;
    }
  }
  return new Grouping(id, expression!, leftParen, rightParen);
}
```

#### buildMacroDecl

Children arrive in order: `[header, variable, equals?, content]`. We discriminate by token type:

```typescript
function buildMacroDecl(id: number, children: Array<Expr | Token>): Macro_decl {
  const header = children[0] as Token;
  const variable = children[1] as Token;
  let equals: Token | undefined;
  let content: Token;

  if (children.length === 4) {
    equals = children[2] as Token;
    content = children[3] as Token;
  } else {
    content = children[2] as Token;
  }
  return new Macro_decl(id, header, variable, content, equals);
}
```

#### buildUserSymbolDecl

Same pattern as buildMacroDecl: `[header, variable, equals?, symbol]`.

---

## Phase 7: GraceGroupData Removal

### 7.1 Rationale

Because the acciaccatura `/` token is now preserved as a child node (`acciaccaturaSlash` field on Grace_group, emitted by childrenVisitor), the CS tree no longer needs the `GraceGroupData` payload. The `isAccacciatura` flag can be derived from the presence of a `GRC_GRP_SLSH` token child.

### 7.2 Location

`abct2/src/csTree/types.ts`

### 7.3 Changes

1. Remove `GraceGroupData` from the `NodeData` union type
2. The union becomes: `type NodeData = TokenData | EmptyData`
3. Grace_group nodes use `EmptyData` like all other compound nodes
4. Remove the `GraceGroupData` interface

### 7.4 Impact on fromAst

The `extractData` function no longer needs the Grace_group special case:

```
extractData(astNode, tag):
  if astNode is Token:
    return { type: "token", lexeme, tokenType, line, position }
  return { type: "empty" }
```

### 7.5 Impact on toAst

The `buildGraceGroup` function no longer reads from a data payload. Instead, it derives `isAccacciatura` from the presence of a GRC_GRP_SLSH child token (already shown in Phase 6).

---

## Tests

### Scanner tests (Phase 2)

- Macro declaration `m:var=content` produces token stream `[MACRO_HDR, MACRO_VAR, EQL, MACRO_STR]`
- User symbol declaration `U:sym=!trill!` produces token stream `[USR_SYM_HDR, USR_SYM_VAR, EQL, USR_SYM_STR]`
- Verify that the EQL token has the correct lexeme `=`, line, and position

### Parser tests (Phase 3)

For each delimiter type, verify the Expr has the delimiter fields populated after parsing:

- `parseChord("[CEG]")` → `chord.leftBracket.lexeme === "["`, `chord.rightBracket.lexeme === "]"`
- `parseGraceGroup("{/CDE}")` → `gg.leftBrace.lexeme === "{"`, `gg.rightBrace.lexeme === "}"`, `gg.acciaccaturaSlash.lexeme === "/"`
- `parseGraceGroup("{CDE}")` → `gg.acciaccaturaSlash === undefined`
- `parseInlineField("[K:Am]")` → `inf.leftBracket.lexeme === "["`, `inf.rightBracket.lexeme === "]"`
- `parseTuplet("(3:2:3")` → `tup.leftParen.lexeme === "("`, `tup.firstColon.lexeme === ":"`, `tup.secondColon.lexeme === ":"`
- `parseTuplet("(3")` → `tup.leftParen` set, `tup.firstColon === undefined`
- Grouping `(2+3)` → `grp.leftParen.lexeme === "("`, `grp.rightParen.lexeme === ")"`
- `prsMacroDecl("m:var=content")` → `macro.equals.lexeme === "="`

### Formatter tests (Phase 4)

- Formatting Exprs WITH delimiter fields produces the stored lexeme
- Formatting Exprs WITHOUT delimiter fields (undefined) produces the hardcoded fallback
- Both paths produce identical output for standard delimiters

### Roundtrip tests (Phase 5-6)

Using the roundtrip property from plan 23 (`roundtrip(source) === format(parse(source))`), verify that delimiter tokens survive the full pipeline:

- `[CEG]2-` roundtrips correctly (brackets as children, then back to Chord fields)
- `{/CDE}` roundtrips correctly (braces and slash as children)
- `[K:Am]` roundtrips correctly (inline field brackets as children)
- `(3:2:3` roundtrips correctly (paren and colons as children)
- `L:1/(2+3)` roundtrips correctly (grouping parens as children)
- `m:var=content` roundtrips correctly (equals as child)

### CS tree structure tests

- Verify that a Chord CS node has `CHRD_LEFT_BRKT` and `CHRD_RIGHT_BRKT` Token children at positions 0 and N-3 (before rhythm/tie)
- Verify that a Grace_group CS node has `GRC_GRP_LEFT_BRACE` as first child and `GRC_GRP_RGHT_BRACE` as last child
- Verify that a Tuplet CS node has `TUPLET_LPAREN` as first child

### GraceGroupData removal tests

- Verify that Grace_group nodes use EmptyData after the removal
- Verify that `isAccacciatura` is correctly derived from the slash token's presence in toAst

---

## Implementation Checklist

1. Update `parse/types/Expr2.ts`:
   - Add optional delimiter Token fields to Chord, Grace_group, Inline_field, Tuplet, Grouping, Macro_decl, User_symbol_decl
   - Add new constructor params (all optional, appended at end for backward compat)
2. Update `parse/parsers/scan2.ts`:
   - Modify `macro_decl` function: emit EQL token for `=` via `advance(ctx)` + `ctx.push(TT.EQL)`
   - Modify `user_symbol_decl` function: same change
   - Fix token lookback offset in both functions: `ctx.tokens[ctx.tokens.length - 2]` → `-3` (because EQL is now between variable and content)
3. Update `parse/parsers/parse2.ts`:
   - `parseChord`: store leftBracket and rightBracket via `ctx.previous()`
   - `parseGraceGroup`: store leftBrace, rightBrace, acciaccaturaSlash
   - `parseInlineField`: store leftBracket, rightBracket
   - `parseTuplet`: store leftParen, firstColon, secondColon
   - `prsMacroDecl`: consume and store EQL token
   - `prsUserSymbolDecl`: consume and store EQL token
4. Update `parse/parsers/infoLines/parseInfoLine2.ts`:
   - `parsePrimary`: store leftParen, rightParen for Grouping (changes error recovery: missing `)` now returns partial Grouping instead of null)
5. Update `parse/Visitors/Formatter2.ts`:
   - `visitChordExpr`: use `expr.leftBracket?.lexeme ?? "["` pattern
   - `visitGraceGroupExpr`: use stored brace/slash tokens with fallback
   - `visitInlineFieldExpr`: use stored bracket tokens with fallback (both paths)
   - `visitTupletExpr`: use stored paren/colon tokens as output triggers (fixes `(3::2` bug)
   - `visitGrouping`: use stored paren tokens with fallback
   - `visitMacroDeclExpr`: use stored equals token with fallback
   - `visitUserSymbolDeclExpr`: use stored equals token with fallback
6. Update `abct2/src/csTree/fromAst.ts`:
   - Update childrenVisitor for all 7 cases: emit delimiter tokens in serialization order
7. Update `abct2/src/csTree/toAst.ts`:
   - Update builder functions for all 7 cases: discriminate delimiter tokens by type, assign to Expr fields
8. Update `abct2/src/csTree/types.ts`:
   - Remove `GraceGroupData` from `NodeData` union
   - Grace_group nodes use EmptyData
9. Update `abct2/src/csTree/fromAst.ts` (extractData):
   - Remove Grace_group special case
10. Write scanner tests for EQL token emission
11. Write parser tests for delimiter field population
12. Write formatter tests for stored-token vs fallback paths
13. Write roundtrip tests for all 7 delimiter types
14. Write CS tree structure tests
15. Run full test suite: `npm run test`
16. Run build: `npm run build`
17. Call the code review agent on all modified files. Address feedback.
18. Commit once build passes and all tests pass.

---

## Critical Files

- `parse/types/Expr2.ts` — Expr class definitions (to be modified)
- `parse/parsers/scan2.ts` — Scanner, macro/user-symbol tokenization (to be modified)
- `parse/parsers/parse2.ts` — Parser functions for Chord, Grace_group, Inline_field, Tuplet, Macro, UserSymbol (to be modified)
- `parse/parsers/infoLines/parseInfoLine2.ts` — parsePrimary for Grouping (to be modified)
- `parse/Visitors/Formatter2.ts` — Formatter methods (to be modified)
- `abct2/src/csTree/fromAst.ts` — childrenVisitor, extractData (to be modified)
- `abct2/src/csTree/toAst.ts` — builder functions (to be modified)
- `abct2/src/csTree/types.ts` — NodeData union, GraceGroupData removal (to be modified)
