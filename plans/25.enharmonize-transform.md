# ABCt2 Enharmonize Transform

## Table of Contents

1. [Goal](#goal)
2. [Context and Prerequisites](#context-and-prerequisites)
3. [The Flat-Spelling Function](#the-flat-spelling-function)
4. [Phase 1: enharmonize](#phase-1-enharmonize)
5. [Assumptions](#assumptions)
6. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are adding an `enharmonize` transform to the ABCt2 transform library. This transform toggles the accidental spelling of selected notes between their sharp and flat enharmonic equivalents. For instance, `^C` (C#) becomes `_D` (Db), and `_E` (Eb) becomes `^D` (D#).

The transform:
- Only acts on notes that carry an explicit sharp, flat, double-sharp, or double-flat accidental. Notes without an accidental (or with a natural `=`) are left unchanged.
- Toggles direction: sharp/double-sharp spellings become flat spellings, and flat/double-flat spellings become sharp spellings.
- When a Chord is selected, enharmonizes each Note child within it (same pattern as the `transpose` transform).

---

## Context and Prerequisites

### Dependency on plan 22

This plan depends on the transform infrastructure from plan 22 (the ABCt2 transforms plan). Plan 22 phases 1 and 2 (types.ts and treeUtils.ts) must be implemented before this plan can proceed. Specifically, this plan relies on:

- `findNodesById(root, cursor)` from `abct2/src/transforms/types.ts`
- `findChildByTag`, `replaceChild` from `abct2/src/transforms/treeUtils.ts`
- The `toAst`/`fromAst` bridge pattern
- The `Selection` type and `ABCContext` parameter convention
- The `toCSTreeWithContext` test helper from `abct2/tests/helpers.ts` (defined in plan 22's test infrastructure section), which returns both the CS tree root and the `ABCContext` so that transforms can generate non-colliding IDs

### How accidentals are represented in the CS tree

A Note's Pitch child has the structure `[Alteration?, NoteLetter, Octave?]`. The Alteration token (when present) has `tokenType == TT.ACCIDENTAL` and a lexeme that is one of: `^`, `^^`, `_`, `__`, `=`.

To determine the accidental direction of a note, the transform inspects the Alteration token's lexeme:
- Starts with `^` (i.e. `^` or `^^`): sharp direction
- Starts with `_` (i.e. `_` or `__`): flat direction
- Is `=` or absent: no enharmonization (node is skipped)

### How the toggle works

The toggle uses the toAst/fromAst bridge combined with `toMidiPitch`:

1. Convert the Pitch CSNode to a Pitch Expr via `toAst`
2. Get the MIDI value via `toMidiPitch`
3. If the accidental is sharp/double-sharp: respell using a flat-spelling function (`fromMidiPitchFlat`)
4. If the accidental is flat/double-flat: respell using `fromMidiPitch` (which produces sharps)
5. Convert the resulting Pitch Expr back to a CSNode via `fromAst`
6. Replace the old Pitch child with the new one

### Enharmonic edge cases

Some enharmonic conversions produce notes without accidentals:
- `^^C` (C double-sharp) = D natural (MIDI pitch class 2). The flat spelling of pitch class 2 is D with no accidental.
- `__D` (D double-flat) = C natural (MIDI pitch class 0). The sharp spelling of pitch class 0 is C with no accidental.
- `^E` (E sharp) = F natural. The flat spelling of pitch class 5 is F with no accidental.
- `_F` (F flat) = E natural. The sharp spelling of pitch class 4 is E with no accidental.
- `^B` (B sharp) = C natural (one octave up). The flat spelling of pitch class 0 is C with no accidental.
- `_C` (C flat) = B natural (one octave down). The sharp spelling of pitch class 11 is B with no accidental.

These cases are handled naturally by the MIDI-based approach: the MIDI value already encodes the correct octave, and the spelling tables produce the correct note letter without an accidental when no accidental is needed.

---

## The Flat-Spelling Function

Because `fromMidiPitch` (in `parse/Visitors/Transposer.ts`) always produces sharp spellings, the enharmonize transform needs a counterpart that produces flat spellings. This function is defined locally in the `enharmonize.ts` file because no other transform needs it. It is exported (following the project's "everything public" convention), which also allows direct unit testing of the flat-spelling logic if needed. However, the primary testing strategy is indirect: the enharmonize tests exercise `fromMidiPitchFlat` through the transform's behavior.

### 3.1 The flat pitch-class mapping

```
FLAT_SPELLING (pitch class -> { letter, accidental }):
  0  -> { letter: "C", accidental: null }
  1  -> { letter: "D", accidental: "_" }
  2  -> { letter: "D", accidental: null }
  3  -> { letter: "E", accidental: "_" }
  4  -> { letter: "E", accidental: null }
  5  -> { letter: "F", accidental: null }
  6  -> { letter: "G", accidental: "_" }
  7  -> { letter: "G", accidental: null }
  8  -> { letter: "A", accidental: "_" }
  9  -> { letter: "A", accidental: null }
  10 -> { letter: "B", accidental: "_" }
  11 -> { letter: "B", accidental: null }
```

This mapping differs from `fromMidiPitch`'s sharp mapping only on the black keys (pitch classes 1, 3, 6, 8, 10), where the sharp mapping produces `^C, ^D, ^F, ^G, ^A` and the flat mapping produces `_D, _E, _G, _A, _B`.

### 3.2 fromMidiPitchFlat

```typescript
function fromMidiPitchFlat(midiPitch: number, ctx: ABCContext): Pitch
```

The algorithm mirrors `fromMidiPitch` exactly (same octave logic, same token creation pattern), but uses the flat spelling table instead of the sharp spelling table:

```
fromMidiPitchFlat(midiPitch, ctx):
  pitchClass = midiPitch % 12
  { letter, accidental } = FLAT_SPELLING[pitchClass]

  midiOctave = floor(midiPitch / 12) - 1

  // Octave 4 and below: uppercase letters
  if midiOctave <= 4:
    noteLetterToken = Token(TT.NOTE_LETTER, letter, ctx.generateId())
    if midiOctave < 4:
      octaveToken = Token(TT.OCTAVE, ",".repeat(4 - midiOctave), ctx.generateId())
  // Octave 5 and above: lowercase letters
  else:
    noteLetterToken = Token(TT.NOTE_LETTER, letter.toLowerCase(), ctx.generateId())
    if midiOctave > 5:
      octaveToken = Token(TT.OCTAVE, "'".repeat(midiOctave - 5), ctx.generateId())

  if accidental:
    accidentalToken = Token(TT.ACCIDENTAL, accidental, ctx.generateId())

  return new Pitch(ctx.generateId(), {
    alteration: accidentalToken,
    noteLetter: noteLetterToken,
    octave: octaveToken
  })
```

### 3.3 Imports needed in enharmonize.ts

| Utility | Location | Purpose |
| --- | --- | --- |
| `toMidiPitch` | `parse/Visitors/Formatter2.ts` | Convert Pitch Expr to MIDI value |
| `fromMidiPitch` | `parse/Visitors/Transposer.ts` | Convert MIDI to sharp-spelled Pitch Expr (for flat-to-sharp toggle) |
| `Pitch` | `parse/types/Expr2.ts` | Pitch Expr class |
| `Token`, `TT` | `parse/parsers/scan2.ts` | Token creation |
| `ABCContext` | `parse/parsers/Context.ts` | ID generation |
| `CSNode`, `TAGS`, `isTokenNode`, `getTokenData` | `abct2/src/csTree/types.ts` | CS tree types |
| `fromAst` | `abct2/src/csTree/fromAst.ts` | Expr to CSNode conversion |
| `toAst` | `abct2/src/csTree/toAst.ts` | CSNode to Expr conversion |
| `Selection` | `abct2/src/selection.ts` | Selection type |
| `findNodesById` | `abct2/src/transforms/types.ts` | Node lookup by cursor IDs |
| `findChildByTag`, `replaceChild` | `abct2/src/transforms/treeUtils.ts` | Tree manipulation |

---

## Phase 1: enharmonize

### 1.1 Location

`abct2/src/transforms/enharmonize.ts`

### 1.2 Interface

```typescript
function enharmonize(selection: Selection, ctx: ABCContext): Selection
```

### 1.3 Algorithm

```
enharmonize(selection, ctx):
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes:
      if csNode.tag == TAGS.Note:
        enharmonizePitchChild(csNode, ctx)
      else if csNode.tag == TAGS.Chord:
        current = csNode.firstChild
        while current != null:
          if current.tag == TAGS.Note:
            enharmonizePitchChild(current, ctx)
          current = current.nextSibling
  return selection

enharmonizePitchChild(noteNode, ctx):
  pitchResult = findChildByTag(noteNode, TAGS.Pitch)
  if pitchResult == null: return

  pitchCSNode = pitchResult.node

  // Walk the Pitch's children to find the Alteration token (TT.ACCIDENTAL)
  alterationToken = null
  current = pitchCSNode.firstChild
  while current != null:
    if isTokenNode(current) AND getTokenData(current).tokenType == TT.ACCIDENTAL:
      alterationToken = current
      break
    current = current.nextSibling

  if alterationToken == null: return  // No accidental, skip

  lexeme = getTokenData(alterationToken).lexeme
  if lexeme == "=": return  // Natural accidental, skip

  // Determine the direction and choose the respelling function
  pitchExpr = toAst(pitchCSNode) as Pitch
  midiPitch = toMidiPitch(pitchExpr)

  newPitchExpr = null
  if lexeme.startsWith("^"):
    // Sharp or double-sharp: respell as flat
    newPitchExpr = fromMidiPitchFlat(midiPitch, ctx)
  else if lexeme.startsWith("_"):
    // Flat or double-flat: respell as sharp
    newPitchExpr = fromMidiPitch(midiPitch, ctx)

  if newPitchExpr == null: return

  // Convert the new Pitch Expr to a CSNode and replace in the tree
  newPitchCSNode = fromAst(newPitchExpr)
  replaceChild(noteNode, pitchResult.prev, pitchCSNode, newPitchCSNode)
```

### 1.4 Re-export

Add `enharmonize` to the re-exports in `abct2/src/transforms/index.ts`.

### 1.5 Tests

Test file: `abct2/tests/enharmonize.spec.ts`

Property-based:
- After `enharmonize`, every selected note's MIDI pitch (via `toAst` on the resulting Pitch CSNode, then `toMidiPitch` on that Expr) equals its original MIDI pitch.
- For any note with a single sharp (`^`) or single flat (`_`), applying `enharmonize` twice produces the same formatted output as the original (because single-sharp ↔ single-flat is a true involution).
- For any note with a double-accidental (`^^` or `__`) whose result has no accidental (e.g. `^^C` → `D`), applying `enharmonize` a second time leaves it unchanged (because notes without accidentals are skipped). However, when a double-accidental resolves to a note that still carries an accidental (e.g. `^^E` → `_G`), the second application toggles it again (producing `^F`). The property test should only assert idempotence-on-second-application for the natural-result sub-case.
- `enharmonize` on a note without an accidental leaves the formatted output unchanged.
- `enharmonize` preserves the rhythm of the note (the Rhythm child is untouched).
- `enharmonize` preserves the tie of the note (the Tie token is untouched).

Example-based (sharp to flat):
- `^C` (C#) becomes `_D` (Db)
- `^D` (D#) becomes `_E` (Eb)
- `^F` (F#) becomes `_G` (Gb)
- `^G` (G#) becomes `_A` (Ab)
- `^A` (A#) becomes `_B` (Bb)

Example-based (flat to sharp):
- `_D` (Db) becomes `^C` (C#)
- `_E` (Eb) becomes `^D` (D#)
- `_G` (Gb) becomes `^F` (F#)
- `_A` (Ab) becomes `^G` (G#)
- `_B` (Bb) becomes `^A` (A#)

Example-based (double accidentals):
- `^^C` (C double-sharp = D) becomes `D` (natural, no accidental)
- `^^D` (D double-sharp = E) becomes `E` (natural, no accidental)
- `^^E` (E double-sharp = F#) becomes `_G` (Gb; note this still has an accidental)
- `__D` (D double-flat = C) becomes `C` (natural, no accidental)
- `__E` (E double-flat = D) becomes `D` (natural, no accidental)
- `__A` (A double-flat = G) becomes `G` (natural, no accidental)

Example-based (double-accidental that resolves to accidental, then toggled again):
- `^^E` → `_G` (first application). Then `_G` → `^F` (second application). This demonstrates that the transform is not idempotent for double-accidentals that resolve to black keys.

Example-based (octave boundary crossings):
- `^B` (uppercase B = octave 4, B# = C in octave 5): becomes `c` (lowercase = octave 5)
- `_c` (lowercase c = octave 5, Cb = B in octave 4): becomes `B` (uppercase = octave 4)
- `^b` (lowercase b = octave 5, B# = C in octave 6): becomes `c'` (lowercase with apostrophe = octave 6)
- `_C` (uppercase C = octave 4, Cb = B in octave 3): becomes `B,` (uppercase with comma = octave 3)

Example-based (skipped notes):
- `C` (no accidental): unchanged
- `=C` (natural): unchanged
- `D2` (no accidental, has rhythm): unchanged

Example-based (chords):
- `[^F^A^C]` (F# A# C# = Gb major chord): becomes `[_G_B_D]`
- `[^C^E^G]`: because `^E` (E#) = pitch class 5 = F (no accidental), the result is `[_DF_A]` (each Note child is enharmonized independently)

Example-based (rhythm and tie preservation):
- `^C2` becomes `_D2` (rhythm preserved)
- `^C-` becomes `_D-` (tie preserved)
- `^C2>` becomes `_D2>` (rhythm with broken token preserved)

Example-based (notes inside a Beam):
- A beamed group containing `^C^D^E` with cursor selecting the middle note: only `^D` becomes `_E`, the others are unchanged

Example-based (multiple cursors):
- Two cursors selecting different notes: both are enharmonized independently

---

## Assumptions

- The CS tree is well-formed (produced by the parser). We do not guard against malformed Pitch nodes missing a NoteLetter child.
- The MIDI values produced by `toMidiPitch` are always in a valid range (0-127) because they originate from parsed notes. No range clamping is needed in `fromMidiPitchFlat`.
- The `fromMidiPitchFlat` function mirrors the octave logic of `fromMidiPitch`. If `fromMidiPitch` changes in the future, `fromMidiPitchFlat` must be updated to match.

---

## Implementation Checklist

Prerequisite: plan 22 phases 1 and 2 (types.ts and treeUtils.ts) must be implemented before this plan can proceed.

1. Create the file `abct2/src/transforms/enharmonize.ts` and the test file `abct2/tests/enharmonize.spec.ts`.
2. Implement `fromMidiPitchFlat` (local to the module) following section 3.2.
3. Implement `enharmonize` following section 1.3.
4. Add the re-export to `abct2/src/transforms/index.ts`.
5. Write all tests (property-based and example-based) following section 1.5.
6. Run tests: `npm run test -w abct2`
7. Run full test suite: `npm run test`
8. Run build: `npm run build`
9. Call the code review agent. Address any feedback.
10. Commit once the build passes and all tests pass.

Copy the plan file into the plans directory, and once you are done with the implementation of each of the phases of the plan, make sure to call the code review agent on the current phase and address any feedback that the code review agent might have. After you are done with the feedback and all the tests are passing, commit the changes and then move onto the next phase. Do this until finished.

---

## Critical Files

- `abct2/src/transforms/types.ts` -- TransformFn type, findNodesById
- `abct2/src/transforms/treeUtils.ts` -- findChildByTag, replaceChild
- `abct2/src/csTree/types.ts` -- CSNode, TAGS, isTokenNode, getTokenData
- `abct2/src/csTree/fromAst.ts` -- Expr to CSNode conversion
- `abct2/src/csTree/toAst.ts` -- CSNode to Expr conversion
- `abct2/src/selection.ts` -- Selection type
- `parse/types/Expr2.ts` -- Pitch Expr class
- `parse/parsers/scan2.ts` -- Token, TT (TokenType)
- `parse/parsers/Context.ts` -- ABCContext
- `parse/Visitors/Formatter2.ts` -- toMidiPitch
- `parse/Visitors/Transposer.ts:339` -- fromMidiPitch
