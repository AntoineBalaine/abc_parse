# Missing Selectors for abct2

## Table of Contents

1. [Goal](#goal)
2. [Selectors to Implement](#selectors-to-implement)
3. [Phase 1: Utility Functions](#phase-1-utility-functions)
4. [Phase 2: selectVoice](#phase-2-selectvoice)
5. [Phase 3: selectRange](#phase-3-selectrange)
6. [Phase 4: selectSiblingsAfter](#phase-4-selectsiblingsafter)
7. [Implementation Checklist](#implementation-checklist)

---

## Goal

Three selectors from the language design (plan 18) are missing from the abct2 runtime. This plan covers their implementation. The `select-system` selector is intentionally excluded because it is not essential.

---

## Selectors to Implement

| Selector              | Signature                                                                                               | Description                                                                      |
| --------------------- | ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `selectVoice`         | `(input: Selection, voiceId: string) => Selection`                                                      | Narrows to nodes that belong to the specified voice                              |
| `selectRange`         | `(input: Selection, startLine: number, startCol: number, endLine: number, endCol: number) => Selection` | Narrows to nodes whose source span falls within the given range                  |
| `selectSiblingsAfter` | `(input: Selection, predicate: (node: CSNode) => boolean) => Selection`                                 | For each selected node, collects the nextSibling chain while the predicate holds |

---

## Phase 1: Utility Functions

### 1.1 Location

`abct2/src/selectors/treeWalk.ts` (new file)

### 1.2 Rationale

Both `selectVoice` and `selectRange` need to find the first (and for range, the last) Token descendant of a CSNode in order to read source position data. Because this traversal logic is shared, we extract it into utility functions.

### 1.3 Functions to Create

```typescript
import { CSNode, isTokenNode, TokenData, getTokenData } from "../csTree/types";

// Returns the TokenData of the leftmost Token descendant, or null if the node
// has no Token descendants. We walk depth-first, always preferring firstChild
// then nextSibling.
function firstTokenData(node: CSNode): TokenData | null

// Returns the TokenData of the rightmost Token descendant, or null if the node
// has no Token descendants. We walk depth-first but always pick the last sibling
// at each level, then the last child.
function lastTokenData(node: CSNode): TokenData | null
```

`firstTokenData` walks the leftmost path:
```
current = node
while current is not null
  if current is a token node
    return getTokenData(current)
  current = current.firstChild
return null
```

`lastTokenData` walks the subtree and returns the last token found. Because the CS tree has no `previousSibling` pointers, we cannot efficiently walk right-to-left. Instead, we walk left-to-right recursively and keep updating the result:
```
function lastTokenData(node):
  if node is a token node
    return getTokenData(node)

  lastResult = null
  child = node.firstChild
  while child is not null
    result = lastTokenData(child)
    if result is not null
      lastResult = result
    child = child.nextSibling
  return lastResult
```

This is O(n) in the subtree size, which is acceptable because the subtrees on which this is called (Note, Chord, Beam, etc.) are small.

These functions are exported so that they can be used by both `selectRange` and tests.

### 1.4 Position Comparison Helper

Because `selectRange` needs to compare (line, col) tuples, we add a helper:

```typescript
// Returns negative if a is before b, 0 if equal, positive if a is after b.
function comparePositions(
  aLine: number, aCol: number,
  bLine: number, bCol: number
): number {
  if (aLine !== bLine) return aLine - bLine;
  return aCol - bCol;
}
```

### 1.5 Node Lookup by ID

Because the CS tree has no parent pointers, `selectSiblingsAfter` needs to locate a node by its ID. The `findById` function already exists in the test helpers; we add a production version here.

A naive `findNodeById` that walks the tree on every call would be O(T) per lookup (where T is the tree size). Because `selectSiblingsAfter` calls this for each ID in each cursor, the total cost would be O(N * M * T) which is unacceptable for large trees. Instead, we provide a `buildIdMap` function that walks the tree once and produces a `Map<number, CSNode>`, bringing the cost down to O(T + N*M).

```typescript
// Walks the tree once and builds a lookup map from node ID to CSNode.
export function buildIdMap(root: CSNode): Map<number, CSNode>

// Finds the node with the given ID by depth-first walking from root.
// Returns null if not found. Use buildIdMap when multiple lookups are needed.
export function findNodeById(root: CSNode, id: number): CSNode | null
```

### 1.6 Tests

Test file: `abct2/tests/treeWalk.spec.ts`

Example-based tests:
- `firstTokenData` on a single Token CSNode returns that token's data.
- `firstTokenData` on a Note CSNode (which has Pitch > noteLetter as its leftmost token descendant) returns the noteLetter token's data.
- `firstTokenData` on a CSNode with no Token descendants (a purely structural node with only EmptyData children) returns null.
- `lastTokenData` on a Note with a Rhythm child returns the last token in the Rhythm subtree.
- `lastTokenData` on a Chord returns the rightmost token (the tie token if present, otherwise the rhythm's last token, otherwise the last note's last token).
- `comparePositions(1, 5, 1, 10)` returns negative (same line, a before b).
- `comparePositions(2, 0, 1, 99)` returns positive (a is on a later line).
- `comparePositions(3, 7, 3, 7)` returns 0.
- `findNodeById` returns the correct node when it exists.
- `findNodeById` returns null when the ID is not in the tree.
- `buildIdMap` produces a map whose size equals the total number of nodes in the tree.
- `buildIdMap` entries are consistent with `findNodeById` (same results for any given ID).

Property-based tests:
- For any parsed ABC tune, `firstTokenData(root)` is never null (because a parsed file always has at least one token).
- For any node where `firstTokenData` returns non-null, the returned token's line and position are <= those of any other token descendant.
- For any node where `lastTokenData` returns non-null, the returned token's line and position are >= those of any other token descendant.

---

## Phase 2: selectVoice

### 2.1 Location

`abct2/src/selectors/voiceSelector.ts` (new file)

### 2.2 Algorithm

Because voice identity in ABC is implicit (determined by the sequential position of voice markers in the tune body), the selector walks the Tune_Body's direct children and tracks which voice is "active." Nodes between one voice marker and the next belong to that voice.

Voice markers come in two forms in the CS tree (both are direct children of the Tune_Body node after flattening):
- `Inline_field` nodes: inline `[V:id]` markers within a music line
- `Info_line` nodes: standalone `V:id` lines in the tune body

The walk happens in two stages:
1. Find all Tune_Body nodes in the tree (unconditionally — see composability note below).
2. For each Tune_Body, walk its direct children (the sibling chain under `firstChild`), tracking voice switches. Collect nodes that match the requested voice ID.

### 2.3 Composability

Unlike other selectors that respect the input cursor's scope, `selectVoice` always walks from the root to find all Tune_Body nodes. Because voice identity is a property of the sequential structure of the tune body, it cannot be determined from an arbitrary subset of nodes. If the input has cursors pointing at individual notes (e.g., after a `selectRange`), there is no way to determine which voice those notes belong to without scanning the full tune body.

Therefore, `selectVoice` ignores the input cursor's scope and always operates on the full tree. The output cursors contain individual content node IDs that belong to the specified voice.

### 2.4 Detecting Voice Markers

In the CS tree, the scanner produces the `[` and `]` brackets as separate tokens (`INLN_FLD_LFT_BRKT` / `INLN_FLD_RGT_BRKT`). The `parseInlineField` function consumes the `[` bracket and then advances to get the `INF_HDR` token. Because the `fromAst` visitor for `Inline_field` returns `[...expr.text]` and `text[0]` is the `field` token (the `INF_HDR`), the first child of an `Inline_field` CS node has lexeme `V:` (without the bracket).

For standalone `Info_line` voice declarations, the `fromAst` visitor returns `[expr.key, ...expr.value]`. The first child (`key`) is the `INF_HDR` token with lexeme `V:`.

To detect a voice marker (works for both forms):
```
function isVoiceMarker(node):
  if node.tag !== TAGS.Inline_field AND node.tag !== TAGS.Info_line
    return false
  if node.firstChild is not a token node
    return false
  return getTokenData(node.firstChild).lexeme.trim() === "V:"
```

To extract the voice ID:
```
function extractVoiceId(node):
  secondChild = node.firstChild.nextSibling
  if secondChild is not a token node
    return null
  // The voice ID is the first whitespace-delimited word of the second child's lexeme,
  // because the rest may contain properties (name="Trumpet" clef=treble)
  return getTokenData(secondChild).lexeme.trim().split(/\s+/)[0]
```

### 2.5 Walk Context and Logic

```typescript
interface VoiceWalkCtx {
  targetVoice: string;
  outputCursors: Set<number>[];
}
```

The walk function:
```
function walkForVoice(ctx, root):
  // find all Tune_Body nodes in the tree (unconditionally)
  for each Tune_Body node reachable from root:
    currentVoice = null
    child = tuneBody.firstChild
    while child is not null
      if isVoiceMarker(child)
        currentVoice = extractVoiceId(child)
      else if currentVoice === ctx.targetVoice
        outputCursors.push(new Set([child.id]))
      child = child.nextSibling
```

Because nodes before any voice marker have `currentVoice = null`, they are not selected by any voice selector. This matches ABC semantics: in a multi-voice tune, content before the first voice marker is ambiguous and typically belongs to a default voice. If needed, a convention can be added later (e.g., treating null as voice "1").

### 2.6 Export

```typescript
export function selectVoice(input: Selection, voiceId: string): Selection
```

### 2.7 Tests

Test file: `abct2/tests/voiceSelector.spec.ts`

Example-based tests:
- Single-voice tune (no voice markers) — selectVoice returns empty cursors for any voice ID.
- Two-voice tune with inline fields (`[V:1]CDE| [V:2]GAB|`) — selectVoice("1") returns only nodes between `[V:1]` and `[V:2]`.
- Two-voice tune with inline fields — selectVoice("2") returns only nodes after `[V:2]`.
- Two-voice tune with standalone Info_line markers (`V:1\nCDE|\nV:2\nGAB|`) — selectVoice("1") returns only nodes between the two V: lines.
- Voice ID with properties (`[V:T1 name="Trumpet" clef=treble]`) — selectVoice("T1") matches (only first word is the ID).
- Voice spanning multiple lines: the same voice ID appearing on separate lines collects nodes from all occurrences.
- Composition: selectVoice then selectChords narrows to chords within a voice.
- Composability: selectVoice ignores the input cursor scope (passing a cursor that points at individual notes still works because the selector walks from root).

Property-based tests:
- Selecting a voice that doesn't exist always returns empty cursors.
- The union of all voice selections covers all non-voice-marker children of the Tune_Body (no node belongs to two voices, and voice markers themselves are not selected).

---

## Phase 3: selectRange

### 3.1 Location

`abct2/src/selectors/rangeSelector.ts` (new file)

### 3.2 Algorithm

For each node in scope of the current cursor, we determine whether its source span is fully contained within the specified range. A node's source span is defined by the position of its first and last token descendants.

The range bounds use exclusive end semantics: `endLine`/`endCol` is the first position AFTER the range. This matches standard text editor range conventions (e.g., LSP ranges) and pairs naturally with `position + lexeme.length` which is the exclusive end of a token.

A node is "within range" when:
- Its first token's (line, position) >= (startLine, startCol)
- Its last token's (line, position + lexeme.length) <= (endLine, endCol)

Nodes that have no token descendants (purely structural nodes with no leaves) are skipped.

### 3.3 Walk Context and Logic

```typescript
interface RangeWalkCtx {
  startLine: number;
  startCol: number;
  endLine: number;
  endCol: number;
  cursor: Set<number>;
  outputCursors: Set<number>[];
}
```

The outer loop iterates over all input cursors, as per the standard pattern used by all other selectors:
```
function selectRange(input, startLine, startCol, endLine, endCol):
  outputCursors = []
  for each cursor in input.cursors
    ctx = { startLine, startCol, endLine, endCol, cursor, outputCursors }
    walkRange(ctx, input.root, false)
  return { root: input.root, cursors: outputCursors }
```

The walk function recurses through the tree. For each node in scope, it checks containment. If a node is fully contained, it is selected (and we do not recurse into its children, because selecting the parent implies the children). If a node is partially overlapping, we recurse into its children to find the contained sub-nodes.

Note: the "do not recurse" optimization means that if the input cursor contains both a parent node ID and its child node IDs, only the parent will be selected (not the children individually). This is acceptable because selecting a parent semantically includes its children.

```
function walkRange(ctx, node, inScope):
  current = node
  while current is not null
    nowInScope = inScope OR ctx.cursor.has(current.id)

    if nowInScope
      first = firstTokenData(current)
      last = lastTokenData(current)
      if first and last
        nodeStart = (first.line, first.position)
        nodeEnd = (last.line, last.position + last.lexeme.length)
        if comparePositions(nodeStart) >= comparePositions(rangeStart)
           AND comparePositions(nodeEnd) <= comparePositions(rangeEnd)
          ctx.outputCursors.push(new Set([current.id]))
          // do not recurse: the whole subtree is in range
          current = current.nextSibling
          continue
        else if comparePositions(nodeEnd) < comparePositions(rangeStart)
                OR comparePositions(nodeStart) > comparePositions(rangeEnd)
          // entirely outside: skip subtree
          current = current.nextSibling
          continue

    // partial overlap or not yet in scope: recurse into children
    if current.firstChild
      walkRange(ctx, current.firstChild, nowInScope)

    current = current.nextSibling
```

### 3.4 Export

```typescript
export function selectRange(
  input: Selection,
  startLine: number,
  startCol: number,
  endLine: number,
  endCol: number
): Selection
```

### 3.5 Tests

Test file: `abct2/tests/rangeSelector.spec.ts`

Example-based tests:
- Range covering the whole file (line 0, col 0 to beyond the last token) — all top-level nodes are selected.
- Range covering a single note (endCol = startCol + lexeme.length, exclusive end) — only that note is selected.
- Range covering half a line — only fully contained nodes are selected, partially-overlapping nodes are not.
- Empty range (startLine > endLine) — returns empty cursors.
- Exclusive-end boundary: a range whose endCol lands exactly at a token's start position does NOT include that token.
- Composition: selectRange then selectNotes narrows to notes within the range.

Property-based tests:
- Selected nodes' token positions are always within the given range (firstTokenData >= start, lastTokenData end <= range end).
- Range covering everything returns at least as many cursors as a type selector on the same input.

---

## Phase 4: selectSiblingsAfter

### 4.1 Location

`abct2/src/selectors/siblingSelector.ts` (new file)

### 4.2 Algorithm

For each node ID in the current cursor, we locate that node in the tree, then walk its `nextSibling` chain collecting nodes while the predicate returns true. Each collected node becomes a new single-ID cursor in the output.

The predicate is a TypeScript function `(node: CSNode) => boolean`. The walk stops as soon as the predicate returns false for a sibling.

Note: the language design (plan 18) mentions "stops at bar lines or when predicate fails" as if bar-line stopping were a built-in behavior. In this implementation, bar-line stopping is the caller's responsibility — they pass `(n) => !isBarLine(n)` as the predicate. This keeps the selector generic and composable.

### 4.3 Walk Logic

Because `selectSiblingsAfter` needs to look up potentially many node IDs, it builds the lookup map once at the start using `buildIdMap` from `treeWalk.ts` (O(T) to build, O(1) per lookup afterward). Multi-ID cursors are handled by iterating over each ID independently; each produces its own sibling chain.

```
function selectSiblingsAfter(input, predicate):
  idMap = buildIdMap(input.root)
  outputCursors = []
  for each cursor in input.cursors
    for each id in cursor
      node = idMap.get(id)
      if node is undefined: continue
      sibling = node.nextSibling
      while sibling is not null AND predicate(sibling)
        outputCursors.push(new Set([sibling.id]))
        sibling = sibling.nextSibling
  return { root: input.root, cursors: outputCursors }
```

### 4.4 Export

```typescript
export function selectSiblingsAfter(
  input: Selection,
  predicate: (node: CSNode) => boolean
): Selection
```

### 4.5 Tests

Test file: `abct2/tests/siblingSelector.spec.ts`

Example-based tests:
- Predicate `() => true` — collects all siblings after the selected node.
- Predicate `(n) => !isBarLine(n)` — stops at the first bar line.
- Selected node has no nextSibling — returns empty cursors.
- Predicate immediately returns false — returns empty cursors.
- Multiple cursors — each one independently collects its siblings.

Property-based tests:
- The collected nodes are always a contiguous prefix of the sibling chain after the selected node.
- With predicate `() => true`, the count of collected siblings equals the number of siblings after the node.

---

## Implementation Checklist

Copy the plan file into the plans directory, and once you are done with the implementation of each of the phases of the plan, make sure to call the code review agent on the current phase and address any feedback that the code review agent might have. After you are done with the feedback and all the tests are passing, commit the changes and then move onto the next phase. Do this until finished.

For each phase, the workflow is: implement the code, write the tests, verify that `npm run test` passes, call the code review agent on the phase's files, address any feedback from the review, verify tests pass again, then commit. Only after committing should you move to the next phase.

- [ ] Phase 1: Create `abct2/src/selectors/treeWalk.ts` (with `firstTokenData`, `lastTokenData`, `comparePositions`, `findNodeById`, `buildIdMap`) and `abct2/tests/treeWalk.spec.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Phase 2: Create `abct2/src/selectors/voiceSelector.ts` and `abct2/tests/voiceSelector.spec.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Phase 3: Create `abct2/src/selectors/rangeSelector.ts` and `abct2/tests/rangeSelector.spec.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Phase 4: Create `abct2/src/selectors/siblingSelector.ts` and `abct2/tests/siblingSelector.spec.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Update `abct2/src/selectors/` index re-exports (if an index file exists).
- [ ] `npm run build` and `npm run test` must both pass.
- [ ] implementer must call the code review agent and address his feedback.
- [ ] Commit once the build passes and all tests pass.
