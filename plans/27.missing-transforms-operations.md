# Missing Transforms and Operations for abct2

## Table of Contents

1. [Goal](#goal)
2. [Operations to Implement](#operations-to-implement)
3. [Phase 1: filter](#phase-1-filter)
4. [Phase 2: pitch inspection](#phase-2-pitch-inspection)
5. [Phase 3: length inspection](#phase-3-length-inspection)
6. [Phase 4: add-voice](#phase-4-add-voice)
7. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are implementing the remaining runtime-level transforms and inspection functions that the ABCt2 language design (plan 18) specifies but that have not yet been built. These are the operations that the language evaluator will call when executing user programs.

The following items from the original design are excluded from this plan:
- `enharmonize` — covered by plan 25 (in progress).
- `stringify` / `stringify-header` / `stringify-body` — not needed because we rely on the ABC parser's formatter.
- `load` — deferred to the evaluator layer because it involves file I/O.
- `over`, `topdown`, `bottomup`, `oncetd`, `alltd` — language-level control constructs that belong to the evaluator, not the runtime transform library.

---

## Operations to Implement

| Operation | Category | Signature | Return type |
|-----------|----------|-----------|-------------|
| `filter` | Control | `(selection: Selection, predicate: (node: CSNode) => boolean) => Selection` | Selection (narrowed) |
| `pitch` | Inspection | `(selection: Selection) => number[]` | One MIDI value per cursor (fewer if cursor has no Note) |
| `length` | Inspection | `(selection: Selection) => number` | Total number of cursors |
| `addVoice` | Score operation | `(selection: Selection, voiceId: string, params: VoiceParams, ctx: ABCContext) => Selection` | Selection (with V: line inserted) |

Note on types: the existing `InspectionFn` type in `types.ts` returns `IRational[]`. Because `pitch` returns `number[]` and `length` returns `number`, these functions do not conform to `InspectionFn`. They are standalone exported functions without a shared type alias.

Design invariant: cursors are always single-ID sets (one node per cursor). Multi-ID cursors are not part of the design. This means `filter` never needs to split a cursor — it simply discards cursors whose single node fails the predicate.

---

## Phase 1: filter

### 1.1 Location

`abct2/src/transforms/filter.ts`

### 1.2 Rationale

The `filter` operation narrows a Selection's cursors to contain only the node IDs for which the predicate returns true. Because predicates like `is-note?` or `is-chord?` already exist as TypeScript utility functions in `abct2/src/csTree/types.ts`, the filter operation only needs to accept a `(node: CSNode) => boolean` callback. The evaluator will eventually translate language-level predicates (e.g. `pitch > C4`) into such callbacks.

### 1.3 Interface

```typescript
import { Selection } from "../selection";
import { CSNode } from "../csTree/types";

function filter(selection: Selection, predicate: (node: CSNode) => boolean): Selection
```

### 1.4 Algorithm

The filter does not modify the tree structure. It discards cursors whose node does not satisfy the predicate.

Because cursors are always single-ID sets, each cursor resolves to exactly one node. If that node passes the predicate, the cursor is kept; otherwise it is discarded.

```
filter(selection, predicate):
  newCursors = []
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    // cursors are single-ID, so nodes has exactly one element
    if nodes.length > 0 AND predicate(nodes[0]):
      newCursors.push(cursor)
  return { root: selection.root, cursors: newCursors }
```

### 1.5 Imports

| Utility | Location | Purpose |
|---------|----------|---------|
| `Selection` | `abct2/src/selection.ts` | Selection type |
| `CSNode` | `abct2/src/csTree/types.ts` | Node type for predicate signature |
| `findNodesById` | `abct2/src/transforms/types.ts` | Resolves node IDs to CSNode references |

### 1.6 Re-export

Add `filter` to `abct2/src/transforms/index.ts`.

### 1.7 Tests

Test file: `abct2/tests/filter.spec.ts`

Example-based tests:
- Parse `CDE[CEG]z|`, select all notes via `selectNotes`, then filter with `isNote`: all cursors are preserved (notes pass the predicate).
- Parse `CDE[CEG]z|`, select all notes via `selectNotes`, then filter with `isChord`: returns empty cursors (no note is a chord).
- Filter with `() => true` on a multi-cursor selection: cursor count is unchanged.
- Filter with `() => false` on a multi-cursor selection: returns zero cursors.
- Filter preserves the tree structure (root is unchanged): verify that `formatSelection` before and after produces the same output.
- Filter after `selectChords` with `isChord` predicate: all chord cursors are preserved.

Property-based tests:
- For any parsed tune, `filter(selection, () => true)` preserves the cursor count.
- For any parsed tune, `filter(selection, () => false)` produces zero cursors.
- For any parsed tune and any type predicate (isNote, isChord, isRest), the output cursor count is <= the input cursor count.

---

## Phase 2: pitch inspection

### 2.1 Location

`abct2/src/transforms/pitch.ts`

### 2.2 Rationale

The `pitch` inspection function extracts the MIDI pitch value from each selected Note. Because the language uses `pitch` in predicates like `filter (pitch > C4)`, it needs to return a numeric value that can be compared. The function returns one MIDI value per cursor. For a Note cursor, it extracts the note's MIDI pitch. For a Chord cursor, it extracts the pitch of the last Note child in source order (matching the `selectTop` convention — the formatter sorts chord notes from lowest to highest, so the last child is the highest pitch in well-formed input). Cursors pointing to Rests or other non-pitch nodes are skipped, so the output array may be shorter than `cursors.length`. This differs from `sumRhythm` (which always returns one value per cursor) because not all node types have a meaningful pitch.

### 2.3 Interface

```typescript
import { Selection } from "../selection";

function pitch(selection: Selection): number[]
```

### 2.4 Algorithm

Because cursors are single-ID, each cursor resolves to exactly one node. If that node has a meaningful pitch, the value is included in the output.

```
pitch(selection):
  results = []
  for each cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    if nodes.length == 0: continue
    midiValue = extractPitch(nodes[0])
    if midiValue is not null:
      results.push(midiValue)
  return results

extractPitch(csNode):
  if csNode.tag == TAGS.Note:
    pitchResult = findChildByTag(csNode, TAGS.Pitch)
    if pitchResult == null: return null
    pitchExpr = toAst(pitchResult.node) as Pitch
    return toMidiPitch(pitchExpr)
  else if csNode.tag == TAGS.Chord:
    // Get the last Note child in source order (matching selectTop convention)
    lastNote = null
    current = csNode.firstChild
    while current is not null:
      if current.tag == TAGS.Note:
        lastNote = current
      current = current.nextSibling
    if lastNote is not null:
      return extractPitch(lastNote)
  return null
```

### 2.5 Imports

| Utility | Location | Purpose |
|---------|----------|---------|
| `Selection` | `abct2/src/selection.ts` | Selection type |
| `CSNode`, `TAGS` | `abct2/src/csTree/types.ts` | Node type and tag constants |
| `findNodesById` | `abct2/src/transforms/types.ts` | Resolves node IDs to CSNode references |
| `findChildByTag` | `abct2/src/transforms/treeUtils.ts` | Finds Pitch child of a Note |
| `toAst` | `abct2/src/csTree/toAst.ts` | CSNode to Expr conversion |
| `Pitch` | `parse/types/Expr2.ts` | Pitch Expr type for cast |
| `toMidiPitch` | `parse/Visitors/Formatter2.ts` | Pitch Expr to MIDI value |

### 2.6 Re-export

Add `pitch` to `abct2/src/transforms/index.ts`.

### 2.7 Tests

Test file: `abct2/tests/pitch.spec.ts`

Example-based tests:
- `pitch` on a single Note `C` (middle C, MIDI 60): returns `[60]`.
- `pitch` on a single Note `^C` (C#, MIDI 61): returns `[61]`.
- `pitch` on a Note with octave `c` (C5, MIDI 72): returns `[72]`.
- `pitch` on a Note with octave modifier `C,` (C3, MIDI 48): returns `[48]`.
- `pitch` on a Chord `[CEG]`: returns the last note's MIDI value (G4 = 67, since notes are in ascending source order).
- `pitch` on a Chord `[GEC]` (non-ascending source order): returns the last note's MIDI value (C4 = 60), confirming source-order behavior.
- `pitch` on a Rest: returns `[]` (no value for that cursor).
- `pitch` on multiple cursors (two Notes): returns two MIDI values.
- `pitch` on an empty selection (no cursors): returns `[]`.

Property-based tests:
- For any parsed tune, `pitch` always returns values in the range [0, 127].
- The number of returned values is always <= the number of cursors.
- For any Note, the MIDI value produced by `pitch` equals the value produced by directly calling `toMidiPitch` on its Pitch Expr.

---

## Phase 3: length inspection

### 3.1 Location

`abct2/src/transforms/length.ts`

### 3.2 Rationale

The `length` inspection function counts elements. The design document uses it in guards like `(c | select @notes | length) >= 4` to check how many notes a chord contains. Because selectors produce one cursor per matched node, the total number of cursors after `select @notes` equals the number of notes in the chord. Therefore `length` returns that cursor count as a single scalar.

### 3.3 Interface

```typescript
import { Selection } from "../selection";

function length(selection: Selection): number
```

### 3.4 Algorithm

```
length(selection):
  return selection.cursors.length
```

When used in the pattern `c | select @notes | length`, the selection pipeline first narrows to the notes inside a chord (producing one cursor per note), then `length` returns how many cursors exist. For a 4-note chord, `select @notes` produces 4 cursors, so `length` returns 4.

### 3.5 Imports

| Utility | Location | Purpose |
|---------|----------|---------|
| `Selection` | `abct2/src/selection.ts` | Selection type |

### 3.6 Re-export

Add `length` to `abct2/src/transforms/index.ts`.

### 3.7 Tests

Test file: `abct2/tests/length.spec.ts`

Example-based tests:
- `length` on a selection with one cursor: returns `1`.
- `length` on a selection with three cursors: returns `3`.
- `length` on an empty selection (no cursors): returns `0`.
- Integration: parse `[CEG]`, selectChords, then selectChordNotes on the chord, then `length`: returns `3` (one cursor per note).
- Integration: parse `CDE|`, selectNotes, then `length`: returns `3`.
- `length` after filter that removes all nodes: returns `0`.

Property-based tests:
- `length` always returns a value >= 0.
- For any parsed tune, `length(createSelection(root))` returns `1` (the root node is the only cursor).
- For any parsed tune, `length` after `selectNotes` equals the number of Note nodes in the tree.

---

## Phase 4: add-voice

### 4.1 Location

`abct2/src/transforms/addVoice.ts`

### 4.2 Rationale

The `add-voice` operation inserts a `V:` declaration (an Info_line node) into the tune header. Because the K: line must always be the last info line in the tune header (per ABC standard), the new V: line is inserted before the K: line. If no K: line exists, the V: line is appended at the end of the Tune_header's child chain.

### 4.3 Interface

```typescript
import { Selection } from "../selection";
import { CSNode } from "../csTree/types";
import { ABCContext } from "../../../parse/parsers/Context";

interface VoiceParams {
  name?: string;
  clef?: string;
  transpose?: number;
}

function addVoice(
  selection: Selection,
  voiceId: string,
  params: VoiceParams,
  ctx: ABCContext
): Selection
```

The `VoiceParams` interface is defined in `abct2/src/transforms/addVoice.ts` and exported from the module.

### 4.4 Algorithm

The operation finds the Tune_header node within the current selection, locates the K: info line, constructs a new V: Info_line CSNode, and inserts it before the K: line.

```
addVoice(selection, voiceId, params, ctx):
  // Find the Tune_header node. We walk from root to find the first Tune_header
  // that is an ancestor of (or is itself in) the current cursor.
  tuneHeader = findTuneHeader(selection.root)
  if tuneHeader is null: return selection

  // Build the V: line text content
  voiceText = buildVoiceText(voiceId, params)

  // Create the Info_line CSNode
  voiceInfoLine = buildVoiceInfoLineNode(voiceText, ctx)

  // Find the K: info line in the Tune_header's children
  kLineResult = findKLine(tuneHeader)

  if kLineResult is not null:
    // Insert the V: line before the K: line
    insertBefore(tuneHeader, kLineResult.prev, kLineResult.node, voiceInfoLine)
  else:
    // No K: line found: append at end
    appendChild(tuneHeader, voiceInfoLine)

  return selection
```

### 4.5 Building the V: line text

The V: info line in ABC has the format: `V:<id> <key=value pairs>`

```
buildVoiceText(voiceId, params):
  parts = [voiceId]
  if params.name is not undefined:
    parts.push('name="' + params.name + '"')
  if params.clef is not undefined:
    parts.push("clef=" + params.clef)
  if params.transpose is not undefined:
    parts.push("transpose=" + params.transpose.toString())
  return parts.join(" ")
```

### 4.6 Constructing the Info_line CSNode

In the CS tree, an Info_line node has token children. The first child is the key token (e.g., `V:`) and subsequent children are the value tokens. Because `buildInfoLine` in `toAst.ts` reconstructs the Info_line from `new Info_line(id, children as Token[])`, we need to produce the same token structure that the parser would produce.

The key token has tokenType `TT.INF_HDR` and lexeme `"V:"`. The value token has tokenType `TT.INFO_STR` and contains the rest of the line content.

```
buildVoiceInfoLineNode(voiceText, ctx):
  keyToken = createCSNode(TAGS.Token, ctx.generateId(), {
    type: "token",
    lexeme: "V:",
    tokenType: TT.INF_HDR,
    line: 0,
    position: 0
  })

  valueToken = createCSNode(TAGS.Token, ctx.generateId(), {
    type: "token",
    lexeme: voiceText,
    tokenType: TT.INFO_STR,
    line: 0,
    position: 2
  })

  infoLineNode = createCSNode(TAGS.Info_line, ctx.generateId(), { type: "empty" })
  infoLineNode.firstChild = keyToken
  keyToken.nextSibling = valueToken

  return infoLineNode
```

The `line` and `position` values are set to 0 because this is a synthesized node (not parsed from source). The formatter does not rely on these for output.

No EOL token is needed as a child or sibling because the formatter's `visitTuneHeaderExpr` joins info lines with `"\n"` automatically.

### 4.7 Finding the Tune_header

Because the selection may contain multiple tunes, we find the first Tune_header reachable from the root. If a more targeted approach is needed (selecting a specific tune's header), the caller should narrow the selection to a specific tune first using `selectTune`.

```
findTuneHeader(root):
  // Walk depth-first from root
  return walkForTag(root, TAGS.Tune_header)

walkForTag(node, tag):
  if node.tag == tag: return node
  current = node.firstChild
  while current is not null:
    result = walkForTag(current, tag)
    if result is not null: return result
    current = current.nextSibling
  return null
```

### 4.8 Finding the K: line

Walk the Tune_header's direct children to find the Info_line whose key token lexeme is `"K:"`.

```
findKLine(tuneHeader):
  prev = null
  current = tuneHeader.firstChild
  while current is not null:
    if current.tag == TAGS.Info_line:
      keyChild = current.firstChild
      if keyChild is not null AND isTokenNode(keyChild):
        if getTokenData(keyChild).lexeme == "K:":
          return { node: current, prev }
    prev = current
    current = current.nextSibling
  return null
```

### 4.9 Imports

| Utility | Location | Purpose |
|---------|----------|---------|
| `Selection` | `abct2/src/selection.ts` | Selection type |
| `CSNode`, `TAGS`, `createCSNode`, `isTokenNode`, `getTokenData` | `abct2/src/csTree/types.ts` | Node types and creation |
| `insertBefore`, `appendChild` | `abct2/src/transforms/treeUtils.ts` | Tree manipulation |
| `ABCContext` | `parse/parsers/Context.ts` | ID generation |
| `TT` | `parse/parsers/scan2.ts` | Token types |

### 4.10 Re-export

Add `addVoice` and `VoiceParams` to `abct2/src/transforms/index.ts`.

### 4.11 Tests

Test file: `abct2/tests/addVoice.spec.ts`

Example-based tests:
- Add voice `"T1"` with no params to a tune with `X:1\nK:C\nCDE|`: the output contains `V:T1` before `K:C` in the header.
- Add voice `"T1"` with `{ name: "Trumpet", clef: "treble" }`: the output contains `V:T1 name="Trumpet" clef=treble` before the K: line.
- Add voice with transpose parameter `{ transpose: -2 }`: the output contains `V:id transpose=-2`.
- Add voice to a tune with multiple header lines (`X:1\nT:My Tune\nM:4/4\nK:C\n`): the V: line appears after M: and before K:.
- Add voice twice (two calls): both V: lines appear before K:, in insertion order.
- Add voice to a tune with no K: line (edge case): the V: line is appended at the end of the header.
- The tune body is unchanged after adding a voice: verify with `formatSelection`.

Property-based tests:
- For any parsed tune, adding a voice and then formatting always produces output that contains the string `V:<voiceId>`.
- The K: line (if present) is always the last Info_line in the header after adding a voice.
- Adding a voice does not change the number of nodes in the tune body.

---

## Implementation Checklist

Copy the plan file into the plans directory, and once you are done with the implementation of each of the phases of the plan, make sure to call the code review agent on the current phase and address any feedback that the code review agent might have. After you are done with the feedback and all the tests are passing, commit the changes and then move onto the next phase. Do this until finished.

For each phase, the workflow is: implement the code, write the tests, verify that `npm run test` passes, call the code review agent on the phase's files, address any feedback from the review, verify tests pass again, then commit. Only after committing should you move to the next phase.

- [ ] Phase 1: Create `abct2/src/transforms/filter.ts` and `abct2/tests/filter.spec.ts`. Add re-export to `index.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Phase 2: Create `abct2/src/transforms/pitch.ts` and `abct2/tests/pitch.spec.ts`. Add re-export to `index.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Phase 3: Create `abct2/src/transforms/length.ts` and `abct2/tests/length.spec.ts`. Add re-export to `index.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Phase 4: Create `abct2/src/transforms/addVoice.ts` and `abct2/tests/addVoice.spec.ts`. Add re-export to `index.ts`. Run tests. Code review. Address feedback. Commit.
- [ ] Final verification: `npm run build` and `npm run test` both pass.
