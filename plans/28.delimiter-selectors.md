# Delimiter Selectors: Inside and Around

## Table of Contents

1. [Goal](#goal)
2. [Delimiter Types Covered](#delimiter-types-covered)
3. [Semantics](#semantics)
4. [Phase 1: Delimiter Selection Core and Exported Selectors](#phase-1-delimiter-selection-core-and-exported-selectors)
5. [Phase 2: Tests](#phase-2-tests)
6. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are adding "inside" and "around" selectors for delimiter-paired constructs in the CS tree. These selectors work analogously to vim text objects (`i[`, `a[`, `i{`, `a{`, `i(`, `a(`): given a cursor, they find the enclosing delimited construct and select either its inner content or the entire node.

Because plan 24 preserves delimiter tokens as children of their respective CSNodes, these selectors can identify delimiter boundaries by inspecting token types in the child list.

The selectors support two usage modes:
- Narrowing mode: the input cursor already points at a delimiter-pair node (e.g., after `selectChords`). The selector narrows to content or selects the node itself.
- Search-outward mode: the input cursor points at any descendant node (e.g., a Note inside a Chord). The selector finds the enclosing delimiter-pair node, then applies inside/around logic.

Both modes are unified in a single downward-walk function. As the walk descends the tree, it tracks the nearest ancestor with the target tag. When a cursor ID is encountered, the tracked ancestor (or the node itself if it matches the target tag) is used as the delimiter node.

---

## Delimiter Types Covered

| Type | Open token type | Close token type | Tag | Inside content |
|------|----------------|-----------------|-----|----------------|
| Chord | `TT.CHRD_LEFT_BRKT` | `TT.CHRD_RIGHT_BRKT` | `TAGS.Chord` | Children between `[` and `]` (rhythm and tie come after `]` in the sibling chain, so they are naturally excluded) |
| Grace group | `TT.GRC_GRP_LEFT_BRACE` | `TT.GRC_GRP_RGHT_BRACE` | `TAGS.Grace_group` | Slash and notes between `{` and `}` |
| Inline field | `TT.INLN_FLD_LFT_BRKT` | `TT.INLN_FLD_RGT_BRKT` | `TAGS.Inline_field` | Field header and text tokens between `[` and `]` |
| Grouping | `TT.LPAREN` | `TT.RPAREN` | `TAGS.Grouping` | The expression between `(` and `)` |

Note on Grouping: `Grouping` nodes only appear inside `%%score`/`%%staves` directives (produced by `parseInfoLine2.ts`), not in music body contexts. The search-outward mode from a music note to a Grouping will never match. This selector is still included for completeness but is only useful when the cursor already sits inside a directive expression.

Tuplet and Macro/UserSymbol are excluded because they lack a wrapping open/close delimiter pair.

---

## Semantics

### "Around"

Selects the entire delimiter-pair CSNode. The result is one single-ID cursor per matched node. For a Chord `[CEG]2-`, "around" includes the brackets, the contents, the rhythm, and the tie (everything under the Chord node).

### "Inside"

Selects the children between the opening and closing delimiter tokens, excluding the delimiters themselves. Because the parser places rhythm and tie nodes after the closing bracket token in the child chain, the "between open and close" logic naturally excludes them without additional filtering.

The result is one multi-ID cursor per matched node, where the cursor's `Set<number>` contains the IDs of all content children between the delimiters.

If neither the opening nor the closing delimiter token is found in the child list (which should not happen with parser-produced trees), `collectInsideIds` returns an empty set and no output cursor is emitted.

### Deduplication

Deduplication is scoped per input cursor (consistent with `chordSelectors.ts` and `fanOut.ts`): when multiple IDs within a single input cursor resolve to the same enclosing delimiter node, only one output cursor is produced for that node. Different input cursors are processed independently and may produce duplicate output cursors for the same delimiter node.

---

## Phase 1: Delimiter Selection Core and Exported Selectors

### 1.1 Location

`abct2/src/selectors/delimiterSelectors.ts` (new file)

### 1.2 Imports

```typescript
import { CSNode, TAGS, isTokenNode, getTokenData } from "../csTree/types";
import { TT } from "../../../parse/parsers/scan2";
import { Selection } from "../selection";
```

No barrel file is created because existing selectors (`chordSelectors.ts`, `typeSelectors.ts`, etc.) are imported directly by their module paths.

### 1.3 DelimiterConfig

```typescript
export interface DelimiterConfig {
  targetTag: string;
  openTokenType: TT;
  closeTokenType: TT;
}
```

Each of the four delimiter types gets a config constant:

```typescript
const CHORD_CONFIG: DelimiterConfig = { ... };
const GRACE_GROUP_CONFIG: DelimiterConfig = { ... };
const INLINE_FIELD_CONFIG: DelimiterConfig = { ... };
const GROUPING_CONFIG: DelimiterConfig = { ... };
```

(Values as listed in the table above.)

### 1.4 Context and Walk Function

The walk follows the same pattern as `chordSelectors.ts`: a context interface holds shared state, and a recursive `walk` function traverses the sibling chain.

```typescript
interface DelimiterWalkCtx {
  cursor: Set<number>;
  config: DelimiterConfig;
  seen: Set<number>;
  outputCursors: Set<number>[];
  collectFn: (delimNode: CSNode, config: DelimiterConfig) => Set<number>;
}
```

The `collectFn` field is the strategy: it receives the matched delimiter node and returns the set of IDs to include in the output cursor.

```
walk(ctx, node, enclosingDelimiter):
  current = node
  while current !== null:
    effectiveEnclosing = enclosingDelimiter
    if current.tag === ctx.config.targetTag:
      effectiveEnclosing = current

    if ctx.cursor.has(current.id) and effectiveEnclosing !== null and not ctx.seen.has(effectiveEnclosing.id):
      ctx.seen.add(effectiveEnclosing.id)
      ids = ctx.collectFn(effectiveEnclosing, ctx.config)
      if ids.size > 0:
        ctx.outputCursors.push(ids)

    if current.firstChild:
      walk(ctx, current.firstChild, effectiveEnclosing)

    current = current.nextSibling
```

How the two modes unify:
- Narrowing: the cursor ID belongs to a node whose tag matches `config.targetTag`. When the walk visits that node, it sets `effectiveEnclosing = current`. Since `cursor.has(current.id)` is true and `effectiveEnclosing` is the node itself, we collect it.
- Search-outward: the cursor ID belongs to a descendant of the delimiter node. When the walk first visits the delimiter ancestor, it sets `effectiveEnclosing`. Later, when the walk reaches the cursor node (a descendant), `effectiveEnclosing` is already set to the delimiter ancestor, so we collect it.

### 1.5 collectInsideIds

```
collectInsideIds(delimNode, config) -> Set<number>:
  children = []
  child = delimNode.firstChild
  while child !== null:
    children.push(child)
    child = child.nextSibling

  openIdx = index of first child where isTokenNode(child) and getTokenData(child).tokenType === config.openTokenType
  closeIdx = index of last child where isTokenNode(child) and getTokenData(child).tokenType === config.closeTokenType

  if openIdx === -1 or closeIdx === -1 or closeIdx <= openIdx:
    return empty Set

  result = new Set<number>
  for i from openIdx+1 to closeIdx-1:
    result.add(children[i].id)
  return result
```

### 1.6 delimiterWalk (shared entry point)

```typescript
function delimiterWalk(
  input: Selection,
  config: DelimiterConfig,
  collectFn: (delimNode: CSNode, config: DelimiterConfig) => Set<number>
): Selection {
  const outputCursors: Set<number>[] = [];

  for (const cursor of input.cursors) {
    const ctx: DelimiterWalkCtx = {
      cursor,
      config,
      seen: new Set(),
      outputCursors,
      collectFn,
    };
    walk(ctx, input.root, null);
  }

  return { root: input.root, cursors: outputCursors };
}
```

Note: `seen` is reset per input cursor because it is created inside the loop. This ensures that different input cursors are processed independently (consistent with how `chordWalk` in `chordSelectors.ts` processes each cursor independently).

### 1.7 selectAroundDelimited and selectInsideDelimited

```typescript
function selectAroundDelimited(input: Selection, config: DelimiterConfig): Selection {
  return delimiterWalk(input, config, (delimNode) => new Set([delimNode.id]));
}

function selectInsideDelimited(input: Selection, config: DelimiterConfig): Selection {
  return delimiterWalk(input, config, collectInsideIds);
}
```

### 1.8 Exported Selectors

8 exported functions, each a one-liner delegating to the core:

```typescript
export function selectInsideChord(input: Selection): Selection
export function selectAroundChord(input: Selection): Selection
export function selectInsideGraceGroup(input: Selection): Selection
export function selectAroundGraceGroup(input: Selection): Selection
export function selectInsideInlineField(input: Selection): Selection
export function selectAroundInlineField(input: Selection): Selection
export function selectInsideGrouping(input: Selection): Selection
export function selectAroundGrouping(input: Selection): Selection
```

Each delegates to `selectInsideDelimited` or `selectAroundDelimited` with the appropriate config constant.

---

## Phase 2: Tests

### 2.1 Test File

`abct2/tests/delimiterSelectors.spec.ts`

### 2.2 Imports and Helpers

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import * as fc from "fast-check";
import { CSNode, TAGS, isTokenNode, getTokenData } from "../src/csTree/types";
import { Selection } from "../src/selection";
import { toCSTree, toSelection, findByTag, findById, genAbcWithChords } from "./helpers";
import { selectChords } from "../src/selectors/typeSelectors";
import {
  selectInsideChord, selectAroundChord,
  selectInsideGraceGroup, selectAroundGraceGroup,
  selectInsideInlineField, selectAroundInlineField,
} from "../src/selectors/delimiterSelectors";
```

### 2.3 New Generator in `abct2/tests/helpers.ts`

Because the existing `genAbcWithChords` only produces chord expressions mixed with notes/rests, we need an additional generator for grace groups. This generator reuses `ParserGen.genGraceGroupExpr`:

```typescript
export const genAbcWithGraceGroups: fc.Arbitrary<string> = fc
  .tuple(
    fc.array(ParserGen.genGraceGroupExpr, { minLength: 1, maxLength: 3 }),
    fc.array(ParserGen.genNoteExpr, { minLength: 1, maxLength: 3 })
  )
  .map(([graces, notes]) => {
    const allTokens = [...graces, ...notes].flatMap((e) => e.tokens);
    return "X:1\nK:C\n" + tokensToString(allTokens) + "|\n";
  });
```

### 2.4 Constructing Selections for Search-Outward Tests

Because `toSelection(source)` produces a selection whose cursor contains only the root's ID, tests for search-outward mode need to build selections manually:

```typescript
const root = toCSTree("X:1\nK:C\n[CEG]|\n");
const noteC = findByTag(root, TAGS.Note)[0];
const selection: Selection = { root, cursors: [new Set([noteC.id])] };
```

This places the cursor at a descendant (Note) rather than the delimiter node itself.

### 2.5 Property-Based Tests for Chord

These tests use `genAbcWithChords` and verify structural invariants:

1. Around is idempotent: applying `selectAroundChord` to a selection where the cursors already point at Chord nodes produces the same cursors. In other words, `selectAroundChord(selectAroundChord(sel))` equals `selectAroundChord(sel)` in terms of cursor IDs.

```
property(genAbcWithChords, abc =>
  sel = toSelection(abc)
  chords = selectChords(sel)
  around1 = selectAroundChord(chords)
  around2 = selectAroundChord(around1)
  around1.cursors and around2.cursors have same IDs
)
```

2. Inside IDs are strict children of the Chord node: for every ID in the `selectInsideChord` output, that node's parent (found via tree walk) is the Chord node selected by `selectAroundChord`.

```
property(genAbcWithChords, abc =>
  sel = toSelection(abc)
  chords = selectChords(sel)
  inside = selectInsideChord(chords)
  for each cursor in inside.cursors:
    for each id in cursor:
      node = findById(root, id)
      // node must be a direct child of some Chord node
)
```

3. Inside excludes delimiter tokens: none of the IDs in the `selectInsideChord` result correspond to nodes with tokenType `CHRD_LEFT_BRKT` or `CHRD_RIGHT_BRKT`.

```
property(genAbcWithChords, abc =>
  sel = toSelection(abc)
  chords = selectChords(sel)
  inside = selectInsideChord(chords)
  for each cursor in inside.cursors:
    for each id in cursor:
      node = findById(root, id)
      if isTokenNode(node):
        getTokenData(node).tokenType is not CHRD_LEFT_BRKT and not CHRD_RIGHT_BRKT
)
```

4. Deduplication within one cursor: for a chord with N notes (N > 1), creating a single cursor with all N note IDs and calling `selectAroundChord` produces exactly 1 output cursor.

```
property(genAbcWithChords, abc =>
  root = toCSTree(abc)
  chords = findByTag(root, TAGS.Chord)
  for each chord in chords:
    notes = children of chord with tag Note
    if notes.length > 1:
      cursor = Set(notes.map(n => n.id))
      sel = { root, cursors: [cursor] }
      result = selectAroundChord(sel)
      result.cursors.length === 1
)
```

5. Search-outward from any Note inside a Chord finds that Chord: for each Chord, picking any child Note and making a selection from it, `selectAroundChord` produces a cursor with the Chord's ID.

```
property(genAbcWithChords, abc =>
  root = toCSTree(abc)
  chords = findByTag(root, TAGS.Chord)
  for each chord in chords:
    notes = children of chord with tag Note
    if notes.length > 0:
      sel = { root, cursors: [Set([notes[0].id])] }
      result = selectAroundChord(sel)
      result.cursors.length === 1
      [...result.cursors[0]][0] === chord.id
)
```

### 2.6 Property-Based Tests for Grace Group

Same structural invariants as Chord, using `genAbcWithGraceGroups`:

1. Around is idempotent.
2. Inside excludes delimiter tokens (`GRC_GRP_LEFT_BRACE`, `GRC_GRP_RGHT_BRACE`).
3. Search-outward from a Note inside a grace group finds the Grace_group node.

### 2.7 Example-Based Tests for Chord

1. Around - narrowing: `[CEG]2|` - cursor is the Chord node's ID. Output cursor contains just that Chord's ID.
2. Around - search-outward: `[CEG]2|` - cursor is the first Note's ID. Output cursor contains the Chord's ID.
3. Inside - narrowing: `[CEG]2|` - cursor is the Chord node's ID. Output cursor contains IDs of the 3 Note children (not the bracket tokens, not rhythm).
4. Inside - search-outward: `[CEG]2|` - cursor is a Note's ID. Same output as (3).
5. No match: `C D E|` - cursor is a standalone Note's ID. `selectAroundChord` returns no cursors.
6. Multiple chords: `[CE] [FA]|` - cursor contains one Note from each chord. Two output cursors are produced.

### 2.8 Example-Based Tests for Grace Group

1. Around - narrowing: `{Bc}d|` - cursor is the Grace_group node's ID.
2. Inside - narrowing: `{Bc}d|` - output contains IDs of children between `{` and `}`.
3. Around - search-outward: `{Bc}d|` - cursor is a Note inside the grace group. Output contains the Grace_group's ID.

### 2.9 Example-Based Tests for Inline Field

1. Around - narrowing: `C [K:Bb] D|` - cursor is the Inline_field node's ID.
2. Inside - narrowing: `C [K:Bb] D|` - output contains IDs between `[` and `]` (field header and text content).

### 2.10 Example-Based Tests for Grouping

Because Grouping nodes only appear in `%%score`/`%%staves` directives, the test source uses a directive context:

1. Around - narrowing: cursor is a Grouping node's ID inside a `%%score` directive.
2. Inside - narrowing: output contains IDs between `(` and `)`.

### 2.11 Edge Case Tests

1. Empty delimiter content: e.g., `[]` produces a Chord with only the bracket tokens and no children between them. `selectInsideChord` returns an empty cursor list.
2. Independent input cursors: two input cursors resolve to the same Chord. Two output cursors are produced (one per input cursor, because deduplication is per-cursor).

---

## Implementation Checklist

- Phase 1: Create `abct2/src/selectors/delimiterSelectors.ts` with: `DelimiterConfig` interface, config constants, `DelimiterWalkCtx` interface, `walk` function, `collectInsideIds` function, `delimiterWalk` shared entry point, `selectAroundDelimited`/`selectInsideDelimited` core functions, and all 8 exported selectors. Commit.
- Phase 2: Create `abct2/tests/delimiterSelectors.spec.ts` with the full test suite. Commit.
- Final verification: `npm run build` and `npm run test` both pass.
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

Copy the plan file into the plans directory, and once you are done with the implementation of each of the phases of the plan, make sure to call the code review agent on the current phase and address any feedback that the code review agent might have. After you are done with the feedback and all the tests are passing, commit the changes and then move onto the next phase. Do this until finished.
