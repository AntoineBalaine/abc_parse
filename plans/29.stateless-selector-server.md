# Plan 29: Stateless selector server

## Table of Contents

1. [Problem statement](#problem-statement)
2. [Design](#design)
3. [Protocol changes](#protocol-changes)
4. [Stale node IDs and graceful degradation](#stale-node-ids-and-graceful-degradation)
5. [CS tree caching](#cs-tree-caching)
6. [Phase 1: Update the server and extension atomically](#phase-1-update-the-server-and-extension-atomically)
7. [Phase 2: Remove the SelectionStateManager](#phase-2-remove-the-selectionstatemanager)
8. [Phase 3: Update tests](#phase-3-update-tests)
9. [To do](#to-do)

## Problem statement

The `SelectionStateManager` on the language server maintains a `Selection` object (a CS tree root + an array of cursor node ID sets) per document URI. The VSCode extension also maintains its own cursor state via `editor.selections`. These two states can diverge:

- When the user moves cursors manually in VSCode, the server's state becomes stale.
- When the user clears a selection, the server's cursors remain unchanged.
- When the server resets its state, VSCode's multi-cursors are not necessarily cleared.

The solution is to eliminate the server-side state and make the server a pure function: it receives cursor node IDs from the extension, applies a selector, and returns new ranges and node IDs. The extension becomes the single source of truth.

## Design

After this refactor:

- The extension stores a `Map<string, number[]>` (keyed by document URI, one node ID per cursor) as local state.
- On each selector command, the extension sends `{ uri, selector, args?, cursorNodeIds: number[] }` to the server.
- The server builds a `Selection` from the CS tree + the provided node IDs, applies the selector, resolves ranges, and returns `{ ranges, cursorNodeIds: number[] }`.
- The extension updates its stored node IDs and `editor.selections` atomically.
- The extension listens to `onDidChangeTextEditorSelection` and `onDidChangeTextDocument`. When a selection change is user-initiated (not from our own programmatic update), or when the document text changes, the extension clears its stored node IDs for that URI. The next selector command will then send an empty `cursorNodeIds`, which the server interprets as "start from root."
- The `resetSelection` command becomes purely local: the extension clears its stored node IDs for the current URI and hides the status bar. No server round-trip is needed.
- The `SelectionStateManager`, `selectionState.ts`, and `selectionState.spec.ts` are deleted.
- The `abct2.resetSelection` request handler is deleted from the server.

### Why `number[]` instead of `number[][]`

Each cursor produced by `fanOutByPredicate` is always a single-element `Set<number>` (see `fanOut.ts` line 23: `outputCursors.push(new Set([current.id]))`). Because cursors never contain multiple node IDs, using `number[]` (one ID per cursor) is simpler and cheaper to serialize than `number[][]`.

## Protocol changes

### Request: `abct2.applySelector`

Current params:
```typescript
interface ApplySelectorParams {
  uri: string;
  selector: string;
  args?: number[];
}
```

New params:
```typescript
interface ApplySelectorParams {
  uri: string;
  selector: string;
  args?: number[];
  cursorNodeIds: number[];  // one node ID per cursor; empty array means "start from root"
}
```

Current result:
```typescript
interface ApplySelectorResult {
  ranges: Array<{ start: { line: number; character: number }; end: { line: number; character: number } }>;
  cursorCount: number;
}
```

New result:
```typescript
interface ApplySelectorResult {
  ranges: Array<{ start: { line: number; character: number }; end: { line: number; character: number } }>;
  cursorNodeIds: number[];  // replaces cursorCount; one node ID per cursor in the output selection
}
```

The `cursorCount` field is removed because it is derivable from `cursorNodeIds.length`.

### Request: `abct2.resetSelection`

Deleted. Reset is now handled entirely within the extension.

## Stale node IDs and graceful degradation

When the document text changes, the AST is re-parsed and node IDs are reassigned. The `ABCContext` uses a per-instance `IdGenerator` that monotonically increments and never resets, so even re-parsing identical text produces entirely different node IDs. If the extension sends node IDs that belonged to a previous parse, those IDs will not be found in the current CS tree.

Under normal operation, stale IDs should never reach the server: the `onDidChangeTextDocument` listener clears the extension's stored IDs whenever the document changes, so the next selector command will start from root. The graceful-degradation behavior described below is a defensive safety net for edge cases (e.g., timing between the server re-parsing and the extension receiving the change event).

The behavior when stale IDs reach the server:
- `fanOutByPredicate` walks the tree and checks `cursor.has(current.id)` for each node. Because none of the stale IDs match any node in the new tree, no scope is entered, and no matches are produced.
- The selector returns a `Selection` with zero cursors.
- `resolveSelectionRanges` returns an empty ranges array.
- The server returns `{ ranges: [], cursorNodeIds: [] }`.

On the extension side, when the server returns an empty `cursorNodeIds`, the extension clears its stored state and hides the status bar without calling `applySelectionsToEditor` (to avoid showing a spurious "No matches found" toast). The next selector command will start from root.

## CS tree caching

The old `SelectionStateManager` cached the CS tree inside `SelectionState`. In the new stateless approach, the server calls `fromAst(doc.AST)` on every request, which does a full recursive traversal allocating new `CSNode` objects.

Because the node IDs come from the AST (which is stable for a given parse), the CS tree only needs to be rebuilt when the document changes. We can cache the CS tree on the `AbcDocument` object, rebuilding it lazily when the AST is re-parsed.

### Implementation

In `abc-lsp-server/src/server.ts` (or in the `AbcDocument` class if it has one), add a cached CS tree getter:

```
getCsTree(doc: AbcDocument): CSNode
  if doc.cachedCsTree is null or doc.astVersion has changed
    doc.cachedCsTree = fromAst(doc.AST)
    doc.cachedAstVersion = doc.currentAstVersion
  return doc.cachedCsTree
```

Because the `AbcDocument` is already recreated or updated on document change, tying the cache to the document's AST version ensures we never serve a stale tree.

If `AbcDocument` does not have a version field, we can use the AST object identity (reference equality) as the cache key:

```
getCsTree(doc: AbcDocument): CSNode
  if doc.cachedCsTreeAst !== doc.AST
    doc.cachedCsTree = fromAst(doc.AST)
    doc.cachedCsTreeAst = doc.AST
  return doc.cachedCsTree
```

## Phase 1: Update the server and extension atomically

Because the protocol changes are breaking (both the request params and result types change simultaneously), the server and extension must be updated together.

### Files to modify

- `abc-lsp-server/src/server.ts`
- `vscode-extension/src/selectorCommands.ts`

### Server changes (`abc-lsp-server/src/server.ts`)

1. Update the `ApplySelectorParams` interface: add `cursorNodeIds: number[]`.
2. Update the `ApplySelectorResult` interface: replace `cursorCount: number` with `cursorNodeIds: number[]`.
3. Add a `getCsTree` function (or method) that caches the CS tree on the document, using AST reference equality as the cache key. The function must always be called with the document fetched by `abcServer.abcDocuments.get(params.uri)`, which is always the latest version.
4. Preserve the existing null guard: if `doc` is null, not an `AbcDocument`, or has no `AST`, return `{ ranges: [], cursorNodeIds: [] }`.
5. Rewrite the `abct2.applySelector` handler:
   - Get the cached CS tree via `getCsTree(doc)`.
   - If `params.cursorNodeIds` is empty, create an initial selection via `createSelection(root)`.
   - Otherwise, reconstruct a `Selection` by converting each ID in `cursorNodeIds` into a single-element `Set<number>` cursor, paired with the CS tree root.
   - Apply the selector function.
   - Resolve ranges via `resolveSelectionRanges`.
   - Extract `cursorNodeIds` from the resulting selection's cursors (take the first element from each `Set<number>`).
   - Return `{ ranges, cursorNodeIds }`.
6. Delete the `abct2.resetSelection` handler.
7. Delete the `ResetSelectionParams` interface.
8. Remove the `selectionStateManager` instantiation and its import.

### New imports needed (server)

- `fromAst` from `../../abct2/src/csTree/fromAst`.
- `createSelection` from `../../abct2/src/selection`.
- `CSNode` from `../../abct2/src/csTree/types`.

### Imports to remove (server)

- `SelectionStateManager` from `./selectionState`.

### Extension changes (`vscode-extension/src/selectorCommands.ts`)

1. Update the `ApplySelectorResult` interface: replace `cursorCount: number` with `cursorNodeIds: number[]`.

2. Add a `Map<string, number[]>` variable `cursorStateByUri` inside `registerSelectorCommands`. This holds the current cursor node IDs per document URI.

3. Add a `Set<string>` variable `pendingProgrammaticUris` to track which URIs are currently being updated programmatically. This replaces a boolean flag and is more robust for multi-document scenarios.

4. Register a `vscode.window.onDidChangeTextEditorSelection` listener. When the active editor's URI is not in `pendingProgrammaticUris`, delete that URI's entry from `cursorStateByUri` and hide the status bar. Push the returned disposable into `context.subscriptions`.

5. Register a `vscode.workspace.onDidChangeTextDocument` listener. Guard: only act when `event.document.languageId === "abc"`. When a document changes, if `cursorStateByUri.has(changedUri)`, delete that URI's entry. If the changed document is the active editor's document, hide the status bar. Push the returned disposable into `context.subscriptions`.

6. Register a `vscode.window.onDidChangeActiveTextEditor` listener. When the active editor changes, update the status bar: if the new editor's URI has an entry in `cursorStateByUri`, show the cursor count; otherwise, hide the status bar. Push the returned disposable into `context.subscriptions`.

7. Update each selector command handler to:
   - Read the current cursor state: `cursorStateByUri.get(uri) ?? []`.
   - Send `cursorNodeIds` in the request params.
   - On success, if `result.cursorNodeIds` is non-empty:
     - Add the URI to `pendingProgrammaticUris`.
     - Call `applySelectionsToEditor`.
     - Remove the URI from `pendingProgrammaticUris`.
     - Store the returned `result.cursorNodeIds` in `cursorStateByUri.set(uri, result.cursorNodeIds)`.
     - Update the status bar with `result.cursorNodeIds.length`.
   - If `result.cursorNodeIds` is empty: delete the URI from `cursorStateByUri`, hide the status bar, and do not call `applySelectionsToEditor` (to avoid a spurious "No matches found" toast in the graceful-degradation case).
   - On error (e.g., unknown selector): leave `cursorStateByUri` unchanged. The previous cursor state remains valid.

8. Simplify the `abc.resetSelection` command: delete the URI's entry from `cursorStateByUri` and hide the status bar. No server communication needed.

9. Remove the `"abct2.resetSelection"` request call entirely.

### Regarding the `pendingProgrammaticUris` set

VSCode fires `onDidChangeTextEditorSelection` even when we set `editor.selections` programmatically. We need to distinguish our own updates from user actions. The set-based approach is more robust than a boolean flag because:

- It handles multi-document scenarios (two editors open simultaneously).
- It avoids the edge case where rapid successive selector commands on different documents could interleave their flag states.

VSCode's extension host is single-threaded, and the selection change event fires synchronously after `editor.selections` is assigned. This means:

```
pendingProgrammaticUris.add(uri)      // mark as programmatic
editor.selections = newSelections      // triggers onDidChangeTextEditorSelection synchronously
pendingProgrammaticUris.delete(uri)   // clear the mark
```

The `onDidChangeTextEditorSelection` callback runs between the `add` and `delete` calls, so it sees the URI in the set and skips the invalidation.

## Phase 2: Remove the SelectionStateManager

### Files to delete

- `abc-lsp-server/src/selectionState.ts`
- `abc-lsp-server/src/selectionState.spec.ts`

## Phase 3: Update tests

### Files to modify

- `abc-lsp-server/src/selectorIntegration.spec.ts`

### Changes

The integration spec currently simulates the server's `applySelector` and `resetSelection` handlers by calling `selectionStateManager.getOrCreate`, `lookupSelector`, `resolveSelectionRanges`, and `selectionStateManager.update/reset`.

Because the server is now stateless, the integration tests should simulate the new protocol:

1. Remove the `SelectionStateManager` import and instantiation.
2. Add an import for `fromAst` from `../../abct2/src/csTree/fromAst` and `createSelection` from `../../abct2/src/selection`.
3. Replace the `applySelector` helper: it now takes a `cursorNodeIds: number[]` argument (replacing the manager's implicit state), builds a `Selection` from the CS tree + cursor IDs, applies the selector, resolves ranges, and returns `{ ranges, cursorNodeIds: number[] }`.
4. Remove the `resetSelection` helper entirely — reset is now a client-only operation.
5. Update each test to thread `cursorNodeIds` through successive selector calls (the output of one call becomes the input of the next).
6. Remove the "resetSelection after applying selectors returns fresh initial state" test. Replace it with a test that verifies applying a selector with an empty `cursorNodeIds` array starts from root (which is the equivalent of a reset from the server's perspective).
7. Remove the "state is invalidated and rebuilt when document changes" test — there is no server-side state to invalidate.

### New tests to add

8. Stale node IDs: parse a document, obtain `cursorNodeIds` from a selector call, then re-parse the same document (creating a new AST with different IDs, because `IdGenerator` is per-context and monotonically incrementing). Verify that calling a selector with the old IDs returns `{ ranges: [], cursorNodeIds: [] }`.

9. Partial cursor failure: parse `X:1\nK:C\n[CEG] [FAC]|\n`, apply `selectChords` with empty `cursorNodeIds` to get two valid chord IDs. Then construct a `cursorNodeIds` array containing both valid IDs plus a fabricated invalid ID (e.g., 99999). Apply `selectTop` with this mixed array. Verify that the result contains exactly 2 ranges (the top notes of the two chords) and 2 `cursorNodeIds` — the stale cursor is silently dropped.

10. Empty document: parse a document with no tunes (just a file header or empty string). Verify that calling `selectTune` with empty `cursorNodeIds` returns `{ ranges: [], cursorNodeIds: [] }`.

11. Multi-step composition with explicit threading: apply `selectTune`, then pass the output `cursorNodeIds` into `selectChords`, then pass those into `selectTop`. Verify the ranges match the top notes of chords within tunes.

## To do

- [ ] Phase 1: Update the server handler and extension atomically (server.ts + selectorCommands.ts)
- [ ] Phase 2: Delete selectionState.ts and selectionState.spec.ts
- [ ] Phase 3: Update selectorIntegration.spec.ts (rewrite helpers, update existing tests, add new tests)
- [ ] Run `npm run build` and verify no errors
- [ ] Run LSP server tests and verify all pass
- [ ] Commit
