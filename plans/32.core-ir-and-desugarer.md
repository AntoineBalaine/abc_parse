# Core IR and Desugarer Implementation

## Table of Contents

1. [Goal](#goal)
2. [Context and Dependencies](#context-and-dependencies)
3. [Design Decisions](#design-decisions)
4. [Phase 1: Core IR Node Types](#phase-1-core-ir-node-types)
5. [Phase 2: Desugarer Infrastructure](#phase-2-desugarer-infrastructure)
6. [Phase 3: Literal and Atom Desugaring](#phase-3-literal-and-atom-desugaring)
7. [Phase 4: Binding and Function Desugaring](#phase-4-binding-and-function-desugaring)
8. [Phase 5: Pipeline and Application Desugaring](#phase-5-pipeline-and-application-desugaring)
9. [Phase 6: over, Selector, and Location Desugaring](#phase-6-over-selector-and-location-desugaring)
10. [Phase 7: Pattern Matching and Strategy Desugaring](#phase-7-pattern-matching-and-strategy-desugaring)
11. [Phase 8: Conditional and Logical Operator Desugaring](#phase-8-conditional-and-logical-operator-desugaring)
12. [Phase 9: Record and Load Desugaring](#phase-9-record-and-load-desugaring)
13. [Phase 10: Example-Based Tests](#phase-10-example-based-tests)
14. [Phase 11: Property-Based Tests](#phase-11-property-based-tests)
15. [Phase 12: Integration with Build](#phase-12-integration-with-build)
16. [Deferred Work](#deferred-work)
17. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are implementing the Core IR data types and the desugaring pass that transforms the v2 surface AST (produced by the parser from plan 31) into the Core IR defined in plan 18. The Core IR is a minimal functional language with eight expression forms. The desugarer is a recursive visitor that translates each surface AST node into its corresponding Core IR representation.

The desugarer's output is consumed by a future evaluator (out of scope for this plan). The desugarer itself does not execute any code; it only restructures the AST into a form that is simpler to evaluate.

---

## Context and Dependencies

### Dependency chain

This plan depends on:
- Plan 30 (scanner updates) -- we need the new token types in the AST
- Plan 31 (parser updates) -- we need the v2 surface AST node types

The desugarer consumes the surface AST types defined in plan 31's `abct/src/ast.ts` and produces Core IR nodes defined in a new `abct/src/core/types.ts`.

### The surface AST types (from plan 31)

The parser produces a `Program` containing `Statement[]`, where `Statement = Assignment | FnDef | FnMatchDef | Expr`. The `Expr` union includes:

- `Pipe`, `Application`, `Or`, `And`, `Not`, `Negate`, `Comparison`, `FilterExpression`
- `Selector`, `LocationSelector`, `TuneSelector`
- `List`, `AbcLiteral`, `AbcLiteralInline`, `StringLiteral`, `NumberLiteral`
- `Identifier`, `Group`, `OverExpr`, `RecordLiteral`, `LoadExpr`, `IfExpr`
- `ErrorExpr`

### The Core IR grammar (from plan 18)

```
e ::= x                        -- variable reference
    | e(e, ...)                 -- function application
    | fn(x, ...) => e           -- function value (closure)
    | let x = e; e              -- sequential binding
    | if e then e else e        -- conditional
    | [e, e, ...]               -- list
    | n | "s" | `abc`           -- literals (number, string, parsed ABC)
    | prim(e, ...)              -- built-in primitive call
```

### Source files to create

```
abct/src/core/
  types.ts       -- Core IR node interfaces and the CoreExpr union type
  utils.ts       -- constructor helpers and type guards for Core IR nodes
abct/src/desugarer/
  index.ts       -- public API: desugar(program) -> CoreProgram
  desugar.ts     -- the recursive desugaring visitor
  primitives.ts  -- mapping from surface identifiers to built-in primitive names
abct/tests/
  core/
    desugarer.spec.ts  -- example-based desugarer tests
    pbt.spec.ts        -- property-based desugarer tests
    generators.ts      -- fast-check generators for Core IR validation
```

### Existing infrastructure reused

- `Loc` and `Pos` types from `abct/src/ast.ts` are reused by Core IR nodes for source location tracking.
- The parser's `Program` type is the desugarer's input.
- Fast-check generators from `abct/tests/generators.ts` (plan 31) are used to generate surface AST source strings for property tests.

---

## Design Decisions

### The implicit pipeline variable uses fresh counter-based names

When a pipeline stage receives its implicit input (the output of the previous stage), the desugarer introduces a `let _N = <previous>; <next>` binding where `_N` is a fresh variable name generated by a monotonically increasing counter (`_0`, `_1`, `_2`, ...). Because user-written identifiers are unlikely to match `_0`, `_1`, etc., and because the desugarer is the sole producer of these names, there is no collision risk. The counter is maintained in the desugarer context.

### Application desugaring distinguishes verbs from regular functions

In the surface syntax, `transpose @chords 2` is an `Application` node with terms `[Identifier("transpose"), Selector("chords"), NumberLiteral(2)]`. The desugarer checks whether the first term is an identifier that matches a known built-in primitive name. If so, it produces a `PrimCall` node. If not, it produces a regular `App` node (function application).

Because selectors are arguments to verbs (not standalone pipeline stages), the desugarer transforms selector arguments into `PrimCall` nodes that narrow the implicit input. For example, `transpose @chords 2` becomes:

```
PrimCall("transpose", [PrimCall("select_chords", [Var("_0")]), NumLit(2)])
```

where `_0` is the current implicit input variable.

### Selectors as standalone atoms produce selector functions

When a selector `@chords` appears as a standalone atom (not as an argument to a verb), it produces a closure that takes a Selection and returns a narrowed Selection:

```
Fn(["_sel"], PrimCall("select_chords", [Var("_sel")]))
```

This is consistent with plan 18's statement that selectors are functions `Selection -> Selection`.

### The `over` construct desugars to a primitive with a closure argument

`over focus (body)` becomes:

```
PrimCall("over", [Var("_0"), desugar(focus), Fn(["_1"], desugar(body) with implicit input = _1)])
```

The body is wrapped in a closure because it needs to operate on the focused subset, not the outer input.

### Pattern matching desugars to a match primitive call

`fn rule = match { arms... }` becomes a `let` binding whose value is a closure that performs the match. Because the Core IR has no native `match` construct (plan 18 does not include it in the grammar), we desugar it to nested `if/then/else` that tests the node's tag:

```
let rule = fn(_n) =>
  if prim("tag_eq", [_n, "chord"]) then
    let c = _n;
    <arm body for chord>
  else if prim("tag_eq", [_n, "note"]) then
    let n = _n;
    <arm body for note>
  else
    _n  -- unmatched nodes pass through
```

Guards are additional conditions conjoined with the tag test.

### Strategy keywords desugar to primitive calls

`topdown my_rule` becomes `PrimCall("topdown", [Var("_0"), Var("my_rule")])` where `_0` is the implicit input. The strategy primitive takes the input tree and the rule function, and applies the rule according to the traversal strategy.

### Record literals desugar to a primitive

Because the Core IR has no native record form (plan 18 lists only lists as compound literals), records desugar to a `PrimCall("make_record", [...fields])` where each field is a two-element list `[StringLit(key), value]`:

```
{name="Trumpet", clef=treble}  -->  PrimCall("make_record", [
  List([StringLit("name"), StringLit("Trumpet")]),
  List([StringLit("clef"), Var("treble")])
])
```

### Filter expressions desugar to a primitive with a predicate closure

`filter (pitch > C4)` becomes:

```
PrimCall("filter", [Var("_0"), Fn(["_el"], desugar(pitch > C4) with implicit input = _el)])
```

### Logical operators desugar to if/then/else

Because the Core IR has conditionals but no boolean operators, we use the truthy/falsy convention where `NumLit(1)` represents true and `NumLit(0)` represents false:
- `a and b` becomes `If(a, b, NumLit(0))`
- `a or b` becomes `Let(_n, a, If(Var(_n), Var(_n), b))` -- the Let avoids evaluating `a` twice
- `not a` becomes `If(a, NumLit(0), NumLit(1))`

We do not add a separate `BoolLit` to the Core IR. The evaluator uses the same truthy/falsy convention as JavaScript: `0` is falsy, anything else is truthy.

### Pipeline right-hand side semantics

When the right side of a pipe is desugared, the implicit input variable is set. The right side can be:
1. A bare identifier (e.g., `a | b`): the desugarer wraps it as `App(Var("b"), [Var("_0")])`.
2. An application (e.g., `a | transpose 2`): the application desugarer injects the implicit input as the first argument.
3. An `over` expression: `desugarOver` reads `ctx.implicitInput` to pass as the first argument to `prim("over", ...)`.
4. An `if/then/else`: the conditional does not consume the implicit input; the pipeline value is discarded. This is semantically correct because `if` is a conditional selector, not a transform.
5. Any other atom (number, string, list, record): the pipeline value is discarded and the atom is the result.

Case 5 is intentional: if the user writes `source | 42`, the result is `42`. The pipeline value is bound to a fresh variable but never referenced. The evaluator will not error on this; it simply produces `42`. This matches the functional semantics where `let _0 = source; 42` evaluates to `42`.

### Application always injects implicit input for user-defined functions

Because the language uses verb-first syntax where the implicit subject flows through the pipeline, the desugarer unconditionally prepends the implicit input as the first argument to every function call inside a pipeline. A user-defined function `fn double(x) { ... }` called as `source | double` becomes `let _0 = source; double(_0)`. The function's first parameter receives the pipeline value. This is the intended semantics: every function in a pipeline is a transform that takes the pipeline value as its first argument.

If a function is called with explicit arguments (`source | my_fn arg1 arg2`), the implicit input is still prepended: `my_fn(_0, arg1, arg2)`. The function must accept the pipeline value as its first parameter and additional arguments after.

### FnDef body uses the first parameter as implicit input

When desugaring a function body, `ctx.implicitInput` is set to the function's first parameter name. This means that within the body, verb-first applications automatically use the first parameter as their implicit subject. For example:

```
fn process(x) { transpose @chords 2 }
```

desugars to:

```
fn(x) => prim("transpose", [prim("select_chords", [Var("x")]), NumLit(2)])
```

This is correct: the function receives a Selection as `x`, and verbs inside the body operate on it. Without this, the user would have to write `fn process(x) { x | transpose @chords 2 }` for every function, which is redundant.

### AbcLiteral's optional location is preserved via a separate PrimCall

The triple-backtick `AbcLiteral` node has an optional `location?: Location` field (for `` ```abc :10:5 `` forms that specify a target location). When this field is present, the desugarer produces a `PrimCall("abc_with_location", [AbcLit(content), <location args>])` instead of a bare `AbcLit`. This allows the evaluator to associate the parsed ABC fragment with a target location for insertion.

### Recursive functions use letrec semantics

The Core IR's `Let` node uses `letrec` semantics: the name being bound is visible within the value expression. This means a function can reference itself by name:

```
fn fib(n) { if n <= 1 then n else fib(n - 1) + fib(n - 2) }
```

desugars to:

```
let fib = fn(n) => if prim("lte", [Var("n"), NumLit(1)]) then Var("n") else ...Var("fib")...
```

The evaluator implements this by creating a closure that captures a reference to the environment cell where the binding will be stored, then filling in the cell after the closure is created. This is the standard letrec implementation strategy. The Core IR type definition does not change; the semantics are a property of the evaluator.

### The `insert` verb is a regular primitive application

`insert :8:0 \`...\`` is parsed as `Application(Identifier("insert"), LocationSelector(...), AbcLiteralInline(...))`. Because `"insert"` is in the PRIMITIVES set, the desugarer handles it via `desugarPrimApplication`, producing:

```
PrimCall("insert", [Var("_0"), PrimCall("location", [...]), AbcLit(...)])
```

No special desugaring logic is needed beyond what `desugarPrimApplication` already provides for the location and ABC literal arguments.

### Hyphenated built-in names from plan 18 map to underscored identifiers

Plan 18 uses hyphenated names (`add-voice`, `select-top`, `to-rest`, etc.) for readability. Because the scanner's identifier regex does not allow hyphens, the surface syntax uses underscored equivalents: `add_voice`, `select_top`, `to_rest`, etc. The `toPrimitiveName` mapping is identity (the surface name equals the primitive name). The PRIMITIVES set in this plan uses the underscored forms throughout.

Plan 18's `add-voice <id> [name] [clef]` maps to `add_voice` (not `add_vx`). The PRIMITIVES set uses `add_voice` as the canonical name.

### The `filter` predicate's implicit element binding

When `filter (pitch > C4)` is desugared, the predicate `pitch > C4` is wrapped in a closure whose parameter becomes the implicit input for the predicate body. The identifier `pitch` inside the predicate is a built-in primitive that extracts the pitch value from the element. Because `ctx.implicitInput` is set to the closure parameter, the desugarer produces:

```
PrimCall("filter", [Var("_0"), Fn(["_1"],
  PrimCall("gt", [PrimCall("pitch", [Var("_1")]), Var("C4")])
)])
```

The `pitch` identifier is recognized as a primitive name, so `desugarApplication` treats it as a `PrimCall` and injects the implicit input `_1` as its first argument. `C4` is a regular identifier (presumably a pitch constant in scope).

### ErrorExpr nodes are preserved and recorded

If the parser produced `ErrorExpr` nodes (due to syntax errors), the desugarer wraps them in a `CoreError` node and pushes an entry to `ctx.errors`. The desugarer does not abort on parse errors; it continues desugaring the rest of the program. The same recording happens for the `default` case in the dispatch function (unknown expression types).

### Nested functions correctly isolate the implicit input

When a function literal appears inside a pipeline or another function, the desugarer saves and restores `ctx.implicitInput` around the inner function's body. This ensures the inner function's body uses its own first parameter as the implicit input, not the outer pipeline's variable. For example:

```
source | my_fn(fn(x) { transpose @chords 2 })
```

The outer pipeline sets `ctx.implicitInput = "_0"` (bound to `source`). When desugaring the `fn(x) { ... }` argument, the desugarer saves `"_0"`, sets `ctx.implicitInput = "x"`, desugars the body (which uses `x` as the implicit input for `transpose`), then restores `"_0"`. The `my_fn` application correctly receives `_0` as its first implicit argument.

### The desugarer is stateless apart from a fresh-name counter

The desugarer context contains only:
- A counter for generating fresh variable names (`_0`, `_1`, ...)
- The current "implicit input" variable name (for pipeline stages)
- The error list (for reporting desugaring errors)

No symbol tables or type environments are maintained. Name resolution is deferred to the evaluator.

### Location tracking is preserved

Every Core IR node carries a `loc: Loc` field pointing back to the source range of the surface AST node it was desugared from. This is essential for the language server to provide diagnostics and hover information on desugared forms.

### Comparison operators desugar to primitive calls

`a >= b` becomes `PrimCall("gte", [desugar(a), desugar(b)])`. Each comparison operator maps to a named primitive: `gt`, `lt`, `gte`, `lte`, `eq`, `neq`.

### Negate desugars to a primitive call

`-x` becomes `PrimCall("negate", [desugar(x)])`.

### TuneSelector desugars to a primitive call

`X:1` becomes `PrimCall("select_tune", [Var("_0"), NumLit(1)])`.

### LoadExpr desugars to a primitive call

`load "file.abc"` becomes `PrimCall("load", [StringLit("file.abc")])`.

### Multi-statement programs desugar to nested lets

A program with statements `s1; s2; s3` (where `;` represents an EOL boundary) desugars to:

```
let _r0 = desugar(s1);
let _r1 = desugar(s2);
desugar(s3)
```

Assignment statements become `let` bindings with user-chosen names. Expression statements become `let` bindings with fresh names (their values are discarded unless they are the last statement, which is the program's return value).

---

## Phase 1: Core IR Node Types

### 1.1 Location

Create `abct/src/core/types.ts`.

### 1.2 The CoreExpr union type

```typescript
import { Loc } from "../ast";

export type CoreExpr =
  | Var
  | App
  | Fn
  | Let
  | If
  | CoreList
  | NumLit
  | StringLit
  | AbcLit
  | PrimCall
  | CoreError;

export interface Var {
  type: "var";
  name: string;
  loc: Loc;
}

export interface App {
  type: "app";
  fn: CoreExpr;
  args: CoreExpr[];
  loc: Loc;
}

export interface Fn {
  type: "fn";
  params: string[];
  paramLocs: Loc[];
  body: CoreExpr;
  loc: Loc;
}

export interface Let {
  type: "let";
  name: string;
  nameLoc: Loc;
  value: CoreExpr;
  body: CoreExpr;
  loc: Loc;
}

export interface If {
  type: "if";
  condition: CoreExpr;
  consequent: CoreExpr;
  alternative: CoreExpr;
  loc: Loc;
}

export interface CoreList {
  type: "list";
  elements: CoreExpr[];
  loc: Loc;
}

export interface NumLit {
  type: "num";
  value: number;
  loc: Loc;
}

export interface StringLit {
  type: "str";
  value: string;
  loc: Loc;
}

export interface AbcLit {
  type: "abc";
  content: string;
  loc: Loc;
}

export interface PrimCall {
  type: "prim";
  name: string;
  args: CoreExpr[];
  loc: Loc;
}

export interface CoreError {
  type: "core_error";
  message: string;
  loc: Loc;
}
```

### 1.3 CoreProgram type

```typescript
export interface CoreProgram {
  body: CoreExpr;
  loc: Loc;
}
```

Because the desugarer transforms a multi-statement program into nested `Let` bindings, the `CoreProgram` contains a single top-level `CoreExpr`.

### 1.4 File: `abct/src/core/utils.ts`

Constructor helpers (one per node type) and type guards (one per node type). Each constructor takes the fields and returns the typed object. This avoids repeating the `type` discriminant everywhere.

```typescript
export function mkVar(name: string, loc: Loc): Var {
  return { type: "var", name, loc };
}

export function mkApp(fn: CoreExpr, args: CoreExpr[], loc: Loc): App {
  return { type: "app", fn, args, loc };
}

export function mkFn(params: string[], paramLocs: Loc[], body: CoreExpr, loc: Loc): Fn {
  return { type: "fn", params, paramLocs, body, loc };
}

export function mkLet(name: string, nameLoc: Loc, value: CoreExpr, body: CoreExpr, loc: Loc): Let {
  return { type: "let", name, nameLoc, value, body, loc };
}

export function mkIf(condition: CoreExpr, consequent: CoreExpr, alternative: CoreExpr, loc: Loc): If {
  return { type: "if", condition, consequent, alternative, loc };
}

export function mkList(elements: CoreExpr[], loc: Loc): CoreList {
  return { type: "list", elements, loc };
}

export function mkNum(value: number, loc: Loc): NumLit {
  return { type: "num", value, loc };
}

export function mkStr(value: string, loc: Loc): StringLit {
  return { type: "str", value, loc };
}

export function mkAbc(content: string, loc: Loc): AbcLit {
  return { type: "abc", content, loc };
}

export function mkPrim(name: string, args: CoreExpr[], loc: Loc): PrimCall {
  return { type: "prim", name, args, loc };
}

export function mkError(message: string, loc: Loc): CoreError {
  return { type: "core_error", message, loc };
}

// Type guards
export function isVar(e: CoreExpr): e is Var { return e.type === "var"; }
export function isApp(e: CoreExpr): e is App { return e.type === "app"; }
export function isFn(e: CoreExpr): e is Fn { return e.type === "fn"; }
export function isLet(e: CoreExpr): e is Let { return e.type === "let"; }
export function isIf(e: CoreExpr): e is If { return e.type === "if"; }
export function isList(e: CoreExpr): e is CoreList { return e.type === "list"; }
export function isNum(e: CoreExpr): e is NumLit { return e.type === "num"; }
export function isStr(e: CoreExpr): e is StringLit { return e.type === "str"; }
export function isAbc(e: CoreExpr): e is AbcLit { return e.type === "abc"; }
export function isPrim(e: CoreExpr): e is PrimCall { return e.type === "prim"; }
export function isCoreError(e: CoreExpr): e is CoreError { return e.type === "core_error"; }
```

---

## Phase 2: Desugarer Infrastructure

### 2.1 Location

Create `abct/src/desugarer/index.ts` and `abct/src/desugarer/desugar.ts`.

### 2.2 Desugarer context

The desugarer context tracks the fresh-name counter and the current implicit input variable name:

```typescript
// In abct/src/desugarer/desugar.ts

export interface DesugarCtx {
  counter: number;
  implicitInput: string | null;  // null at top level (no implicit input available)
  errors: DesugarError[];
}

export interface DesugarError {
  message: string;
  loc: Loc;
}

export function createDesugarCtx(): DesugarCtx {
  return { counter: 0, implicitInput: null, errors: [] };
}

export function freshName(ctx: DesugarCtx): string {
  return `_${ctx.counter++}`;
}
```

### 2.3 Public API

```typescript
// In abct/src/desugarer/index.ts

import { Program } from "../ast";
import { CoreProgram } from "../core/types";
import { DesugarError } from "./desugar";

export { DesugarError } from "./desugar";

export interface DesugarResult {
  program: CoreProgram;
  errors: DesugarError[];
}

export function desugar(program: Program): DesugarResult {
  const ctx = createDesugarCtx();
  const body = desugarProgram(ctx, program.statements);
  return {
    program: { body, loc: program.loc },
    errors: ctx.errors,
  };
}
```

`DesugarError` is part of the public API and is exported from `abct/src/index.ts` alongside the other desugarer types.

### 2.4 The main dispatch function

```typescript
// In abct/src/desugarer/desugar.ts

export function desugarExpr(ctx: DesugarCtx, expr: Expr): CoreExpr {
  switch (expr.type) {
    case "identifier":   return desugarIdentifier(ctx, expr);
    case "number":       return desugarNumber(ctx, expr);
    case "string":       return desugarString(ctx, expr);
    case "abc_literal":  return desugarAbcLiteral(ctx, expr);
    case "abc_literal_inline": return desugarAbcLiteralInline(ctx, expr);
    case "list":         return desugarList(ctx, expr);
    case "group":        return desugarGroup(ctx, expr);
    case "pipe":         return desugarPipe(ctx, expr);
    case "application":  return desugarApplication(ctx, expr);
    case "selector":     return desugarSelector(ctx, expr);
    case "location_selector": return desugarLocation(ctx, expr);
    case "tune_selector": return desugarTuneSelector(ctx, expr);
    case "over":         return desugarOver(ctx, expr);
    case "record":       return desugarRecord(ctx, expr);
    case "load":         return desugarLoad(ctx, expr);
    case "if":           return desugarIf(ctx, expr);
    case "filter":       return desugarFilter(ctx, expr);
    case "comparison":   return desugarComparison(ctx, expr);
    case "or":           return desugarOr(ctx, expr);
    case "and":          return desugarAnd(ctx, expr);
    case "not":          return desugarNot(ctx, expr);
    case "negate":       return desugarNegate(ctx, expr);
    case "error":        return desugarError(ctx, expr);
    default:
      const msg = `Unknown expression type: ${(expr as any).type}`;
      ctx.errors.push({ message: msg, loc: expr.loc });
      return mkError(msg, expr.loc);
  }
}
```

### 2.5 Utility definitions

The desugarer uses two location helpers:

```typescript
// A zero-width location used for synthetic nodes that have no source text
const DUMMY_LOC: Loc = { start: { line: 0, col: 0, offset: 0 }, end: { line: 0, col: 0, offset: 0 } };

// Creates a location spanning from the start of `a` to the end of `b`
function spanLoc(a: { loc: Loc }, b: { loc: Loc }): Loc {
  return { start: a.loc.start, end: b.loc.end };
}
```

Both live in `abct/src/desugarer/desugar.ts`.

### 2.6 Program and statement desugaring

The desugarer transforms the statement list into nested `Let` bindings. The last statement's value is the program's result (not wrapped in a `Let`):

```
desugarProgram(ctx, statements):
  if statements.length == 0:
    return mkList([], DUMMY_LOC)   // empty program produces an empty list value
  if statements.length == 1:
    return desugarStatement(ctx, statements[0])
  // for multi-statement programs, nest lets:
  stmt = statements[0]
  rest = desugarProgram(ctx, statements.slice(1))
  return wrapStatementAsLet(ctx, stmt, rest)
```

The `desugarStatement` function handles a single statement without nesting:

```
desugarStatement(ctx, stmt):
  if stmt is Assignment:
    // A trailing assignment with no continuation body is semantically a binding
    // whose body is the value itself (the program's result is the bound value)
    value = desugarExpr(ctx, stmt.value)
    return mkLet(stmt.id, stmt.idLoc, value, mkVar(stmt.id, stmt.idLoc), stmt.loc)
  if stmt is FnDef:
    fnValue = desugarFnDef(ctx, stmt)
    return mkLet(stmt.name, stmt.nameLoc, fnValue, mkVar(stmt.name, stmt.nameLoc), stmt.loc)
  if stmt is FnMatchDef:
    matchValue = desugarFnMatchDef(ctx, stmt)
    return mkLet(stmt.name, stmt.nameLoc, matchValue, mkVar(stmt.name, stmt.nameLoc), stmt.loc)
  // bare expression:
  return desugarExpr(ctx, stmt)
```

The `wrapStatementAsLet` function creates a `Let` for a non-terminal statement:

```
wrapStatementAsLet(ctx, stmt, rest):
  if stmt is Assignment:
    value = desugarExpr(ctx, stmt.value)
    return mkLet(stmt.id, stmt.idLoc, value, rest, spanLoc(stmt, rest))
  if stmt is FnDef:
    return mkLet(stmt.name, stmt.nameLoc, desugarFnDef(ctx, stmt), rest, spanLoc(stmt, rest))
  if stmt is FnMatchDef:
    return mkLet(stmt.name, stmt.nameLoc, desugarFnMatchDef(ctx, stmt), rest, spanLoc(stmt, rest))
  // bare expression statement: bind to a fresh name (value is discarded)
  name = freshName(ctx)
  value = desugarExpr(ctx, stmt)
  return mkLet(name, stmt.loc, value, rest, spanLoc(stmt, rest))
```

---

## Phase 3: Literal and Atom Desugaring

### 3.1 Identifier

An identifier desugars to a `Var` reference:

```
desugarIdentifier(ctx, expr):
  return mkVar(expr.name, expr.loc)
```

### 3.2 NumberLiteral

The parser's `NumberLiteral` node stores `value: string` because fractions like `"1/2"` are not representable as a single JavaScript number before evaluation. The desugarer must parse the string into a numeric value:

```
desugarNumber(ctx, expr):
  numValue = parseNumericValue(expr.value)  // handles integers, decimals, and fractions
  return mkNum(numValue, expr.loc)
```

The helper `parseNumericValue(s: string): number` handles three cases:
- Integer: `"42"` -> `42` (via `parseInt`)
- Decimal: `"3.14"` -> `3.14` (via `parseFloat`)
- Fraction: `"1/2"` -> `0.5` (splits on `/`, divides numerator by denominator)

This helper lives in `abct/src/desugarer/desugar.ts`.

### 3.3 StringLiteral

```
desugarString(ctx, expr):
  return mkStr(expr.value, expr.loc)
```

### 3.4 AbcLiteral (triple-backtick fenced)

The `AbcLiteral` node has an optional `location?: Location` field. When a location is present, the desugarer produces a `PrimCall` wrapping the literal so the evaluator can associate the content with a target location:

```
desugarAbcLiteral(ctx, expr):
  abcNode = mkAbc(expr.content, expr.loc)
  if expr.location is not null:
    locationArgs = buildLocationArgs(ctx, expr.location, expr.loc)
    return mkPrim("abc_with_location", [abcNode, ...locationArgs], expr.loc)
  return abcNode
```

### 3.5 AbcLiteralInline (single-backtick)

```
desugarAbcLiteralInline(ctx, expr):
  return mkAbc(expr.content, expr.loc)
```

The inline form has no location field, so it always produces a plain `AbcLit`. Both forms produce the same base Core IR node type (`AbcLit`). The evaluator is responsible for parsing the ABC content into a tree value.

### 3.6 List

```
desugarList(ctx, expr):
  elements = expr.items.map(item => desugarExpr(ctx, item))
  return mkList(elements, expr.loc)
```

### 3.7 Group

A group `(expr)` is transparent; the desugarer recurses into the inner expression. We use the group's own `loc` (which spans the parentheses) rather than the inner expression's `loc`, so that LSP features like "select enclosing expression" can identify the group boundaries:

```
desugarGroup(ctx, group):
  inner = desugarExpr(ctx, group.expr)
  // Override the inner node's loc with the group's loc to preserve the parentheses span
  return { ...inner, loc: group.loc }
```

---

## Phase 4: Binding and Function Desugaring

### 4.1 Assignment (handled in desugarProgram)

`name = expr` becomes `Let(name, desugar(expr), <rest>)`. Because assignments are not expressions in the surface syntax (they are statements), this is handled in `desugarProgram` rather than `desugarExpr`.

### 4.2 FnDef

`fn name(x, y) { body }` desugars to a closure value. The name binding is handled by the program-level `Let`:

```
desugarFnDef(ctx, fnDef):
  // Save and restore implicitInput because the function body has its own scope
  savedInput = ctx.implicitInput
  // The first parameter becomes the implicit input for the body
  // (for verb-first syntax: fn double(x) { transpose @chords x })
  if fnDef.params.length > 0:
    ctx.implicitInput = fnDef.params[0].name
  body = desugarExpr(ctx, fnDef.body)
  ctx.implicitInput = savedInput
  paramNames = fnDef.params.map(p => p.name)
  paramLocs = fnDef.params.map(p => p.loc)
  return mkFn(paramNames, paramLocs, body, fnDef.loc)
```

### 4.3 FnMatchDef

`fn rule = match { arms... }` desugars to a closure containing nested conditionals. The parameter is the node being matched:

```
desugarFnMatchDef(ctx, fnMatch):
  matchParam = freshName(ctx)
  savedInput = ctx.implicitInput
  ctx.implicitInput = matchParam
  body = desugarMatchArms(ctx, fnMatch.arms, matchParam)
  ctx.implicitInput = savedInput
  // Use matchKwLoc for the synthetic parameter's location because it does not
  // correspond to any user-written source text (the function name is not a parameter).
  return mkFn([matchParam], [fnMatch.matchKwLoc], body, fnMatch.loc)
```

The match arms are desugared in `desugarMatchArms` (Phase 7).

---

## Phase 5: Pipeline and Application Desugaring

### 5.1 Pipeline

`a | b` desugars to `b(a)` -- reversed application. The left side is evaluated, bound to a fresh name, and the right side receives it as implicit input:

```
desugarPipe(ctx, pipe):
  left = desugarExpr(ctx, pipe.left)
  name = freshName(ctx)
  savedInput = ctx.implicitInput
  ctx.implicitInput = name
  right = desugarExpr(ctx, pipe.right)
  ctx.implicitInput = savedInput
  // If right desugared to a bare Var (function name), wrap it as App(right, [Var(name)])
  // because a function name alone needs to be called with the pipeline value.
  // For App and PrimCall, the implicit input was already injected by their respective
  // desugaring functions. For atoms (NumLit, etc.), the pipeline value is simply discarded.
  if right.type === "var":
    right = mkApp(right, [mkVar(name, pipe.left.loc)], pipe.loc)
  return mkLet(name, pipe.left.loc, left, right, pipe.loc)
```

For a multi-segment pipeline `a | b | c`, the parser produces left-associative nested `Pipe` nodes: `Pipe(Pipe(a, b), c)`. The desugarer handles them recursively. The left side `Pipe(a, b)` desugars first (producing a `Let` with the `b` application as its body), and the outer pipe wraps that in another `Let`. The result is nested bindings:

```
let _0 = desugar(a);
let _1 = b(_0);       -- desugar(Pipe(a, b)) with b as right side
let _2 = <result>;    -- desugar of the outer pipe
c(_2)
```

Note: the right side of a single `Pipe` node is never itself a `Pipe` because the parser's left-associative parsing produces nested left `Pipe` nodes. The right side is always a single expression (application, atom, over, if, etc.).

### 5.2 Application

`verb arg1 arg2 ...` desugars differently depending on whether the first term is a known built-in primitive:

```
desugarApplication(ctx, app):
  terms = app.terms
  head = terms[0]

  // Check if head is an identifier matching a built-in
  if head.type === "identifier" and isPrimitiveName(head.name):
    return desugarPrimApplication(ctx, app)

  // Otherwise, regular function application
  fnExpr = desugarExpr(ctx, head)
  args = terms.slice(1).map(t => desugarApplicationArg(ctx, t))
  // If there's an implicit input and the function expects it, pass it as first arg
  if ctx.implicitInput is not null:
    return mkApp(fnExpr, [mkVar(ctx.implicitInput, app.loc), ...args], app.loc)
  return mkApp(fnExpr, args, app.loc)
```

### 5.3 Primitive application

When the head identifier is a known built-in:

```
desugarPrimApplication(ctx, app):
  head = app.terms[0] as Identifier
  primName = toPrimitiveName(head.name)  // e.g., "transpose" -> "transpose"
  args = []
  for term in app.terms.slice(1):
    if term.type === "selector":
      // Selector argument: narrows the implicit input
      args.push(desugarSelectorAsNarrowing(ctx, term))
    else:
      args.push(desugarExpr(ctx, term))
  // Inject implicit input as the first argument (the Selection being operated on)
  if ctx.implicitInput is not null:
    return mkPrim(primName, [mkVar(ctx.implicitInput, app.loc), ...args], app.loc)
  return mkPrim(primName, args, app.loc)
```

### 5.4 Selector as narrowing argument

When a selector appears as an argument to a verb (`transpose @chords 2`), it produces a `PrimCall` that narrows the implicit input:

```
desugarSelectorAsNarrowing(ctx, selector):
  primName = selectorToPrimName(selector)  // uses selector.path.id
  if ctx.implicitInput is not null:
    inputRef = mkVar(ctx.implicitInput, selector.loc)
    if selector.path.value is not undefined:
      valueArg = desugarSelectorValue(ctx, selector)
      return mkPrim(primName, [inputRef, valueArg], selector.loc)
    return mkPrim(primName, [inputRef], selector.loc)
  // No implicit input available: this is a desugaring error because
  // selectors as verb arguments require a subject to narrow. Report the error
  // and fall back to a standalone selector closure.
  ctx.errors.push({ message: "Selector used as verb argument without an implicit input", loc: selector.loc })
  return desugarSelector(ctx, selector)
```

---

## Phase 6: over, Selector, and Location Desugaring

### 6.1 over

`over focus (body)` desugars to a `PrimCall("over", [outerInput, focus, bodyFn])`. The body is wrapped in a closure whose parameter becomes the implicit input for the body's verbs:

```
desugarOver(ctx, over):
  focusExpr = desugarExpr(ctx, over.focus)
  outerInput = ctx.implicitInput    // the pipeline value that over operates on
  bodyParam = freshName(ctx)
  ctx.implicitInput = bodyParam     // body verbs operate on the focused subset
  bodyExpr = desugarExpr(ctx, over.body)
  ctx.implicitInput = outerInput    // restore after body desugaring
  bodyClosure = mkFn([bodyParam], [over.body.loc], bodyExpr, over.body.loc)
  if outerInput is not null:
    return mkPrim("over", [mkVar(outerInput, over.loc), focusExpr, bodyClosure], over.loc)
  return mkPrim("over", [focusExpr, bodyClosure], over.loc)
```

### 6.2 Standalone selector

When a selector appears as a standalone expression (not as a verb argument), it produces a closure:

```
desugarSelector(ctx, selector):
  primName = selectorToPrimName(selector)  // uses selector.path.id
  param = freshName(ctx)
  if selector.path.value is not undefined:
    valueArg = desugarSelectorValue(ctx, selector)
    body = mkPrim(primName, [mkVar(param, selector.loc), valueArg], selector.loc)
  else:
    body = mkPrim(primName, [mkVar(param, selector.loc)], selector.loc)
  return mkFn([param], [selector.loc], body, selector.loc)
```

### 6.3 Selector-to-primitive mapping

File: `abct/src/desugarer/primitives.ts`

The `Selector` node has a `path: SelectorPath` field (a single object, not an array). The `SelectorPath` has `id: string` and an optional `value?: string | number | Range`.

```typescript
const SELECTOR_MAP: Record<string, string> = {
  "chords": "select_chords",
  "notes": "select_notes",
  "rests": "select_rests",
  "V": "select_voice",
};

export function selectorToPrimName(selector: Selector): string {
  const id = selector.path.id;
  return SELECTOR_MAP[id] ?? `select_${id}`;
}

export function desugarSelectorValue(ctx: DesugarCtx, selector: Selector): CoreExpr {
  const path = selector.path;
  if (path.value === undefined) {
    return mkStr("", selector.loc);
  }
  // path.value can be string, number, or Range
  if (typeof path.value === "string") {
    return mkStr(path.value, path.valueLoc!);
  }
  if (typeof path.value === "number") {
    return mkNum(path.value, path.valueLoc!);
  }
  // Range: { start: number, end: number }
  return mkList([
    mkNum(path.value.start, path.valueLoc!),
    mkNum(path.value.end, path.valueLoc!)
  ], path.valueLoc!);
}
```

### 6.4 Location selector

`:5:1-8` desugars to a location value represented as a `PrimCall`:

```
desugarLocation(ctx, locSel):
  args = buildLocationArgs(ctx, locSel.location, locSel.loc)
  return mkPrim("location", args, locSel.loc)
```

The `buildLocationArgs` helper converts the parser's `LocationSelector` node structure into numeric literal arguments. The `Location` type (from `ast.ts`) has fields:
- `line: number` -- the starting line
- `col?: number` -- the optional starting column
- `end?: RangeEnd` -- the optional end of the range

`RangeEnd` is a union:
- `{ type: "singleline", col: number }` -- same line, ending at a column
- `{ type: "multiline", line: number, col: number }` -- ending at a different line and column

The helper produces the arguments as follows:

```
buildLocationArgs(ctx, location, fallbackLoc):
  args = [mkNum(location.line, fallbackLoc)]
  if location.col is not undefined:
    args.push(mkNum(location.col, fallbackLoc))
  if location.end is not undefined:
    if location.end.type === "singleline":
      args.push(mkNum(location.end.col, fallbackLoc))
    else:  // multiline
      args.push(mkNum(location.end.line, fallbackLoc))
      args.push(mkNum(location.end.col, fallbackLoc))
  return args
```

The evaluator interprets the argument count to determine the location shape: 1 arg = line only, 2 args = line:col, 3 args = line:col-endCol (singleline range), 4 args = startLine:startCol-endLine:endCol (multiline range).

### 6.5 TuneSelector

`X:1` desugars to a primitive call on the implicit input:

```
desugarTuneSelector(ctx, tuneSelector):
  numArg = mkNum(tuneSelector.tuneNumber, tuneSelector.loc)
  if ctx.implicitInput is not null:
    return mkPrim("select_tune", [mkVar(ctx.implicitInput, tuneSelector.loc), numArg], tuneSelector.loc)
  return mkPrim("select_tune", [numArg], tuneSelector.loc)
```

---

## Phase 7: Pattern Matching and Strategy Desugaring

### 7.1 Match arms to nested if/else

Each match arm produces a conditional that tests the node's tag. Arms are chained as nested if/else with the default being pass-through (return the node unchanged):

```
desugarMatchArms(ctx, arms, matchParam):
  if arms.length == 0:
    // Unmatched nodes pass through unchanged. This is intentional: a match function
    // is a partial transform that only modifies matching nodes. Exhaustiveness
    // checking is deferred to a future lint pass (not the desugarer's responsibility).
    return mkVar(matchParam, DUMMY_LOC)

  arm = arms[0]
  rest = desugarMatchArms(ctx, arms.slice(1), matchParam)

  // Condition: tag equality test
  condition = mkPrim("tag_eq", [mkVar(matchParam, arm.tagLoc), mkStr(arm.tag, arm.tagLoc)], arm.tagLoc)

  // If there's a guard, conjoin it with the tag test
  if arm.guard is not null:
    guardExpr = desugarExpr(ctx, arm.guard)
    condition = mkIf(condition, guardExpr, mkNum(0, arm.loc), arm.loc)

  // Consequent: arm body
  // If there's a capture, bind it before the body
  savedInput = ctx.implicitInput
  consequent: CoreExpr
  if arm.capture is not null:
    ctx.implicitInput = arm.capture.name
    bodyExpr = desugarExpr(ctx, arm.body)
    consequent = mkLet(arm.capture.name, arm.capture.nameLoc, mkVar(matchParam, arm.capture.nameLoc), bodyExpr, arm.loc)
  else:
    bodyExpr = desugarExpr(ctx, arm.body)
    consequent = bodyExpr
  ctx.implicitInput = savedInput

  return mkIf(condition, consequent, rest, arm.loc)
```

### 7.2 Strategy keywords

When the atom dispatch produces an `Identifier` from a strategy keyword token (plan 31, Phase 9: `topdown`, `bottomup`, `oncetd`, `alltd` scan as keywords but parse as identifiers), the desugarer treats them as regular identifiers. They become the head of an application:

```
topdown my_rule  -->  Application(Identifier("topdown"), Identifier("my_rule"))
```

The application desugarer checks `isPrimitiveName("topdown")` which returns true, so it produces:

```
PrimCall("topdown", [Var("_0"), Var("my_rule")])
```

### 7.3 Primitive names registry

File: `abct/src/desugarer/primitives.ts` (extended from 6.3)

```typescript
const PRIMITIVES = new Set([
  // Operations
  "transpose", "remove", "to_rest", "set_rhythm", "sum_rhythm",
  "add_to_rhythm", "unwrap_single", "insert",
  // Selectors
  "select_chords", "select_notes", "select_rests", "select_voice",
  "select_top", "select_bottom", "select_nth_from_top",
  "select_all_but_top", "select_all_but_bottom",
  "select_siblings_after", "select_non_chord_notes", "select_chord_notes",
  "select_tune", "select_system", "select_range",
  // Strategies
  "topdown", "bottomup", "oncetd", "alltd",
  // Control
  "over", "filter",
  // Score
  "load", "add_voice",
  // Inspection
  "pitch", "length", "stringify", "stringify_header", "stringify_body",
  // Predicates
  "is_rest", "is_note", "is_chord",
  // Comparison (used internally by desugarComparison, not user-facing)
  "gt", "lt", "gte", "lte", "eq", "neq",
  // Misc
  "negate", "tag_eq", "make_record", "location", "abc_with_location",
]);

export function isPrimitiveName(name: string): boolean {
  return PRIMITIVES.has(name);
}

// The surface name equals the primitive name because plan 30 mandates
// underscored identifiers. No remapping is needed.
export function toPrimitiveName(name: string): string {
  return name;
}

// Mapping from Comparison.op values to primitive names
const COMPARISON_OP_MAP: Record<string, string> = {
  ">": "gt",
  "<": "lt",
  ">=": "gte",
  "<=": "lte",
  "==": "eq",
  "!=": "neq",
};

export function comparisonOpToPrimName(op: string): string {
  return COMPARISON_OP_MAP[op] ?? "eq";
}
```

---

## Phase 8: Conditional and Logical Operator Desugaring

### 8.1 IfExpr

`if cond then cons else alt` maps directly to the Core IR's `If` node. The `else` branch is always present because the parser (plan 31, Phase 8) requires it and reports an error if missing. The desugarer can therefore unconditionally access `ifExpr.alternative`:

```
desugarIf(ctx, ifExpr):
  condition = desugarExpr(ctx, ifExpr.condition)
  consequent = desugarExpr(ctx, ifExpr.consequent)
  alternative = desugarExpr(ctx, ifExpr.alternative)
  return mkIf(condition, consequent, alternative, ifExpr.loc)
```

### 8.2 Or

`a or b` desugars to `if a then a else b`. Because we do not want to evaluate `a` twice, we bind it to a fresh name:

```
desugarOr(ctx, orExpr):
  leftExpr = desugarExpr(ctx, orExpr.left)
  rightExpr = desugarExpr(ctx, orExpr.right)
  name = freshName(ctx)
  // let _n = a; if _n then _n else b
  return mkLet(name, orExpr.left.loc, leftExpr,
    mkIf(mkVar(name, orExpr.left.loc), mkVar(name, orExpr.left.loc), rightExpr, orExpr.loc),
    orExpr.loc)
```

### 8.3 And

`a and b` desugars to `if a then b else false`:

```
desugarAnd(ctx, andExpr):
  leftExpr = desugarExpr(ctx, andExpr.left)
  rightExpr = desugarExpr(ctx, andExpr.right)
  return mkIf(leftExpr, rightExpr, mkNum(0, andExpr.loc), andExpr.loc)
```

### 8.4 Not

`not a` desugars to `if a then false else true`:

```
desugarNot(ctx, notExpr):
  operand = desugarExpr(ctx, notExpr.operand)
  return mkIf(operand, mkNum(0, notExpr.loc), mkNum(1, notExpr.loc), notExpr.loc)
```

### 8.5 Comparison

`a >= b` becomes `PrimCall("gte", [desugar(a), desugar(b)])`:

```
desugarComparison(ctx, comp):
  left = desugarExpr(ctx, comp.left)
  right = desugarExpr(ctx, comp.right)
  primName = comparisonOpToPrimName(comp.op)  // ">="->"gte", "<="->"lte", etc.
  return mkPrim(primName, [left, right], comp.loc)
```

### 8.6 Negate

`-x` becomes `PrimCall("negate", [desugar(x)])`:

```
desugarNegate(ctx, neg):
  operand = desugarExpr(ctx, neg.operand)
  return mkPrim("negate", [operand], neg.loc)
```

---

## Phase 9: Record and Load Desugaring

### 9.1 RecordLiteral

`{key1=val1, key2=val2}` desugars to a `PrimCall("make_record", [...])` where each field becomes a two-element list:

```
desugarRecord(ctx, record):
  fieldArgs = record.fields.map(field => {
    key = mkStr(field.key, field.keyLoc)
    value = desugarExpr(ctx, field.value)
    return mkList([key, value], field.loc)
  })
  return mkPrim("make_record", fieldArgs, record.loc)
```

### 9.2 LoadExpr

`load "file.abc"` desugars to `PrimCall("load", [StringLit("file.abc")])`:

```
desugarLoad(ctx, loadExpr):
  return mkPrim("load", [mkStr(loadExpr.path, loadExpr.pathLoc)], loadExpr.loc)
```

### 9.3 FilterExpression

`filter (predicate)` desugars to a primitive call with a predicate closure:

```
desugarFilter(ctx, filterExpr):
  // The filter's predicate operates on each element
  param = freshName(ctx)
  savedInput = ctx.implicitInput
  ctx.implicitInput = param
  predicateBody = desugarExpr(ctx, filterExpr.predicate)
  ctx.implicitInput = savedInput
  predicateClosure = mkFn([param], [filterExpr.predicate.loc], predicateBody, filterExpr.predicate.loc)
  if savedInput is not null:
    return mkPrim("filter", [mkVar(savedInput, filterExpr.loc), predicateClosure], filterExpr.loc)
  return mkPrim("filter", [predicateClosure], filterExpr.loc)
```

### 9.4 ErrorExpr

```
desugarError(ctx, errorExpr):
  ctx.errors.push({ message: errorExpr.message, loc: errorExpr.loc })
  return mkError(errorExpr.message, errorExpr.loc)
```

---

## Phase 10: Example-Based Tests

### 10.1 Location

`abct/tests/core/desugarer.spec.ts`

### 10.2 Test helper

```typescript
function desugarSource(source: string): DesugarResult {
  const scanResult = scan(source);
  const parseResult = parse(scanResult.tokens);
  return desugar(parseResult.program);
}
```

### 10.3 Literal tests

```typescript
it("should desugar a number literal to NumLit", () => {
  const { program } = desugarSource("42");
  expect(isNum(program.body)).to.be.true;
  if (isNum(program.body)) expect(program.body.value).to.equal(42);
});

it("should desugar a string literal to StringLit", () => {
  const { program } = desugarSource('"hello"');
  expect(isStr(program.body)).to.be.true;
  if (isStr(program.body)) expect(program.body.value).to.equal("hello");
});

it("should desugar an inline ABC literal to AbcLit", () => {
  const { program } = desugarSource("`CEG A2`");
  expect(isAbc(program.body)).to.be.true;
  if (isAbc(program.body)) expect(program.body.content).to.equal("CEG A2");
});

it("should desugar a list to CoreList", () => {
  const { program } = desugarSource("[1, 2, 3]");
  expect(isList(program.body)).to.be.true;
  if (isList(program.body)) expect(program.body.elements).to.have.length(3);
});

it("should desugar an identifier to Var", () => {
  const { program } = desugarSource("x");
  expect(isVar(program.body)).to.be.true;
  if (isVar(program.body)) expect(program.body.name).to.equal("x");
});
```

### 10.4 Binding tests

```typescript
it("should desugar assignment to Let", () => {
  const { program } = desugarSource("x = 5\nx");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body)) {
    expect(program.body.name).to.equal("x");
    expect(isNum(program.body.value)).to.be.true;
    expect(isVar(program.body.body)).to.be.true;
  }
});

it("should desugar multiple assignments to nested Lets", () => {
  const { program } = desugarSource("x = 1\ny = 2\nx");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body)) {
    expect(program.body.name).to.equal("x");
    expect(isLet(program.body.body)).to.be.true;
  }
});
```

### 10.5 Pipeline tests

```typescript
it("should desugar 'a | b' to let + application", () => {
  const { program } = desugarSource("a | b");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body)) {
    expect(isVar(program.body.value)).to.be.true;  // desugar(a) -> Var("a")
    expect(isApp(program.body.body)).to.be.true;   // b(Var("_0"))
  }
});

it("should desugar 'a | b | c' to nested lets", () => {
  const { program } = desugarSource("a | b | c");
  expect(isLet(program.body)).to.be.true;
  // let _0 = a; let _1 = b(_0); c(_1)
});

it("should desugar 'a | transpose @chords 2' to let + PrimCall", () => {
  const { program } = desugarSource("a | transpose @chords 2");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body)) {
    expect(isPrim(program.body.body)).to.be.true;
    if (isPrim(program.body.body)) {
      expect(program.body.body.name).to.equal("transpose");
    }
  }
});
```

### 10.6 Function tests

```typescript
it("should desugar fn def to Let + Fn", () => {
  const { program } = desugarSource("fn double(x) { x }\ndouble");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body)) {
    expect(program.body.name).to.equal("double");
    expect(isFn(program.body.value)).to.be.true;
    if (isFn(program.body.value)) {
      expect(program.body.value.params).to.deep.equal(["x"]);
    }
  }
});
```

### 10.7 Over tests

```typescript
it("should desugar 'over @chords (transpose 2)' to PrimCall with closure", () => {
  const { program } = desugarSource("x | over @chords (transpose 2)");
  // let _0 = x; prim("over", [Var("_0"), <selector fn>, Fn([_1], prim("transpose", ...))])
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body) && isPrim(program.body.body)) {
    expect(program.body.body.name).to.equal("over");
    // Third arg should be a Fn (the body closure)
    expect(isFn(program.body.body.args[2])).to.be.true;
  }
});
```

### 10.8 Match tests

```typescript
it("should desugar fn match to nested if/else", () => {
  const src = "fn rule = match {\n  chord |c| => c\n  note |n| => n\n}\nrule";
  const { program } = desugarSource(src);
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body) && isFn(program.body.value)) {
    // Body of the fn should be an If (nested conditionals)
    expect(isIf(program.body.value.body)).to.be.true;
  }
});
```

### 10.9 Conditional and logical tests

```typescript
it("should desugar if/then/else to If node", () => {
  const { program } = desugarSource("if x then y else z");
  expect(isIf(program.body)).to.be.true;
});

it("should desugar 'a and b' to If(a, b, 0)", () => {
  const { program } = desugarSource("a and b");
  expect(isIf(program.body)).to.be.true;
  if (isIf(program.body)) {
    expect(isVar(program.body.condition)).to.be.true;
    expect(isVar(program.body.consequent)).to.be.true;
    expect(isNum(program.body.alternative)).to.be.true;
  }
});

it("should desugar 'a or b' to Let + If", () => {
  const { program } = desugarSource("a or b");
  expect(isLet(program.body)).to.be.true;
});

it("should desugar 'not a' to If(a, 0, 1)", () => {
  const { program } = desugarSource("not a");
  expect(isIf(program.body)).to.be.true;
});
```

### 10.10 Record and load tests

```typescript
it("should desugar record to PrimCall make_record", () => {
  const { program } = desugarSource('{name="Trumpet"}');
  expect(isPrim(program.body)).to.be.true;
  if (isPrim(program.body)) {
    expect(program.body.name).to.equal("make_record");
    expect(program.body.args).to.have.length(1);
    expect(isList(program.body.args[0])).to.be.true;
  }
});

it("should desugar load to PrimCall", () => {
  const { program } = desugarSource('load "file.abc"');
  expect(isPrim(program.body)).to.be.true;
  if (isPrim(program.body)) {
    expect(program.body.name).to.equal("load");
    expect(isStr(program.body.args[0])).to.be.true;
  }
});
```

### 10.11 Strategy tests

```typescript
it("should desugar 'topdown my_rule' to PrimCall", () => {
  const { program } = desugarSource("x | topdown my_rule");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body) && isPrim(program.body.body)) {
    expect(program.body.body.name).to.equal("topdown");
  }
});
```

### 10.12 Negate, TuneSelector, LocationSelector, and Filter tests

```typescript
it("should desugar '-x' to PrimCall negate", () => {
  const { program } = desugarSource("-x");
  expect(isPrim(program.body)).to.be.true;
  if (isPrim(program.body)) {
    expect(program.body.name).to.equal("negate");
    expect(program.body.args).to.have.length(1);
    expect(isVar(program.body.args[0])).to.be.true;
  }
});

it("should desugar '-42' to PrimCall negate with NumLit", () => {
  const { program } = desugarSource("-42");
  expect(isPrim(program.body)).to.be.true;
  if (isPrim(program.body)) {
    expect(program.body.name).to.equal("negate");
    expect(isNum(program.body.args[0])).to.be.true;
  }
});

it("should desugar 'X:1' to PrimCall select_tune in a pipeline", () => {
  const { program } = desugarSource("source | X:1");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body) && isPrim(program.body.body)) {
    expect(program.body.body.name).to.equal("select_tune");
    expect(program.body.body.args).to.have.length(2);
    // first arg is the implicit input, second is the tune number
    expect(isVar(program.body.body.args[0])).to.be.true;
    expect(isNum(program.body.body.args[1])).to.be.true;
    if (isNum(program.body.body.args[1])) expect(program.body.body.args[1].value).to.equal(1);
  }
});

it("should desugar ':5:1-8' to PrimCall location", () => {
  const { program } = desugarSource(":5:1-8");
  expect(isPrim(program.body)).to.be.true;
  if (isPrim(program.body)) {
    expect(program.body.name).to.equal("location");
    // 3 args: line=5, col=1, endCol=8
    expect(program.body.args).to.have.length(3);
  }
});

it("should desugar ':10' to PrimCall location with 1 arg", () => {
  const { program } = desugarSource(":10");
  expect(isPrim(program.body)).to.be.true;
  if (isPrim(program.body)) {
    expect(program.body.name).to.equal("location");
    expect(program.body.args).to.have.length(1);
  }
});

it("should desugar 'filter (pitch > C4)' to PrimCall with closure", () => {
  const { program } = desugarSource("x | filter (pitch > C4)");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body) && isPrim(program.body.body)) {
    expect(program.body.body.name).to.equal("filter");
    expect(program.body.body.args).to.have.length(2);
    // first arg is implicit input, second is predicate closure
    expect(isVar(program.body.body.args[0])).to.be.true;
    expect(isFn(program.body.body.args[1])).to.be.true;
  }
});

it("should desugar a >= b to PrimCall gte", () => {
  const { program } = desugarSource("a >= b");
  expect(isPrim(program.body)).to.be.true;
  if (isPrim(program.body)) {
    expect(program.body.name).to.equal("gte");
    expect(program.body.args).to.have.length(2);
  }
});

it("should desugar fraction literal '1/2' to NumLit 0.5", () => {
  const { program } = desugarSource("1/2");
  expect(isNum(program.body)).to.be.true;
  if (isNum(program.body)) expect(program.body.value).to.equal(0.5);
});
```

### 10.13 Integration tests (composed constructs)

```typescript
it("should desugar 'source | over @chords (filter (pitch > C4))' correctly", () => {
  const { program } = desugarSource("source | over @chords (filter (pitch > C4))");
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body) && isPrim(program.body.body)) {
    expect(program.body.body.name).to.equal("over");
    // The body closure should contain a filter PrimCall
    const bodyClosure = program.body.body.args[2];
    expect(isFn(bodyClosure)).to.be.true;
    if (isFn(bodyClosure) && isPrim(bodyClosure.body)) {
      expect(bodyClosure.body.name).to.equal("filter");
    }
  }
});

it("should desugar 'source | topdown my_rule | stringify' correctly", () => {
  const { program, errors } = desugarSource("source | topdown my_rule | stringify");
  expect(errors).to.have.length(0);
  // Should produce two nested Let bindings
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body) && isLet(program.body.body)) {
    // Inner Let body should reference stringify
    expect(isPrim(program.body.body.body) || isApp(program.body.body.body)).to.be.true;
  }
});

it("should desugar a full program with fn def, pipeline, and match", () => {
  const src = [
    "fn my_rule = match {",
    "  chord |c| => c",
    "  note |n| => n",
    "}",
    'load "input.abc" | X:1 | topdown my_rule | stringify',
  ].join("\n");
  const { program, errors } = desugarSource(src);
  expect(errors).to.have.length(0);
  // Top level should be a Let (for fn def) followed by the pipeline
  expect(isLet(program.body)).to.be.true;
  if (isLet(program.body)) {
    expect(program.body.name).to.equal("my_rule");
    expect(isFn(program.body.value)).to.be.true;
  }
});
```

### 10.14 Error handling tests

```typescript
it("should preserve ErrorExpr as CoreError", () => {
  // This test uses a source that the parser produces an ErrorExpr for
  const { program, errors } = desugarSource("fn bad = match {}");
  expect(errors.length).to.be.greaterThan(0);
});

it("should produce no errors for valid programs", () => {
  const { errors } = desugarSource("x = 5\nx");
  expect(errors).to.have.length(0);
});
```

---

## Phase 11: Property-Based Tests

### 11.1 Location

`abct/tests/core/pbt.spec.ts`

### 11.2 Generator file

`abct/tests/core/generators.ts` -- reuses the parser generators from `abct/tests/generators.ts`.

### 11.3 Structural properties

```typescript
it("property: all generated expressions desugar without throwing", () => {
  fc.assert(
    fc.property(genExpr, (src) => {
      const result = desugarSource(src);
      return result.program.body !== undefined;
    }),
    { numRuns: 5000 }
  );
});

it("property: all generated statements desugar without throwing", () => {
  fc.assert(
    fc.property(genStatement, (src) => {
      const result = desugarSource(src);
      return result.program.body !== undefined;
    }),
    { numRuns: 5000 }
  );
});

it("property: all generated programs desugar without throwing", () => {
  fc.assert(
    fc.property(genProgram, (src) => {
      const result = desugarSource(src);
      return result.program.body !== undefined;
    }),
    { numRuns: 10000 }
  );
});
```

### 11.4 Location preservation property

```typescript
it("property: every Core IR node has a valid loc", () => {
  fc.assert(
    fc.property(genExpr, (src) => {
      const { program } = desugarSource(src);
      return allNodesHaveLoc(program.body);
    }),
    { numRuns: 5000 }
  );
});

function allNodesHaveLoc(node: CoreExpr): boolean {
  if (!node.loc || node.loc.start.line < 0) return false;
  // recursively check all child nodes
  switch (node.type) {
    case "app": return allNodesHaveLoc(node.fn) && node.args.every(allNodesHaveLoc);
    case "fn": return allNodesHaveLoc(node.body);
    case "let": return allNodesHaveLoc(node.value) && allNodesHaveLoc(node.body);
    case "if": return allNodesHaveLoc(node.condition) && allNodesHaveLoc(node.consequent) && allNodesHaveLoc(node.alternative);
    case "list": return node.elements.every(allNodesHaveLoc);
    case "prim": return node.args.every(allNodesHaveLoc);
    default: return true;
  }
}
```

### 11.5 Pipeline flattening property

Because the `genIdentifier` generator excludes keywords and primitive names, all generated identifiers desugar to bare `Var` nodes. The pipeline desugarer wraps each stage in a `Let` binding, so a pipeline of N identifiers produces exactly N-1 `Let` bindings:

```typescript
it("property: a pipeline of N identifiers produces N-1 Let bindings", () => {
  fc.assert(
    fc.property(
      fc.array(genIdentifier, { minLength: 2, maxLength: 6 }),
      (ids) => {
        const src = ids.join(" | ");
        const { program } = desugarSource(src);
        let depth = 0;
        let node: CoreExpr = program.body;
        while (isLet(node)) { depth++; node = node.body; }
        return depth === ids.length - 1;
      }
    ),
    { numRuns: 3000 }
  );
});
```

Note: The `genIdentifier` filter (from plan 31's generators) already excludes all keywords including strategy keywords and primitive names, so no identifier will trigger the `isPrimitiveName` code path. If it did, the structural depth would still be the same, but the leaf node would be a `PrimCall` instead of an `App`.

### 11.6 Idempotence-adjacent property: no surface constructs survive

```typescript
it("property: desugared output contains no surface-only node types", () => {
  fc.assert(
    fc.property(genProgram, (src) => {
      const { program } = desugarSource(src);
      return containsNoSurfaceTypes(program.body);
    }),
    { numRuns: 5000 }
  );
});

function containsNoSurfaceTypes(node: CoreExpr): boolean {
  // All nodes should have type in the CoreExpr union
  const validTypes = new Set(["var", "app", "fn", "let", "if", "list", "num", "str", "abc", "prim", "core_error"]);
  if (!validTypes.has(node.type)) return false;
  // recursively check children...
  switch (node.type) {
    case "app": return containsNoSurfaceTypes(node.fn) && node.args.every(containsNoSurfaceTypes);
    case "fn": return containsNoSurfaceTypes(node.body);
    case "let": return containsNoSurfaceTypes(node.value) && containsNoSurfaceTypes(node.body);
    case "if": return containsNoSurfaceTypes(node.condition) && containsNoSurfaceTypes(node.consequent) && containsNoSurfaceTypes(node.alternative);
    case "list": return node.elements.every(containsNoSurfaceTypes);
    case "prim": return node.args.every(containsNoSurfaceTypes);
    default: return true;
  }
}
```

---

## Phase 12: Integration with Build

### 12.1 Exports

Add to `abct/src/index.ts`:

```typescript
export { CoreExpr, CoreProgram, Var, App, Fn, Let, If, CoreList, NumLit, StringLit, AbcLit, PrimCall, CoreError } from "./core/types";
export { mkVar, mkApp, mkFn, mkLet, mkIf, mkList, mkNum, mkStr, mkAbc, mkPrim, mkError } from "./core/utils";
export { isVar, isApp, isFn, isLet, isIf, isList, isNum, isStr, isAbc, isPrim, isCoreError } from "./core/utils";
export { desugar, DesugarResult } from "./desugarer/index";
```

### 12.2 Build verification

Run `npm run build` from the repo root. The new files must compile without errors.

### 12.3 Test verification

Run `npm run test` from the repo root. All existing tests must continue passing, and the new desugarer tests must pass.

---

## Deferred Work

The following are out of scope for this plan:

- Evaluator: the component that interprets Core IR nodes, manages environments, and calls built-in primitives. This is a separate plan.
- Child-sibling tree: the `CSNode` structure and `fromAst()`/`toAst()` conversions are part of the evaluator's runtime, not the desugarer.
- Built-in primitive implementations: the desugarer only names the primitives (via `PrimCall` nodes). Their implementations are in the evaluator.
- Formatter updates: the formatter operates on the surface AST, not the Core IR.
- LSP integration: hover/completion for Core IR constructs is deferred.
- Runtime replacement: the existing `abct/src/runtime/` module (which directly queries/mutates ABC ASTs) is not replaced by this plan. The Core IR evaluator will eventually supersede it.

---

## Implementation Checklist

- [ ] Phase 1: Create `abct/src/core/types.ts` with `CoreExpr` union (11 variants: Var, App, Fn, Let, If, CoreList, NumLit, StringLit, AbcLit, PrimCall, CoreError), `CoreProgram` interface; create `abct/src/core/utils.ts` with 11 `mk*` constructor helpers and 11 `is*` type guards
- [ ] Phase 2: Create `abct/src/desugarer/index.ts` (public API with `desugar()` and `DesugarResult`), `abct/src/desugarer/desugar.ts` (context with counter/implicitInput/errors, `freshName`, `DUMMY_LOC`, `spanLoc`, `parseNumericValue`, main dispatch, `desugarProgram`, `desugarStatement`, `wrapStatementAsLet`)
- [ ] Phase 3: Implement `desugarIdentifier` (Var), `desugarNumber` (parse fraction/decimal/int string to NumLit), `desugarString` (StringLit), `desugarAbcLiteral` (AbcLit with optional abc_with_location PrimCall), `desugarAbcLiteralInline` (AbcLit), `desugarList` (CoreList), `desugarGroup` (transparent with group loc override)
- [ ] Phase 4: Implement `desugarFnDef` (Fn closure, first param as implicit input), `desugarFnMatchDef` (Fn with nested if/else body, matchKwLoc for synthetic param)
- [ ] Phase 5: Implement `desugarPipe` (Let-binding + reversed application, Var wrapping), `desugarApplication` (built-in check + implicit input prepend for both paths), `desugarPrimApplication` (selector narrowing via `desugarSelectorAsNarrowing`), `desugarSelectorAsNarrowing` (PrimCall with error for missing implicit input)
- [ ] Phase 6: Implement `desugarOver` (PrimCall with body closure, save/restore implicit input), `desugarSelector` (standalone: Fn closure), `desugarLocation` (PrimCall with `buildLocationArgs` handling singleline/multiline ranges), `desugarTuneSelector` (PrimCall select_tune); create `abct/src/desugarer/primitives.ts` with `SELECTOR_MAP`, `selectorToPrimName` (using `selector.path.id`), `desugarSelectorValue` (handling string/number/Range), `isPrimitiveName`, `toPrimitiveName`, `comparisonOpToPrimName`
- [ ] Phase 7: Implement `desugarMatchArms` (nested If/else with tag_eq PrimCall, captures as Let bindings, guards as conjoined conditions, pass-through default); extend `primitives.ts` with PRIMITIVES set (operations, selectors, strategies, control, inspection, predicates, misc)
- [ ] Phase 8: Implement `desugarIf` (direct If mapping, else always present), `desugarOr` (Let + If to avoid double evaluation), `desugarAnd` (If with NumLit(0) alternative), `desugarNot` (If inversion with NumLit(0)/NumLit(1)), `desugarComparison` (PrimCall with comparisonOpToPrimName), `desugarNegate` (PrimCall negate)
- [ ] Phase 9: Implement `desugarRecord` (PrimCall make_record with List field pairs), `desugarLoad` (PrimCall load with StringLit path), `desugarFilter` (PrimCall with predicate Fn closure, implicit input for predicate body), `desugarError` (CoreError + ctx.errors push)
- [ ] Phase 10: Create `abct/tests/core/desugarer.spec.ts` with example-based tests for: literals (number, string, abc, list, identifier, fraction), bindings, pipelines, functions, over, match, conditionals (if, and, or, not), comparison, negate, record, load, strategy, tune selector, location selector, filter, error handling
- [ ] Phase 11: Create `abct/tests/core/pbt.spec.ts` with property-based tests: no-throw for all generators, location preservation on all nodes, pipeline Let-binding depth, no surface node types in output
- [ ] Phase 12: Update `abct/src/index.ts` exports (Core IR types, utils, desugar function, DesugarError); verify `npm run build` and `npm run test` succeed

Copy the plan file into the plans directory, and once you are done with the implementation of each phase, call the code review agent on the changes and address any feedback. After the feedback is addressed, verify that the build succeeds (`npm run build`) and all tests pass (`npm run test`). Only then commit the changes.
