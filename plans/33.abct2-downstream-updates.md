# ABCt v2 Downstream Updates (Formatter, Validator, LSP)

## Table of Contents

1. [Goal](#goal)
2. [Context and Dependencies](#context-and-dependencies)
3. [Scope Clarification](#scope-clarification)
4. [Phase 1: ABCT Formatter](#phase-1-abct-formatter)
5. [Phase 2: AST Utilities](#phase-2-ast-utilities)
6. [Phase 3: ABCT Validator](#phase-3-abct-validator)
7. [Phase 4: Operator Docs and Hover Provider](#phase-4-operator-docs-and-hover-provider)
8. [Phase 5: Completion Context and Provider](#phase-5-completion-context-and-provider)
9. [Phase 6: Semantic Token Mapping](#phase-6-semantic-token-mapping)
10. [Phase 7: Evaluator Updates (Partial)](#phase-7-evaluator-updates-partial)
11. [Phase 8: Tests](#phase-8-tests)
12. [Deferred Work](#deferred-work)
13. [Implementation Checklist](#implementation-checklist)

---

## Goal

We are updating the LSP-side components that consume the ABCT AST so that they compile and function correctly after the parser update (plan 31). Because the parser removes 4 AST types and adds 9 new ones, every component that dispatches on the Expr union or imports AST types must be updated. The updates fall into two categories:

1. Mechanical updates: removing references to deleted types, adding dispatch/format/traversal branches for new types. These are purely structural and do not require new runtime infrastructure.
2. Semantic updates: implementing evaluation logic for new constructs (functions, records, conditionals). These require the core IR and runtime to be extended and are largely deferred to plan 32.

---

## Context and Dependencies

### Dependency on plan 31

This plan depends on the parser update. All new AST types (`StringLiteral`, `AbcLiteralInline`, `OverExpr`, `FnDef`, `FnMatchDef`, `RecordLiteral`, `LoadExpr`, `IfExpr`, `TuneSelector`) and their type guards must exist in `abct/src/ast.ts` before these files can be updated.

### Dependency on plan 30

Phase 6 (semantic token mapping) depends on the scanner update. The scanner must produce the new token types before the mapping can reference them. Phase 6 MUST NOT be implemented until plan 30 is complete. The scanner must produce: `FN`, `MATCH`, `OVER`, `IF`, `THEN`, `ELSE`, `TOPDOWN`, `BOTTOMUP`, `ONCETD`, `ALLTD`, `LOAD`, `ARROW`, `LBRACE`, `RBRACE`, `COLON`, `ABC_LITERAL_OPEN`, `ABC_LITERAL_CONTENT`, `ABC_LITERAL_CLOSE`, and must no longer produce `PIPE_EQ`.

Note: `PLUS` is NOT removed from the scanner enum in plan 30. The scanner will still emit `PLUS` tokens when it encounters `+` characters. However, `+` has no grammatical role in v2, so it is treated as an invalid operator. We keep `PLUS` in the semantic token mapping as an operator scope so the user can see the highlighted `+` character (which aids error discovery when they write `a + b` and wonder why it does not work).

### AST changes summary

Removed:
- `Concat` (type: `"concat"`)
- `Update` (type: `"update"`)
- `FileRef` (type: `"file_ref"`)
- `VoiceRef` (type: `"voice_ref"`)

Added:
- `StringLiteral` (type: `"string"`)
- `AbcLiteralInline` (type: `"abc_literal_inline"`)
- `OverExpr` (type: `"over"`)
- `FnDef` (type: `"fn_def"`)
- `FnMatchDef` (type: `"fn_match_def"`)
- `RecordLiteral` (type: `"record"`)
- `LoadExpr` (type: `"load"`)
- `IfExpr` (type: `"if"`)
- `TuneSelector` (type: `"tune_selector"`)

Statement type changed:
- Old: `Statement = Assignment | Expr`
- New: `Statement = Assignment | FnDef | FnMatchDef | Expr`

Scanner tokens removed: `PIPE_EQ`
Scanner tokens added: `FN`, `MATCH`, `OVER`, `LET`, `IF`, `THEN`, `ELSE`, `TOPDOWN`, `BOTTOMUP`, `ONCETD`, `ALLTD`, `LOAD`, `ARROW`, `LBRACE`, `RBRACE`, `COLON`, `ABC_LITERAL_OPEN`, `ABC_LITERAL_CONTENT`, `ABC_LITERAL_CLOSE`

### Migration note: FileRef with location

In v1, the user could write `song.abc:3:1` which parsed as a `FileRef` with a `location` field and optionally a `selector` field. In v2, these are expressed as a pipeline: `load "song.abc" | :3:1` (pipe into a location selector). This is not a behavioral regression -- the syntax is equivalent but more explicit.

### Source files

- `abct/src/ast-utils.ts` -- AST traversal utilities (findNodeAtPosition, getNodePath)
- `abc-lsp-server/src/abct/AbctFormatter.ts` -- ABCT code formatter
- `abc-lsp-server/src/abct/AbctValidator.ts` -- ABCT semantic validator
- `abc-lsp-server/src/abct/AbctHoverProvider.ts` -- hover documentation
- `abc-lsp-server/src/abct/AbctCompletionProvider.ts` -- auto-completion
- `abc-lsp-server/src/abct/completionContext.ts` -- completion context detection
- `abc-lsp-server/src/abct/operatorDocs.ts` -- operator documentation registry
- `abc-lsp-server/src/server_helpers.ts` -- semantic token mapping
- `abc-lsp-server/src/abctEvaluator.ts` -- ABCT program evaluator

---

## Scope Clarification

### What is NOT in scope

The ABC notation formatter (`parse/Visitors/Formatter2.ts`) and the ABC notation semantic analyzer (`parse/analyzers/semantic-analyzer.ts`) operate on ABC music notation ASTs (Note, Chord, Tune, etc.), not on ABCT language ASTs. They are unaffected by the parser update and are not covered here.

The components updated in this plan are all in `abc-lsp-server/src/` and `abct/src/`, and operate on the ABCT language AST (Pipe, Application, Selector, etc.).

---

## Phase 1: ABCT Formatter

### File: `abc-lsp-server/src/abct/AbctFormatter.ts`

### 1.1 Imports to remove

Remove from the import statement:
- `Concat`, `Update`, `FileRef`, `VoiceRef`
- `isConcat`, `isUpdate`, `isFileRef`, `isVoiceRef`

### 1.2 Imports to add

Add to the import statement from `../../../abct/src/ast`:
- `StringLiteral`, `AbcLiteralInline`, `OverExpr`, `FnDef`, `FnMatchDef`, `RecordLiteral`, `LoadExpr`, `IfExpr`, `TuneSelector`
- `isStringLiteral`, `isAbcLiteralInline`, `isOverExpr`, `isFnDef`, `isFnMatchDef`, `isRecordLiteral`, `isLoadExpr`, `isIfExpr`, `isTuneSelector`
- `MatchArm`, `RecordField`, `FnParam`

### 1.3 Methods to delete

- `formatConcat(concat: Concat): void`
- `formatUpdate(update: Update): void`
- `formatFileRef(ref: FileRef): void`
- `formatVoiceRef(ref: VoiceRef): void`

### 1.4 Update `formatExpr` dispatch

Remove the `isConcat`, `isUpdate`, `isVoiceRef`, `isFileRef` branches from `formatExpr`. Add new branches at the end (before the implicit fallthrough):

```
} else if (isStringLiteral(expr)) {
  this.formatStringLiteral(expr);
} else if (isAbcLiteralInline(expr)) {
  this.formatAbcLiteralInline(expr);
} else if (isOverExpr(expr)) {
  this.formatOver(expr);
} else if (isRecordLiteral(expr)) {
  this.formatRecord(expr);
} else if (isLoadExpr(expr)) {
  this.formatLoad(expr);
} else if (isIfExpr(expr)) {
  this.formatIf(expr);
} else if (isTuneSelector(expr)) {
  this.formatTuneSelector(expr);
}
```

Note: `FnDef` and `FnMatchDef` are NOT in the `Expr` union (they are `Statement` variants), so they do not appear in `formatExpr`. They are dispatched from `formatStatement` (section 1.5).

### 1.5 Update `formatStatement`

Because `Statement` now includes `FnDef` and `FnMatchDef`, the dispatch must be updated:

```
formatStatement(stmt: Statement):
  if isAssignment(stmt):     formatAssignment(stmt)
  else if isFnDef(stmt):     formatFnDef(stmt)
  else if isFnMatchDef(stmt): formatFnMatchDef(stmt)
  else:                       formatExpr(stmt)
```

### 1.6 Update `formatApplicationTerm`

Remove `isConcat` from the parenthesization condition (line 363). The condition becomes:

```
if (isPipe(expr) || isOr(expr) || isAnd(expr) || isComparison(expr))
```

Note: `OverExpr` does NOT need parenthesization here. Because `over` is parsed at the atom level (it self-terminates at the closing `)` of its body), an `OverExpr` in application position is already a complete, unambiguous unit.

### 1.7 New format methods

```
formatStringLiteral(lit: StringLiteral):
  output.push('"')
  output.push(lit.value)
  output.push('"')

formatAbcLiteralInline(lit: AbcLiteralInline):
  output.push('`')
  output.push(lit.content)
  output.push('`')

formatOver(over: OverExpr):
  output.push("over ")
  formatExpr(over.focus)
  output.push(" (")
  // The body may be multi-line (it is parsed with parsePipeline).
  // Because formatPipe already handles multi-line pipes and updates
  // currentLine internally, we delegate line tracking to it.
  formatExpr(over.body)
  output.push(")")

formatFnDef(fn: FnDef):
  output.push("fn ")
  output.push(fn.name)
  output.push("(")
  for i, param of fn.params:
    if i > 0: output.push(", ")
    output.push(param.name)
  output.push(") {")
  currentLine = fn.openBraceLoc.start.line
  // Emit body starting on the next line
  output.push("\n")
  currentLine++
  formatExpr(fn.body)
  currentLine = fn.body.loc.end.line
  output.push("\n}")
  currentLine++

formatFnMatchDef(fn: FnMatchDef):
  output.push("fn ")
  output.push(fn.name)
  output.push(" = match {")
  currentLine = fn.openBraceLoc.start.line
  for arm of fn.arms:
    output.push("\n")
    currentLine++
    formatMatchArm(arm)
    currentLine = arm.loc.end.line
  output.push("\n}")
  currentLine++

formatMatchArm(arm: MatchArm):
  output.push("  ")
  output.push(arm.tag)
  if arm.capture:
    output.push(" |")
    output.push(arm.capture.name)
    output.push("|")
  if arm.guard:
    output.push(" if ")
    formatExpr(arm.guard)
  output.push(" => ")
  formatExpr(arm.body)

formatRecord(rec: RecordLiteral):
  // Record fields use no spaces around = (intentionally different from
  // top-level assignment formatting which uses " = "). This is because
  // record fields are a compact, data-literal syntax.
  output.push("{")
  for i, field of rec.fields:
    if i > 0: output.push(", ")
    output.push(field.key)
    output.push("=")
    formatExpr(field.value)
  output.push("}")

formatLoad(load: LoadExpr):
  output.push('load "')
  output.push(load.path)
  output.push('"')

formatIf(ifExpr: IfExpr):
  output.push("if ")
  formatExpr(ifExpr.condition)
  output.push(" then ")
  formatExpr(ifExpr.consequent)
  output.push(" else ")
  formatExpr(ifExpr.alternative)

formatTuneSelector(sel: TuneSelector):
  output.push("X:")
  output.push(String(sel.tuneNumber))
```

### 1.8 Multi-line formatting for over bodies and fn bodies

Because `OverExpr` bodies, `FnDef` bodies, and `IfExpr` sub-expressions can all be multi-line pipelines (parsed with `parsePipeline`), the formatter must handle `currentLine` tracking correctly in all of them.

The key insight is that `formatPipe` (the existing method for Pipe expressions) already handles multi-line pipes by checking `pipe.opLoc.start.line > pipe.left.loc.end.line` and emitting newlines accordingly, updating `currentLine` as it goes. We can rely on this: whenever `formatExpr` is called on a multi-line body, if that body is a Pipe, the pipe formatter handles line tracking internally.

For `formatOver`: because the body is enclosed in parentheses, all newlines in the body are visually between `(` and `)`. The `currentLine` is updated by the inner `formatExpr` call.

For `formatFnDef` and `formatFnMatchDef`: we explicitly emit `\n` before the body and after the body, and set `currentLine` based on the AST's loc fields (see the pseudo-code in 1.7). This ensures that if comments exist between the `{` and the body, they are emitted at the correct positions.

### 1.9 Indentation note

The current formatter does not use indentation beyond the 2-space indent for match arms. Because the existing code does not implement a general indentation system (no `indent`/`dedent` stack), we keep the approach minimal: match arms get a literal `"  "` prefix, and fn bodies are not additionally indented (they appear as top-level statements inside `{}`). This matches the existing formatter's philosophy of minimal formatting.

---

## Phase 2: AST Utilities

### File: `abct/src/ast-utils.ts`

This file provides `findNodeAtPosition` (used by the hover provider) and `buildPathInExpr` (used by `isInApplicationPosition`). Both dispatch on AST node types and must be updated.

### 2.1 Imports to remove

- `isConcat`, `isUpdate`, `isFileRef`, `isVoiceRef`
- `Concat`, `Update`

### 2.2 Imports to add

- `isOverExpr`, `isFnDef`, `isFnMatchDef`, `isRecordLiteral`, `isLoadExpr`, `isIfExpr`, `isStringLiteral`, `isAbcLiteralInline`, `isTuneSelector`
- `OverExpr`, `FnDef`, `FnMatchDef`, `RecordLiteral`, `IfExpr`, `LoadExpr`

### 2.3 Delete functions

- `findInConcat(concat: Concat, ...)` -- synthesized `"concat_op"` nodes
- `findInUpdate(update: Update, ...)` -- synthesized `"update_op"` nodes

### 2.4 New traversal functions

```
findInOver(over: OverExpr, line: number, column: number): AstNode | null
  // Check the 'over' keyword
  if containsPosition(over.kwLoc, line, column):
    return { type: "over_kw", loc: over.kwLoc, keyword: "over" } as AstNode

  // Check open paren
  if containsPosition(over.openLoc, line, column):
    return { type: "over_open", loc: over.openLoc } as AstNode

  // Check close paren
  if containsPosition(over.closeLoc, line, column):
    return { type: "over_close", loc: over.closeLoc } as AstNode

  // Check focus
  inFocus = findInExpr(over.focus, line, column)
  if inFocus: return inFocus

  // Check body
  inBody = findInExpr(over.body, line, column)
  if inBody: return inBody

  return over

findInIf(ifExpr: IfExpr, line: number, column: number): AstNode | null
  // Check 'if' keyword
  if containsPosition(ifExpr.ifLoc, line, column):
    return { type: "if_kw", loc: ifExpr.ifLoc, keyword: "if" } as AstNode

  // Check 'then' keyword
  if containsPosition(ifExpr.thenLoc, line, column):
    return { type: "then_kw", loc: ifExpr.thenLoc, keyword: "then" } as AstNode

  // Check 'else' keyword
  if containsPosition(ifExpr.elseLoc, line, column):
    return { type: "else_kw", loc: ifExpr.elseLoc, keyword: "else" } as AstNode

  // Check sub-expressions
  inCond = findInExpr(ifExpr.condition, line, column)
  if inCond: return inCond

  inCons = findInExpr(ifExpr.consequent, line, column)
  if inCons: return inCons

  inAlt = findInExpr(ifExpr.alternative, line, column)
  if inAlt: return inAlt

  return ifExpr

findInRecord(rec: RecordLiteral, line: number, column: number): AstNode | null
  // Check open brace
  if containsPosition(rec.openLoc, line, column):
    return { type: "record_open", loc: rec.openLoc } as AstNode

  // Check close brace
  if containsPosition(rec.closeLoc, line, column):
    return { type: "record_close", loc: rec.closeLoc } as AstNode

  // Check fields
  for field of rec.fields:
    if containsPosition(field.loc, line, column):
      // Check field key
      if containsPosition(field.keyLoc, line, column):
        return { type: "record_key", loc: field.keyLoc, key: field.key } as AstNode
      // Check field value
      inValue = findInExpr(field.value, line, column)
      if inValue: return inValue
      return field as AstNode

  return rec

findInLoad(load: LoadExpr, line: number, column: number): AstNode | null
  // Check 'load' keyword
  if containsPosition(load.kwLoc, line, column):
    return { type: "load_kw", loc: load.kwLoc, keyword: "load" } as AstNode

  // Check path string
  if containsPosition(load.pathLoc, line, column):
    return { type: "load_path", loc: load.pathLoc, path: load.path } as AstNode

  return load
```

### 2.5 Update `findInExpr` dispatch

Remove the `isConcat(expr)` and `isUpdate(expr)` branches. Add new branches:

```
if isOverExpr(expr):
  return findInOver(expr, line, column)
if isIfExpr(expr):
  return findInIf(expr, line, column)
if isRecordLiteral(expr):
  return findInRecord(expr, line, column)
if isLoadExpr(expr):
  return findInLoad(expr, line, column)
```

Update the leaf nodes check (line 196-198). Remove `isFileRef` and `isVoiceRef`. Add new leaf types:

```
if isIdentifier(expr) or isAbcLiteral(expr) or isNumberLiteral(expr)
   or isLocationSelector(expr) or isStringLiteral(expr)
   or isAbcLiteralInline(expr) or isTuneSelector(expr):
  return expr
```

### 2.6 Update `findInStatement`

Because `Statement` now includes `FnDef` and `FnMatchDef`, add handling:

```
findInStatement(stmt: Statement, line: number, column: number): AstNode | null
  if not containsPosition(getStatementLoc(stmt), line, column):
    return null
  if isAssignment(stmt):
    return findInAssignment(stmt, line, column)
  if isFnDef(stmt):
    return findInFnDef(stmt, line, column)
  if isFnMatchDef(stmt):
    return findInFnMatchDef(stmt, line, column)
  return findInExpr(stmt, line, column)
```

### 2.7 New Statement-level traversal functions

```
findInFnDef(fn: FnDef, line: number, column: number): AstNode | null
  // Check 'fn' keyword
  if containsPosition(fn.kwLoc, line, column):
    return { type: "fn_kw", loc: fn.kwLoc, keyword: "fn" } as AstNode

  // Check function name (hovering on name shows fn info)
  if containsPosition(fn.nameLoc, line, column):
    return fn  // Return the FnDef node itself so hover shows fn signature

  // Check parameter names
  for param of fn.params:
    if containsPosition(param.loc, line, column):
      return { type: "fn_param", loc: param.loc, name: param.name } as AstNode

  // Check body
  inBody = findInExpr(fn.body, line, column)
  if inBody: return inBody

  return fn

findInFnMatchDef(fn: FnMatchDef, line: number, column: number): AstNode | null
  // Check 'fn' keyword
  if containsPosition(fn.kwLoc, line, column):
    return { type: "fn_kw", loc: fn.kwLoc, keyword: "fn" } as AstNode

  // Check function name
  if containsPosition(fn.nameLoc, line, column):
    return fn  // Return the FnMatchDef node itself

  // Check 'match' keyword
  if containsPosition(fn.matchKwLoc, line, column):
    return { type: "match_kw", loc: fn.matchKwLoc, keyword: "match" } as AstNode

  // Check arms
  for arm of fn.arms:
    if containsPosition(arm.loc, line, column):
      return findInMatchArm(arm, fn, line, column)

  return fn

findInMatchArm(arm: MatchArm, parent: FnMatchDef, line: number, column: number): AstNode | null
  // Check tag identifier
  if containsPosition(arm.tagLoc, line, column):
    return { type: "match_tag", loc: arm.tagLoc, tag: arm.tag } as AstNode

  // Check capture binding
  if arm.capture and containsPosition(arm.capture.nameLoc, line, column):
    return { type: "capture_name", loc: arm.capture.nameLoc, name: arm.capture.name } as AstNode

  // Check guard 'if' keyword
  if arm.guardIfLoc and containsPosition(arm.guardIfLoc, line, column):
    return { type: "guard_if_kw", loc: arm.guardIfLoc, keyword: "if" } as AstNode

  // Check guard expression
  if arm.guard:
    inGuard = findInExpr(arm.guard, line, column)
    if inGuard: return inGuard

  // Check arrow
  if containsPosition(arm.arrowLoc, line, column):
    return { type: "match_arrow", loc: arm.arrowLoc } as AstNode

  // Check body
  inBody = findInExpr(arm.body, line, column)
  if inBody: return inBody

  return { type: "match_arm", loc: arm.loc } as AstNode
```

### 2.8 Update `getStatementLoc`

Add handling for FnDef and FnMatchDef:

```
getStatementLoc(stmt: Statement): Loc
  if isAssignment(stmt): return stmt.loc
  if isFnDef(stmt): return stmt.loc
  if isFnMatchDef(stmt): return stmt.loc
  return (stmt as Expr & { loc: Loc }).loc
```

### 2.9 Update `buildPathInExpr`

Remove the `isConcat` and `isUpdate` branches. Add new branches:

```
} else if (isOverExpr(expr)) {
  buildPathInExpr(expr.focus, line, column, path);
  buildPathInExpr(expr.body, line, column, path);
} else if (isIfExpr(expr)) {
  buildPathInExpr(expr.condition, line, column, path);
  buildPathInExpr(expr.consequent, line, column, path);
  buildPathInExpr(expr.alternative, line, column, path);
} else if (isRecordLiteral(expr)) {
  for (const field of expr.fields) {
    buildPathInExpr(field.value, line, column, path);
  }
}
```

### 2.10 Update `buildPathInProgram`

Add handling for FnDef and FnMatchDef in the statement loop:

```
for stmt of ast.statements:
  stmtLoc = getStatementLoc(stmt)
  if containsPosition(stmtLoc, line, column):
    path.push(stmt)
    if isAssignment(stmt):
      buildPathInExpr(stmt.value, line, column, path)
    else if isFnDef(stmt):
      buildPathInExpr(stmt.body, line, column, path)
    else if isFnMatchDef(stmt):
      for arm of stmt.arms:
        if arm.guard: buildPathInExpr(arm.guard, line, column, path)
        buildPathInExpr(arm.body, line, column, path)
    else:
      buildPathInExpr(stmt, line, column, path)
    return
```

### 2.11 Update `collectVariables`

Because `FnDef` and `FnMatchDef` introduce named bindings (the function name), add them:

```
collectVariables(ast: Program): Map<string, Assignment>
  variables = new Map()
  for stmt of ast.statements:
    if isAssignment(stmt):
      variables.set(stmt.id, stmt)
    // Note: FnDef and FnMatchDef also introduce names, but collectVariables
    // currently returns Map<string, Assignment>. Extending the return type
    // to support function definitions is deferred to a follow-up.
  return variables
```

---

## Phase 3: ABCT Validator

### File: `abc-lsp-server/src/abct/AbctValidator.ts`

### 3.1 Imports to remove

- `isUpdate`, `isConcat`

### 3.2 Imports to add

- `isOverExpr`, `isFnDef`, `isFnMatchDef`, `isRecordLiteral`, `isLoadExpr`, `isIfExpr`, `isStringLiteral`, `isAbcLiteralInline`, `isTuneSelector`
- `FnDef`, `FnMatchDef`, `OverExpr`, `IfExpr`, `RecordLiteral`

### 3.3 Update `validateExpr` dispatch

Remove the `isUpdate` and `isConcat` branches. Add new branches for recursive traversal of child expressions:

```
} else if (isOverExpr(expr)) {
  // Validate both focus and body
  this.validateExpr(expr.focus, false);
  this.validateExpr(expr.body, true);  // body is in transform position
} else if (isIfExpr(expr)) {
  this.validateExpr(expr.condition, false);
  this.validateExpr(expr.consequent, inTransformPosition);
  this.validateExpr(expr.alternative, inTransformPosition);
} else if (isRecordLiteral(expr)) {
  for (const field of expr.fields) {
    this.validateExpr(field.value, false);
  }
}
// StringLiteral, AbcLiteralInline, NumberLiteral, LoadExpr, TuneSelector,
// AbcLiteral, LocationSelector are leaf nodes that do not require
// recursive validation.
```

### 3.4 Update `validateProgram` to handle new Statement types

Because `Statement` now includes `FnDef` and `FnMatchDef`, the program-level loop must be updated:

```
for stmt of program.statements:
  if isAssignment(stmt):
    validateExpr(stmt.value, false)
  else if isFnDef(stmt):
    validateFnDef(stmt)
  else if isFnMatchDef(stmt):
    validateFnMatchDef(stmt)
  else:
    validateExpr(stmt, false)
```

### 3.5 New validation methods

```
validateFnDef(fn: FnDef):
  // Validate the function body (which is a pipeline/expression)
  validateExpr(fn.body, false)

validateFnMatchDef(fn: FnMatchDef):
  for arm of fn.arms:
    // Validate guard if present
    if arm.guard:
      validateExpr(arm.guard, false)
    // Validate arm body (which is in transform position since it produces output)
    validateExpr(arm.body, true)
```

### 3.6 Update `validateApplication` nested term validation

In `validateApplication`, the remaining-terms loop (line 192-204) checks for `isUpdate` and `isConcat` to decide whether to recurse. Remove those checks. Add `isOverExpr`, `isIfExpr`, and `isRecordLiteral`:

```
for i from 1 to app.terms.length:
  term = app.terms[i]
  if isApplication(term) or isPipe(term) or isOverExpr(term):
    validateExpr(term, false)
  else if isSelector(term):
    validateSelector(term)
  else if isList(term):
    for item of term.items:
      validateExpr(item, false)
  else if isIfExpr(term):
    validateExpr(term, false)
  else if isRecordLiteral(term):
    for field of term.fields:
      validateExpr(field.value, false)
```

---

## Phase 4: Operator Docs and Hover Provider

### 4.1 File: `abc-lsp-server/src/abct/operatorDocs.ts`

#### Remove entries

Delete the `"|="` (update) and `"+"` (concat) entries from `operatorDocs`.

#### Update the `"|"` entry

Remove the reference to `|=` and `+` from the documentation string and `seeAlso`. Update the documentation to mention `over` as the replacement for the update pattern:

```
documentation: "The pipe operator passes the result of the left expression
as input to the right expression.

The result flows left-to-right through the pipeline. Each step receives
the output of the previous step.

To transform nodes in-place (without extracting), use the 'over' keyword instead."

seeAlso: ["over", "@"]
```

#### Update the `"@"` entry

The current `seeAlso` for `"@"` is `["|="]`. Because `|=` no longer exists, update to:

```
seeAlso: ["over", "|"]
```

#### Add new entries

Add entries for `over`, `fn`, `match`, `if`, `load`, `topdown`, `bottomup`, `oncetd`, `alltd`:

```
"over":
  symbol: "over"
  name: "lens update"
  description: "Focus on a selection and reintegrate the result"
  documentation: "The over keyword focuses on nodes matched by a selector,
  applies a transform body, and reintegrates the result into the original context.

  Syntax: over @selector (body)

  The focus can be a selector (@notes, @chords) or a location (:3:1-5).
  The body is any pipeline expression enclosed in parentheses."
  examples: ["over @chords (transpose 2)", "over :5:1-8 (remove)"]
  seeAlso: ["|", "@"]

"fn":
  symbol: "fn"
  name: "function definition"
  description: "Define a named function"
  documentation: "The fn keyword defines a named function with parameters.

  Syntax: fn name(params) { body }

  The body is a pipeline expression. Parameters are identifiers separated by commas."
  examples: ["fn double(x) { x | transpose 12 }", "fn reset() { source }"]
  seeAlso: ["match"]

"match":
  symbol: "match"
  name: "pattern match"
  description: "Define a function by pattern matching on node types"
  documentation: "The match keyword defines a function that dispatches
  on the type of the matched node.

  Syntax: fn name = match { tag |capture| => body, ... }

  Each arm has a tag (node type name), an optional capture binding,
  an optional guard (if condition), and a body expression."
  examples: [
    "fn rule = match {\n  chord |c| => c | transpose 2\n  note |n| => n\n}"
  ]
  seeAlso: ["fn"]

"if":
  symbol: "if/then/else"
  name: "conditional"
  description: "Conditional expression"
  documentation: "The if/then/else expression evaluates a condition and
  returns one of two branches.

  Syntax: if condition then consequent else alternative

  The else branch is greedy: it consumes subsequent pipe expressions.
  Use parentheses to limit scope."
  examples: ["if is_chord then transpose 2 else transpose 1"]
  seeAlso: ["fn", "match"]

"load":
  symbol: "load"
  name: "file load"
  description: "Load an ABC file by path"
  documentation: "The load expression reads an ABC file and returns its content
  as a selection.

  Syntax: load \"path/to/file.abc\""
  examples: ['load "song.abc"', 'load "lib/theme.abc"']
  seeAlso: ["|"]
```

Strategy keywords (`topdown`, `bottomup`, `oncetd`, `alltd`) use the same documentation pattern:

```
"topdown":
  symbol: "topdown"
  name: "top-down strategy"
  description: "Apply a rule from root to leaves"
  documentation: "The topdown combinator applies a rule function to each
  node in the tree, starting from the root and descending to leaves."
  examples: ["topdown my_rule"]
  seeAlso: ["bottomup", "oncetd", "alltd"]
```

(Analogous entries for `bottomup`, `oncetd`, `alltd`.)

### 4.2 File: `abc-lsp-server/src/abct/AbctHoverProvider.ts`

#### How `findNodeAtPosition` produces hover targets for new types

The hover provider's switch dispatches on `getNodeType(node)` which returns `node.type`. After the Phase 2 updates to `ast-utils.ts`, `findNodeAtPosition` will return:

- When cursor is on the `over` keyword: `{ type: "over_kw", ... }` -- matches the `"over_kw"` case below.
- When cursor is on the function name in `fn double(...)`: the `FnDef` node itself (with `type: "fn_def"`) -- matches the `"fn_def"` case below.
- When cursor is on the function name in `fn rule = match { ... }`: the `FnMatchDef` node itself (with `type: "fn_match_def"`) -- matches the `"fn_match_def"` case below.
- When cursor is on `if`/`then`/`else` keywords: synthesized `{ type: "if_kw" }`, `{ type: "then_kw" }`, `{ type: "else_kw" }` nodes.
- When cursor is on the `load` keyword: `{ type: "load_kw", ... }`.
- When cursor is on the `fn` keyword: `{ type: "fn_kw", ... }`.
- When cursor is on the `match` keyword: `{ type: "match_kw", ... }`.

#### Remove cases

- `"update_op"` -- the Update AST type no longer exists
- `"concat_op"` -- the Concat AST type no longer exists

#### Add cases

In the `switch (nodeType)` of `provideHover`:

```
case "over_kw":
  return formatOperatorHover(getOperatorInfo("over"));
case "fn_kw":
  return formatOperatorHover(getOperatorInfo("fn"));
case "match_kw":
  return formatOperatorHover(getOperatorInfo("match"));
case "fn_def":
  return formatFnDefHover(node);
case "fn_match_def":
  return formatFnMatchDefHover(node);
case "if_kw":
case "then_kw":
case "else_kw":
  return formatOperatorHover(getOperatorInfo("if"));
case "load_kw":
  return formatOperatorHover(getOperatorInfo("load"));
```

#### Add hover formatters for fn definitions

```
formatFnDefHover(node: AstNode): Hover | null
  if not isFnDef(node): return null
  lines = []
  paramStr = node.params.map(p => p.name).join(", ")
  lines.push("fn " + node.name + "(" + paramStr + ")")
  lines.push("")
  lines.push("User-defined function")
  return { contents: { kind: MarkupKind.Markdown, value: lines.join("\n") } }

formatFnMatchDefHover(node: AstNode): Hover | null
  if not isFnMatchDef(node): return null
  lines = []
  lines.push("fn " + node.name + " = match { ... }")
  lines.push("")
  lines.push("Pattern-matching function with " + node.arms.length + " arm(s)")
  return { contents: { kind: MarkupKind.Markdown, value: lines.join("\n") } }
```

#### Imports to add

- `isFnDef`, `isFnMatchDef`, `FnDef`, `FnMatchDef` from `../../../abct/src/ast`

---

## Phase 5: Completion Context and Provider

### 5.1 File: `abc-lsp-server/src/abct/completionContext.ts`

#### Update pipe match regex (line 85)

The current regex `\|\s*=?\s*(\w*)$` matches `|` optionally followed by `=`. Because `|=` no longer exists, we simplify by removing the `=?`:

```
const pipeMatch = textBefore.match(/\|\s*(\w*)$/);
```

This preserves the existing behavior: after typing `|` (with or without trailing spaces), the user gets transform completions.

#### Add keyword completion detection

Insert a new check BEFORE the `assignRhsMatch` and `lineStartMatch` checks (because those regexes would otherwise match keyword prefixes like `fn` or `over` at line start). The insertion point is after the `pipeMatch` check (line 88) and before the `assignRhsMatch` check (line 92):

```
// After the pipeMatch check, before the assignRhsMatch check:

// At line start, typing a keyword prefix -> keyword completion
const ABCT_KEYWORDS = ["fn", "over", "load", "if", "topdown", "bottomup", "oncetd", "alltd"];
const lineStartIdent = textBefore.match(/^\s*(\w+)$/);
if (lineStartIdent) {
  const typed = lineStartIdent[1];
  const matchesKeyword = ABCT_KEYWORDS.some(kw => kw.startsWith(typed));
  if (matchesKeyword) {
    return { type: "keyword", prefix: typed };
  }
}
```

This way, typing `fn` at line start matches the keyword context (not the file context), while typing `song` matches the file context (since `song` does not start any keyword).

#### Update CompletionContextType

Add `"keyword"` to the type union:

```typescript
export type CompletionContextType =
  | "transform"
  | "selector"
  | "file"
  | "variable"
  | "keyword"
  | "selectorArg"
  | "none";
```

#### Extend `getDefinedVariables` for fn definitions

Because fn definitions introduce named transforms, they should appear in variable/transform completions:

```
// After the assignment match (line 138):
// Match fn definitions: fn name(...) or fn name = match
const fnMatch = line.match(/^\s*fn\s+(\w+)\s*[\(=]/);
if (fnMatch) {
  const fnName = fnMatch[1];
  const existingIndex = variables.findIndex((v) => v.name === fnName);
  if (existingIndex >= 0) {
    variables[existingIndex] = { name: fnName, line: i + 1 };
  } else {
    variables.push({ name: fnName, line: i + 1 });
  }
}
```

### 5.2 File: `abc-lsp-server/src/abct/AbctCompletionProvider.ts`

#### Add keyword completions

Add the `"keyword"` case to the switch in `provideAbctCompletions`:

```
case "keyword":
  return getKeywordCompletions(context.prefix);
```

Implement `getKeywordCompletions`:

```
function getKeywordCompletions(prefix: string): CompletionItem[]
  keywords = [
    { label: "fn", detail: "Define a function" },
    { label: "over", detail: "Focus and reintegrate" },
    { label: "load", detail: "Load an ABC file" },
    { label: "if", detail: "Conditional expression" },
    { label: "topdown", detail: "Top-down strategy" },
    { label: "bottomup", detail: "Bottom-up strategy" },
    { label: "oncetd", detail: "Once top-down strategy" },
    { label: "alltd", detail: "All top-down strategy" },
  ]
  normalizedPrefix = prefix.toLowerCase()
  items = []
  for kw of keywords:
    if kw.label.startsWith(normalizedPrefix):
      items.push({
        label: kw.label,
        kind: CompletionItemKind.Keyword,
        detail: kw.detail,
        insertText: kw.label,
        sortText: kw.label,
      })
  return items
```

---

## Phase 6: Semantic Token Mapping

### File: `abc-lsp-server/src/server_helpers.ts`

IMPORTANT: This phase MUST NOT be implemented until plan 30 (scanner update) is complete. The `AbctTT` enum values referenced below do not exist until the scanner is updated.

### 6.1 Remove obsolete token type cases

- Remove `AbctTT.PIPE_EQ` from the operator branch (this token type no longer exists in the scanner enum after plan 30).
- Keep `AbctTT.PLUS` in the operator branch. Although `+` has no grammatical role in v2, the scanner still emits `PLUS` tokens. Keeping it highlighted as an operator helps users see that the `+` character is recognized but has no effect, which aids error discovery.

### 6.2 Add new keyword token mappings

Add to the switch:

```
case AbctTT.FN:
case AbctTT.MATCH:
case AbctTT.OVER:
case AbctTT.IF:
case AbctTT.THEN:
case AbctTT.ELSE:
case AbctTT.LOAD:
case AbctTT.LET:
case AbctTT.TOPDOWN:
case AbctTT.BOTTOMUP:
case AbctTT.ONCETD:
case AbctTT.ALLTD:
  return standardTokenScopes.keyword;
```

### 6.3 Add structural token mappings

```
case AbctTT.LBRACE:
case AbctTT.RBRACE:
case AbctTT.ARROW:
case AbctTT.COLON:
  return standardTokenScopes.operator;
```

### 6.4 Add inline ABC literal token mappings

```
case AbctTT.ABC_LITERAL_OPEN:
case AbctTT.ABC_LITERAL_CONTENT:
case AbctTT.ABC_LITERAL_CLOSE:
  return standardTokenScopes.string;
```

---

## Phase 7: Evaluator Updates (Partial)

### File: `abc-lsp-server/src/abctEvaluator.ts`

The evaluator is tightly coupled to v1 semantics. We update what maps cleanly to existing runtime primitives and stub the rest.

### 7.1 Replace FileRef with LoadExpr

Because `LoadExpr` semantically replaces `FileRef` (both load an ABC file by path), we:

- Remove `FileRef` import and `isFileRef` guard.
- Add `LoadExpr` import and `isLoadExpr` guard.
- Rename `evaluateFileRef` to `evaluateLoad`.
- Update `evaluateExpr`: replace the `isFileRef(expr)` branch with `isLoadExpr(expr)`.
- In `evaluateLoad`, use `expr.path` (which is already the unquoted string, same as `FileRef.path`).
- Remove the selector-application logic that `evaluateFileRef` had for `expr.selector`, and remove the location-handling logic for `expr.location`. Because `LoadExpr` has neither a `selector` nor a `location` field (the v2 syntax expresses these as `load "file.abc" | @selector` and `load "file.abc" | :3:1`), only the file-loading behavior is preserved.

```
evaluateLoad(expr: LoadExpr): Promise<Selection>
  loaded = await this.fileResolver.loadAbc(expr.path)
  return selectAll(loaded.ast)
```

### 7.2 Replace Update with OverExpr

Because `OverExpr` semantically replaces `Update` (both focus on a selection and apply a transform), we:

- Remove `Update` import and `isUpdate` guard.
- Add `OverExpr` import and `isOverExpr` guard.
- Update `evaluateExpr`: replace the `isUpdate(expr)` branch with `isOverExpr(expr)`.
- In `evaluatePipe`, replace the `isUpdate(expr.right)` branch with `isOverExpr(expr.right)`.
- Rename `evaluateUpdate` to `evaluateOver` and `evaluateUpdateInContext` to `evaluateOverInContext`.

```
evaluateOver(expr: OverExpr): Promise<Selection>
  throw new EvaluatorError(
    "Over expression requires a source value. Use: source | over @focus (body)",
    expr.loc
  )

evaluateOverInContext(context: Selection, over: OverExpr): Promise<Selection>
  // Step 1: Apply the focus to narrow the selection
  selection: Selection
  if isSelector(over.focus):
    selection = applySelectorToSelection(context, over.focus)
  else if isLocationSelector(over.focus):
    filter = locationSelectorToFilter(over.focus)
    selection = selectByLocationFromSelection(context, filter)
  else if isIdentifier(over.focus):
    throw new EvaluatorError("Identifier as over focus is not yet supported", over.focus.loc)
  else:
    throw new EvaluatorError("Over focus must be a selector or location", over.focus.loc)

  // Step 2: Evaluate the body as a transform on the focused selection.
  // This dispatch mirrors the old evaluateUpdateInContext logic.
  if isApplication(over.body):
    applyTransformToSelection(selection, over.body)
  else if isIdentifier(over.body):
    app = Application { type: "application", terms: [over.body], loc: over.body.loc }
    applyTransformToSelection(selection, app)
  else if isPipe(over.body):
    await evaluatePipelineAsTransform(selection, over.body)
  else if isGroup(over.body):
    inner = over.body.expr
    if isPipe(inner):
      await evaluatePipelineAsTransform(selection, inner)
    else if isApplication(inner):
      applyTransformToSelection(selection, inner)
    else if isIdentifier(inner):
      app = Application { type: "application", terms: [inner], loc: inner.loc }
      applyTransformToSelection(selection, app)
    else:
      throw new EvaluatorError("Invalid grouped transform in over body", over.body.loc)
  else:
    throw new EvaluatorError("Invalid over body expression", over.body.loc)

  // AST is mutated in place; return the original context
  return context
```

### 7.3 Handle `evaluatePipe` right-side dispatch updates

In `evaluatePipe`, update the right-side dispatch:
- Replace `isUpdate(expr.right)` with `isOverExpr(expr.right)` and call `evaluateOverInContext(leftValue, expr.right)`.
- Add a case for `isTuneSelector(expr.right)` that throws "Tune selector evaluation is not yet supported" (because there is no "tune" selector in the current runtime registry).
- The rest of the dispatch (selector, application, identifier, filter, location) remains unchanged.

### 7.4 Update `evaluateStatement` for new Statement types

Because `FnDef` and `FnMatchDef` are now in the Statement union but not in Expr, TypeScript requires explicit handling before the `evaluateExpr` fallthrough:

```
evaluateStatement(stmt: Statement): Promise<Selection | null>
  if isAssignment(stmt):
    value = await evaluateExpr(stmt.value)
    if value: runtime.setVariable(stmt.id, value)
    return null
  if isFnDef(stmt):
    // Fn definitions require core IR (plan 32) to register as user transforms.
    // For now, skip evaluation silently.
    return null
  if isFnMatchDef(stmt):
    // Same as above.
    return null
  // Expression statement
  return evaluateExpr(stmt)
```

### 7.5 Stub new expression types in `evaluateExpr`

For expression types that cannot be fully evaluated yet (because they require the core IR from plan 32), add stubs in `evaluateExpr` before the final `return null`:

```
if isIfExpr(expr):
  throw new EvaluatorError("if/then/else is not yet supported in evaluation", expr.loc)

if isRecordLiteral(expr):
  throw new EvaluatorError("Record literals are not yet supported in evaluation", expr.loc)

if isStringLiteral(expr):
  throw new EvaluatorError("String literals cannot be evaluated as standalone expressions", expr.loc)

if isAbcLiteralInline(expr):
  return evaluateAbcLiteralInline(expr)

if isTuneSelector(expr):
  throw new EvaluatorError("Tune selector requires a source value. Use: source | X:1", expr.loc)
```

### 7.6 evaluateAbcLiteralInline

Because inline ABC literals contain raw ABC text (same as the content of triple-backtick blocks), we reuse the same evaluation logic:

```
evaluateAbcLiteralInline(expr: AbcLiteralInline): Selection
  ctx = new ABCContext()
  tokens = Scanner(expr.content, ctx)
  ast = parseAbcContent(tokens, ctx)
  return selectAll(ast)
```

### 7.7 Imports update summary

Remove from imports: `FileRef`, `isFileRef`, `Update`, `isUpdate`
Add to imports: `LoadExpr`, `isLoadExpr`, `OverExpr`, `isOverExpr`, `isIfExpr`, `isRecordLiteral`, `isStringLiteral`, `isAbcLiteralInline`, `isTuneSelector`, `isFnDef`, `isFnMatchDef`, `AbcLiteralInline`

### 7.8 Remove flattenPipeline Update references

In `evaluateOverInContext` (the renamed `evaluateUpdateInContext`), all references to the `Update` type have been replaced with `OverExpr` field access (section 7.2).

In `evaluatePipelineAsTransform`, no changes are needed (it already handles Application, Identifier, Selector).

---

## Phase 8: Tests

### 8.1 Create test file: `abc-lsp-server/src/abct/AbctFormatter.spec.ts`

Test the formatter by parsing ABCT source strings and verifying the formatted output.

Because the formatter operates on AST nodes (not source strings directly), the tests must: parse the source -> format the AST -> compare the output. The `currentLine` tracking is validated implicitly by checking that multi-line constructs produce correct output.

```
describe("AbctFormatter"):
  // Existing constructs (should still work)
  it("formats a simple pipe: 'a | b' -> 'a | b'")
  it("formats an application: 'transpose 2' -> 'transpose 2'")
  it("formats a selector: '@chords' -> '@chords'")
  it("formats a list: '[1, 2, 3]' -> '[1, 2, 3]'")
  it("formats a comparison: 'pitch > C4' -> 'pitch > C4'")
  it("formats an ABC literal block preserving content")

  // New constructs
  it("formats a string literal")
    source: '"hello"'
    expected output: '"hello"\n'

  it("formats an inline ABC literal")
    source: '`CEG A2`'
    expected output: '`CEG A2`\n'

  it("formats an over expression")
    source: 'over  @chords  ( transpose  2 )'
    expected output: 'over @chords (transpose 2)\n'

  it("formats a fn definition")
    source: 'fn double(x) {\nx\n}'
    expected output: 'fn double(x) {\nx\n}\n'

  it("formats a fn definition with multiple params")
    source: 'fn add( x , y ) {\nx\n}'
    expected output: 'fn add(x, y) {\nx\n}\n'

  it("formats a fn match definition")
    source: 'fn rule = match {\n  chord |c| => c\n  note |n| => n\n}'
    expected output: 'fn rule = match {\n  chord |c| => c\n  note |n| => n\n}\n'

  it("formats a match arm with guard")
    source: 'fn rule = match {\n  chord |c| if length >= 4 => c\n}'
    expected output: 'fn rule = match {\n  chord |c| if length >= 4 => c\n}\n'

  it("formats a record literal with no spaces around =")
    source: '{name="Trumpet", transpose=-2}'
    expected output: '{name="Trumpet", transpose=-2}\n'

  it("formats an empty record")
    source: '{}'
    expected output: '{}\n'

  it("formats a load expression")
    source: 'load "song.abc"'
    expected output: 'load "song.abc"\n'

  it("formats an if/then/else expression")
    source: 'if  x  then  y  else  z'
    expected output: 'if x then y else z\n'

  it("formats a tune selector")
    source: 'X:1'
    expected output: 'X:1\n'

  it("formats over in a pipeline preserving multi-line structure")
    source: 'source\n| over @chords (transpose 2)'
    expected output: 'source\n| over @chords (transpose 2)\n'
```

### 8.2 Create test file: `abc-lsp-server/src/abct/AbctValidator.spec.ts`

```
describe("AbctValidator"):
  it("validates pipe expressions recursively")
  it("validates over expression focus and body")
  it("reports unknown transform in over body")
  it("validates fn body expressions")
  it("validates fn match arm guards and bodies")
  it("reports unknown transform in match arm body")
  it("validates record field values recursively")
  it("validates if/then/else branches")
  it("validates nested terms in application (over, if, record)")
  it("does not error on leaf nodes (StringLiteral, LoadExpr, TuneSelector, AbcLiteralInline)")
```

### 8.3 Create test file: `abct/src/ast-utils.spec.ts`

```
describe("findNodeAtPosition"):
  it("returns over_kw when cursor is on 'over' keyword")
  it("returns FnDef when cursor is on fn name")
  it("returns fn_kw when cursor is on 'fn' keyword")
  it("returns fn_param when cursor is on a parameter")
  it("returns FnMatchDef when cursor is on fn-match name")
  it("returns match_kw when cursor is on 'match' keyword")
  it("returns match_tag when cursor is on arm tag")
  it("returns if_kw, then_kw, else_kw for respective keywords")
  it("returns load_kw when cursor is on 'load' keyword")
  it("returns load_path when cursor is on path string")
  it("returns record_key when cursor is on field key")
  it("returns deepest node for nested expressions")
  it("does not return concat_op or update_op (types removed)")
```

### 8.4 Update existing test file: `abc-lsp-server/src/abctEvaluator.spec.ts`

- Remove tests that use `FileRef` AST construction -- replace with `LoadExpr`.
- Remove tests that use `Update` AST construction -- replace with `OverExpr`.
- Add tests for `AbcLiteralInline` evaluation.
- Add tests that verify stubs throw appropriate errors:
  - `IfExpr` throws "if/then/else is not yet supported"
  - `RecordLiteral` throws "Record literals are not yet supported"
  - `StringLiteral` throws "String literals cannot be evaluated as standalone expressions"
  - `TuneSelector` (standalone) throws "Tune selector requires a source value"
  - `FnDef` and `FnMatchDef` statements return null (no error, no output)

---

## Deferred Work

The following updates depend on the core IR and runtime extension (plan 32) and are out of scope:

- Full evaluation of `FnDef` and `FnMatchDef` (requires function environment, closure capture, pattern matching dispatch)
- Full evaluation of `IfExpr` (requires truthy-value semantics for selections)
- Full evaluation of `RecordLiteral` (requires a record value type in the runtime)
- Evaluation of strategy combinators (`topdown`, `bottomup`, `oncetd`, `alltd`)
- `TuneSelector` evaluation in pipe context (requires a "tune" selector in the runtime registry)
- Go-to-definition for fn-defined names
- Rename refactoring for fn parameters
- Inline ABC literal content-assist (ABC-specific completions inside backticks)
- `ErrorExpr` handling in the formatter (currently silently dropped; pre-existing issue not introduced by this plan)
- Extending `collectVariables` in ast-utils to return fn-defined names (currently typed as `Map<string, Assignment>`, would require a union return type)

---

## Implementation Checklist

- [ ] Phase 1: Update AbctFormatter (remove 4 old methods, add 10 new methods, update formatExpr/formatStatement/formatApplicationTerm, handle multi-line over/fn bodies)
- [ ] Phase 2: Update ast-utils.ts (remove findInConcat/findInUpdate, add findInOver/findInIf/findInRecord/findInLoad/findInFnDef/findInFnMatchDef/findInMatchArm, update findInExpr/findInStatement/buildPathInExpr/buildPathInProgram/getStatementLoc)
- [ ] Phase 3: Update AbctValidator (remove isUpdate/isConcat, add traversal for new types including RecordLiteral in term validation, add validateFnDef/validateFnMatchDef)
- [ ] Phase 4: Update operatorDocs (remove |=/+, update @'s seeAlso, add over/fn/match/if/load/strategies) and AbctHoverProvider (remove old cases, add new synthesized-type cases and fn hover formatters)
- [ ] Phase 5: Update completionContext (regex, keyword context before file-match, fn definition detection in getDefinedVariables) and AbctCompletionProvider (keyword completions)
- [ ] Phase 6: Update server_helpers (remove PIPE_EQ, keep PLUS, add all new keyword and structural token mappings) -- ONLY after plan 30 is complete
- [ ] Phase 7: Update abctEvaluator (replace FileRef->LoadExpr, Update->OverExpr, add FnDef/FnMatchDef in evaluateStatement, stub new types, add AbcLiteralInline evaluation)
- [ ] Phase 8: Create AbctFormatter.spec.ts, AbctValidator.spec.ts, ast-utils.spec.ts; update abctEvaluator.spec.ts
- [ ] Run `npm run build` and verify no errors
- [ ] Run `npm run test` and verify all pass
- [ ] Commit

Copy the plan file into the plans directory, and once you are done with the implementation of each phase, call the code review agent on the changes and address any feedback. After the feedback is addressed, verify that the build succeeds (`npm run build`) and all tests pass (`npm run test`). Only then commit the changes.
