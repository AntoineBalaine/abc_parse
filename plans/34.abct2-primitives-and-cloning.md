# ABCt v2 Primitives and CS Tree Cloning

## Table of Contents

1. [Goal](#goal)
2. [Context and Dependencies](#context-and-dependencies)
3. [Phase 1: CS Tree Cloning](#phase-1-cs-tree-cloning)
4. [Phase 2: insert Transform](#phase-2-insert-transform)
5. [Phase 3: Value Primitives (Comparison, Arithmetic, Record, TagEq)](#phase-3-value-primitives)
6. [Phase 4: Predicate Primitives](#phase-4-predicate-primitives)
7. [Phase 5: Load Primitive](#phase-5-load-primitive)
8. [Phase 6: Location and ABC-with-Location](#phase-6-location-and-abc-with-location)
9. [Phase 7: Export Updates and Build Integration](#phase-7-export-updates-and-build-integration)
10. [To Do](#to-do)

---

## Goal

We are implementing the pure primitives and CS tree cloning that the ABCt v2 evaluator (plan 36) depends on. These functions are self-contained: they operate on CS trees, on Selections, or on plain values, and have no dependency on the evaluator itself. By implementing them separately, we ensure the evaluator can be built against a stable, tested set of primitives.

---

## Context and Dependencies

### What already exists

The `abct2/` directory contains substantial infrastructure:

- CS tree types in `abct2/src/csTree/types.ts`: `CSNode`, `TokenData`, `EmptyData`, `NodeData`, `createCSNode`, tag predicates (`isRest`, `isNote`, `isChord`, `isBarLine`, `isBeam`), `TAGS` constant map.
- CS tree conversions: `abct2/src/csTree/fromAst.ts` (AST to CS tree) and `abct2/src/csTree/toAst.ts` (CS tree to AST).
- Selection type in `abct2/src/selection.ts`: `Selection = { root: CSNode, cursors: Cursor[] }` where `Cursor = Set<number>`, `createSelection()`.
- Existing selectors in `abct2/src/selectors/`: type selectors, chord selectors, `selectTune`, `selectRange`, `selectSiblingsAfter`, `selectVoice`, delimiter selectors.
- Existing transforms in `abct2/src/transforms/`: `remove`, `transpose`, `toRest`, `setRhythm`, `sumRhythm`, `addToRhythm`, `unwrapSingle`, `enharmonize`, `filter`, `addVoice`, `pitch` (inspection), `length` (inspection).
- Transform types in `abct2/src/transforms/types.ts`: `TransformFn`, `InspectionFn`, `findNodesById`.
- Tree utilities in `abct2/src/transforms/treeUtils.ts`: `findChildByTag`, `removeChild`, `replaceChild`, `insertBefore`, `appendChild`, `collectChildren`, `findParent`.
- Test helpers in `abct2/tests/helpers.ts`: `toCSTree`, `toSelection`, `formatSelection`, `roundtrip`, `collectAll`, `findByTag`, `findById`.

### Dependency chain

This plan depends on:
- The CS tree infrastructure (already implemented).
- The AbcFormatter from `parse/Visitors/Formatter2.ts` (already exists).
- The `ABCContext` from `parse/parsers/Context.ts` (already exists).

The evaluator (plan 36) depends on the output of this plan.

### The primitives registry in the desugarer (plan 32)

The desugarer's `PRIMITIVES` set (in `abct/src/desugarer/primitives.ts`) references the following primitive names that this plan implements: `gt`, `lt`, `gte`, `lte`, `eq`, `neq`, `negate`, `tag_eq`, `make_record`, `location`, `abc_with_location`, `load`, `is_rest`, `is_note`, `is_chord`, `insert`.

---

## Phase 1: CS Tree Cloning

### 1.1 File location

`abct2/src/csTree/clone.ts`

### 1.2 Function signature

```typescript
import { CSNode, NodeData, TokenData } from "./types";

export function cloneCSTree(root: CSNode, idGenerator: () => number): CSNode
```

### 1.3 Algorithm

Because transforms mutate the CS tree in place (modifying `firstChild`/`nextSibling` pointers, and for some transforms modifying `TokenData.lexeme`), the evaluator must clone the tree before applying any mutating transform so the caller's input is never modified. The cloning produces new `CSNode` objects with fresh IDs (obtained from the `idGenerator`), copied `tag` and `data` values, and independent structural pointers.

Because the formatter and cursor resolution rely on unique node IDs, every cloned node must receive a fresh ID from the same generator that the parser uses (`ABCContext.generateId()`). The evaluator passes `() => ctx.abcContext.generateId()` as the `idGenerator` argument.

Because `NodeData` is either `TokenData` (which contains only primitive fields: `type`, `lexeme`, `tokenType`, `line`, `position`) or `EmptyData` (which contains only `type`), we produce a shallow copy of the data object. This is sufficient because the fields are all strings/numbers (no nested references that could be shared).

The walk builds new nodes by iterating the sibling chain (avoiding recursion on the sibling axis to prevent stack overflow on very long sibling lists) and recurses on the child axis (which is bounded by tree depth, not breadth).

We null the cloned root's `nextSibling` because the clone represents an isolated subtree. The original root's siblings are not part of this clone.

```
cloneCSTree(root, idGenerator):
  cloned = cloneNode(root, idGenerator)
  cloned.nextSibling = null
  return cloned

cloneNode(node, idGenerator):
  newData = cloneData(node.data)
  newNode = { tag: node.tag, id: idGenerator(), data: newData, firstChild: null, nextSibling: null }
  if node.firstChild is not null:
    newNode.firstChild = cloneSiblingChain(node.firstChild, idGenerator)
  return newNode

cloneSiblingChain(start, idGenerator):
  // We iterate the sibling axis (rather than recursing on it) to avoid stack
  // overflow on very wide sibling chains. Recursion happens only on the child
  // axis via cloneNode, which is bounded by tree depth.
  firstClone = cloneNode(start, idGenerator)
  lastClone = firstClone
  current = start.nextSibling
  while current is not null:
    clone = cloneNode(current, idGenerator)
    lastClone.nextSibling = clone
    lastClone = clone
    current = current.nextSibling
  return firstClone

cloneData(data):
  if data.type === "token":
    return { type: "token", lexeme: data.lexeme, tokenType: data.tokenType, line: data.line, position: data.position }
  return { type: "empty" }
```

### 1.4 Tests

File: `abct2/tests/clone.spec.ts`

Example-based tests (use a simple counter `let id = 1000; const gen = () => id++` as the idGenerator):
- Cloning a single-note tune produces a structurally identical tree, but the root object identity differs (`cloned !== original`).
- Mutating the clone's structure (removing a child) does not affect the original tree.
- Mutating the clone's TokenData (changing `lexeme`) does not affect the original tree's TokenData.
- All node IDs in the clone are fresh (no ID in the clone appears in the original).
- The number of nodes in the clone equals the number of nodes in the original.
- A tree with no children (single token node) clones correctly.
- The cloned root's `nextSibling` is null even if the original root had a sibling.

Property-based tests:
- For any generated ABC tune, cloning produces a tree with no ID overlap with the original (intersection of ID sets is empty).
- For any generated ABC tune, `formatSelection({ root: cloneCSTree(toCSTree(source), gen), cursors: [] })` produces the same string as `formatSelection({ root: toCSTree(source), cursors: [] })` (structural equivalence despite different IDs).

### 1.5 Imports that the test file needs

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import * as fc from "fast-check";
import { toCSTree, formatSelection, collectAll, genAbcTune } from "./helpers";
import { cloneCSTree } from "../src/csTree/clone";
import { CSNode, isTokenNode, getTokenData } from "../src/csTree/types";
```

---

## Phase 2: insert Transform

### 2.1 File location

`abct2/src/transforms/insert.ts`

### 2.2 Function signature

```typescript
import { Selection } from "../selection";
import { CSNode } from "../csTree/types";
import { findNodesById } from "./types";
import { cloneCSTree } from "../csTree/clone";

export function insert(selection: Selection, content: CSNode, idGenerator: () => number): Selection
```

### 2.3 Semantics

The `insert` transform inserts the `content` node after each node in the selection's cursors, within the sibling chain. For each selected node, we splice `content` in as the next sibling (the selected node's original nextSibling becomes content's nextSibling).

Because the same `content` CSNode cannot appear in multiple positions in the tree, every insertion uses a clone (with fresh IDs from `idGenerator`). We use `cloneCSTree` from Phase 1 for this.

### 2.4 Algorithm

```
insert(selection, content, idGenerator):
  for cursor in selection.cursors:
    nodes = findNodesById(selection.root, cursor)
    for node in nodes:
      toInsert = cloneCSTree(content, idGenerator)
      toInsert.nextSibling = node.nextSibling
      node.nextSibling = toInsert
  return selection
```

### 2.5 Export from index

Add to `abct2/src/transforms/index.ts`:
```typescript
export { insert } from "./insert";
```

### 2.6 Tests

File: `abct2/tests/insert.spec.ts`

Test imports:
```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { toCSTreeWithContext, formatSelection, findByTag } from "./helpers";
import { TAGS, createCSNode } from "../src/csTree/types";
import { Selection } from "../src/selection";
import { insert } from "../src/transforms/insert";
```

Example-based tests:
- Inserting a rest node after the first note in `"X:1\nK:C\nC D E|\n"` produces a tree where the formatted output shows the rest between C and D.
- Inserting after the last note in a sibling chain works (the inserted node becomes the sibling between the last note and the barline).
- With multiple cursors selecting different notes, each gets a (cloned) copy of the content inserted after it.
- The returned Selection's root reflects the modified tree.
- Inserting with an empty cursor list does not modify the tree.

---

## Phase 3: Value Primitives

### 3.1 File location

`abct2/src/evaluator/valuePrimitives.ts`

### 3.2 Function signatures

```typescript
import { CSNode } from "../csTree/types";

// Comparison primitives
export function gt(a: number, b: number): boolean {
  return a > b;
}

export function lt(a: number, b: number): boolean {
  return a < b;
}

export function gte(a: number, b: number): boolean {
  return a >= b;
}

export function lte(a: number, b: number): boolean {
  return a <= b;
}

export function eq(a: unknown, b: unknown): boolean {
  return a === b;
}

export function neq(a: unknown, b: unknown): boolean {
  return a !== b;
}

// Arithmetic primitives
export function negate(a: number): number {
  return -a;
}

// Tag equality primitive
export function tagEq(node: CSNode, tag: string): boolean {
  return node.tag === tag;
}

// Record construction primitive
export function makeRecord(fields: Array<[string, unknown]>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of fields) {
    result[key] = value;
  }
  return result;
}
```

### 3.3 Semantics

Comparison primitives:
- `gt(a, b)` returns `a > b`.
- `lt(a, b)` returns `a < b`.
- `gte(a, b)` returns `a >= b`.
- `lte(a, b)` returns `a <= b`.
- `eq(a, b)` returns `a === b` (strict equality). Because the evaluator works with numbers, strings, and booleans as values, strict equality is appropriate.
- `neq(a, b)` returns `a !== b`.

Arithmetic:
- `negate(a)` returns `-a`.

Tag equality:
- `tagEq(node, tag)` returns `node.tag === tag`. This is used by the pattern matching dispatch (see plan 32, Phase 7) to test whether a node has a specific tag.

Record construction:
- `makeRecord(fields)` takes an array of key-value pairs and produces a plain JavaScript object. Each element of `fields` is a tuple `[key, value]` where `key` is a string.

### 3.4 Tests

File: `abct2/tests/valuePrimitives.spec.ts`

Test imports:
```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import * as fc from "fast-check";
import { gt, lt, gte, lte, eq, neq, negate, tagEq, makeRecord } from "../src/evaluator/valuePrimitives";
import { createCSNode } from "../src/csTree/types";
```

Example-based tests:
- `gt(3, 2)` is true, `gt(2, 3)` is false, `gt(2, 2)` is false.
- `lt(2, 3)` is true, `lt(3, 2)` is false, `lt(2, 2)` is false.
- `gte(3, 2)` is true, `gte(2, 2)` is true, `gte(1, 2)` is false.
- `lte(2, 3)` is true, `lte(2, 2)` is true, `lte(3, 2)` is false.
- `eq(1, 1)` is true, `eq(1, 2)` is false, `eq("a", "a")` is true, `eq("a", "b")` is false.
- `neq(1, 2)` is true, `neq(1, 1)` is false.
- `negate(5)` is -5, `negate(-3)` is 3, `negate(0)` is -0 (which equals 0).
- `tagEq(node, "Note")` is true when `node.tag === "Note"`, false otherwise. Construct a test node via `createCSNode("Note", 1, { type: "empty" })`.
- `makeRecord([["name", "Trumpet"], ["clef", "treble"]])` returns `{ name: "Trumpet", clef: "treble" }`.
- `makeRecord([])` returns `{}`.

Property-based tests:
- For any number `n`, `negate(negate(n))` equals `n`.
- For any two distinct numbers `a` and `b`, exactly one of `gt(a, b)` and `lt(a, b)` is true.
- For any `a` and `b`, `neq(a, b)` is the negation of `eq(a, b)`.
- For any `a` and `b`, `gte(a, b)` equals `gt(a, b) || eq(a, b)`.

---

## Phase 4: Predicate Primitives

### 4.1 File location

`abct2/src/evaluator/predicates.ts`

### 4.2 Function signatures

```typescript
import { Selection } from "../selection";
import { CSNode, isRest, isNote, isChord } from "../csTree/types";
import { findNodesById } from "../transforms/types";

export function selectionIsRest(selection: Selection): boolean

export function selectionIsNote(selection: Selection): boolean

export function selectionIsChord(selection: Selection): boolean
```

### 4.3 Semantics

These functions test whether all nodes in all cursors of the selection match the given predicate. The existing `isRest`, `isNote`, `isChord` functions in `csTree/types.ts` test individual `CSNode` objects; these wrappers operate at the Selection level.

Because the evaluator passes a Selection value to these predicates (the current pipeline value), we need to resolve the cursor IDs to actual nodes and then test each one. A predicate returns true only when every resolved node matches.

If the selection has no cursors or all cursors are empty, the predicate returns false (vacuously, there is nothing to test).

### 4.4 Algorithm

We define a shared helper `selectionMatchesAll` that is not exported (it is internal to the module):

```
function selectionMatchesAll(selection: Selection, predicate: (node: CSNode) => boolean): boolean {
  if (selection.cursors.length === 0) return false;
  for (const cursor of selection.cursors) {
    const nodes = findNodesById(selection.root, cursor);
    if (nodes.length === 0) return false;
    for (const node of nodes) {
      if (!predicate(node)) return false;
    }
  }
  return true;
}

selectionIsRest(selection):
  return selectionMatchesAll(selection, isRest)

selectionIsNote(selection):
  return selectionMatchesAll(selection, isNote)

selectionIsChord(selection):
  return selectionMatchesAll(selection, isChord)
```

### 4.5 Tests

File: `abct2/tests/predicates.spec.ts`

Test imports:
```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { toCSTreeWithContext, findByTag } from "./helpers";
import { TAGS } from "../src/csTree/types";
import { Selection } from "../src/selection";
import { selectionIsRest, selectionIsNote, selectionIsChord } from "../src/evaluator/predicates";
```

Example-based tests:
- Parse `"X:1\nK:C\nz|\n"` and create a selection focused on the Rest node: `selectionIsRest` returns true, `selectionIsNote` returns false.
- Parse `"X:1\nK:C\nC|\n"` and create a selection focused on the Note node: `selectionIsNote` returns true, `selectionIsRest` returns false.
- Parse `"X:1\nK:C\n[CEG]|\n"` and create a selection focused on the Chord node: `selectionIsChord` returns true, `selectionIsNote` returns false.
- A selection with mixed node types (one cursor on a Note, another on a Rest): all three predicates return false.
- An empty selection (no cursors): all predicates return false.

---

## Phase 5: Load Primitive

### 5.1 File location

`abct2/src/evaluator/load.ts`

### 5.2 Interface and function signatures

```typescript
import { Selection, createSelection } from "../selection";
import { fromAst } from "../csTree/fromAst";
import { Scanner } from "../../../parse/parsers/scan2";
import { parse } from "../../../parse/parsers/parse2";
import { ABCContext } from "../../../parse/parsers/Context";

export interface FileResolver {
  readFile(path: string): Promise<string>;
}

export async function load(path: string, resolver: FileResolver): Promise<Selection>
```

### 5.3 Semantics

The `load` primitive reads a file at the given path using the provided `FileResolver` interface, parses the content as ABC notation, and returns a `Selection` rooted at the resulting CS tree. This is the same pipeline as the `toSelection` test helper but with an asynchronous file-reading step at the front.

The `FileResolver` interface abstracts filesystem access so that the evaluator can be used in different environments (Node.js file system, LSP virtual documents, browser fetch, etc.). The LSP already provides equivalent functionality through its document manager.

### 5.4 Algorithm

```
load(path, resolver):
  content = await resolver.readFile(path)
  ctx = new ABCContext()
  tokens = Scanner(content, ctx)
  ast = parse(tokens, ctx)
  root = fromAst(ast)
  return createSelection(root)
```

### 5.5 Tests

File: `abct2/tests/load.spec.ts`

Test imports:
```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { FileResolver, load } from "../src/evaluator/load";
import { TAGS } from "../src/csTree/types";
import { formatSelection } from "./helpers";
```

Example-based tests (using a mock FileResolver that returns pre-defined strings):
- Loading a valid ABC file returns a Selection whose root has tag `TAGS.File_structure`.
- Loading a file with a simple tune (`"X:1\nK:C\nCDE|\n"`) produces a tree that, when formatted via `formatSelection`, contains "CDE|".
- The resolver's `readFile` is called exactly once with the provided path (use a spy/counter in the mock).
- Loading a file that produces a parse error still returns a Selection (the parser recovers and produces a partial tree).

---

## Phase 6: Location and ABC-with-Location

### 6.1 File location

`abct2/src/evaluator/locationPrimitives.ts`

### 6.2 Types and function signatures

```typescript
import { CSNode } from "../csTree/types";

export interface LocationFilter {
  startLine: number;
  startCol: number;
  endLine: number;
  endCol: number;
}

export interface LocatedContent {
  content: CSNode;
  location: LocationFilter;
}

export function location(startLine: number, startCol: number, endLine: number, endCol: number): LocationFilter {
  return { startLine, startCol, endLine, endCol };
}

export function locationFromArgs(args: number[]): LocationFilter {
  // Normalizes 1-4 numeric arguments into a canonical LocationFilter.
  switch (args.length) {
    case 1: return { startLine: args[0], startCol: 0, endLine: args[0], endCol: Infinity };
    case 2: return { startLine: args[0], startCol: args[1], endLine: args[0], endCol: Infinity };
    case 3: return { startLine: args[0], startCol: args[1], endLine: args[0], endCol: args[2] };
    case 4: return { startLine: args[0], startCol: args[1], endLine: args[2], endCol: args[3] };
    default: return { startLine: 0, startCol: 0, endLine: 0, endCol: 0 };
  }
}

export function abcWithLocation(content: CSNode, loc: LocationFilter): LocatedContent {
  return { content, location: loc };
}
```

### 6.3 Semantics

`location` constructs a `LocationFilter` value that represents a source range. The evaluator uses this to determine where in the output tree an inserted fragment should be placed. The four parameters match the four-argument form from the desugarer (plan 32, Phase 6.4): start line, start column, end line, end column.

The desugarer can produce 1 to 4 arguments for the `location` primitive (see plan 32, section 6.4). We provide `locationFromArgs` that normalizes 1-4 arguments into the canonical form:
- 1 arg (line only): the whole line.
- 2 args (line, col): from that position to end of line.
- 3 args (line, col, endCol): single-line range.
- 4 args (startLine, startCol, endLine, endCol): as given.

`abcWithLocation` pairs a parsed ABC content (a CSNode, the result of parsing an ABC literal) with a target location. The evaluator stores this pair and uses the location to determine where to insert the content during the final assembly phase.

### 6.4 Tests

File: `abct2/tests/locationPrimitives.spec.ts`

Test imports:
```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { location, locationFromArgs, abcWithLocation, LocationFilter } from "../src/evaluator/locationPrimitives";
import { createCSNode } from "../src/csTree/types";
```

Example-based tests:
- `location(5, 1, 8, 10)` returns `{ startLine: 5, startCol: 1, endLine: 8, endCol: 10 }`.
- `locationFromArgs([10])` returns `{ startLine: 10, startCol: 0, endLine: 10, endCol: Infinity }`.
- `locationFromArgs([5, 3])` returns `{ startLine: 5, startCol: 3, endLine: 5, endCol: Infinity }`.
- `locationFromArgs([5, 1, 8])` returns `{ startLine: 5, startCol: 1, endLine: 5, endCol: 8 }`.
- `locationFromArgs([5, 1, 8, 10])` returns `{ startLine: 5, startCol: 1, endLine: 8, endCol: 10 }`.
- `locationFromArgs([])` returns `{ startLine: 0, startCol: 0, endLine: 0, endCol: 0 }` (edge case: empty args).
- `abcWithLocation(someNode, someLoc)` returns an object with `content` equal to the node and `location` equal to the provided location.

---

## Phase 7: Export Updates and Build Integration

### 7.1 Verify `abct2/src/transforms/index.ts`

If Phase 2 was implemented correctly, the following export already exists. Verify its presence:

```typescript
export { insert } from "./insert";
```

### 7.2 Create `abct2/src/evaluator/index.ts`

Because this is the first file in the `abct2/src/evaluator/` directory, we need to create an index that exports all evaluator-level primitives:

```typescript
export { gt, lt, gte, lte, eq, neq, negate, tagEq, makeRecord } from "./valuePrimitives";
export { selectionIsRest, selectionIsNote, selectionIsChord } from "./predicates";
export { load, FileResolver } from "./load";
export { location, locationFromArgs, abcWithLocation, LocationFilter, LocatedContent } from "./locationPrimitives";
```

### 7.3 Create or update `abct2/src/csTree/index.ts`

Add an index for the csTree module that exports the clone function alongside the existing types and conversions:

```typescript
export { cloneCSTree } from "./clone";
export { CSNode, TokenData, EmptyData, NodeData, createCSNode, isTokenNode, getTokenData, TAGS, isRest, isNote, isChord, isBarLine, isBeam } from "./types";
export { fromAst } from "./fromAst";
export { toAst } from "./toAst";
```

If an index already exists, add only the `cloneCSTree` export line.

### 7.4 Build verification

Run `npm run build` from the repo root. All new files must compile without errors. No changes to `tsconfig.json` should be needed because the new files are within the existing `abct2/src/` directory structure.

### 7.5 Test verification

Run `npm run test` from the repo root. All existing tests must continue passing, and the new tests (clone, insert, valuePrimitives, predicates, load, locationPrimitives) must pass.

---

## To Do

Phase 1: CS Tree Cloning
- Create `abct2/src/csTree/clone.ts` with `cloneCSTree`, `cloneNode`, `cloneSiblingChain`, `cloneData`.
- Create `abct2/tests/clone.spec.ts` with example-based and property-based tests.
- Verify: `npm run build` succeeds and `npm run test` passes.

Phase 2: insert Transform
- Create `abct2/src/transforms/insert.ts` with the `insert` function (imports: `Selection`, `CSNode`, `findNodesById`, `cloneCSTree`).
- Add `export { insert } from "./insert"` to `abct2/src/transforms/index.ts`.
- Create `abct2/tests/insert.spec.ts` with example-based tests.
- Verify: build and tests pass.

Phase 3: Value Primitives
- Create `abct2/src/evaluator/valuePrimitives.ts` with `gt`, `lt`, `gte`, `lte`, `eq`, `neq`, `negate`, `tagEq`, `makeRecord` (import: `CSNode` from `../csTree/types`).
- Create `abct2/tests/valuePrimitives.spec.ts` with example-based and property-based tests.
- Verify: build and tests pass.

Phase 4: Predicate Primitives
- Create `abct2/src/evaluator/predicates.ts` with `selectionMatchesAll`, `selectionIsRest`, `selectionIsNote`, `selectionIsChord` (imports: `Selection`, `CSNode`, `isRest`, `isNote`, `isChord`, `findNodesById`).
- Create `abct2/tests/predicates.spec.ts` with example-based tests.
- Verify: build and tests pass.

Phase 5: Load Primitive
- Create `abct2/src/evaluator/load.ts` with `FileResolver` interface and `load` async function (imports: `Selection`, `createSelection`, `fromAst`, `Scanner`, `parse`, `ABCContext`).
- Create `abct2/tests/load.spec.ts` with tests using a mock resolver.
- Verify: build and tests pass.

Phase 6: Location and ABC-with-Location
- Create `abct2/src/evaluator/locationPrimitives.ts` with `LocationFilter`, `LocatedContent`, `location`, `locationFromArgs`, `abcWithLocation` (import: `CSNode`).
- Create `abct2/tests/locationPrimitives.spec.ts` with example-based tests.
- Verify: build and tests pass.

Phase 7: Export Updates and Build Integration
- Create `abct2/src/evaluator/index.ts` with all evaluator exports.
- Update `abct2/src/transforms/index.ts` with the `insert` export (if not done in earlier phases).
- Create or update `abct2/src/csTree/index.ts` with `cloneCSTree` export.
- Final verification: build and tests both pass.
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
