# Core IR Evaluator

## Table of Contents

1. [Goal](#goal)
2. [Context and Dependencies](#context-and-dependencies)
3. [Design Decisions](#design-decisions)
4. [Phase 1: Value Types and Environment](#phase-1-value-types-and-environment)
5. [Phase 2: Core Evaluate Function](#phase-2-core-evaluate-function)
6. [Phase 3: Primitive Dispatch Table](#phase-3-primitive-dispatch-table)
7. [Phase 4: Bridge Utilities](#phase-4-bridge-utilities)
8. [Phase 5: The over Primitive](#phase-5-the-over-primitive)
9. [Phase 6: Top-level Entry Point and Error Handling](#phase-6-top-level-entry-point-and-error-handling)
10. [Phase 7: Example-Based Tests](#phase-7-example-based-tests)
11. [Phase 8: Integration with Build](#phase-8-integration-with-build)

---

## Goal

We are implementing the Core IR Evaluator, which is the component that interprets Core IR nodes (produced by the desugarer from plan 32) and dispatches to the existing primitives in `abct2/`. The evaluator is a recursive tree-walking interpreter written in TypeScript. It manages environments (variable bindings), handles closures, and bridges between the Core IR's `PrimCall` nodes and the concrete implementations of transforms and selectors.

---

## Context and Dependencies

### Dependency chain

This plan depends on:
- Plan 32 (Core IR types and desugarer): produces `CoreProgram` containing nested `CoreExpr` nodes. The evaluator imports `CoreExpr` and `CoreProgram` from `abct/src/core/types.ts`, and imports `Loc` directly from `abct/src/ast.ts`.
- Plan 34 (pure primitives and CS tree cloning): provides `cloneCSTree` (at `abct2/src/csTree/clone.ts`), value primitives, predicates, load, location

### The Core IR types (from plan 32, `abct/src/core/types.ts`)

The evaluator consumes these node types:

```typescript
type CoreExpr =
  | Var       // { type: "var", name: string, loc: Loc }
  | App       // { type: "app", fn: CoreExpr, args: CoreExpr[], loc: Loc }
  | Fn        // { type: "fn", params: string[], paramLocs: Loc[], body: CoreExpr, loc: Loc }
  | Let       // { type: "let", name: string, nameLoc: Loc, value: CoreExpr, body: CoreExpr, loc: Loc }
  | If        // { type: "if", condition: CoreExpr, consequent: CoreExpr, alternative: CoreExpr, loc: Loc }
  | CoreList  // { type: "list", elements: CoreExpr[], loc: Loc }
  | NumLit    // { type: "num", value: number, loc: Loc }
  | StringLit // { type: "str", value: string, loc: Loc }
  | AbcLit    // { type: "abc", content: string, loc: Loc }
  | PrimCall  // { type: "prim", name: string, args: CoreExpr[], loc: Loc }
  | CoreError // { type: "core_error", message: string, loc: Loc }

interface CoreProgram {
  body: CoreExpr;
  loc: Loc;
}
```

### Existing transforms (`abct2/src/transforms/`)

Each transform operates on a `Selection` and returns a `Selection`. Their signatures vary:

- `remove(selection: Selection): Selection`
- `transpose(selection: Selection, semitones: number, ctx: ABCContext): Selection`
- `toRest(selection: Selection, ctx: ABCContext): Selection`
- `setRhythm(selection: Selection, rational: IRational, ctx: ABCContext): Selection`
- `sumRhythm(selection: Selection): IRational[]`
- `addToRhythm(selection: Selection, rational: IRational, ctx: ABCContext): Selection`
- `unwrapSingle(selection: Selection): Selection`
- `enharmonize(selection: Selection, ctx: ABCContext): Selection`
- `filter(selection: Selection, predicate: (node: CSNode) => boolean): Selection`
- `addVoice(selection: Selection, voiceId: string, params: VoiceParams, ctx: ABCContext): Selection`
- `pitch(selection: Selection): number[]`
- `length(selection: Selection): number`

### Existing selectors (`abct2/src/selectors/`)

Each selector takes a `Selection` and returns a narrowed `Selection`:

- `selectChords(input: Selection): Selection`
- `selectNotes(input: Selection): Selection`
- `selectNonChordNotes(input: Selection): Selection`
- `selectChordNotes(input: Selection): Selection`
- `selectRests(input: Selection): Selection`
- `selectTop(input: Selection): Selection`
- `selectBottom(input: Selection): Selection`
- `selectNthFromTop(input: Selection, n: number): Selection`
- `selectAllButTop(input: Selection): Selection`
- `selectAllButBottom(input: Selection): Selection`
- `selectVoice(input: Selection, voiceId: string): Selection`
- `selectTune(input: Selection): Selection`
- `selectRange(input: Selection, startLine: number, startCol: number, endLine: number, endCol: number): Selection`
- `selectSiblingsAfter(input: Selection, predicate: (node: CSNode) => boolean): Selection`

### CS tree cloning (from plan 34, `abct2/src/csTree/clone.ts`)

```typescript
function cloneCSTree(root: CSNode, idGenerator: () => number): CSNode;
```

### Selection type (`abct2/src/selection.ts`)

```typescript
type Cursor = Set<number>;
interface Selection {
  root: CSNode;
  cursors: Cursor[];
}
function createSelection(root: CSNode): Selection;
```

### CSNode type (`abct2/src/csTree/types.ts`)

```typescript
interface CSNode {
  tag: string;
  id: number;
  data: NodeData;
  firstChild: CSNode | null;
  nextSibling: CSNode | null;
}
```

### ABCContext (`parse/parsers/Context.ts`)

Several transforms require an `ABCContext` instance for generating fresh IDs. The evaluator creates one upon initialization and threads it through primitive calls.

```typescript
class ABCContext {
  generateId(): number;
  // ... other fields
}
```

### Source files to create

```
abct2/src/evaluator/
  types.ts          -- Value, Env, EvalContext, EvaluatorError types
  env.ts            -- createEnv, lookup, bind
  evaluate.ts       -- main evaluate function
  primitives.ts     -- primitive dispatch table
  bridges.ts        -- closureToPredicate, parseAbcContent utilities
  index.ts          -- public API (evaluateProgram)
```

---

## Design Decisions

### The evaluator is synchronous, not async

Because none of the existing transforms or selectors are asynchronous, the evaluator does not need `async/await`. The only operation that could conceptually be async is `load` (reading a file from disk), but because `FileResolver.resolve` in the existing codebase is synchronous (it reads from a pre-populated map), we keep the evaluator fully synchronous.

If a future file resolver requires async I/O, the evaluator's signature can be changed to return `Promise<Value>` at that point. For now, keeping it synchronous avoids unnecessary complexity.

### Letrec semantics via deferred initialization

The Core IR's `Let` node uses letrec semantics: the name being bound is visible within the value expression (allowing recursive functions). The implementation uses a two-step approach:

1. Bind the name to a sentinel value (`UNINITIALIZED`) in the environment.
2. Evaluate the value expression in the environment that already contains the binding.
3. Replace the sentinel with the computed value.

Because the value expression is typically a `Fn` node (which captures a reference to the environment, not a snapshot), the resulting closure can reference itself via the binding. When the closure is later invoked and evaluates its body, the binding already holds the closure itself.

If the value expression attempts to read the binding before it is initialized (e.g., `let x = x + 1`), the evaluator throws an `EvaluatorError` indicating that the variable was accessed before initialization.

### Truthy/falsy convention mirrors JavaScript

The evaluator uses the same truthy/falsy convention as the desugarer (plan 32): `NumberValue(0)` and `NullValue` are falsy, everything else is truthy. This is consistent with the desugarer's translation of `and`, `or`, and `not` into `If` nodes with `NumLit(0)` and `NumLit(1)`.

### Primitives that need ABCContext receive it from EvalContext

Several transforms (`transpose`, `toRest`, `setRhythm`, `addToRhythm`, `enharmonize`, `addVoice`) require an `ABCContext` parameter for generating node IDs. Rather than passing `ABCContext` as an explicit argument from the user's code, the evaluator's `EvalContext` holds a single shared `ABCContext` instance. The primitive wrappers extract it from the context.

### The filter primitive bridges closures to predicates

The existing `filter` transform takes a `(node: CSNode) => boolean` predicate. When the user writes `filter (pitch > C4)`, the desugarer produces `PrimCall("filter", [input, Fn([param], ...)])`. The evaluator must convert the `ClosureValue` into a `(node: CSNode) => boolean` function by:

1. Wrapping the node in a single-cursor `Selection`.
2. Invoking the closure with the `SelectionValue`.
3. Interpreting the closure's return value as truthy/falsy.

This bridging is performed by the `closureToPredicate` utility in `bridges.ts`.

### AbcLit evaluation requires parsing the ABC content at runtime

When an `AbcLit` node is evaluated, the evaluator must parse the ABC content string into a CS tree and wrap it as a `SelectionValue`. This involves:

1. Tokenizing the ABC string using the `Scanner` function from `parse/parsers/scan2` (which takes a source string and an `ABCContext` and returns `Token[]`).
2. Parsing the tokens using the ABC parser (`parse2`).
3. Converting the resulting AST to a CS tree via `fromAst`.
4. Creating a `Selection` with the root focused.

The `ABCContext` from `EvalContext` is used for the parsing step.

### The over primitive clones before applying the body

`over(input, focus, body)`:
1. Applies the focus (a selector closure or a `PrimCall` result) to narrow the input's cursors.
2. Clones the input's CS tree via `cloneCSTree`.
3. Invokes the body closure on the focused/cloned selection.
4. Returns the modified selection as the result.

The clone ensures that the body's mutations do not affect other references to the original tree.

### Record values use a Map for field storage

`RecordValue` stores fields in a `Map<string, Value>`. The `make_record` primitive receives a list of two-element list pairs `[StringLit(key), value]` and constructs the map.

### Stack overflow detection uses a depth counter

The `EvalContext` tracks `currentDepth` and `maxDepth`. Every recursive `evaluate` call increments the depth. If `currentDepth > maxDepth`, the evaluator throws an `EvaluatorError`. The default `maxDepth` is 1000.

### Comparison primitives return NumberValue (1 or 0)

Because the Core IR has no boolean type, comparison primitives (`gt`, `lt`, `gte`, `lte`, `eq`, `neq`) return `NumberValue(1)` for true and `NumberValue(0)` for false. This is consistent with the desugarer's convention.

### The location primitive returns a ListValue of numbers

`PrimCall("location", [NumLit(5), NumLit(1), NumLit(8)])` evaluates to `ListValue([NumberValue(5), NumberValue(1), NumberValue(8)])`. The `over` and `select_range` primitives interpret the list as location coordinates.

### The tag_eq primitive checks the CSNode's tag field

`PrimCall("tag_eq", [node, StringLit("chord")])` extracts the CSNode from a SelectionValue (using the first cursor), checks whether `node.tag === "Chord"` (mapping lowercase surface names to the TAGS constants), and returns `NumberValue(1)` or `NumberValue(0)`.

### Error handling uses a custom EvaluatorError class

All runtime errors are reported via `EvaluatorError`, which carries a message and a source `Loc`. The evaluator catches these at the top level and converts them to `Diagnostic` entries in the `EvalContext`.

### Nested functions cannot be private methods

Because the project's coding conventions prohibit nested functions, all helper functions within the evaluator are top-level module functions. State that would have been captured via closure is instead passed as explicit context parameters.

---

## Phase 1: Value Types and Environment

### 1.1 File: `abct2/src/evaluator/types.ts`

```typescript
import { Loc } from "../../../abct/src/ast";
import { Selection } from "../selection";
import { CSNode } from "../csTree/types";
import { CoreExpr } from "../../../abct/src/core/types";
import { ABCContext } from "../../../parse/parsers/Context";

// --- Sentinel for letrec ---
export const UNINITIALIZED: unique symbol = Symbol("UNINITIALIZED");

// --- Value types ---

export interface SelectionValue {
  type: "selection";
  selection: Selection;
}

export interface NumberValue {
  type: "number";
  value: number;
}

export interface StringValue {
  type: "string";
  value: string;
}

export interface BooleanValue {
  type: "boolean";
  value: boolean;
}

export interface ClosureValue {
  type: "closure";
  params: string[];
  body: CoreExpr;
  env: Env;
}

export interface ListValue {
  type: "list";
  items: Value[];
}

export interface RecordValue {
  type: "record";
  fields: Map<string, Value>;
}

export interface NullValue {
  type: "null";
}

export interface PrimitiveFnValue {
  type: "primitive_fn";
  name: string;
  fn: PrimImpl;
}

export type Value =
  | SelectionValue
  | NumberValue
  | StringValue
  | BooleanValue
  | ClosureValue
  | ListValue
  | RecordValue
  | NullValue
  | PrimitiveFnValue;

// --- Environment ---

export interface Env {
  bindings: Map<string, Value | typeof UNINITIALIZED>;
  parent: Env | null;
}

// --- Primitive implementation signature ---

export type PrimImpl = (args: Value[], ctx: EvalContext) => Value;

// --- Evaluation context ---

export interface FileResolver {
  resolve(path: string): string | null;
}

export interface EvalDiagnostic {
  message: string;
  loc: Loc;
}

export interface EvalContext {
  fileResolver: FileResolver;
  diagnostics: EvalDiagnostic[];
  maxDepth: number;
  currentDepth: number;
  abcContext: ABCContext;
}

// --- Error class ---

export class EvaluatorError extends Error {
  loc: Loc;
  constructor(message: string, loc: Loc) {
    super(message);
    this.name = "EvaluatorError";
    this.loc = loc;
  }
}
```

The `ABCContext` import comes from `../../../parse/parsers/Context` (the existing ABC parser context class).

### 1.2 File: `abct2/src/evaluator/env.ts`

```typescript
import { Env, Value, UNINITIALIZED, EvaluatorError } from "./types";
import { Loc } from "../../../abct/src/ast";

export function createEnv(parent: Env | null): Env {
  return { bindings: new Map(), parent };
}

export function lookup(env: Env, name: string, loc: Loc): Value {
  let current: Env | null = env;
  while (current !== null) {
    if (current.bindings.has(name)) {
      const val = current.bindings.get(name)!;
      if (val === UNINITIALIZED) {
        throw new EvaluatorError(
          `Variable "${name}" was accessed before initialization`,
          loc
        );
      }
      return val as Value;
    }
    current = current.parent;
  }
  throw new EvaluatorError(`Undefined variable: "${name}"`, loc);
}

export function bind(env: Env, name: string, value: Value | typeof UNINITIALIZED): void {
  env.bindings.set(name, value);
}
```

Parameters:
- `createEnv(parent: Env | null): Env` -- creates a new empty environment with the given parent. The `Env` type is defined in `types.ts`.
- `lookup(env: Env, name: string, loc: Loc): Value` -- walks the parent chain looking for `name`. Throws `EvaluatorError` (from `types.ts`) if not found or if the value is `UNINITIALIZED`. The `Loc` type is imported from `abct/src/ast.ts`.
- `bind(env: Env, name: string, value: Value | typeof UNINITIALIZED): void` -- sets the binding in the given env. Accepts `UNINITIALIZED` for the letrec pre-binding step.

---

## Phase 2: Core Evaluate Function

### 2.1 File: `abct2/src/evaluator/evaluate.ts`

The main evaluate function dispatches on the `type` field of the `CoreExpr` node:

```typescript
import { CoreExpr } from "../../../abct/src/core/types";
import { Loc } from "../../../abct/src/ast";
import { Value, Env, EvalContext, EvaluatorError, ClosureValue, SelectionValue,
         NumberValue, StringValue, ListValue, NullValue, PrimitiveFnValue,
         UNINITIALIZED } from "./types";
import { createEnv, lookup, bind } from "./env";
import { getPrimitive } from "./primitives";
import { parseAbcContent } from "./bridges";

export function evaluate(expr: CoreExpr, env: Env, ctx: EvalContext): Value {
  ctx.currentDepth++;
  if (ctx.currentDepth > ctx.maxDepth) {
    throw new EvaluatorError(
      `Maximum recursion depth exceeded (${ctx.maxDepth})`,
      expr.loc
    );
  }

  try {
    const result = evaluateNode(expr, env, ctx);
    return result;
  } finally {
    ctx.currentDepth--;
  }
}
```

### 2.2 The evaluateNode dispatch

```typescript
function evaluateNode(expr: CoreExpr, env: Env, ctx: EvalContext): Value {
  switch (expr.type) {
    case "var":
      return lookup(env, expr.name, expr.loc);

    case "num":
      return { type: "number", value: expr.value };

    case "str":
      return { type: "string", value: expr.value };

    case "abc":
      return evaluateAbcLit(expr.content, expr.loc, ctx);

    case "list":
      return evaluateList(expr.elements, env, ctx);

    case "fn":
      return evaluateFn(expr.params, expr.body, env);

    case "app":
      return evaluateApp(expr.fn, expr.args, expr.loc, env, ctx);

    case "let":
      return evaluateLet(expr.name, expr.value, expr.body, expr.loc, env, ctx);

    case "if":
      return evaluateIf(expr.condition, expr.consequent, expr.alternative, env, ctx);

    case "prim":
      return evaluatePrimCall(expr.name, expr.args, expr.loc, env, ctx);

    case "core_error":
      throw new EvaluatorError(expr.message, expr.loc);

    default:
      throw new EvaluatorError(
        `Unknown expression type: ${(expr as any).type}`,
        expr.loc
      );
  }
}
```

### 2.3 Individual evaluation functions

Each is a top-level function (no nesting) in `evaluate.ts`:

```typescript
function evaluateAbcLit(content: string, loc: Loc, ctx: EvalContext): SelectionValue {
  return parseAbcContent(content, loc, ctx);
}

function evaluateList(elements: CoreExpr[], env: Env, ctx: EvalContext): ListValue {
  const items: Value[] = [];
  for (const elem of elements) {
    items.push(evaluate(elem, env, ctx));
  }
  return { type: "list", items };
}

function evaluateFn(params: string[], body: CoreExpr, env: Env): ClosureValue {
  return { type: "closure", params, body, env };
}

function evaluateApp(
  fnExpr: CoreExpr,
  argExprs: CoreExpr[],
  loc: Loc,
  env: Env,
  ctx: EvalContext
): Value {
  const fnVal = evaluate(fnExpr, env, ctx);
  const args: Value[] = [];
  for (const argExpr of argExprs) {
    args.push(evaluate(argExpr, env, ctx));
  }
  return applyFunction(fnVal, args, loc, ctx);
}

export function applyFunction(fnVal: Value, args: Value[], loc: Loc, ctx: EvalContext): Value {
  if (fnVal.type === "closure") {
    return applyClosure(fnVal, args, loc, ctx);
  }
  if (fnVal.type === "primitive_fn") {
    return fnVal.fn(args, ctx);
  }
  throw new EvaluatorError(
    `Cannot apply non-function value of type "${fnVal.type}"`,
    loc
  );
}

export function applyClosure(closure: ClosureValue, args: Value[], loc: Loc, ctx: EvalContext): Value {
  if (args.length !== closure.params.length) {
    throw new EvaluatorError(
      `Function expects ${closure.params.length} arguments but received ${args.length}`,
      loc
    );
  }
  const callEnv = createEnv(closure.env);
  for (let i = 0; i < closure.params.length; i++) {
    bind(callEnv, closure.params[i], args[i]);
  }
  return evaluate(closure.body, callEnv, ctx);
}

function evaluateLet(
  name: string,
  valueExpr: CoreExpr,
  bodyExpr: CoreExpr,
  loc: Loc,
  env: Env,
  ctx: EvalContext
): Value {
  // Letrec: bind the name first (allows recursive references)
  const childEnv = createEnv(env);
  bind(childEnv, name, UNINITIALIZED);
  const value = evaluate(valueExpr, childEnv, ctx);
  bind(childEnv, name, value);
  return evaluate(bodyExpr, childEnv, ctx);
}

function evaluateIf(
  condExpr: CoreExpr,
  consExpr: CoreExpr,
  altExpr: CoreExpr,
  env: Env,
  ctx: EvalContext
): Value {
  const condVal = evaluate(condExpr, env, ctx);
  if (isTruthy(condVal)) {
    return evaluate(consExpr, env, ctx);
  }
  return evaluate(altExpr, env, ctx);
}

function evaluatePrimCall(
  name: string,
  argExprs: CoreExpr[],
  loc: Loc,
  env: Env,
  ctx: EvalContext
): Value {
  const primImpl = getPrimitive(name);
  if (primImpl === undefined) {
    throw new EvaluatorError(`Unknown primitive: "${name}"`, loc);
  }
  const args: Value[] = [];
  for (const argExpr of argExprs) {
    args.push(evaluate(argExpr, env, ctx));
  }
  return primImpl(args, ctx);
}
```

Note: `applyFunction` and `applyClosure` are exported because `primitives.ts` needs them for the `over` primitive. This creates a circular dependency between `evaluate.ts` (which imports `getPrimitive` from `primitives.ts`) and `primitives.ts` (which imports `evaluate`, `applyClosure`, `isTruthy` from `evaluate.ts`). Because both modules export only functions (not eagerly computed values), TypeScript handles this correctly at runtime.

### 2.4 Truthiness helper

```typescript
export function isTruthy(val: Value): boolean {
  if (val.type === "number") return val.value !== 0;
  if (val.type === "null") return false;
  if (val.type === "boolean") return val.value;
  if (val.type === "string") return val.value.length > 0;
  if (val.type === "list") return val.items.length > 0;
  return true;
}
```

This function is exported because `bridges.ts` needs it for converting closure results to booleans.

---

## Phase 3: Primitive Dispatch Table

### 3.1 File: `abct2/src/evaluator/primitives.ts`

The dispatch table maps each primitive name (as produced by the desugarer's `PrimCall` nodes) to a `PrimImpl` function.

```typescript
import { Value, PrimImpl, EvalContext, EvaluatorError, SelectionValue, NumberValue,
         StringValue, ListValue, RecordValue, NullValue, ClosureValue } from "./types";
import { Loc } from "../../../abct/src/ast";

// Transform imports
import { remove } from "../transforms/remove";
import { transpose } from "../transforms/transpose";
import { toRest } from "../transforms/toRest";
import { setRhythm } from "../transforms/setRhythm";
import { sumRhythm } from "../transforms/sumRhythm";
import { addToRhythm } from "../transforms/addToRhythm";
import { unwrapSingle } from "../transforms/unwrapSingle";
import { enharmonize } from "../transforms/enharmonize";
import { filter } from "../transforms/filter";
import { pitch } from "../transforms/pitch";
import { length } from "../transforms/length";
import { addVoice, VoiceParams } from "../transforms/addVoice";

// Selector imports
import { selectChords, selectNotes, selectRests, selectNonChordNotes, selectChordNotes } from "../selectors/typeSelectors";
import { selectTop, selectBottom, selectNthFromTop, selectAllButTop, selectAllButBottom } from "../selectors/chordSelectors";
import { selectVoice } from "../selectors/voiceSelector";
import { selectTune } from "../selectors/structureSelectors";
import { selectRange } from "../selectors/rangeSelector";
import { selectSiblingsAfter } from "../selectors/siblingSelector";

// CS tree and selection imports
import { cloneCSTree } from "../csTree/clone";
import { Selection } from "../selection";
import { CSNode, TAGS } from "../csTree/types";

// Bridge imports
import { closureToPredicate, parseAbcContent } from "./bridges";
import { evaluate, isTruthy, applyClosure } from "./evaluate";

// Rational type
import { IRational } from "../../../parse/Visitors/fmt2/rational";
```

### 3.2 Value extractors

Helper functions that extract typed values from `Value[]` arguments, throwing `EvaluatorError` when the type does not match:

```typescript
function expectSelection(val: Value, argName: string): Selection {
  if (val.type !== "selection") {
    throw new EvaluatorError(
      `Expected a selection for "${argName}" but received "${val.type}"`,
      DUMMY_LOC
    );
  }
  return val.selection;
}

function expectNumber(val: Value, argName: string): number {
  if (val.type !== "number") {
    throw new EvaluatorError(
      `Expected a number for "${argName}" but received "${val.type}"`,
      DUMMY_LOC
    );
  }
  return val.value;
}

function expectString(val: Value, argName: string): string {
  if (val.type !== "string") {
    throw new EvaluatorError(
      `Expected a string for "${argName}" but received "${val.type}"`,
      DUMMY_LOC
    );
  }
  return val.value;
}

function expectClosure(val: Value, argName: string): ClosureValue {
  if (val.type !== "closure") {
    throw new EvaluatorError(
      `Expected a function for "${argName}" but received "${val.type}"`,
      DUMMY_LOC
    );
  }
  return val;
}

function expectList(val: Value, argName: string): Value[] {
  if (val.type !== "list") {
    throw new EvaluatorError(
      `Expected a list for "${argName}" but received "${val.type}"`,
      DUMMY_LOC
    );
  }
  return val.items;
}

const DUMMY_LOC: Loc = { start: { line: 0, column: 0, offset: 0 }, end: { line: 0, column: 0, offset: 0 } };
```

### 3.3 The dispatch table

```typescript
const PRIMITIVES: Map<string, PrimImpl> = new Map();

export function getPrimitive(name: string): PrimImpl | undefined {
  return PRIMITIVES.get(name);
}

export function getAllPrimitiveNames(): string[] {
  return Array.from(PRIMITIVES.keys());
}
```

### 3.4 Transform primitives

Each entry wraps the existing transform function, extracting typed arguments from the `Value[]`:

```typescript
// remove: (selection) -> selection
PRIMITIVES.set("remove", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "remove/input");
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: remove(clonedSelection) };
});

// transpose: (selection, semitones) -> selection
PRIMITIVES.set("transpose", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "transpose/input");
  const semitones = expectNumber(args[1], "transpose/semitones");
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: transpose(clonedSelection, semitones, ctx.abcContext) };
});

// to_rest: (selection) -> selection
PRIMITIVES.set("to_rest", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "to_rest/input");
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: toRest(clonedSelection, ctx.abcContext) };
});

// set_rhythm: (selection, rational) -> selection
// The rational argument is a list [numerator, denominator] or a single number
PRIMITIVES.set("set_rhythm", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "set_rhythm/input");
  const rational = valueToRational(args[1], "set_rhythm/rational");
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: setRhythm(clonedSelection, rational, ctx.abcContext) };
});

// sum_rhythm: (selection) -> number (the sum as a decimal)
PRIMITIVES.set("sum_rhythm", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "sum_rhythm/input");
  const rationals = sumRhythm(sel);
  // Return the sum of all rationals as a single number
  let total = 0;
  for (const r of rationals) {
    total += r.numerator / r.denominator;
  }
  return { type: "number", value: total };
});

// add_to_rhythm: (selection, rational) -> selection
PRIMITIVES.set("add_to_rhythm", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "add_to_rhythm/input");
  const rational = valueToRational(args[1], "add_to_rhythm/rational");
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: addToRhythm(clonedSelection, rational, ctx.abcContext) };
});

// unwrap_single: (selection) -> selection
PRIMITIVES.set("unwrap_single", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "unwrap_single/input");
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: unwrapSingle(clonedSelection) };
});

// enharmonize: (selection) -> selection
PRIMITIVES.set("enharmonize", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "enharmonize/input");
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: enharmonize(clonedSelection, ctx.abcContext) };
});

// filter: (selection, predicate_closure) -> selection
PRIMITIVES.set("filter", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "filter/input");
  const predicateClosure = expectClosure(args[1], "filter/predicate");
  const predicate = closureToPredicate(predicateClosure, ctx);
  return { type: "selection", selection: filter(sel, predicate) };
});

// add_voice: (selection, voiceId, recordOrNothing) -> selection
PRIMITIVES.set("add_voice", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "add_voice/input");
  const voiceId = expectString(args[1], "add_voice/voiceId");
  const params: VoiceParams = {};
  if (args.length > 2 && args[2].type === "record") {
    const fields = args[2].fields;
    if (fields.has("name")) params.name = expectString(fields.get("name")!, "add_voice/name");
    if (fields.has("clef")) params.clef = expectString(fields.get("clef")!, "add_voice/clef");
    if (fields.has("transpose")) params.transpose = expectNumber(fields.get("transpose")!, "add_voice/transpose");
  }
  const cloned = cloneCSTree(sel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: cloned, cursors: sel.cursors };
  return { type: "selection", selection: addVoice(clonedSelection, voiceId, params, ctx.abcContext) };
});
```

### 3.5 Inspection primitives

```typescript
// pitch: (selection) -> list of numbers
PRIMITIVES.set("pitch", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "pitch/input");
  const values = pitch(sel);
  return { type: "list", items: values.map(v => ({ type: "number", value: v } as NumberValue)) };
});

// length: (selection) -> number
PRIMITIVES.set("length", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "length/input");
  return { type: "number", value: length(sel) };
});

```

### 3.6 Selector primitives

```typescript
// select_chords: (selection) -> selection
PRIMITIVES.set("select_chords", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_chords/input");
  return { type: "selection", selection: selectChords(sel) };
});

// select_notes: (selection) -> selection
PRIMITIVES.set("select_notes", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_notes/input");
  return { type: "selection", selection: selectNotes(sel) };
});

// select_rests: (selection) -> selection
PRIMITIVES.set("select_rests", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_rests/input");
  return { type: "selection", selection: selectRests(sel) };
});

// select_non_chord_notes: (selection) -> selection
PRIMITIVES.set("select_non_chord_notes", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_non_chord_notes/input");
  return { type: "selection", selection: selectNonChordNotes(sel) };
});

// select_chord_notes: (selection) -> selection
PRIMITIVES.set("select_chord_notes", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_chord_notes/input");
  return { type: "selection", selection: selectChordNotes(sel) };
});

// select_top: (selection) -> selection
PRIMITIVES.set("select_top", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_top/input");
  return { type: "selection", selection: selectTop(sel) };
});

// select_bottom: (selection) -> selection
PRIMITIVES.set("select_bottom", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_bottom/input");
  return { type: "selection", selection: selectBottom(sel) };
});

// select_nth_from_top: (selection, n) -> selection
PRIMITIVES.set("select_nth_from_top", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_nth_from_top/input");
  const n = expectNumber(args[1], "select_nth_from_top/n");
  return { type: "selection", selection: selectNthFromTop(sel, n) };
});

// select_all_but_top: (selection) -> selection
PRIMITIVES.set("select_all_but_top", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_all_but_top/input");
  return { type: "selection", selection: selectAllButTop(sel) };
});

// select_all_but_bottom: (selection) -> selection
PRIMITIVES.set("select_all_but_bottom", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_all_but_bottom/input");
  return { type: "selection", selection: selectAllButBottom(sel) };
});

// select_voice: (selection, voiceId) -> selection
PRIMITIVES.set("select_voice", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_voice/input");
  const voiceId = expectString(args[1], "select_voice/voiceId");
  return { type: "selection", selection: selectVoice(sel, voiceId) };
});

// select_tune: (selection, tuneNumber) -> selection
// Note: the existing selectTune does not take a tuneNumber argument;
// it selects all Tune nodes. We wrap it and then narrow by index.
PRIMITIVES.set("select_tune", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_tune/input");
  const tuneNumber = expectNumber(args[1], "select_tune/tuneNumber");
  const allTunes = selectTune(sel);
  // X:n is 1-based, cursors are 0-indexed in the array
  const idx = tuneNumber - 1;
  if (idx < 0 || idx >= allTunes.cursors.length) {
    return { type: "selection", selection: { root: allTunes.root, cursors: [] } };
  }
  return { type: "selection", selection: { root: allTunes.root, cursors: [allTunes.cursors[idx]] } };
});

// select_range: (selection, startLine, startCol, endLine, endCol) -> selection
PRIMITIVES.set("select_range", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_range/input");
  const startLine = expectNumber(args[1], "select_range/startLine");
  const startCol = expectNumber(args[2], "select_range/startCol");
  const endLine = expectNumber(args[3], "select_range/endLine");
  const endCol = expectNumber(args[4], "select_range/endCol");
  return { type: "selection", selection: selectRange(sel, startLine, startCol, endLine, endCol) };
});

// select_siblings_after: (selection, predicate_closure) -> selection
PRIMITIVES.set("select_siblings_after", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "select_siblings_after/input");
  const predicateClosure = expectClosure(args[1], "select_siblings_after/predicate");
  const predicate = closureToPredicate(predicateClosure, ctx);
  return { type: "selection", selection: selectSiblingsAfter(sel, predicate) };
});
```

### 3.7 Comparison primitives

```typescript
// gt: (a, b) -> number (1 or 0)
PRIMITIVES.set("gt", (args: Value[], ctx: EvalContext): Value => {
  const a = expectNumber(args[0], "gt/left");
  const b = expectNumber(args[1], "gt/right");
  return { type: "number", value: a > b ? 1 : 0 };
});

// lt: (a, b) -> number (1 or 0)
PRIMITIVES.set("lt", (args: Value[], ctx: EvalContext): Value => {
  const a = expectNumber(args[0], "lt/left");
  const b = expectNumber(args[1], "lt/right");
  return { type: "number", value: a < b ? 1 : 0 };
});

// gte: (a, b) -> number (1 or 0)
PRIMITIVES.set("gte", (args: Value[], ctx: EvalContext): Value => {
  const a = expectNumber(args[0], "gte/left");
  const b = expectNumber(args[1], "gte/right");
  return { type: "number", value: a >= b ? 1 : 0 };
});

// lte: (a, b) -> number (1 or 0)
PRIMITIVES.set("lte", (args: Value[], ctx: EvalContext): Value => {
  const a = expectNumber(args[0], "lte/left");
  const b = expectNumber(args[1], "lte/right");
  return { type: "number", value: a <= b ? 1 : 0 };
});

// eq: (a, b) -> number (1 or 0)
PRIMITIVES.set("eq", (args: Value[], ctx: EvalContext): Value => {
  return { type: "number", value: valuesEqual(args[0], args[1]) ? 1 : 0 };
});

// neq: (a, b) -> number (1 or 0)
PRIMITIVES.set("neq", (args: Value[], ctx: EvalContext): Value => {
  return { type: "number", value: valuesEqual(args[0], args[1]) ? 0 : 1 };
});
```

The `valuesEqual` helper performs structural equality for numbers and strings, and reference equality for selections:

```typescript
function valuesEqual(a: Value, b: Value): boolean {
  if (a.type !== b.type) return false;
  if (a.type === "number" && b.type === "number") return a.value === b.value;
  if (a.type === "string" && b.type === "string") return a.value === b.value;
  if (a.type === "boolean" && b.type === "boolean") return a.value === b.value;
  if (a.type === "null" && b.type === "null") return true;
  return a === b; // reference equality for selections, closures, etc.
}
```

### 3.8 Miscellaneous primitives

```typescript
// negate: (number) -> number
PRIMITIVES.set("negate", (args: Value[], ctx: EvalContext): Value => {
  const n = expectNumber(args[0], "negate/operand");
  return { type: "number", value: -n };
});

// tag_eq: (selection, tag_string) -> number (1 or 0)
PRIMITIVES.set("tag_eq", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "tag_eq/input");
  const tagName = expectString(args[1], "tag_eq/tag");
  if (sel.cursors.length === 0) {
    return { type: "number", value: 0 };
  }
  // Find the node indicated by the first cursor
  const firstCursor = sel.cursors[0];
  const targetId = firstCursor.values().next().value;
  const node = findNodeById(sel.root, targetId);
  if (node === null) {
    return { type: "number", value: 0 };
  }
  // Map surface tag names (lowercase) to TAGS constants (capitalized)
  const normalizedTag = normalizeTagName(tagName);
  return { type: "number", value: node.tag === normalizedTag ? 1 : 0 };
});

// make_record: (...field_pairs) -> record
PRIMITIVES.set("make_record", (args: Value[], ctx: EvalContext): Value => {
  const fields = new Map<string, Value>();
  for (const arg of args) {
    if (arg.type !== "list" || arg.items.length !== 2) {
      throw new EvaluatorError("make_record: each field must be a [key, value] pair", DUMMY_LOC);
    }
    const key = expectString(arg.items[0], "make_record/key");
    fields.set(key, arg.items[1]);
  }
  return { type: "record", fields };
});

// location: (...numbers) -> list of numbers
// The location primitive simply packages its arguments into a list.
// The over primitive and select_range interpret the list.
PRIMITIVES.set("location", (args: Value[], ctx: EvalContext): Value => {
  const items: Value[] = args.map(a => {
    expectNumber(a, "location/arg");
    return a;
  });
  return { type: "list", items };
});

// abc_with_location: (abcLit, ...location_args) -> selection
// Evaluates the ABC literal and associates the result with a target location.
// For now, the location is stored as metadata but does not change the Selection.
PRIMITIVES.set("abc_with_location", (args: Value[], ctx: EvalContext): Value => {
  // The first argument is already a SelectionValue (the evaluated AbcLit)
  if (args[0].type === "selection") return args[0];
  throw new EvaluatorError("abc_with_location: first argument must be a selection", DUMMY_LOC);
});

// load: (path_string) -> selection
PRIMITIVES.set("load", (args: Value[], ctx: EvalContext): Value => {
  const path = expectString(args[0], "load/path");
  const content = ctx.fileResolver.resolve(path);
  if (content === null) {
    throw new EvaluatorError(`Failed to load file: "${path}"`, DUMMY_LOC);
  }
  return parseAbcContent(content, DUMMY_LOC, ctx);
});

// insert: (selection, location_list, abc_selection) -> selection
// Inserts ABC content at the specified location within the selection.
// This is a placeholder implementation that returns the input unchanged
// until the insertion logic is fully specified.
PRIMITIVES.set("insert", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "insert/input");
  // The insertion logic involves splicing the abc_selection's tree into
  // the input tree at the given location. Because this requires careful
  // CS tree manipulation, we defer the full implementation to a future plan.
  // For now, we return the input unchanged.
  return { type: "selection", selection: sel };
});

// is_rest: (selection) -> number (1 or 0)
PRIMITIVES.set("is_rest", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "is_rest/input");
  const node = getFirstCursorNode(sel);
  return { type: "number", value: node !== null && node.tag === TAGS.Rest ? 1 : 0 };
});

// is_note: (selection) -> number (1 or 0)
PRIMITIVES.set("is_note", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "is_note/input");
  const node = getFirstCursorNode(sel);
  return { type: "number", value: node !== null && node.tag === TAGS.Note ? 1 : 0 };
});

// is_chord: (selection) -> number (1 or 0)
PRIMITIVES.set("is_chord", (args: Value[], ctx: EvalContext): Value => {
  const sel = expectSelection(args[0], "is_chord/input");
  const node = getFirstCursorNode(sel);
  return { type: "number", value: node !== null && node.tag === TAGS.Chord ? 1 : 0 };
});
```

### 3.9 Utility functions for primitives

```typescript
// Converts a Value (number or [numerator, denominator] list) to IRational
function valueToRational(val: Value, argName: string): IRational {
  if (val.type === "number") {
    // Treat as numerator/1
    return { numerator: val.value, denominator: 1 };
  }
  if (val.type === "list" && val.items.length === 2) {
    const num = expectNumber(val.items[0], argName + "/numerator");
    const den = expectNumber(val.items[1], argName + "/denominator");
    return { numerator: num, denominator: den };
  }
  throw new EvaluatorError(
    `Expected a number or [numerator, denominator] list for "${argName}" but received "${val.type}"`,
    DUMMY_LOC
  );
}

// Maps surface tag names (lowercase) to the TAGS constants
function normalizeTagName(tag: string): string {
  const TAG_MAP: Record<string, string> = {
    "chord": TAGS.Chord,
    "note": TAGS.Note,
    "rest": TAGS.Rest,
    "beam": TAGS.Beam,
    "barline": TAGS.BarLine,
    "tune": TAGS.Tune,
    "tune_header": TAGS.Tune_header,
    "tune_body": TAGS.Tune_Body,
    "info_line": TAGS.Info_line,
    "decoration": TAGS.Decoration,
    "grace_group": TAGS.Grace_group,
    "tuplet": TAGS.Tuplet,
  };
  return TAG_MAP[tag.toLowerCase()] ?? tag;
}

// Finds a CSNode by id within the tree
function findNodeById(root: CSNode, id: number): CSNode | null {
  if (root.id === id) return root;
  let child = root.firstChild;
  while (child !== null) {
    const found = findNodeById(child, id);
    if (found !== null) return found;
    child = child.nextSibling;
  }
  return null;
}

// Extracts the first node pointed to by the first cursor of a selection
function getFirstCursorNode(sel: Selection): CSNode | null {
  if (sel.cursors.length === 0) return null;
  const firstCursor = sel.cursors[0];
  const targetId = firstCursor.values().next().value;
  if (targetId === undefined) return null;
  return findNodeById(sel.root, targetId);
}
```

---

## Phase 4: Bridge Utilities

### 4.1 File: `abct2/src/evaluator/bridges.ts`

This file contains utility functions that bridge between the evaluator's `Value` world and the concrete function signatures expected by transforms and selectors.

```typescript
import { ClosureValue, EvalContext, SelectionValue, Value, EvaluatorError } from "./types";
import { evaluate, isTruthy } from "./evaluate";
import { createEnv, bind } from "./env";
import { CSNode } from "../csTree/types";
import { Selection, createSelection } from "../selection";
import { Loc } from "../../../abct/src/ast";

// ABC parsing imports
import { ABCContext } from "../../../parse/parsers/Context";
import { Scanner } from "../../../parse/parsers/scan2"; // Scanner is a function, not a class
import { parse as parseAbc } from "../../../parse/parsers/parse2";
import { fromAst } from "../csTree/fromAst";

```

### 4.2 closureToPredicate

Converts a `ClosureValue` (a user-defined predicate function) to a `(node: CSNode) => boolean` function for use with `filter` and `selectSiblingsAfter`.

```typescript
export function closureToPredicate(closure: ClosureValue, ctx: EvalContext): (node: CSNode) => boolean {
  return (node: CSNode): boolean => {
    const inputSelection = createSelection(node);
    const inputValue: SelectionValue = { type: "selection", selection: inputSelection };

    const callEnv = createEnv(closure.env);
    if (closure.params.length > 0) {
      bind(callEnv, closure.params[0], inputValue);
    }

    const result = evaluate(closure.body, callEnv, ctx);
    return isTruthy(result);
  };
}
```

### 4.3 parseAbcContent

Parses an ABC string into a `SelectionValue`. This is used by both `AbcLit` evaluation and the `load` primitive.

```typescript
export function parseAbcContent(content: string, loc: Loc, ctx: EvalContext): SelectionValue {
  const tokens = Scanner(content, ctx.abcContext);
  const ast = parseAbc(tokens, ctx.abcContext);
  const csRoot = fromAst(ast);
  const selection = createSelection(csRoot);
  return { type: "selection", selection };
}
```

Parameters:
- `content: string` -- the raw ABC notation string to parse
- `loc: Loc` -- the source location of the literal (from `abct/src/ast.ts`), used only for error reporting
- `ctx: EvalContext` -- the evaluation context (from `./types.ts`), which provides `ctx.abcContext`

Returns: `SelectionValue` (from `./types.ts`)

Imports needed:
- `Scanner` (a function, not a class) from `../../../parse/parsers/scan2`
- `parse` (aliased as `parseAbc`) from `../../../parse/parsers/parse2`
- `fromAst` from `../csTree/fromAst`
- `createSelection` from `../selection`

---

## Phase 5: The over Primitive

### 5.1 Semantics

`over(input, focus, body)`:
1. `input` is the full `SelectionValue` the pipeline has been operating on.
2. `focus` is a selector result (a `SelectionValue` with narrowed cursors) or a closure that narrows the input.
3. `body` is a `ClosureValue` that will transform the focused subset.

The `over` primitive is registered in the dispatch table in `primitives.ts`:

```typescript
// over: (input_selection, focus_or_selector, body_closure) -> selection
PRIMITIVES.set("over", (args: Value[], ctx: EvalContext): Value => {
  const inputSel = expectSelection(args[0], "over/input");
  const focus = args[1];
  const bodyClosure = expectClosure(args[2], "over/body");
  return evaluateOver(inputSel, focus, bodyClosure, ctx);
});
```

### 5.2 Implementation

The `evaluateOver` function lives in `primitives.ts` (not nested, at module level):

```typescript
function evaluateOver(
  inputSel: Selection,
  focus: Value,
  bodyClosure: ClosureValue,
  ctx: EvalContext
): SelectionValue {
  // Step 1: Determine the focused selection.
  // If focus is a closure (a selector function), apply it to the input.
  // If focus is a selection (an already-narrowed result), use it directly.
  // If focus is a list (a location), convert it to a range selection.
  let focusedSelection: Selection;

  if (focus.type === "closure") {
    const focusResult = applyClosure(focus, [{ type: "selection", selection: inputSel }], DUMMY_LOC, ctx);
    focusedSelection = expectSelection(focusResult, "over/focus result");
  } else if (focus.type === "selection") {
    focusedSelection = focus.selection;
  } else if (focus.type === "list") {
    // Location list: interpret as range coordinates
    focusedSelection = locationToSelection(inputSel, focus.items);
  } else {
    throw new EvaluatorError(
      `over: focus must be a selector function, selection, or location, got "${focus.type}"`,
      DUMMY_LOC
    );
  }

  // Step 2: Clone the CS tree for isolation.
  const clonedRoot = cloneCSTree(inputSel.root, () => ctx.abcContext.generateId());
  const clonedSelection: Selection = { root: clonedRoot, cursors: focusedSelection.cursors };

  // Step 3: Invoke the body closure on the focused/cloned selection.
  const bodyInput: SelectionValue = { type: "selection", selection: clonedSelection };
  const callEnv = createEnv(bodyClosure.env);
  if (bodyClosure.params.length > 0) {
    bind(callEnv, bodyClosure.params[0], bodyInput);
  }
  const bodyResult = evaluate(bodyClosure.body, callEnv, ctx);

  // Step 4: Return the result. The body's result carries the modified tree.
  if (bodyResult.type === "selection") {
    return { type: "selection", selection: bodyResult.selection };
  }
  // If the body did not return a selection, return the cloned input unchanged.
  return { type: "selection", selection: { root: clonedRoot, cursors: inputSel.cursors } };
}
```

Note: `evaluateOver` uses `applyClosure` imported from `./evaluate`.

### 5.3 Location-to-selection helper

```typescript
function locationToSelection(inputSel: Selection, locationItems: Value[]): Selection {
  // Interpret location list length:
  // 1 arg: line only -> startLine=line, startCol=0, endLine=line, endCol=Infinity
  // 2 args: line:col -> point selection (endLine=startLine, endCol=startCol+1)
  // 3 args: line:col-endCol -> same line range
  // 4 args: startLine:startCol-endLine:endCol -> multi-line range
  const nums = locationItems.map((v, i) => expectNumber(v, `location[${i}]`));

  let startLine: number, startCol: number, endLine: number, endCol: number;
  switch (nums.length) {
    case 1:
      startLine = nums[0]; startCol = 0;
      endLine = nums[0]; endCol = 999999;
      break;
    case 2:
      startLine = nums[0]; startCol = nums[1];
      endLine = nums[0]; endCol = nums[1] + 1;
      break;
    case 3:
      startLine = nums[0]; startCol = nums[1];
      endLine = nums[0]; endCol = nums[2];
      break;
    case 4:
      startLine = nums[0]; startCol = nums[1];
      endLine = nums[2]; endCol = nums[3];
      break;
    default:
      throw new EvaluatorError(
        `location: expected 1-4 arguments but received ${nums.length}`,
        DUMMY_LOC
      );
  }

  return selectRange(inputSel, startLine, startCol, endLine, endCol);
}
```

This function uses the existing `selectRange` (imported from `../selectors/rangeSelector`).

---

## Phase 6: Top-level Entry Point and Error Handling

### 6.1 File: `abct2/src/evaluator/index.ts`

```typescript
import { CoreProgram } from "../../../abct/src/core/types";
import { Value, EvalContext, EvalDiagnostic, EvaluatorError, FileResolver, Env } from "./types";
import { evaluate } from "./evaluate";
import { createEnv, bind } from "./env";
import { getPrimitive, getAllPrimitiveNames } from "./primitives";
import { ABCContext } from "../../../parse/parsers/Context";

export { Value, EvalContext, EvalDiagnostic, EvaluatorError, FileResolver } from "./types";
export { SelectionValue, NumberValue, StringValue, ClosureValue, ListValue,
         RecordValue, NullValue, BooleanValue, PrimitiveFnValue } from "./types";

export interface EvaluateResult {
  value: Value;
  diagnostics: EvalDiagnostic[];
}

export interface EvaluateOptions {
  maxDepth?: number;
  fileResolver?: FileResolver;
}
```

### 6.2 createEvalContext

```typescript
export function createEvalContext(options: EvaluateOptions = {}): EvalContext {
  return {
    fileResolver: options.fileResolver ?? { resolve: () => null },
    diagnostics: [],
    maxDepth: options.maxDepth ?? 1000,
    currentDepth: 0,
    abcContext: new ABCContext(),
  };
}
```

### 6.3 buildRootEnv

Creates the root environment pre-populated with all primitives as `PrimitiveFnValue` bindings:

```typescript
export function buildRootEnv(): Env {
  const env = createEnv(null);
  const names = getAllPrimitiveNames();
  for (const name of names) {
    const impl = getPrimitive(name)!;
    bind(env, name, { type: "primitive_fn", name, fn: impl });
  }
  return env;
}
```

### 6.4 evaluateProgram

The top-level entry point. Because a `CoreProgram` is a single `CoreExpr` (nested `Let` bindings ending in a final expression), the evaluator simply evaluates that expression in the root environment:

```typescript
export function evaluateProgram(program: CoreProgram, options: EvaluateOptions = {}): EvaluateResult {
  const ctx = createEvalContext(options);
  const rootEnv = buildRootEnv();

  try {
    const value = evaluate(program.body, rootEnv, ctx);
    return { value, diagnostics: ctx.diagnostics };
  } catch (err) {
    if (err instanceof EvaluatorError) {
      ctx.diagnostics.push({ message: err.message, loc: err.loc });
      return { value: { type: "null" }, diagnostics: ctx.diagnostics };
    }
    throw err;
  }
}
```

Parameters:
- `program: CoreProgram` -- from `abct/src/core/types.ts` (plan 32). Contains a single `body: CoreExpr` field.
- `options: EvaluateOptions` -- optional configuration. `maxDepth` defaults to 1000. `fileResolver` defaults to a no-op resolver.

Returns: `EvaluateResult` with the computed `Value` and any diagnostics.

---

## Phase 7: Example-Based Tests

### 7.1 Location

`abct2/tests/evaluator/evaluator.spec.ts`

### 7.2 Test helpers

```typescript
import { describe, it, expect } from "vitest";
import { evaluateProgram, Value, EvaluateOptions, SelectionValue } from "../../src/evaluator";
import { CoreProgram, CoreExpr } from "../../../abct/src/core/types";
import { Loc } from "../../../abct/src/ast";
import { mkVar, mkApp, mkFn, mkLet, mkIf, mkList, mkNum, mkStr, mkAbc, mkPrim, mkError } from "../../../abct/src/core/utils";

const DUMMY_LOC: Loc = { start: { line: 0, column: 0, offset: 0 }, end: { line: 0, column: 0, offset: 0 } };

function evalExpr(expr: CoreExpr, options?: EvaluateOptions): Value {
  const program: CoreProgram = { body: expr, loc: DUMMY_LOC };
  const result = evaluateProgram(program, options);
  return result.value;
}
```

### 7.3 Var lookup tests

```typescript
describe("Var evaluation", () => {
  it("should resolve a variable bound via Let", () => {
    // let x = 42; x
    const expr = mkLet("x", DUMMY_LOC, mkNum(42, DUMMY_LOC), mkVar("x", DUMMY_LOC), DUMMY_LOC);
    const val = evalExpr(expr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(42);
  });

  it("should throw for undefined variable", () => {
    const expr = mkVar("nonexistent", DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Undefined variable");
  });
});
```

### 7.4 Literal evaluation tests

```typescript
describe("Literal evaluation", () => {
  it("should evaluate NumLit", () => {
    const val = evalExpr(mkNum(3.14, DUMMY_LOC));
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(3.14);
  });

  it("should evaluate StringLit", () => {
    const val = evalExpr(mkStr("hello", DUMMY_LOC));
    expect(val.type).toBe("string");
    if (val.type === "string") expect(val.value).toBe("hello");
  });

  it("should evaluate AbcLit by parsing ABC content", () => {
    const val = evalExpr(mkAbc("X:1\nT:Test\nK:C\nCDEF|", DUMMY_LOC));
    expect(val.type).toBe("selection");
  });

  it("should evaluate CoreList", () => {
    const val = evalExpr(mkList([mkNum(1, DUMMY_LOC), mkNum(2, DUMMY_LOC)], DUMMY_LOC));
    expect(val.type).toBe("list");
    if (val.type === "list") {
      expect(val.items.length).toBe(2);
      expect(val.items[0].type).toBe("number");
    }
  });
});
```

### 7.5 Fn creation and App tests

```typescript
describe("Fn and App evaluation", () => {
  it("should create a closure from Fn", () => {
    // fn(x) => x
    const val = evalExpr(mkFn(["x"], [DUMMY_LOC], mkVar("x", DUMMY_LOC), DUMMY_LOC));
    expect(val.type).toBe("closure");
    if (val.type === "closure") {
      expect(val.params).toEqual(["x"]);
    }
  });

  it("should apply a closure via App", () => {
    // let id = fn(x) => x; id(42)
    const idFn = mkFn(["x"], [DUMMY_LOC], mkVar("x", DUMMY_LOC), DUMMY_LOC);
    const expr = mkLet("id", DUMMY_LOC, idFn,
      mkApp(mkVar("id", DUMMY_LOC), [mkNum(42, DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(42);
  });

  it("should apply a multi-parameter closure", () => {
    // fn(a,b) => a (returns first arg)
    const pickFirst = mkFn(["a", "b"], [DUMMY_LOC, DUMMY_LOC], mkVar("a", DUMMY_LOC), DUMMY_LOC);
    const expr = mkLet("f", DUMMY_LOC, pickFirst,
      mkApp(mkVar("f", DUMMY_LOC), [mkNum(10, DUMMY_LOC), mkNum(20, DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(10);
  });

  it("should throw when applying a non-function", () => {
    // 42(1)
    const expr = mkApp(mkNum(42, DUMMY_LOC), [mkNum(1, DUMMY_LOC)], DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Cannot apply non-function");
  });

  it("should throw on argument count mismatch", () => {
    // let f = fn(x) => x; f(1, 2)
    const fn = mkFn(["x"], [DUMMY_LOC], mkVar("x", DUMMY_LOC), DUMMY_LOC);
    const expr = mkLet("f", DUMMY_LOC, fn,
      mkApp(mkVar("f", DUMMY_LOC), [mkNum(1, DUMMY_LOC), mkNum(2, DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("expects 1 arguments but received 2");
  });
});
```

### 7.6 Let bindings tests (sequential and letrec)

```typescript
describe("Let evaluation", () => {
  it("should evaluate sequential Let bindings", () => {
    // let x = 1; let y = 2; prim("gt", [y, x]) -> 1
    const expr = mkLet("x", DUMMY_LOC, mkNum(1, DUMMY_LOC),
      mkLet("y", DUMMY_LOC, mkNum(2, DUMMY_LOC),
        mkPrim("gt", [mkVar("y", DUMMY_LOC), mkVar("x", DUMMY_LOC)], DUMMY_LOC),
        DUMMY_LOC
      ),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(1);
  });

  it("should support letrec for recursive functions", () => {
    // let f = fn(n) => n  (simple non-recursive check)
    const simpleFn = mkFn(["n"], [DUMMY_LOC], mkVar("n", DUMMY_LOC), DUMMY_LOC);
    const expr = mkLet("f", DUMMY_LOC, simpleFn,
      mkApp(mkVar("f", DUMMY_LOC), [mkNum(5, DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(5);
  });

  it("should allow recursive function to reference itself", () => {
    // let f = fn() => f; f() returns the closure itself
    const fn = mkFn([], [], mkVar("f", DUMMY_LOC), DUMMY_LOC);
    const expr = mkLet("f", DUMMY_LOC, fn,
      mkApp(mkVar("f", DUMMY_LOC), [], DUMMY_LOC),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("closure");
  });

  it("should throw when accessing variable before initialization", () => {
    // let x = x; x
    const expr = mkLet("x", DUMMY_LOC, mkVar("x", DUMMY_LOC), mkVar("x", DUMMY_LOC), DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("accessed before initialization");
  });
});
```

### 7.7 If branching tests

```typescript
describe("If evaluation", () => {
  it("should evaluate consequent when condition is truthy", () => {
    const expr = mkIf(mkNum(1, DUMMY_LOC), mkStr("yes", DUMMY_LOC), mkStr("no", DUMMY_LOC), DUMMY_LOC);
    const val = evalExpr(expr);
    expect(val.type).toBe("string");
    if (val.type === "string") expect(val.value).toBe("yes");
  });

  it("should evaluate alternative when condition is falsy (0)", () => {
    const expr = mkIf(mkNum(0, DUMMY_LOC), mkStr("yes", DUMMY_LOC), mkStr("no", DUMMY_LOC), DUMMY_LOC);
    const val = evalExpr(expr);
    expect(val.type).toBe("string");
    if (val.type === "string") expect(val.value).toBe("no");
  });

  it("should treat non-zero numbers as truthy", () => {
    const expr = mkIf(mkNum(-5, DUMMY_LOC), mkNum(1, DUMMY_LOC), mkNum(0, DUMMY_LOC), DUMMY_LOC);
    const val = evalExpr(expr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(1);
  });

  it("should treat non-empty strings as truthy", () => {
    const expr = mkIf(mkStr("x", DUMMY_LOC), mkNum(1, DUMMY_LOC), mkNum(0, DUMMY_LOC), DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(1);
  });

  it("should treat empty strings as falsy", () => {
    const expr = mkIf(mkStr("", DUMMY_LOC), mkNum(1, DUMMY_LOC), mkNum(0, DUMMY_LOC), DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(0);
  });
});
```

### 7.8 PrimCall dispatch tests

```typescript
describe("PrimCall evaluation", () => {
  it("should dispatch transpose on a selection", () => {
    // Parse ABC, then transpose
    const abcExpr = mkAbc("X:1\nT:Test\nK:C\nCDEF|", DUMMY_LOC);
    const expr = mkLet("src", DUMMY_LOC, abcExpr,
      mkPrim("transpose", [
        mkPrim("select_notes", [mkVar("src", DUMMY_LOC)], DUMMY_LOC),
        mkNum(2, DUMMY_LOC)
      ], DUMMY_LOC),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("selection");
  });

  it("should dispatch select_chords", () => {
    const abcExpr = mkAbc("X:1\nT:Test\nK:C\n[CEG]|", DUMMY_LOC);
    const expr = mkLet("src", DUMMY_LOC, abcExpr,
      mkPrim("select_chords", [mkVar("src", DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("selection");
    if (val.type === "selection") {
      expect(val.selection.cursors.length).toBeGreaterThan(0);
    }
  });

  it("should throw on unknown primitive", () => {
    const expr = mkPrim("nonexistent_prim", [], DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Unknown primitive");
  });

  it("should dispatch comparison primitives", () => {
    const gtExpr = mkPrim("gt", [mkNum(5, DUMMY_LOC), mkNum(3, DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(gtExpr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(1);

    const ltExpr = mkPrim("lt", [mkNum(5, DUMMY_LOC), mkNum(3, DUMMY_LOC)], DUMMY_LOC);
    const val2 = evalExpr(ltExpr);
    if (val2.type === "number") expect(val2.value).toBe(0);
  });

  it("should dispatch negate", () => {
    const expr = mkPrim("negate", [mkNum(5, DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(-5);
  });

  it("should dispatch make_record", () => {
    const expr = mkPrim("make_record", [
      mkList([mkStr("name", DUMMY_LOC), mkStr("Trumpet", DUMMY_LOC)], DUMMY_LOC),
      mkList([mkStr("clef", DUMMY_LOC), mkStr("treble", DUMMY_LOC)], DUMMY_LOC),
    ], DUMMY_LOC);
    const val = evalExpr(expr);
    expect(val.type).toBe("record");
    if (val.type === "record") {
      expect(val.fields.get("name")).toEqual({ type: "string", value: "Trumpet" });
      expect(val.fields.get("clef")).toEqual({ type: "string", value: "treble" });
    }
  });

  it("should dispatch tag_eq", () => {
    const abcExpr = mkAbc("X:1\nT:Test\nK:C\n[CEG]|", DUMMY_LOC);
    const expr = mkLet("src", DUMMY_LOC, abcExpr,
      mkLet("chords", DUMMY_LOC,
        mkPrim("select_chords", [mkVar("src", DUMMY_LOC)], DUMMY_LOC),
        mkPrim("tag_eq", [mkVar("chords", DUMMY_LOC), mkStr("chord", DUMMY_LOC)], DUMMY_LOC),
        DUMMY_LOC
      ),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("number");
    if (val.type === "number") expect(val.value).toBe(1);
  });
});
```

### 7.9 over primitive tests

```typescript
describe("over primitive", () => {
  it("should apply body to focused selection and return result", () => {
    // source | over @chords (transpose 2)
    // Represented as: let src = abc; prim("over", [src, selectorClosure, bodyClosure])
    const abcExpr = mkAbc("X:1\nT:Test\nK:C\n[CEG]A|", DUMMY_LOC);
    const selectorFn = mkFn(["s"], [DUMMY_LOC],
      mkPrim("select_chords", [mkVar("s", DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const bodyFn = mkFn(["focused"], [DUMMY_LOC],
      mkPrim("transpose", [mkVar("focused", DUMMY_LOC), mkNum(2, DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const expr = mkLet("src", DUMMY_LOC, abcExpr,
      mkPrim("over", [mkVar("src", DUMMY_LOC), selectorFn, bodyFn], DUMMY_LOC),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("selection");
  });
});
```

### 7.10 load primitive tests

```typescript
describe("load primitive", () => {
  it("should load and parse an ABC file via fileResolver", () => {
    const abcContent = "X:1\nT:Loaded\nK:C\nCDEF|";
    const fileResolver = {
      resolve: (path: string) => path === "test.abc" ? abcContent : null,
    };
    const expr = mkPrim("load", [mkStr("test.abc", DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(expr, { fileResolver });
    expect(val.type).toBe("selection");
  });

  it("should report an error when file is not found", () => {
    const fileResolver = { resolve: () => null };
    const expr = mkPrim("load", [mkStr("missing.abc", DUMMY_LOC)], DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC }, { fileResolver });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Failed to load file");
  });
});
```

### 7.11 Stack overflow detection tests

```typescript
describe("Stack overflow detection", () => {
  it("should throw when maxDepth is exceeded", () => {
    // let f = fn(x) => f(x); f(1)
    // This creates infinite recursion.
    const fn = mkFn(["x"], [DUMMY_LOC],
      mkApp(mkVar("f", DUMMY_LOC), [mkVar("x", DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const expr = mkLet("f", DUMMY_LOC, fn,
      mkApp(mkVar("f", DUMMY_LOC), [mkNum(1, DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC }, { maxDepth: 50 });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Maximum recursion depth exceeded");
  });
});
```

### 7.12 Type mismatch error tests

```typescript
describe("Type mismatch errors", () => {
  it("should throw when transpose receives a non-selection", () => {
    const expr = mkPrim("transpose", [mkNum(42, DUMMY_LOC), mkNum(2, DUMMY_LOC)], DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Expected a selection");
  });

  it("should throw when gt receives a non-number", () => {
    const expr = mkPrim("gt", [mkStr("a", DUMMY_LOC), mkNum(2, DUMMY_LOC)], DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Expected a number");
  });
});
```

### 7.13 CoreError evaluation test

```typescript
describe("CoreError evaluation", () => {
  it("should report a diagnostic for CoreError nodes", () => {
    const expr = mkError("Something went wrong", DUMMY_LOC);
    const result = evaluateProgram({ body: expr, loc: DUMMY_LOC });
    expect(result.diagnostics.length).toBeGreaterThan(0);
    expect(result.diagnostics[0].message).toContain("Something went wrong");
  });
});
```

### 7.14 Filter primitive test

```typescript
describe("filter primitive", () => {
  it("should filter selection using a predicate closure", () => {
    // Parse ABC with multiple notes, select notes, filter by a predicate
    const abcExpr = mkAbc("X:1\nT:Test\nK:C\nCDEF|", DUMMY_LOC);
    // Predicate: is_note (always true for notes)
    const predicate = mkFn(["el"], [DUMMY_LOC],
      mkPrim("is_note", [mkVar("el", DUMMY_LOC)], DUMMY_LOC),
      DUMMY_LOC
    );
    const expr = mkLet("src", DUMMY_LOC, abcExpr,
      mkLet("notes", DUMMY_LOC,
        mkPrim("select_notes", [mkVar("src", DUMMY_LOC)], DUMMY_LOC),
        mkPrim("filter", [mkVar("notes", DUMMY_LOC), predicate], DUMMY_LOC),
        DUMMY_LOC
      ),
      DUMMY_LOC
    );
    const val = evalExpr(expr);
    expect(val.type).toBe("selection");
    if (val.type === "selection") {
      // All notes pass is_note, so cursor count should be preserved
      expect(val.selection.cursors.length).toBeGreaterThan(0);
    }
  });
});
```

### 7.15 Equality and inequality tests

```typescript
describe("Equality primitives", () => {
  it("should return 1 for equal numbers", () => {
    const expr = mkPrim("eq", [mkNum(5, DUMMY_LOC), mkNum(5, DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(1);
  });

  it("should return 0 for unequal numbers", () => {
    const expr = mkPrim("eq", [mkNum(5, DUMMY_LOC), mkNum(3, DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(0);
  });

  it("should return 1 for equal strings", () => {
    const expr = mkPrim("eq", [mkStr("abc", DUMMY_LOC), mkStr("abc", DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(1);
  });

  it("should return 0 for different types", () => {
    const expr = mkPrim("eq", [mkNum(5, DUMMY_LOC), mkStr("5", DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(0);
  });

  it("should return 1 for neq on different values", () => {
    const expr = mkPrim("neq", [mkNum(5, DUMMY_LOC), mkNum(3, DUMMY_LOC)], DUMMY_LOC);
    const val = evalExpr(expr);
    if (val.type === "number") expect(val.value).toBe(1);
  });
});
```

---

## Phase 8: Integration with Build

### 8.1 Exports

Add to `abct2/src/index.ts` (or create it if needed):

```typescript
export { evaluateProgram, EvaluateResult, EvaluateOptions, Value, EvalContext,
         EvalDiagnostic, EvaluatorError, FileResolver,
         SelectionValue, NumberValue, StringValue, ClosureValue, ListValue,
         RecordValue, NullValue, BooleanValue, PrimitiveFnValue } from "./evaluator";
```

### 8.2 Build verification

Run `npm run build` from the repo root. The new files must compile without errors.

### 8.3 Test verification

Run `npm run test` from the repo root. All existing tests must continue passing, and the new evaluator tests must pass.

---

## Summary of the complete primitive dispatch table

This table maps every `PrimCall` name that the desugarer (plan 32) can produce to the concrete implementation it dispatches to:

| PrimCall name            | Implementation                    | Signature summary              |
| ------------------------ | --------------------------------- | ------------------------------ |
| `transpose`              | `transforms/transpose.ts`         | (sel, num) -> sel              |
| `remove`                 | `transforms/remove.ts`            | (sel) -> sel                   |
| `to_rest`                | `transforms/toRest.ts`            | (sel) -> sel                   |
| `set_rhythm`             | `transforms/setRhythm.ts`         | (sel, rational) -> sel         |
| `sum_rhythm`             | `transforms/sumRhythm.ts`         | (sel) -> num                   |
| `add_to_rhythm`          | `transforms/addToRhythm.ts`       | (sel, rational) -> sel         |
| `unwrap_single`          | `transforms/unwrapSingle.ts`      | (sel) -> sel                   |
| `enharmonize`            | `transforms/enharmonize.ts`       | (sel) -> sel                   |
| `filter`                 | `transforms/filter.ts`            | (sel, closure) -> sel          |
| `add_voice`              | `transforms/addVoice.ts`          | (sel, str, record?) -> sel     |
| `pitch`                  | `transforms/pitch.ts`             | (sel) -> list[num]             |
| `length`                 | `transforms/length.ts`            | (sel) -> num                   |
| `select_chords`          | `selectors/typeSelectors.ts`      | (sel) -> sel                   |
| `select_notes`           | `selectors/typeSelectors.ts`      | (sel) -> sel                   |
| `select_rests`           | `selectors/typeSelectors.ts`      | (sel) -> sel                   |
| `select_non_chord_notes` | `selectors/typeSelectors.ts`      | (sel) -> sel                   |
| `select_chord_notes`     | `selectors/typeSelectors.ts`      | (sel) -> sel                   |
| `select_top`             | `selectors/chordSelectors.ts`     | (sel) -> sel                   |
| `select_bottom`          | `selectors/chordSelectors.ts`     | (sel) -> sel                   |
| `select_nth_from_top`    | `selectors/chordSelectors.ts`     | (sel, num) -> sel              |
| `select_all_but_top`     | `selectors/chordSelectors.ts`     | (sel) -> sel                   |
| `select_all_but_bottom`  | `selectors/chordSelectors.ts`     | (sel) -> sel                   |
| `select_voice`           | `selectors/voiceSelector.ts`      | (sel, str) -> sel              |
| `select_tune`            | `selectors/structureSelectors.ts` | (sel, num) -> sel              |
| `select_range`           | `selectors/rangeSelector.ts`      | (sel, n, n, n, n) -> sel       |
| `select_siblings_after`  | `selectors/siblingSelector.ts`    | (sel, closure) -> sel          |
| `over`                   | evaluator/primitives.ts           | (sel, focus, closure) -> sel   |
| `load`                   | bridges.ts parseAbcContent        | (str) -> sel                   |
| `insert`                 | placeholder (returns input)       | (sel, list, sel) -> sel        |
| `gt`                     | inline comparison                 | (num, num) -> num              |
| `lt`                     | inline comparison                 | (num, num) -> num              |
| `gte`                    | inline comparison                 | (num, num) -> num              |
| `lte`                    | inline comparison                 | (num, num) -> num              |
| `eq`                     | inline equality                   | (val, val) -> num              |
| `neq`                    | inline equality                   | (val, val) -> num              |
| `negate`                 | inline arithmetic                 | (num) -> num                   |
| `tag_eq`                 | evaluator/primitives.ts           | (sel, str) -> num              |
| `make_record`            | evaluator/primitives.ts           | (...[str,val] pairs) -> record |
| `location`               | evaluator/primitives.ts           | (...nums) -> list              |
| `abc_with_location`      | evaluator/primitives.ts           | (sel, ...nums) -> sel          |
| `is_rest`                | evaluator/primitives.ts           | (sel) -> num                   |
| `is_note`                | evaluator/primitives.ts           | (sel) -> num                   |
| `is_chord`               | evaluator/primitives.ts           | (sel) -> num                   |

Total: 43 primitives (all entries from plan 32's PRIMITIVES set, plus `enharmonize` which exists in the transforms but is not yet in the desugarer's set).

---

## To Do

- Create `abct2/src/evaluator/types.ts` with the `Value` union type (9 variants), `Env` interface, `EvalContext` interface, `FileResolver` interface, `EvalDiagnostic` interface, `EvaluatorError` class, `PrimImpl` type alias, and the `UNINITIALIZED` sentinel symbol.
- Create `abct2/src/evaluator/env.ts` with `createEnv`, `lookup`, and `bind` functions.
- Create `abct2/src/evaluator/evaluate.ts` with the main `evaluate` function, the `evaluateNode` dispatch, and the individual evaluation functions (`evaluateAbcLit`, `evaluateList`, `evaluateFn`, `evaluateApp`, `applyFunction`, `applyClosure`, `evaluateLet`, `evaluateIf`, `evaluatePrimCall`). Export `isTruthy`, `applyFunction`, and `applyClosure`.
- Create `abct2/src/evaluator/primitives.ts` with the complete dispatch table (all 43 primitives), the value extractor helpers (`expectSelection`, `expectNumber`, `expectString`, `expectClosure`, `expectList`), the utility functions (`valueToRational`, `normalizeTagName`, `findNodeById`, `getFirstCursorNode`, `valuesEqual`, `locationToSelection`, `evaluateOver`), and the `getPrimitive`/`getAllPrimitiveNames` exports.
- Create `abct2/src/evaluator/bridges.ts` with `closureToPredicate` and `parseAbcContent`.
- Create `abct2/src/evaluator/index.ts` with the public API: `evaluateProgram`, `createEvalContext`, `buildRootEnv`, `EvaluateResult`, `EvaluateOptions`, and all re-exported value types.
- Create `abct2/tests/evaluator/evaluator.spec.ts` with example-based tests covering: Var lookup (found/not found), NumLit/StringLit/AbcLit/CoreList evaluation, Fn creation, App (closure invocation, argument mismatch, non-function application), Let (sequential and letrec, accessing before initialization), If (truthy/falsy branching for numbers, strings, empty values), PrimCall dispatch (transpose, select_chords, comparison, negate, make_record, tag_eq, unknown primitive), over primitive, load primitive (success and failure), filter primitive, equality/inequality, CoreError, stack overflow detection, type mismatch errors.
- Update `abct2/src/index.ts` to re-export the evaluator's public API.
- Final verification: build and tests both pass.
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

Copy the plan file into the plans directory, and once you are done with the implementation of each of the phases of the plan, make sure to call the code review agent on the current phase and address any feedback that the code review agent might have. After you are done with the feedback and all the tests are passing, commit the changes and then move onto the next phase. Do this until finished.
