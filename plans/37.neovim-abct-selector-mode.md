# Neovim ABCT Selector Keymaps

## Table of Contents

1. [Goal](#goal)
2. [Prerequisites](#prerequisites)
3. [Architecture Overview](#architecture-overview)
4. [Per-buffer State](#per-buffer-state)
5. [Module: `lua/abc_lsp/selectors.lua`](#module-luaabc_lspselectorslua)
6. [Integration into Existing Plugin](#integration-into-existing-plugin)
7. [Keymap Table](#keymap-table)
8. [Visual Highlighting](#visual-highlighting)
9. [Auto-clearing on Document Edit](#auto-clearing-on-document-edit)
10. [Statusline Integration](#statusline-integration)
11. [To Do](#to-do)

---

## Goal

We want to prototype ABCT selectors (narrowing, nestable) inside Neovim so that we can evaluate their ergonomics interactively before implementing the ABCT v2 language layer. The approach uses leader-prefixed keymaps (always available, no mode switching) that:

- Send `abct2.applySelector` requests to the existing LSP server
- Highlight returned ranges with extmarks
- Maintain a stack of cursor states so that selectors can be undone
- Clear state automatically on document edits

Because the keymaps live behind `<leader>s`, no normal-mode keys are shadowed and there is no risk of getting stuck in a custom mode.

## Prerequisites

- The `abct2.applySelector` handler lives on the `feature/abct-grammar` branch of `abc_parse`. The Neovim plugin must connect to a build of the LSP server from that branch (or a merge thereof into main).
- We work off the `main` branch of `abc-lsp.nvim`, creating a new branch for this feature.

## Architecture Overview

```
User presses <leader>sc (selectChords)
  |
  v
Keymap callback calls selectors.apply(bufnr, "selectChords")
  |
  v
selectors.apply() sets state.pending = true,
sends "abct2.applySelector" to LSP server via client.request()
  |
  v
LSP server returns { ranges, cursorNodeIds }
  |
  v
In the callback:
  - push previous { cursor_node_ids, ranges, selector_name } onto the stack
  - store new cursorNodeIds and ranges in buffer state
  - clear old extmarks, set new extmarks at returned ranges
  - set state.pending = false
  - trigger statusline refresh
  |
  v
User sees highlighted ranges, presses <leader>st to narrow further
```

The push happens inside the callback (after we receive the response) rather than before sending the request. This prevents race conditions when the user presses keys rapidly — if a request is already in flight (`state.pending == true`), the new keypress is ignored.

## Per-buffer State

A Lua table stored in a module-level map keyed by buffer number:

```lua
-- selectors.lua (module-level)
local ns = vim.api.nvim_create_namespace("abct_selectors")  -- global, stable across reloads
local buffer_states = {}   -- map: bufnr -> BufferState

-- BufferState structure:
{
  cursor_node_ids = {},    -- number[]: current IDs sent to the LSP
  ranges = {},             -- table[]: current highlighted ranges (cached for undo stack)
  stack = {},              -- StackEntry[]: history for undo (see below)
  selector_names = {},     -- string[]: chain of applied selector names (for statusline)
  pending = false,         -- boolean: true while an LSP request is in flight
  autocmd_id = nil,        -- number|nil: ID of the TextChanged autocmd (nil if not registered)
}

-- StackEntry structure (each entry in state.stack):
{
  cursor_node_ids = {},    -- number[]: the cursor IDs before this selector was applied
  ranges = {},             -- table[]: the ranges before this selector was applied
  selector_name = "",      -- string: the selector name that produced this entry's parent state
}
```

## Module: `lua/abc_lsp/selectors.lua`

This module is a new file at `/Users/antoine/Documents/personnel/experiments/abc/abc-lsp.nvim/lua/abc_lsp/selectors.lua`. It exposes the following functions:

### `selectors.setup_keymaps(bufnr)`

Registers all `<leader>s`-prefixed keymaps for the given buffer using `vim.keymap.set("n", ..., { buffer = bufnr })`. Called once per buffer when the LSP attaches (from `on_attach` in `server.lua`).

Each keymap callback calls the appropriate function (`selectors.apply`, `selectors.undo`, or `selectors.reset`).

### `selectors.apply(bufnr, selector_name, args)`

Parameters:
- `bufnr`: number
- `selector_name`: string (e.g., `"selectChords"`)
- `args`: number[] | nil (e.g., `{1}` for `selectNthFromTop`)

Steps:
1. Retrieve or create the buffer state for `bufnr`.
2. If `state.pending` is true, return early (ignore the keypress because a previous request has not resolved yet).
3. Get the LSP client: `vim.lsp.get_client_by_id(require("abc_lsp.server").client_id)`. If nil, notify the user ("ABC LSP server not connected") and return.
4. Set `state.pending = true`.
5. Build the URI: `vim.uri_from_bufnr(bufnr)`.
6. Build request params: `{ uri = uri, selector = selector_name, args = args or {}, cursorNodeIds = state.cursor_node_ids }`.
7. Call `client.request("abct2.applySelector", params, callback, bufnr)`.
8. The callback receives `(err, result)`:
   - If `err` is non-nil: set `state.pending = false`, notify the user with the error message, return.
   - If `result.cursorNodeIds` is empty (selector matched nothing): set `state.pending = false`, notify the user ("Selector matched nothing"), return without modifying state.
   - Push the previous state onto the stack: `table.insert(state.stack, { cursor_node_ids = state.cursor_node_ids, ranges = state.ranges, selector_name = state.selector_names[#state.selector_names] or "" })`.
   - Store `result.cursorNodeIds` into `state.cursor_node_ids`.
   - Store `result.ranges` into `state.ranges`.
   - Append `selector_name` to `state.selector_names`.
   - Call `selectors.highlight(bufnr, result.ranges)`.
   - Set `state.pending = false`.
   - If `state.autocmd_id` is nil, register the TextChanged autocmd (see auto-clearing section) and store its ID.
   - Trigger statusline refresh.

### `selectors.undo(bufnr)`

1. Retrieve the buffer state. If no state exists or `state.stack` is empty, call `selectors.reset(bufnr)` and return.
2. Pop the last entry from `state.stack`.
3. Set `state.cursor_node_ids = entry.cursor_node_ids`.
4. Set `state.ranges = entry.ranges`.
5. Remove the last entry from `state.selector_names`.
6. If `entry.ranges` is empty (we're back to the initial state before any selector was applied), call `selectors.reset(bufnr)`.
7. Otherwise, call `selectors.highlight(bufnr, entry.ranges)`.
8. Trigger statusline refresh.

### `selectors.reset(bufnr)`

Fully resets all state for the buffer:
1. Clear all extmarks in the `ns` namespace for this buffer.
2. If the state has a registered autocmd (`state.autocmd_id`), delete it via `vim.api.nvim_del_autocmd(state.autocmd_id)`.
3. Reset the buffer state to its initial values: `cursor_node_ids = {}`, `ranges = {}`, `stack = {}`, `selector_names = {}`, `pending = false`, `autocmd_id = nil`.
4. Trigger statusline refresh.

### `selectors.highlight(bufnr, ranges)`

1. Clear all extmarks in `ns` for this buffer: `vim.api.nvim_buf_clear_namespace(bufnr, ns, 0, -1)`.
2. For each range in `ranges`, set an extmark:
```lua
vim.api.nvim_buf_set_extmark(bufnr, ns, range.start.line, range.start.character, {
  end_row = range["end"].line,
  end_col = range["end"].character,
  hl_group = "AbctSelection",
  priority = 200,
})
```

### `selectors.get_status(bufnr)`

1. Retrieve the buffer state. If no state or `selector_names` is empty, return `nil`.
2. Build a chain string by stripping the `"select"` prefix from each name and lowercasing: e.g., `"selectChords"` becomes `"chords"`, `"selectTop"` becomes `"top"`.
3. Return: `"ABCT: chords > top (3)"` where `3` is `#state.cursor_node_ids`.

### `selectors.cleanup(bufnr)`

Called when a buffer is wiped/deleted. Removes the buffer entry from `buffer_states`:
```lua
buffer_states[bufnr] = nil
```

## Integration into Existing Plugin

### Changes to `lua/abc_lsp/server.lua`

In the `on_attach` callback (line 93 of `server.lua`), add:

```lua
on_attach = function(_, bufnr)
  abc_cmds.register_buffer_commands(bufnr)
  require("abc_lsp.selectors").setup_keymaps(bufnr)
end,
```

### Changes to `lua/abc_lsp/commands.lua`

Add two subcommands to the `subcommands` table:

```lua
selector_reset = {
  impl = function()
    require("abc_lsp.selectors").reset(vim.api.nvim_get_current_buf())
  end,
  desc = "Reset ABCT selection and highlights"
},
selector_undo = {
  impl = function()
    require("abc_lsp.selectors").undo(vim.api.nvim_get_current_buf())
  end,
  desc = "Undo last ABCT selector"
},
```

Add a `"Selectors:"` entry to the `groups` table in `show_help()`:

```lua
{ title = "Selectors:", commands = { "selector_reset", "selector_undo" } },
```

### Changes to `lua/abc_lsp/init.lua`

Register a `BufWipeout` autocmd in `create_autocommands()` to clean up buffer state:

```lua
vim.api.nvim_create_autocmd("BufWipeout", {
  group = augroup,
  pattern = { "*.abc", "*.abcx" },
  callback = function(ev)
    require("abc_lsp.selectors").cleanup(ev.buf)
  end,
})
```

### Highlight Group Definition

At the top of `selectors.lua`, during module load:

```lua
vim.api.nvim_set_hl(0, "AbctSelection", { bg = "#3a3a5a", underline = true })
```

This provides a default that can be overridden by the user's colorscheme.

## Keymap Table

All keymaps are prefixed with `<leader>s` and registered as permanent buffer-local normal-mode mappings when the LSP attaches.

| Keys | Selector | Description |
|------|----------|-------------|
| `<leader>sc` | `selectChords` | Select all chord nodes |
| `<leader>sn` | `selectNotes` | Select all note nodes |
| `<leader>sN` | `selectNonChordNotes` | Select notes that are not inside chords |
| `<leader>sC` | `selectChordNotes` | Select notes that are inside chords |
| `<leader>sr` | `selectRests` | Select all rest nodes |
| `<leader>ss` | `selectTune` | Select tune nodes (scopes to individual tunes) |
| `<leader>st` | `selectTop` | Narrow to the top note of each chord |
| `<leader>sb` | `selectBottom` | Narrow to the bottom note of each chord |
| `<leader>sT` | `selectAllButTop` | Narrow to all notes except the top |
| `<leader>sB` | `selectAllButBottom` | Narrow to all notes except the bottom |
| `<leader>su` | (undo) | Pop the selector stack, restore previous highlights |
| `<leader>sq` | (reset) | Clear all selection state and highlights |

For `selectNthFromTop(n)`, we use a count prefix on the `<leader>st` key. The `t` handler checks `vim.v.count1`:

```lua
vim.keymap.set("n", "<leader>st", function()
  local count = vim.v.count1
  local selectors = require("abc_lsp.selectors")
  local bufnr = vim.api.nvim_get_current_buf()
  if count > 1 then
    selectors.apply(bufnr, "selectNthFromTop", { count - 1 })
  else
    selectors.apply(bufnr, "selectTop")
  end
end, { buffer = bufnr, desc = "ABCT: select top (or Nth from top with count)" })
```

For instance, `3<leader>st` means "select the 3rd note from the top" (0-indexed arg = 2).

All other keymaps follow this pattern:

```lua
vim.keymap.set("n", "<leader>sc", function()
  require("abc_lsp.selectors").apply(vim.api.nvim_get_current_buf(), "selectChords")
end, { buffer = bufnr, desc = "ABCT: select chords" })
```

## Visual Highlighting

Each highlighted range uses an extmark with:
- `hl_group = "AbctSelection"` — a subtle background + underline
- `priority = 200` — above default highlights (100) but below search highlights (300)

The `AbctSelection` highlight group defaults to `{ bg = "#3a3a5a", underline = true }` but can be overridden in the user's colorscheme or Neovim config.

## Auto-clearing on Document Edit

Because the AST changes on every edit, the stored `cursor_node_ids` become invalid (the node IDs from the CS tree no longer correspond to the document's current state). We register a `TextChanged` autocmd the first time a selector is successfully applied, and remove it when the state is reset:

```lua
state.autocmd_id = vim.api.nvim_create_autocmd({ "TextChanged", "TextChangedI" }, {
  buffer = bufnr,
  callback = function()
    selectors.reset(bufnr)
  end,
})
```

This autocmd is only active while there is an active selection. When `reset()` is called, it deletes the autocmd and sets `state.autocmd_id = nil`. This avoids unnecessary overhead when no selection is active.

## Statusline Integration

The module exposes `selectors.get_status(bufnr)` which returns a displayable string or nil. Integration with lualine:

```lua
-- Example lualine component:
{
  function()
    local selectors = require("abc_lsp.selectors")
    return selectors.get_status(vim.api.nvim_get_current_buf()) or ""
  end,
  cond = function()
    local selectors = require("abc_lsp.selectors")
    return selectors.get_status(vim.api.nvim_get_current_buf()) ~= nil
  end,
}
```

The status string format: `"ABCT: chords > top (3)"` where:
- `chords > top` is the selector chain (`state.selector_names` with `"select"` prefix stripped and lowercased)
- `(3)` is the number of cursor positions (`#state.cursor_node_ids`)

## To Do

- Create `lua/abc_lsp/selectors.lua` with: module-level namespace, buffer state map, `setup_keymaps`, `apply`, `undo`, `reset`, `highlight`, `get_status`, and `cleanup` functions.
- Define the `AbctSelection` highlight group at module load time.
- Add `setup_keymaps(bufnr)` call to the `on_attach` callback in `server.lua`.
- Add the `selector_reset` and `selector_undo` subcommands to `commands.lua`, and update the `show_help` groups table.
- Add the `BufWipeout` autocmd in `init.lua` to call `selectors.cleanup()`.
- Verify that the LSP server (from `feature/abct-grammar` branch of `abc_parse`) responds correctly to `abct2.applySelector` when called from Neovim.
- Test the full flow: apply selectors via leader keys, verify highlights appear, undo restores previous state, reset clears everything.
- Test edge cases: rapid keypresses while pending, selector that matches nothing, LSP not connected.
- Final verification: the plugin loads without errors and the selectors work end-to-end.
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
