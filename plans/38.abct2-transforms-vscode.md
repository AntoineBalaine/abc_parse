# Plan 38: Integrate ABCt2 Transforms into the VSCode Extension

## Table of Contents

1. [Overview](#overview)
2. [Design Decisions](#design-decisions)
3. [Phase 1: Shared Cursor State Module](#phase-1-shared-cursor-state-module)
4. [Phase 2: Transform Lookup on the Server](#phase-2-transform-lookup-on-the-server)
5. [Phase 3: LSP Protocol - applyTransform Handler](#phase-3-lsp-protocol---applytransform-handler)
6. [Phase 4: Cursor Preservation Strategy](#phase-4-cursor-preservation-strategy)
7. [Phase 5: Extension Transform Commands](#phase-5-extension-transform-commands)
8. [Phase 6: Command Definitions in package.json](#phase-6-command-definitions-in-packagejson)
9. [Phase 7: Remove Old Transform Commands](#phase-7-remove-old-transform-commands)
10. [Phase 8: Vim Extension Integration](#phase-8-vim-extension-integration)
11. [Phase 9: Testing Strategy](#phase-9-testing-strategy)
12. [To Do List](#to-do-list)
13. [Verification](#verification)

---

## Overview

The goal is to expose all ABCt2 transforms as VSCode commands that operate on the current selection state established by selector commands. Because transforms modify the document text, the cursor state must be preserved across document changes so that users can chain multiple transforms on the same selection.

### Transforms to expose

| Transform | Arguments | Description |
|-----------|-----------|-------------|
| `transpose` | `semitones: number` | Transpose selected notes/chords by N semitones |
| `enharmonize` | none | Toggle enharmonic spelling (sharp to flat or vice versa) |
| `setRhythm` | `rational: string` (e.g., "1/4") | Set rhythm of selected elements to a specific value |
| `addToRhythm` | `rational: string` | Add a rational value to the current rhythm |
| `toRest` | none | Convert selected notes/chords to rests |
| `unwrapSingle` | none | Unwrap single-note chords back to notes |
| `remove` | none | Remove selected elements from the score |
| `addVoice` | `voiceId: string`, optional `name`, `clef`, `transpose` | Add a voice definition to the tune header |

---

## Design Decisions

### 1. Selector state is shared with transform commands

The `cursorStateByUri` Map (currently local to `selectorCommands.ts`) will be extracted to a shared module so that both selector and transform commands can read and update cursor state.

### 2. Transforms consume selector state

The workflow is:
1. User invokes selector commands to narrow down to specific notes/chords
2. User invokes a transform command
3. The transform applies to all nodes in the current cursor state
4. The document is updated and cursor state is preserved

### 3. Cursor state is preserved across transforms

The transforms mutate the CSTree in place, so the cursor node IDs remain stable for most transforms. After a transform modifies the document:
- For non-destructive transforms (transpose, enharmonize, setRhythm, addToRhythm, toRest, unwrapSingle, addVoice): the cursor node IDs from the modified tree are used directly
- For the `remove` transform: cursor IDs pointing to deleted nodes are filtered out
- The server re-parses the new text only to compute fresh token positions for `cursorRanges` (visual highlighting)
- The extension updates its cursor state with the post-transform IDs

### 4. Arguments are gathered via VSCode input prompts

For transforms that require arguments (transpose, setRhythm, addToRhythm, addVoice), the extension uses `vscode.window.showInputBox` or `vscode.window.showQuickPick` to prompt the user.

### 5. Document-change event handling

Because the extension's `onDidChangeTextDocument` handler clears cursor state, we need to suppress this clearing when the change comes from a transform command. We use a version-based approach: when a transform is applied, we store the expected post-edit document version. The `onDidChangeTextDocument` handler checks whether the new version matches the expected version and skips clearing if so.

### 6. Minimal diff for TextEdits

To preserve undo history granularity, we adapt the existing character-level LCS diff algorithm from `vscode-extension/src/abct/diffToPatches.ts`. The `diffChars` function computes character-level differences, which we convert to LSP `TextEdit` objects. This reuses proven code and provides accurate minimal diffs.

### 7. Old transform commands are replaced

The existing commands in `extensionCommands.ts` (divideRhythm, multiplyRhythm, transposeUp, transposeDn) that use the older parse library's visitors will be removed. The new abct2-based transforms will replace them entirely. This simplifies the codebase and ensures all transforms follow the same selection-based workflow.

---

## Phase 1: Shared Cursor State Module

### Files to create

`vscode-extension/src/cursorState.ts`

### Implementation

```typescript
// cursorState.ts
import * as vscode from "vscode";

export interface CursorState {
  cursorNodeIds: number[];
  expectedVersion: number | null;  // Version after a transform edit, or null
}

// Map from document URI to cursor state
const stateByUri = new Map<string, CursorState>();

export function getCursorNodeIds(uri: string): number[] {
  return stateByUri.get(uri)?.cursorNodeIds ?? [];
}

export function setCursorNodeIds(uri: string, ids: number[]): void {
  const existing = stateByUri.get(uri);
  if (existing) {
    existing.cursorNodeIds = ids;
  } else {
    stateByUri.set(uri, { cursorNodeIds: ids, expectedVersion: null });
  }
}

export function clearCursorState(uri: string): void {
  stateByUri.delete(uri);
}

export function hasCursorState(uri: string): boolean {
  const state = stateByUri.get(uri);
  return state !== undefined && state.cursorNodeIds.length > 0;
}

// Called before applying a transform edit to record expected post-edit version
// Pass null to clear the expected version (e.g., after a failed edit)
export function setExpectedVersion(uri: string, version: number | null): void {
  const existing = stateByUri.get(uri);
  if (existing) {
    existing.expectedVersion = version;
  } else if (version !== null) {
    stateByUri.set(uri, { cursorNodeIds: [], expectedVersion: version });
  }
}

// Called by onDidChangeTextDocument to check if this change is from a transform
export function shouldSkipClear(uri: string, newVersion: number): boolean {
  const state = stateByUri.get(uri);
  if (state?.expectedVersion === newVersion) {
    state.expectedVersion = null;  // Consume the expected version
    return true;
  }
  return false;
}
```

### Files to modify

`vscode-extension/src/selectorCommands.ts`
- Remove the local `cursorStateByUri` Map
- Import and use functions from `cursorState.ts`
- Update `onDidChangeTextDocument` handler to use `shouldSkipClear(uri, event.document.version)` before clearing

---

## Phase 2: Transform Lookup on the Server

### Files to create

`abc-lsp-server/src/transformLookup.ts`

### Implementation

```typescript
// transformLookup.ts
import { Selection } from "../../abct2/src/selection";
import { ABCContext } from "abc-parser";
import {
  transpose, enharmonize, setRhythm, addToRhythm,
  toRest, unwrapSingle, remove, addVoice, VoiceParams
} from "../../abct2/src/transforms";
import { IRational } from "abc-parser";

export type TransformFn = (
  selection: Selection,
  ctx: ABCContext,
  ...args: any[]
) => Selection;

const TRANSFORM_MAP: Record<string, TransformFn> = {
  transpose: (sel, ctx, semitones: number) => transpose(sel, semitones, ctx),
  enharmonize: (sel, ctx) => enharmonize(sel, ctx),
  setRhythm: (sel, ctx, rational: IRational) => setRhythm(sel, rational, ctx),
  addToRhythm: (sel, ctx, rational: IRational) => addToRhythm(sel, rational, ctx),
  toRest: (sel, ctx) => toRest(sel, ctx),
  unwrapSingle: (sel) => unwrapSingle(sel),
  remove: (sel) => remove(sel),
  addVoice: (sel, ctx, voiceId: string, params: VoiceParams) => addVoice(sel, voiceId, params, ctx),
};

export function lookupTransform(name: string): TransformFn | null {
  return TRANSFORM_MAP[name] ?? null;
}
```

### Imports to add in `abc-lsp-server/src/server.ts`

```typescript
import { lookupTransform } from "./transformLookup";
```

---

## Phase 3: LSP Protocol - applyTransform Handler

### Types

```typescript
interface ApplyTransformParams {
  uri: string;
  transform: string;
  cursorNodeIds: number[];
  args: any[];
}

interface ApplyTransformResult {
  textEdits: TextEdit[];
  cursorNodeIds: number[];
  cursorRanges: Range[];
}
```

### Implementation in `abc-lsp-server/src/server.ts`

The handler:
1. Gets the document and its AST
2. Builds a CSTree from the AST
3. Creates a Selection from cursorNodeIds (preserving multi-element cursors)
4. Looks up and applies the transform function
5. Collects surviving cursor node IDs from the modified tree
6. Serializes the modified tree to text (using `toAst` + `AbcFormatter`)
7. Computes TextEdits using the existing LCS-based diff algorithm
8. Re-parses the new text only to compute accurate cursorRanges for highlighting
9. Returns TextEdits + cursor node IDs + cursorRanges

```typescript
connection.onRequest("abct2.applyTransform", async (params: ApplyTransformParams): Promise<ApplyTransformResult> => {
  const doc = abcServer.abcDocuments.get(params.uri);
  if (!doc || !(doc instanceof AbcDocument) || !doc.AST || !doc.ctx) {
    return { textEdits: [], cursorNodeIds: [], cursorRanges: [] };
  }

  const transformFn = lookupTransform(params.transform);
  if (!transformFn) {
    throw new ResponseError(-1, `Unknown transform: "${params.transform}"`);
  }

  const root = getCsTree(doc.AST);

  // Build selection from cursorNodeIds, preserving multi-element cursors
  const selection: Selection = params.cursorNodeIds.length === 0
    ? createSelection(root)
    : { root, cursors: params.cursorNodeIds.map(id => new Set([id])) };

  // Apply transform (mutates tree in place, returns updated Selection)
  const newSelection = transformFn(selection, doc.ctx, ...params.args);

  // Collect surviving cursor node IDs from the modified tree
  // The transforms mutate in place, so cursor IDs are stable unless nodes were deleted
  const survivingCursorIds = collectSurvivingCursorIds(newSelection);

  // Serialize modified tree to text, passing the original context for formatting
  const newText = serializeCSTree(newSelection.root, doc.ctx);
  const oldText = doc.getText();

  // Compute minimal TextEdits using existing LCS-based diff
  const textEdits = computeTextEditsFromDiff(oldText, newText);

  // Re-parse new text to get accurate token positions for cursor highlighting
  const freshCtx = new ABCContext();
  const freshTokens = Scanner(newText, freshCtx);
  const freshAST = parse(freshTokens, freshCtx);
  const freshRoot = fromAst(freshAST);

  // Map surviving cursor IDs to their positions in the fresh tree
  // Since structure is preserved, we find nodes at the same ordinal positions
  const cursorRanges = computeCursorRangesFromFreshTree(
    survivingCursorIds, newSelection.root, freshRoot
  );

  return { textEdits, cursorNodeIds: survivingCursorIds, cursorRanges };
});
```

### Helper functions to add

`abc-lsp-server/src/cursorPreservation.ts`:

```typescript
import { CSNode, TAGS } from "../../abct2/src/csTree/types";
import { Selection } from "../../abct2/src/selection";
import { Range } from "vscode-languageserver";

// Collects all cursor node IDs that still exist in the tree after a transform
// Handles multi-element cursors by flattening all IDs
export function collectSurvivingCursorIds(selection: Selection): number[] {
  const allIds = new Set<number>();
  collectAllNodeIds(selection.root, allIds);

  const surviving: number[] = [];
  for (const cursor of selection.cursors) {
    for (const id of cursor) {
      if (allIds.has(id)) {
        surviving.push(id);
      }
    }
  }
  return surviving;
}

function collectAllNodeIds(node: CSNode | null, ids: Set<number>): void {
  if (!node) return;
  ids.add(node.id);
  collectAllNodeIds(node.firstChild, ids);
  collectAllNodeIds(node.nextSibling, ids);
}

// Maps cursor IDs from the modified tree to positions in the fresh tree
// Uses ordinal correspondence: the Nth music element in modified = Nth in fresh
export function computeCursorRangesFromFreshTree(
  cursorIds: number[],
  modifiedRoot: CSNode,
  freshRoot: CSNode
): Range[] {
  // Build ordinal map: cursor ID -> ordinal position in modified tree
  const modifiedElements = collectMusicElements(modifiedRoot);
  const idToOrdinal = new Map<number, number>();
  modifiedElements.forEach((node, idx) => idToOrdinal.set(node.id, idx));

  // Get ordinal positions of cursor IDs
  const ordinals = cursorIds
    .map(id => idToOrdinal.get(id))
    .filter((ord): ord is number => ord !== undefined);

  // Find corresponding nodes in fresh tree
  const freshElements = collectMusicElements(freshRoot);
  const ranges: Range[] = [];

  for (const ord of ordinals) {
    if (ord < freshElements.length) {
      const range = computeNodeRange(freshElements[ord]);
      if (range) ranges.push(range);
    }
  }

  return ranges;
}

function collectMusicElements(root: CSNode): CSNode[] {
  const elements: CSNode[] = [];
  function walk(node: CSNode | null): void {
    if (!node) return;
    if (node.tag === TAGS.Note || node.tag === TAGS.Chord || node.tag === TAGS.Rest) {
      elements.push(node);
    }
    walk(node.firstChild);
    walk(node.nextSibling);
  }
  walk(root);
  return elements;
}
```

Note: The `computeNodeRange` function needs to be exported from `selectionRangeResolver.ts`. Currently it is a local function. As part of Phase 3, we need to:
1. Export `computeNodeRange` from `abc-lsp-server/src/selectionRangeResolver.ts`
2. Import it in `cursorPreservation.ts`:

```typescript
import { computeNodeRange } from "./selectionRangeResolver";
```

`abc-lsp-server/src/csTreeSerializer.ts`:

```typescript
import { CSNode } from "../../abct2/src/csTree/types";
import { toAst } from "../../abct2/src/csTree/toAst";
import { AbcFormatter, ABCContext, Expr } from "abc-parser";

// Serializes CSTree to text, using the provided context for formatting preferences
export function serializeCSTree(root: CSNode, ctx: ABCContext): string {
  const ast = toAst(root);
  return new AbcFormatter(ctx).stringify(ast as Expr);
}
```

`abc-lsp-server/src/textEditFromDiff.ts`:

Note: The `diffChars` function currently lives in `vscode-extension/src/abct/diffToPatches.ts`. Since the server should not depend on the extension, we need to either:
1. Move `diffToPatches.ts` to a shared package (e.g., `abct2/src/utils/`), or
2. Copy the diff implementation into the server package

For this plan, we will move `diffToPatches.ts` to `abct2/src/utils/diffToPatches.ts` and update both the extension and server to import from there.

```typescript
import { TextEdit, Range } from "vscode-languageserver";
import { diffChars, Change } from "../../abct2/src/utils/diffToPatches";

// Converts character-level diff to LSP TextEdits
// Adapts the existing LCS-based diffChars function
export function computeTextEditsFromDiff(oldText: string, newText: string): TextEdit[] {
  const changes = diffChars(oldText, newText);
  return changes.map(change => changeToTextEdit(change));
}

function changeToTextEdit(change: Change): TextEdit {
  // diffChars uses 1-based positions, LSP uses 0-based
  const start = {
    line: change.originalStart.line - 1,
    character: change.originalStart.column - 1
  };
  // originalEnd is inclusive (points to last char), LSP end is exclusive (points after last char)
  // For a single character at column 5, diffChars gives column 5, LSP needs column 6
  const end = {
    line: change.originalEnd.line - 1,
    character: change.originalEnd.column  // Already correct: diffChars column + 0 = LSP exclusive end
  };

  if (change.type === "insert") {
    return TextEdit.insert(start, change.newContent);
  }

  const range: Range = { start, end };
  if (change.type === "delete") {
    return TextEdit.del(range);
  }

  // replace
  return TextEdit.replace(range, change.newContent);
}
```

Additional step for Phase 3: Move `vscode-extension/src/abct/diffToPatches.ts` to `abct2/src/utils/diffToPatches.ts` and update the import in `vscode-extension/src/abct/` to re-export from the new location.

---

## Phase 4: Cursor Preservation Strategy

The cursor preservation approach uses two complementary techniques:

### 1. ID-based preservation (for cursor state)

Since transforms mutate the CSTree in place, the cursor node IDs remain stable. After a transform:
- We collect all node IDs that still exist in the modified tree
- Cursor IDs pointing to deleted nodes (from `remove`) are filtered out
- The surviving IDs are returned to the extension for state management

### 2. Ordinal-based mapping (for visual ranges only)

To compute accurate text ranges for editor highlighting, we need positions from the freshly-parsed tree:
- We build an ordinal map: cursor ID -> position in DFS traversal of music elements
- After re-parsing, we find nodes at the same ordinal positions in the fresh tree
- We compute ranges from those fresh nodes (which have correct token positions)

### Edge cases

| Transform | ID Preservation | Range Computation |
|-----------|-----------------|-------------------|
| `transpose`, `enharmonize`, `setRhythm`, `addToRhythm` | IDs stable | Ordinals unchanged |
| `toRest` | ID stable (same node, tag changed) | Ordinal unchanged (Rest replaces Note) |
| `unwrapSingle` | Original Chord ID removed, new Note IDs | Ordinals may shift slightly |
| `remove` | IDs removed from tree | Corresponding ordinals skipped |
| `addVoice` | Cursor IDs unaffected | Ordinals unchanged |

### Error handling

If a transform fails partway (throws an exception):
- The CSTree may be partially modified
- The extension catches the error and displays a message
- Cursor state is NOT updated (preserves pre-transform state)
- The document is NOT modified (TextEdits are not applied)

---

## Phase 5: Extension Transform Commands

### Files to create

`vscode-extension/src/transformCommands.ts`

### Implementation

```typescript
import * as vscode from "vscode";
import { LanguageClient } from "vscode-languageclient/node";
import {
  getCursorNodeIds, setCursorNodeIds, setExpectedVersion
} from "./cursorState";

interface ApplyTransformResult {
  textEdits: Array<{ range: Range; newText: string }>;
  cursorNodeIds: number[];
  cursorRanges: Array<{ start: Position; end: Position }>;
}

export function registerTransformCommands(
  context: vscode.ExtensionContext,
  client: LanguageClient,
  statusBarItem: vscode.StatusBarItem
): void {

  // Transforms without arguments
  const simpleTransforms: Array<[string, string]> = [
    ["abc.enharmonize", "enharmonize"],
    ["abc.toRest", "toRest"],
    ["abc.unwrapSingle", "unwrapSingle"],
    ["abc.remove", "remove"],
  ];

  for (const [commandId, transformName] of simpleTransforms) {
    context.subscriptions.push(
      vscode.commands.registerCommand(commandId, () =>
        applyTransform(client, transformName, [], statusBarItem)
      )
    );
  }

  // transpose: prompt for semitones
  context.subscriptions.push(
    vscode.commands.registerCommand("abc.transpose", async () => {
      const input = await vscode.window.showInputBox({
        prompt: "Semitones to transpose (negative = down)",
        validateInput: v => isNaN(Number(v)) ? "Must be a number" : null,
      });
      if (input === undefined) return;
      await applyTransform(client, "transpose", [Number(input)], statusBarItem);
    })
  );

  // setRhythm: prompt for rational value
  context.subscriptions.push(
    vscode.commands.registerCommand("abc.setRhythm", async () => {
      const input = await vscode.window.showInputBox({
        prompt: "Rhythm value (e.g., 1/4, 1/2, 3/8)",
        placeHolder: "1/4",
      });
      if (input === undefined) return;
      const rational = parseRational(input);
      if (!rational) {
        vscode.window.showErrorMessage("Invalid rational format");
        return;
      }
      await applyTransform(client, "setRhythm", [rational], statusBarItem);
    })
  );

  // addToRhythm: prompt for rational value
  context.subscriptions.push(
    vscode.commands.registerCommand("abc.addToRhythm", async () => {
      const input = await vscode.window.showInputBox({
        prompt: "Value to add to rhythm (e.g., 1/8, -1/4)",
        placeHolder: "1/8",
      });
      if (input === undefined) return;
      const rational = parseRational(input);
      if (!rational) {
        vscode.window.showErrorMessage("Invalid rational format");
        return;
      }
      await applyTransform(client, "addToRhythm", [rational], statusBarItem);
    })
  );

  // addVoice: prompt for voice ID and optional params
  context.subscriptions.push(
    vscode.commands.registerCommand("abc.addVoice", async () => {
      const voiceId = await vscode.window.showInputBox({
        prompt: "Voice ID (e.g., V1, T, S)",
      });
      if (!voiceId) return;

      const name = await vscode.window.showInputBox({
        prompt: "Voice name (optional)",
      });

      await applyTransform(client, "addVoice", [
        voiceId,
        { name: name || undefined }
      ], statusBarItem);
    })
  );
}

async function applyTransform(
  client: LanguageClient,
  transform: string,
  args: any[],
  statusBarItem: vscode.StatusBarItem
): Promise<void> {
  const editor = vscode.window.activeTextEditor;
  if (!editor || editor.document.languageId !== "abc") return;

  const uri = editor.document.uri.toString();
  const cursorNodeIds = getCursorNodeIds(uri);

  if (cursorNodeIds.length === 0) {
    vscode.window.showInformationMessage("No selection. Use selector commands first.");
    return;
  }

  try {
    const result = await client.sendRequest<ApplyTransformResult>(
      "abct2.applyTransform",
      { uri, transform, cursorNodeIds, args }
    );

    // Record expected version BEFORE applying edit to prevent state clearing
    const currentVersion = editor.document.version;
    setExpectedVersion(uri, currentVersion + 1);

    // Apply text edits
    const workspaceEdit = new vscode.WorkspaceEdit();
    for (const edit of result.textEdits) {
      const range = new vscode.Range(
        edit.range.start.line, edit.range.start.character,
        edit.range.end.line, edit.range.end.character
      );
      workspaceEdit.replace(editor.document.uri, range, edit.newText);
    }

    const editSuccess = await vscode.workspace.applyEdit(workspaceEdit);
    if (!editSuccess) {
      // Edit failed, clear the expected version to avoid stale state
      setExpectedVersion(uri, null);
      vscode.window.showErrorMessage("Failed to apply transform edits");
      return;
    }

    // Update cursor state with surviving IDs
    setCursorNodeIds(uri, result.cursorNodeIds);

    // Update editor selections
    if (result.cursorRanges.length > 0) {
      editor.selections = result.cursorRanges.map(r => new vscode.Selection(
        new vscode.Position(r.start.line, r.start.character),
        new vscode.Position(r.end.line, r.end.character)
      ));
      updateStatusBar(statusBarItem, result.cursorNodeIds.length);
    } else {
      // After remove or when no cursors remain, reset to single cursor
      statusBarItem.hide();
    }

  } catch (error) {
    // Clear expected version on error to avoid stale state
    setExpectedVersion(uri, null);
    vscode.window.showErrorMessage(`Transform failed: ${error}`);
  }
}

function parseRational(input: string): { numerator: number; denominator: number } | null {
  const match = input.match(/^(-?\d+)(?:\/(\d+))?$/);
  if (!match) return null;
  const numerator = parseInt(match[1], 10);
  const denominator = match[2] ? parseInt(match[2], 10) : 1;
  if (denominator === 0) return null;
  return { numerator, denominator };
}

function updateStatusBar(item: vscode.StatusBarItem, count: number): void {
  if (count > 0) {
    item.text = `$(selection) ${count} cursor${count > 1 ? "s" : ""}`;
    item.show();
  } else {
    item.hide();
  }
}
```

### Files to modify

`vscode-extension/src/extension.ts`
- Create the statusBarItem in `activate()` before calling registration functions
- Import and call `registerTransformCommands` AFTER `client.start()` completes (same as selectorCommands)
- Pass the statusBarItem to both `registerSelectorCommands` and `registerTransformCommands`

The activation sequence should be:
```typescript
export async function activate(context: ExtensionContext) {
  // ... setup code ...

  // Create shared statusBarItem
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
  statusBarItem.command = "abc.resetSelection";
  context.subscriptions.push(statusBarItem);

  // Register commands that don't need the client
  registerCommands(context, client);  // Only MIDI commands now
  registerRendererCommands(context);
  registerPlaybackCommands(context);
  registerAbctCommands(context, client);

  // Start the client
  await client.start();

  // Register commands that need the client to be ready
  registerSelectorCommands(context, client, statusBarItem);
  registerTransformCommands(context, client, statusBarItem);
}
```

Update `registerSelectorCommands` signature to accept statusBarItem as a parameter instead of creating it internally.

---

## Phase 6: Command Definitions in package.json

Add to `vscode-extension/package.json` under `contributes.commands`:

```json
{
  "command": "abc.transpose",
  "title": "ABC: Transpose Selection",
  "category": "ABC"
},
{
  "command": "abc.enharmonize",
  "title": "ABC: Enharmonize Selection",
  "category": "ABC"
},
{
  "command": "abc.setRhythm",
  "title": "ABC: Set Rhythm",
  "category": "ABC"
},
{
  "command": "abc.addToRhythm",
  "title": "ABC: Add to Rhythm",
  "category": "ABC"
},
{
  "command": "abc.toRest",
  "title": "ABC: Convert to Rest",
  "category": "ABC"
},
{
  "command": "abc.unwrapSingle",
  "title": "ABC: Unwrap Single-Note Chord",
  "category": "ABC"
},
{
  "command": "abc.remove",
  "title": "ABC: Remove Selection",
  "category": "ABC"
},
{
  "command": "abc.addVoice",
  "title": "ABC: Add Voice",
  "category": "ABC"
},
{
  "command": "abc.transposeOctaveUp",
  "title": "ABC: Transpose Octave Up",
  "category": "ABC"
},
{
  "command": "abc.transposeOctaveDown",
  "title": "ABC: Transpose Octave Down",
  "category": "ABC"
},
{
  "command": "abc.transposeHalfStepUp",
  "title": "ABC: Transpose Half Step Up",
  "category": "ABC"
},
{
  "command": "abc.transposeHalfStepDown",
  "title": "ABC: Transpose Half Step Down",
  "category": "ABC"
}
```

These quick-access transpose commands are registered in `transformCommands.ts`:

```typescript
// Quick-access transpose commands with preset values
const transposePresets: Array<[string, number]> = [
  ["abc.transposeOctaveUp", 12],
  ["abc.transposeOctaveDown", -12],
  ["abc.transposeHalfStepUp", 1],
  ["abc.transposeHalfStepDown", -1],
];

for (const [commandId, semitones] of transposePresets) {
  context.subscriptions.push(
    vscode.commands.registerCommand(commandId, () =>
      applyTransform(client, "transpose", [semitones], statusBarItem)
    )
  );
}
```

Add to `contributes.menus.commandPalette`:

```json
{ "command": "abc.transpose", "when": "editorLangId == abc" },
{ "command": "abc.enharmonize", "when": "editorLangId == abc" },
{ "command": "abc.setRhythm", "when": "editorLangId == abc" },
{ "command": "abc.addToRhythm", "when": "editorLangId == abc" },
{ "command": "abc.toRest", "when": "editorLangId == abc" },
{ "command": "abc.unwrapSingle", "when": "editorLangId == abc" },
{ "command": "abc.remove", "when": "editorLangId == abc" },
{ "command": "abc.addVoice", "when": "editorLangId == abc" },
{ "command": "abc.transposeOctaveUp", "when": "editorLangId == abc" },
{ "command": "abc.transposeOctaveDown", "when": "editorLangId == abc" },
{ "command": "abc.transposeHalfStepUp", "when": "editorLangId == abc" },
{ "command": "abc.transposeHalfStepDown", "when": "editorLangId == abc" }
```

---

## Phase 7: Remove Old Transform Commands

### Files to modify

`vscode-extension/src/extensionCommands.ts`
- Remove `registerTransformCommands` function
- Remove the command registrations for `abc.divideRhythm`, `abc.multiplyRhythm`, `abc.transposeUp`, `abc.transposeDn`
- Keep `registerMidiInputs` function

`abc-lsp-server/src/server.ts`
- Remove the request handlers for `divideRhythm`, `multiplyRhythm`, `transposeUp`, `transposeDn`
- Remove imports for `AbcTransformParams` if no longer needed

`abc-lsp-server/src/AbcLspServer.ts`
- Remove `onRhythmTransform` method
- Remove `onTranspose` method

`vscode-extension/package.json`
- Remove command definitions for `abc.divideRhythm`, `abc.multiplyRhythm`, `abc.transposeUp`, `abc.transposeDn`
- Remove any keybindings associated with these commands

### New equivalent commands

The old commands are replaced by the new abct2-based transforms:

| Old Command | New Equivalent |
|-------------|----------------|
| `abc.divideRhythm` | Use `abc.setRhythm` with half the current value |
| `abc.multiplyRhythm` | Use `abc.setRhythm` with double the current value |
| `abc.transposeUp` | `abc.transpose` with semitones=12 |
| `abc.transposeDn` | `abc.transpose` with semitones=-12 |

For convenience, we can add predefined quick-access commands:

```json
{ "command": "abc.transposeOctaveUp", "title": "ABC: Transpose Octave Up" },
{ "command": "abc.transposeOctaveDown", "title": "ABC: Transpose Octave Down" },
{ "command": "abc.transposeHalfStepUp", "title": "ABC: Transpose Half Step Up" },
{ "command": "abc.transposeHalfStepDown", "title": "ABC: Transpose Half Step Down" }
```

These simply call `abc.transpose` with preset values (12, -12, 1, -1).

---

## Phase 8: Vim Extension Integration

Since the user uses the Vim extension in VSCode, we should document how to integrate transform commands with Vim-style keybindings rather than adding standalone shortcuts that may conflict.

### Recommended Vim keybindings

Add to VSCode `settings.json` under `vim.normalModeKeyBindings`:

```json
{
  "vim.normalModeKeyBindings": [
    // Transpose
    { "before": ["<leader>", "t", "u"], "commands": ["abc.transposeHalfStepUp"] },
    { "before": ["<leader>", "t", "d"], "commands": ["abc.transposeHalfStepDown"] },
    { "before": ["<leader>", "t", "U"], "commands": ["abc.transposeOctaveUp"] },
    { "before": ["<leader>", "t", "D"], "commands": ["abc.transposeOctaveDown"] },
    { "before": ["<leader>", "t", "t"], "commands": ["abc.transpose"] },

    // Other transforms
    { "before": ["<leader>", "t", "e"], "commands": ["abc.enharmonize"] },
    { "before": ["<leader>", "t", "r"], "commands": ["abc.toRest"] },
    { "before": ["<leader>", "t", "x"], "commands": ["abc.remove"] },
    { "before": ["<leader>", "t", "s"], "commands": ["abc.setRhythm"] },
    { "before": ["<leader>", "t", "a"], "commands": ["abc.addToRhythm"] },
    { "before": ["<leader>", "t", "w"], "commands": ["abc.unwrapSingle"] },
    { "before": ["<leader>", "t", "v"], "commands": ["abc.addVoice"] },

    // Selection commands (for completeness)
    { "before": ["<leader>", "s", "n"], "commands": ["abc.selectNotes"] },
    { "before": ["<leader>", "s", "c"], "commands": ["abc.selectChords"] },
    { "before": ["<leader>", "s", "r"], "commands": ["abc.selectRests"] },
    { "before": ["<leader>", "s", "t"], "commands": ["abc.selectTop"] },
    { "before": ["<leader>", "s", "b"], "commands": ["abc.selectBottom"] },
    { "before": ["<leader>", "s", "R"], "commands": ["abc.resetSelection"] }
  ]
}
```

The mnemonic is:
- `<leader>t` prefix for transforms
- `<leader>s` prefix for selections

This keeps all ABC-related commands under a consistent namespace and avoids conflicts with core Vim bindings.

---

## Phase 9: Testing Strategy

Because the goal is to minimize manual testing, we leverage three levels of automated tests:
1. Unit tests for isolated helper functions
2. Integration tests that simulate the full LSP workflow without VSCode
3. Property-based tests that verify invariants across many inputs

### Test file locations

| Test file | Location | Purpose |
|-----------|----------|---------|
| `cursorPreservation.spec.ts` | `abc-lsp-server/src/` | Unit tests for cursor ID preservation helpers |
| `textEditFromDiff.spec.ts` | `abc-lsp-server/src/` | Unit tests for LCS-based diff to TextEdit conversion |
| `transformIntegration.spec.ts` | `abc-lsp-server/src/` | End-to-end tests simulating client-server flow |
| `transformIntegration.pbt.spec.ts` | `abc-lsp-server/src/` | Property-based tests for transform invariants |

### Shared test helpers

Because the `abct2/tests/helpers.ts` file already contains useful utilities, we will import them directly:

```typescript
import {
  toCSTreeWithContext,
  formatSelection,
  findByTag,
  genAbcTune,
  genAbcWithChords,
  genRational
} from "../../abct2/tests/helpers";
```

We also reuse the selector integration test's `applySelector` pattern (from `selectorIntegration.spec.ts`) for building test selections.

### Unit tests for cursor preservation

Create `abc-lsp-server/src/cursorPreservation.spec.ts`:

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { collectSurvivingCursorIds, computeCursorRangesFromFreshTree } from "./cursorPreservation";
import { toCSTreeWithContext, findByTag, formatSelection } from "../../abct2/tests/helpers";
import { TAGS } from "../../abct2/src/csTree/types";
import { Selection } from "../../abct2/src/selection";
import { transpose } from "../../abct2/src/transforms/transpose";
import { remove } from "../../abct2/src/transforms/remove";
import { toRest } from "../../abct2/src/transforms/toRest";
import { fromAst } from "../../abct2/src/csTree/fromAst";
import { Scanner, parse, ABCContext } from "abc-parser";

describe("collectSurvivingCursorIds", () => {
  it("returns all cursor IDs after transpose (non-destructive)", () => {
    const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC D E|\n");
    const notes = findByTag(root, TAGS.Note);
    const cursorIds = notes.map(n => n.id);
    const sel: Selection = { root, cursors: cursorIds.map(id => new Set([id])) };

    transpose(sel, 2, ctx);
    const surviving = collectSurvivingCursorIds(sel);

    expect(surviving).to.have.members(cursorIds);
  });

  it("filters out deleted node IDs after remove transform", () => {
    const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC D E|\n");
    const notes = findByTag(root, TAGS.Note);
    const middleNoteId = notes[1].id;
    const sel: Selection = { root, cursors: [new Set([middleNoteId])] };

    remove(sel);
    const surviving = collectSurvivingCursorIds(sel);

    expect(surviving).to.not.include(middleNoteId);
    expect(surviving).to.be.empty;
  });

  it("handles multi-element cursors (from fanOut)", () => {
    const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC D E|\n");
    const notes = findByTag(root, TAGS.Note);
    // Simulate a fanOut cursor: one cursor containing all three note IDs
    const multiElementCursor = new Set(notes.map(n => n.id));
    const sel: Selection = { root, cursors: [multiElementCursor] };

    transpose(sel, 2, ctx);
    const surviving = collectSurvivingCursorIds(sel);

    expect(surviving.length).to.equal(3);
  });

  it("keeps cursor ID after toRest (node mutated but not deleted)", () => {
    const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC|\n");
    const notes = findByTag(root, TAGS.Note);
    const noteId = notes[0].id;
    const sel: Selection = { root, cursors: [new Set([noteId])] };

    toRest(sel, ctx);
    const surviving = collectSurvivingCursorIds(sel);

    // The node ID should still exist (the node was converted, not deleted)
    expect(surviving).to.include(noteId);
  });
});

describe("computeCursorRangesFromFreshTree", () => {
  it("maps cursor IDs to correct positions in fresh tree", () => {
    const source = "X:1\nK:C\nC D E|\n";
    const { root: modifiedRoot, ctx } = toCSTreeWithContext(source);
    const notes = findByTag(modifiedRoot, TAGS.Note);
    const cursorIds = [notes[1].id]; // Select middle note 'D'

    // Transpose to get modified tree
    const sel: Selection = { root: modifiedRoot, cursors: cursorIds.map(id => new Set([id])) };
    transpose(sel, 2, ctx);

    // Re-parse the modified text to get fresh tree
    const modifiedText = formatSelection(sel);
    const freshCtx = new ABCContext();
    const freshTokens = Scanner(modifiedText, freshCtx);
    const freshAST = parse(freshTokens, freshCtx);
    const freshRoot = fromAst(freshAST);

    const ranges = computeCursorRangesFromFreshTree(cursorIds, modifiedRoot, freshRoot);

    expect(ranges).to.have.length(1);
    // The second note should be on line 2 (0-indexed), at the expected character position
    expect(ranges[0].start.line).to.equal(2);
  });

  it("returns empty ranges for stale cursor IDs (not found in tree)", () => {
    const { root: modifiedRoot, ctx } = toCSTreeWithContext("X:1\nK:C\nC|\n");
    const staleIds = [999999]; // Non-existent ID

    const freshCtx = new ABCContext();
    const freshTokens = Scanner("X:1\nK:C\nC|\n", freshCtx);
    const freshAST = parse(freshTokens, freshCtx);
    const freshRoot = fromAst(freshAST);

    const ranges = computeCursorRangesFromFreshTree(staleIds, modifiedRoot, freshRoot);

    expect(ranges).to.be.empty;
  });
});
```

### Unit tests for TextEdit computation

Create `abc-lsp-server/src/textEditFromDiff.spec.ts`:

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { computeTextEditsFromDiff } from "./textEditFromDiff";

describe("computeTextEditsFromDiff", () => {
  it("returns empty array for identical strings", () => {
    const edits = computeTextEditsFromDiff("X:1\nK:C\nCDE|", "X:1\nK:C\nCDE|");
    expect(edits).to.deep.equal([]);
  });

  it("computes insert edit correctly (single character)", () => {
    const edits = computeTextEditsFromDiff("AC", "ABC");
    expect(edits.length).to.equal(1);
    expect(edits[0].newText).to.equal("B");
    // Position after 'A' (0-indexed: line 0, character 1)
    expect(edits[0].range.start.line).to.equal(0);
    expect(edits[0].range.start.character).to.equal(1);
  });

  it("computes delete edit correctly (single character)", () => {
    const edits = computeTextEditsFromDiff("ABC", "AC");
    expect(edits.length).to.equal(1);
    expect(edits[0].newText).to.equal("");
    expect(edits[0].range.start.character).to.equal(1);
    expect(edits[0].range.end.character).to.equal(2);
  });

  it("computes replace edit correctly", () => {
    const edits = computeTextEditsFromDiff("ABC", "AXC");
    expect(edits.length).to.equal(1);
    expect(edits[0].newText).to.equal("X");
    expect(edits[0].range.start.character).to.equal(1);
  });

  it("handles multi-line changes", () => {
    const edits = computeTextEditsFromDiff("A\nB\nC", "A\nX\nC");
    expect(edits.length).to.equal(1);
    expect(edits[0].range.start.line).to.equal(1);
    expect(edits[0].newText).to.equal("X");
  });

  it("handles ABC transposition (C to D)", () => {
    const edits = computeTextEditsFromDiff("X:1\nK:C\nCDE|", "X:1\nK:C\nDEF|");
    // Should produce minimal edits (ideally 3 single-char replacements or one range)
    expect(edits.length).to.be.greaterThan(0);
  });

  it("handles note with rhythm change", () => {
    const edits = computeTextEditsFromDiff("X:1\nK:C\nC2|\n", "X:1\nK:C\nC3/4|\n");
    expect(edits.length).to.be.greaterThan(0);
  });
});
```

### Integration tests for the full workflow

Create `abc-lsp-server/src/transformIntegration.spec.ts`:

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { toCSTreeWithContext, findByTag, formatSelection } from "../../abct2/tests/helpers";
import { TAGS } from "../../abct2/src/csTree/types";
import { Selection } from "../../abct2/src/selection";
import { lookupTransform } from "./transformLookup";
import { collectSurvivingCursorIds, computeCursorRangesFromFreshTree } from "./cursorPreservation";
import { serializeCSTree } from "./csTreeSerializer";
import { computeTextEditsFromDiff } from "./textEditFromDiff";
import { fromAst } from "../../abct2/src/csTree/fromAst";
import { Scanner, parse, ABCContext } from "abc-parser";
import { createRational } from "abc-parser";

// Simulates the full applyTransform flow without the LSP layer
function simulateApplyTransform(
  source: string,
  cursorNodeIds: number[],
  transformName: string,
  args: any[]
): { newText: string; survivingIds: number[]; rangeCount: number } {
  const { root, ctx } = toCSTreeWithContext(source);

  const selection: Selection = cursorNodeIds.length === 0
    ? { root, cursors: [new Set([root.id])] }
    : { root, cursors: cursorNodeIds.map(id => new Set([id])) };

  const transformFn = lookupTransform(transformName);
  if (!transformFn) throw new Error(`Unknown transform: ${transformName}`);

  const newSelection = transformFn(selection, ctx, ...args);
  const survivingIds = collectSurvivingCursorIds(newSelection);
  const newText = serializeCSTree(newSelection.root, ctx);

  // Re-parse for range computation
  const freshCtx = new ABCContext();
  const freshTokens = Scanner(newText, freshCtx);
  const freshAST = parse(freshTokens, freshCtx);
  const freshRoot = fromAst(freshAST);
  const ranges = computeCursorRangesFromFreshTree(survivingIds, newSelection.root, freshRoot);

  return { newText, survivingIds, rangeCount: ranges.length };
}

describe("Transform integration (simulated LSP flow)", () => {
  describe("transpose", () => {
    it("transposes all notes and preserves cursor state", () => {
      const source = "X:1\nK:C\nCDE|\n";
      const { root, ctx } = toCSTreeWithContext(source);
      const notes = findByTag(root, TAGS.Note);
      const cursorIds = notes.map(n => n.id);

      const result = simulateApplyTransform(source, cursorIds, "transpose", [2]);

      expect(result.newText).to.contain("DEF");
      expect(result.survivingIds.length).to.equal(3);
      expect(result.rangeCount).to.equal(3);
    });

    it("chained transpose: +2 then +2 produces +4 semitones total", () => {
      const source = "X:1\nK:C\nC|\n";
      const { root, ctx } = toCSTreeWithContext(source);
      const notes = findByTag(root, TAGS.Note);
      const cursorIds = notes.map(n => n.id);

      // First transpose
      const result1 = simulateApplyTransform(source, cursorIds, "transpose", [2]);
      expect(result1.newText).to.contain("D");

      // We need to get the fresh IDs from the modified tree
      const { root: root2, ctx: ctx2 } = toCSTreeWithContext(result1.newText);
      const notes2 = findByTag(root2, TAGS.Note);
      const cursorIds2 = notes2.map(n => n.id);

      // Second transpose
      const result2 = simulateApplyTransform(result1.newText, cursorIds2, "transpose", [2]);
      expect(result2.newText).to.contain("E");
    });
  });

  describe("enharmonize", () => {
    it("toggles sharp to flat", () => {
      const source = "X:1\nK:C\n^C|\n";
      const { root } = toCSTreeWithContext(source);
      const notes = findByTag(root, TAGS.Note);
      const cursorIds = notes.map(n => n.id);

      const result = simulateApplyTransform(source, cursorIds, "enharmonize", []);

      expect(result.newText).to.contain("_D");
      expect(result.survivingIds.length).to.equal(1);
    });
  });

  describe("setRhythm", () => {
    it("sets rhythm on note", () => {
      const source = "X:1\nK:C\nC|\n";
      const { root } = toCSTreeWithContext(source);
      const notes = findByTag(root, TAGS.Note);
      const cursorIds = notes.map(n => n.id);

      const result = simulateApplyTransform(source, cursorIds, "setRhythm", [createRational(3, 4)]);

      expect(result.newText).to.contain("C3/4");
    });

    it("sets rhythm on chord", () => {
      const source = "X:1\nK:C\n[CEG]|\n";
      const { root } = toCSTreeWithContext(source);
      const chords = findByTag(root, TAGS.Chord);
      const cursorIds = chords.map(n => n.id);

      const result = simulateApplyTransform(source, cursorIds, "setRhythm", [createRational(2, 1)]);

      expect(result.newText).to.contain("[CEG]2");
    });
  });

  describe("toRest", () => {
    it("converts note to rest", () => {
      const source = "X:1\nK:C\nC2|\n";
      const { root } = toCSTreeWithContext(source);
      const notes = findByTag(root, TAGS.Note);
      const cursorIds = notes.map(n => n.id);

      const result = simulateApplyTransform(source, cursorIds, "toRest", []);

      expect(result.newText).to.contain("z2");
      // The cursor ID should still be valid (pointing to the now-rest)
      expect(result.survivingIds.length).to.equal(1);
    });
  });

  describe("remove", () => {
    it("removes selected notes and empties cursor state", () => {
      const source = "X:1\nK:C\nC D E|\n";
      const { root } = toCSTreeWithContext(source);
      const notes = findByTag(root, TAGS.Note);
      const middleNoteId = notes[1].id;

      const result = simulateApplyTransform(source, [middleNoteId], "remove", []);

      expect(result.newText).to.not.contain("D");
      expect(result.survivingIds).to.be.empty;
    });
  });

  describe("unwrapSingle", () => {
    it("unwraps single-note chord to note", () => {
      const source = "X:1\nK:C\n[C]|\n";
      const { root } = toCSTreeWithContext(source);
      const chords = findByTag(root, TAGS.Chord);
      const cursorIds = chords.map(n => n.id);

      const result = simulateApplyTransform(source, cursorIds, "unwrapSingle", []);

      expect(result.newText).to.not.contain("[");
      expect(result.newText).to.contain("C");
    });
  });

  describe("error handling", () => {
    it("unknown transform name throws error", () => {
      expect(() => simulateApplyTransform("X:1\nK:C\nC|\n", [], "nonExistent", []))
        .to.throw("Unknown transform");
    });

    it("empty cursor list uses root selection", () => {
      // With empty cursorNodeIds, the transform applies to root
      // This should not throw
      const result = simulateApplyTransform("X:1\nK:C\nC|\n", [], "transpose", [0]);
      expect(result.newText).to.include("C");
    });
  });
});
```

### Property-based tests

Create `abc-lsp-server/src/transformIntegration.pbt.spec.ts`:

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import * as fc from "fast-check";
import {
  toCSTreeWithContext,
  findByTag,
  formatSelection,
  genAbcTune,
  genAbcWithChords,
  genRational
} from "../../abct2/tests/helpers";
import { TAGS } from "../../abct2/src/csTree/types";
import { Selection } from "../../abct2/src/selection";
import { transpose } from "../../abct2/src/transforms/transpose";
import { setRhythm } from "../../abct2/src/transforms/setRhythm";
import { enharmonize } from "../../abct2/src/transforms/enharmonize";
import { toRest } from "../../abct2/src/transforms/toRest";
import { collectSurvivingCursorIds } from "./cursorPreservation";
import { serializeCSTree } from "./csTreeSerializer";
import { Scanner, parse, ABCContext } from "abc-parser";

describe("Transform properties", () => {
  describe("transpose", () => {
    it("property: transpose(n) followed by transpose(-n) restores original", () => {
      fc.assert(
        fc.property(
          genAbcTune,
          fc.integer({ min: -12, max: 12 }),
          (source, semitones) => {
            const { root: root1, ctx: ctx1 } = toCSTreeWithContext(source);
            const notes1 = findByTag(root1, TAGS.Note);
            if (notes1.length === 0) return true;

            const originalText = formatSelection({ root: root1, cursors: [] });
            const ids = notes1.map(n => n.id);
            const sel: Selection = { root: root1, cursors: ids.map(id => new Set([id])) };

            // Transpose up
            transpose(sel, semitones, ctx1);
            // Transpose back down
            transpose(sel, -semitones, ctx1);

            const finalText = formatSelection(sel);
            return finalText === originalText;
          }
        ),
        { numRuns: 500 }
      );
    });

    it("property: transpose(0) is identity", () => {
      fc.assert(
        fc.property(genAbcTune, (source) => {
          const { root, ctx } = toCSTreeWithContext(source);
          const notes = findByTag(root, TAGS.Note);
          if (notes.length === 0) return true;

          const originalText = formatSelection({ root, cursors: [] });
          const ids = notes.map(n => n.id);
          const sel: Selection = { root, cursors: ids.map(id => new Set([id])) };

          transpose(sel, 0, ctx);

          const finalText = formatSelection(sel);
          return finalText === originalText;
        }),
        { numRuns: 500 }
      );
    });
  });

  describe("cursor preservation", () => {
    it("property: non-destructive transforms preserve all cursor IDs", () => {
      fc.assert(
        fc.property(
          genAbcTune,
          fc.integer({ min: -12, max: 12 }),
          (source, semitones) => {
            const { root, ctx } = toCSTreeWithContext(source);
            const notes = findByTag(root, TAGS.Note);
            if (notes.length === 0) return true;

            const ids = notes.map(n => n.id);
            const sel: Selection = { root, cursors: ids.map(id => new Set([id])) };

            transpose(sel, semitones, ctx);
            const surviving = collectSurvivingCursorIds(sel);

            // All original IDs should survive
            return ids.every(id => surviving.includes(id));
          }
        ),
        { numRuns: 500 }
      );
    });
  });

  describe("serialization roundtrip", () => {
    it("property: transform -> serialize -> parse produces valid ABC", () => {
      fc.assert(
        fc.property(
          genAbcTune,
          fc.integer({ min: -6, max: 6 }),
          (source, semitones) => {
            const { root, ctx } = toCSTreeWithContext(source);
            const notes = findByTag(root, TAGS.Note);
            if (notes.length === 0) return true;

            const ids = notes.map(n => n.id);
            const sel: Selection = { root, cursors: ids.map(id => new Set([id])) };

            transpose(sel, semitones, ctx);
            const newText = serializeCSTree(sel.root, ctx);

            // Attempt to parse the result - should not throw
            const freshCtx = new ABCContext();
            const freshTokens = Scanner(newText, freshCtx);
            const freshAST = parse(freshTokens, freshCtx);

            return freshAST !== null;
          }
        ),
        { numRuns: 500 }
      );
    });
  });

  describe("setRhythm", () => {
    it("property: setRhythm followed by query returns the set value", () => {
      fc.assert(
        fc.property(genAbcTune, genRational, (source, rational) => {
          const { root, ctx } = toCSTreeWithContext(source);
          const notes = findByTag(root, TAGS.Note);
          if (notes.length === 0) return true;

          const ids = notes.map(n => n.id);
          const sel: Selection = { root, cursors: ids.map(id => new Set([id])) };

          setRhythm(sel, rational, ctx);

          // The serialize -> parse roundtrip should preserve the rhythm
          const newText = serializeCSTree(sel.root, ctx);
          return newText.length > 0; // Basic validity check
        }),
        { numRuns: 500 }
      );
    });
  });
});
```

### Running the tests

Add test scripts to `abc-lsp-server/package.json` (or run from root):

```json
{
  "scripts": {
    "test": "mocha -r ts-node/register 'src/**/*.spec.ts'",
    "test:unit": "mocha -r ts-node/register 'src/cursorPreservation.spec.ts' 'src/textEditFromDiff.spec.ts'",
    "test:integration": "mocha -r ts-node/register 'src/transformIntegration.spec.ts'",
    "test:pbt": "mocha -r ts-node/register 'src/**/*.pbt.spec.ts'"
  }
}
```

From the project root, run all tests:

```bash
npm run test
```

### Manual testing checklist

Manual testing should only be needed for VSCode-specific UI behavior:

1. Verify status bar shows cursor count after selection
2. Verify input prompt appears for transpose/setRhythm
3. Verify editor selections highlight the transformed elements
4. Verify Cmd+Z undoes the transform
5. Verify chained transforms work (select -> transform -> transform)
6. Verify cursor state clears on manual document edit (not via transform)

### Test coverage goals

| Component | Coverage target | Test type |
|-----------|-----------------|-----------|
| `collectSurvivingCursorIds` | 100% | Unit |
| `computeCursorRangesFromFreshTree` | 100% | Unit |
| `computeTextEditsFromDiff` | 100% | Unit |
| `serializeCSTree` | Via integration | Integration |
| `lookupTransform` | 100% | Integration |
| Transform chaining | All transforms | Integration |
| ID stability | 500+ inputs | Property-based |
| Serialization roundtrip | 500+ inputs | Property-based |

---

## To Do List

### Phase 1: Shared Cursor State Module
- Create `vscode-extension/src/cursorState.ts` with version-based state management
- Refactor `vscode-extension/src/selectorCommands.ts` to use the shared module
- Update `onDidChangeTextDocument` handler to use `shouldSkipClear(uri, version)`

### Phase 2: Transform Lookup on the Server
- Create `abc-lsp-server/src/transformLookup.ts`
- Add imports to `abc-lsp-server/src/server.ts`

### Phase 3: LSP Protocol - applyTransform Handler
- Move `vscode-extension/src/abct/diffToPatches.ts` to `abct2/src/utils/diffToPatches.ts`
- Update import in `vscode-extension/src/abct/` to re-export from new location
- Export `computeNodeRange` from `abc-lsp-server/src/selectionRangeResolver.ts`
- Create `abc-lsp-server/src/cursorPreservation.ts` with `collectSurvivingCursorIds` and `computeCursorRangesFromFreshTree`
- Create `abc-lsp-server/src/csTreeSerializer.ts`
- Create `abc-lsp-server/src/textEditFromDiff.ts` adapting `diffChars` to LSP TextEdits
- Add `abct2.applyTransform` request handler to `abc-lsp-server/src/server.ts`

### Phase 4: Cursor Preservation
- Implement ID-based preservation for cursor state (stable after in-place mutation)
- Implement ordinal-based mapping only for computing visual ranges from fresh tree
- Handle `remove` transform by filtering out deleted node IDs

### Phase 5: Extension Transform Commands
- Create `vscode-extension/src/transformCommands.ts`
- Update `registerSelectorCommands` signature to accept `statusBarItem` as a third parameter
- Update `vscode-extension/src/extension.ts`:
  - Create statusBarItem in `activate()`
  - Pass statusBarItem to both `registerSelectorCommands` and `registerTransformCommands`
  - Register transform commands AFTER `client.start()` completes

### Phase 6: package.json Updates
- Add all transform command definitions
- Add command palette visibility conditions
- Add quick-access transpose commands (octave up/down, half step up/down)

### Phase 7: Remove Old Transform Commands
- Remove `registerTransformCommands` from `vscode-extension/src/extensionCommands.ts`
- Remove `divideRhythm`, `multiplyRhythm`, `transposeUp`, `transposeDn` handlers from `abc-lsp-server/src/server.ts`
- Remove `onRhythmTransform` and `onTranspose` methods from `abc-lsp-server/src/AbcLspServer.ts`
- Remove old command definitions from `vscode-extension/package.json`

### Phase 8: Vim Extension Integration
- Document recommended Vim keybindings in the extension's README or CLAUDE.md
- Provide sample `vim.normalModeKeyBindings` configuration

### Phase 9: Testing
- Create `abc-lsp-server/src/cursorPreservation.spec.ts` with unit tests for:
  - `collectSurvivingCursorIds` (non-destructive, remove, multi-element, toRest)
  - `computeCursorRangesFromFreshTree` (mapping, stale IDs)
- Create `abc-lsp-server/src/textEditFromDiff.spec.ts` with unit tests for:
  - Empty diff, insert, delete, replace, multi-line
- Create `abc-lsp-server/src/transformIntegration.spec.ts` with integration tests for:
  - All transforms (transpose, enharmonize, setRhythm, toRest, remove, unwrapSingle)
  - Transform chaining
  - Error handling
- Create `abc-lsp-server/src/transformIntegration.pbt.spec.ts` with property-based tests for:
  - Transpose roundtrip: transpose(n) then transpose(-n) restores original
  - Transpose identity: transpose(0) is identity
  - Cursor preservation: non-destructive transforms preserve all cursor IDs
  - Serialization roundtrip: transform -> serialize -> parse produces valid ABC
  - setRhythm validity: setRhythm produces parseable output
- Run `npm run test` to verify all tests pass

### Final Steps
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass

---

## Verification

1. Build the project: `npm run build`
2. Run tests: `npm run test`
3. Manual testing in VSCode:
   - Open an ABC file
   - Use `ABC: Select Notes` to select all notes
   - Use `ABC: Transpose Selection` and enter "2" (transpose up a whole step)
   - Verify the notes are transposed and the selection is preserved
   - Use `ABC: Enharmonize Selection` to toggle sharp/flat
   - Use `ABC: Convert to Rest` to convert selected notes to rests
   - Verify chaining works: select, transform, transform again
