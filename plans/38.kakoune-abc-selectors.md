# Kakoune ABC Selector Integration

## Table of Contents

1. [Goal](#goal)
2. [Why Kakoune](#why-kakoune)
3. [Architecture Overview](#architecture-overview)
   - [Race Condition: Document Sync](#race-condition-document-sync)
   - [File Type Limitation](#file-type-limitation)
4. [Phase 1: LSP Server Socket + Selector Commands](#phase-1-lsp-server-socket--selector-commands)
   - [1.1 Add Unix Socket Listener](#11-add-unix-socket-listener-to-the-abc-lsp-server)
   - [1.1.1 Input Validation](#111-input-validation)
   - [1.2 Socket Path Convention](#12-socket-path-convention)
   - [1.3 Kakoune Plugin](#13-kakoune-plugin-rcabckak)
   - [1.4 Selector Commands](#14-selector-commands)
   - [1.4.1 Commands with Arguments](#141-commands-with-arguments)
   - [1.5 Concurrent Request Protection](#15-concurrent-request-protection)
5. [Phase 2: kak-lsp Configuration for Standard Features](#phase-2-kak-lsp-configuration-for-standard-features)
6. [Phase 3: Preview Server Integration](#phase-3-preview-server-integration)
7. [Selection Mapping (UTF-16 to Bytes)](#selection-mapping-utf-16-to-bytes)
   - [Reverse Conversion (Kakoune to LSP)](#reverse-conversion-kakoune-to-lsp-for-scope)
8. [Scope and Narrowing](#scope-and-narrowing)
9. [Socket Client Tool](#socket-client-tool)
10. [Error Handling and Edge Cases](#error-handling-and-edge-cases)
11. [Plugin Structure](#plugin-structure)
12. [Build Integration](#build-integration)
13. [Kakoune Plugin Testing with kak-spec](#kakoune-plugin-testing-with-kak-spec)
14. [To Do](#to-do)

---

## Goal

We want to integrate the ABC LSP selectors into Kakoune so that AST-level pattern matching becomes a native part of the editing workflow. Kakoune's multi-selection model is a natural fit: ABC selectors produce multiple disjoint ranges, and Kakoune represents those as first-class selections that can be further narrowed, split, or acted upon using standard Kakoune operations.

The Neovim plugin's selector system works but is limited by Vim's single-selection model. Highlights simulate multi-selection visually, but the user cannot narrow or compose them with standard editor motions. Kakoune eliminates this impedance mismatch.

---

## Why Kakoune

Kakoune's editing model is "select then act." Selections are the fundamental primitive:

- Multiple disjoint selections are native (no plugin required).
- `s` narrows within existing selections (regex filter).
- `S` splits selections.
- `<a-k>` / `<a-K>` keep/reject selections matching a pattern.
- Any action (delete, replace, indent, etc.) applies to all selections simultaneously.

ABC selectors map directly onto this model: they are just another way to create or narrow selections, alongside regex, text objects, and movement keys.

---

## Architecture Overview

```
kak-lsp ──stdio──> ABC LSP Server <──Unix socket── Kakoune plugin (%sh{})
     |                   |                               |
     |                   |                               |
 standard LSP        single process,                 second client,
 (diagnostics,       single document state           custom methods only
  completions,                                       (abct2.applySelector)
  hover, format,
  semantic tokens)
```

Two clients connect to the same LSP server process:

1. kak-lsp connects via stdio and handles all standard LSP features. Because kak-lsp sends `textDocument/didOpen` and `textDocument/didChange` over this connection, the server's document state stays in sync with the editor. No custom code needed on the kak-lsp side — just a `kak-lsp.toml` configuration entry.

2. The Kakoune plugin connects via a secondary Unix socket that the LSP server exposes. This socket accepts only custom method calls (selector requests). Because the server already has up-to-date document content from kak-lsp, the plugin does not need to mirror buffer state — it only sends selector parameters and receives range results.

This eliminates the need for a separate daemon process. The LSP server is the single source of truth.

### Race Condition: Document Sync

Because kak-lsp sends `didOpen` asynchronously, a selector request could arrive before the server has document state. The socket handler must handle this gracefully:

1. If the requested URI is not in the server's document map, return an error: `{"error": {"code": -32001, "message": "Document not yet opened"}}`.
2. The client script detects this error code and emits a Kakoune error message: `echo -markup "{Error}Document not ready - wait for LSP to connect"`.
3. The user can retry after a moment. Because this race window is small (only on freshly-opened files), no automatic retry is implemented.

### File Type Limitation

Selectors only work with `.abc` files, not `.abcx` files. The current `abct2.applySelector` handler in the LSP server checks for `AbcDocument` instances, and `.abcx` files are stored as `AbcxDocument`. This limitation is documented in the plugin; attempting to use selectors on `.abcx` files displays an error message.

---

## Phase 1: LSP Server Socket + Selector Commands

This phase delivers the core differentiator: ABC selectors producing native Kakoune multi-selections.

### 1.1 Add Unix Socket Listener to the ABC LSP Server

The ABC LSP server (`abc-lsp-server/src/server.ts`) must be modified to:

1. Accept an `initializationOptions.socketPath` parameter from the kak-lsp `initialize` request (alternatively, an environment variable `ABC_LSP_SOCKET`).
2. On initialization, create a Unix socket listener at the specified path.
3. Accept connections on this socket using newline-delimited JSON (one request per line, one response per line).
4. Handle only the `abct2.applySelector` method on this socket — all other methods are handled via the stdio connection.
5. On `shutdown`, close the socket and unlink the socket file.

The socket protocol is minimal. A request is a JSON object:
```json
{
  "id": 1,
  "method": "abct2.applySelector",
  "params": {
    "uri": "file:///path.abc",
    "selector": "selectChords",
    "args": [],
    "cursorNodeIds": [],
    "scope": [
      {"start": {"line": 0, "character": 0}, "end": {"line": 10, "character": 0}}
    ]
  }
}
```

The `scope` parameter is an array of LSP ranges (UTF-16 offsets). If provided, the socket handler filters results to only include ranges fully contained within at least one scope range. If `scope` is empty or omitted, the entire document is in scope.

Note: Scope filtering is specific to the socket interface. The existing `abct2.applySelector` handler (used via stdio by Neovim/VSCode) does not support scope filtering; it always operates on the entire document. The socket handler adds this capability by post-processing the results before returning them to the Kakoune client.

A response is:
```json
{"id": 1, "result": {"cursorNodeIds": [42, 87, 123], "ranges": [{"start": {"line": 0, "character": 5}, "end": {"line": 0, "character": 8}}, ...]}}
```

The response returns LSP-format ranges (0-indexed line, UTF-16 character offsets). The Kakoune plugin handles the conversion to byte-indexed Kakoune descriptors.

If the request fails, the response contains an error:
```json
{"id": 1, "error": {"code": -32001, "message": "Document not yet opened"}}
```

Error codes:
- `-32001`: Document not found (race condition on file open)
- `-32002`: File type not supported (ABCx files)
- `-32600`: Invalid request (malformed JSON or missing required fields)
- `-32601`: Unknown method (only `abct2.applySelector` is supported)
- `-32602`: Invalid parameters (unknown selector name, invalid args type)

The socket handler wraps the existing `abct2.applySelector` handler (used by the stdio LSP connection). The existing handler returns empty results `{ ranges: [], cursorNodeIds: [] }` for missing documents or unsupported file types. The socket handler translates these empty results into explicit error responses with the codes above, providing better feedback to the Kakoune plugin.

### 1.1.1 Input Validation

The socket handler must validate all incoming requests:
- `method`: Must be exactly `"abct2.applySelector"`. Other methods return error `-32601`.
- `params.uri`: Must be a valid `file://` URI. Path traversal sequences (`..`) are rejected.
- `params.selector`: Must be one of the known selector names (whitelist). Unknown selectors return error `-32602`.
- `params.args`: Must be an array. Non-array values return error `-32602`.
- `params.cursorNodeIds`: Must be an array of numbers. Invalid types return error `-32602`.
- `params.scope`: If present, must be an array of valid LSP range objects.

### 1.2 Socket Path Convention

The socket uses a fixed per-user path with a "first server wins" pattern. This approach follows how system daemons typically work: one instance per user, shared across all sessions.

The socket path is determined by (in priority order):
1. `$XDG_RUNTIME_DIR/abc-lsp.sock` if `XDG_RUNTIME_DIR` is set (typically `/run/user/<UID>`, mode 0700).
2. `/tmp/abc-lsp-$USER/lsp.sock` as fallback, with the directory created mode 0700.

When the ABC LSP server starts with `--socket=<path>`:
1. If the socket file does not exist, create it and listen.
2. If the socket file exists, attempt to connect to it:
   - If connection succeeds, another server is already running. Log a message and skip socket creation (but continue running for stdio LSP communication with this session's kak-lsp).
   - If connection fails (ECONNREFUSED), the socket is stale. Unlink it (after verifying ownership) and create a new one.

This means multiple Kakoune sessions may each spawn an ABC LSP server process, but only one will own the socket. The Kakoune plugin always connects to the same socket path, regardless of which server instance created it.

Limitation: If the socket-owning server exits (user closes that Kakoune session) while other sessions are still running, those sessions will lose selector functionality until they restart their LSP server. This is because the non-owning servers skipped socket creation at startup and cannot claim ownership later. In typical single-session usage this is not an issue. For multi-session workflows, users should be aware that closing the first-opened session may affect selectors in other sessions.

The Kakoune plugin constructs the socket path identically:
```kak
declare-option -hidden str abc_socket_path %sh{
    if [ -n "$XDG_RUNTIME_DIR" ]; then
        echo "$XDG_RUNTIME_DIR/abc-lsp.sock"
    else
        echo "/tmp/abc-lsp-$USER/lsp.sock"
    fi
}
```

Security consideration: `$XDG_RUNTIME_DIR` is per-user with restricted permissions. The fallback directory is created with mode 0700 to prevent other users from accessing the socket.

### 1.3 Kakoune Plugin (`rc/abc.kak`)

The Kakoune plugin script:

1. Detects `.abc` filetypes via `hook global BufCreate .*\.abc %{ ... }`. (ABCx files are detected but selectors are not enabled for them.)
2. Declares buffer-scoped options to store selector state:
   ```kak
   declare-option -hidden str abc_cursor_node_ids ""
   declare-option -hidden str abc_last_selections ""
   declare-option -hidden int abc_last_timestamp 0
   declare-option -hidden bool abc_pending false
   ```
3. Clears `abc_cursor_node_ids` when the buffer is modified or selections change. The detection uses `NormalIdle` to compare `%val{timestamp}` (buffer modification timestamp) and `%val{selections_desc}` against cached values:
   ```kak
   hook buffer NormalIdle .* %{
       evaluate-commands %sh{
           # Clear state if buffer was modified
           if [ "$kak_timestamp" != "$kak_opt_abc_last_timestamp" ]; then
               echo "set-option buffer abc_cursor_node_ids ''"
               echo "set-option buffer abc_last_timestamp $kak_timestamp"
           fi
           # Clear state if selections changed (user moved cursor or used Kakoune motions)
           if [ "$kak_selections_desc" != "$kak_opt_abc_last_selections" ]; then
               echo "set-option buffer abc_cursor_node_ids ''"
               echo "set-option buffer abc_last_selections '$kak_selections_desc'"
           fi
       }
   }
   ```
   This approach avoids relying on `NormalKey` (which does not fire for remapped keys) or `InsertEnd` (which does not exist in Kakoune).
4. Defines user commands for each selector (see section 1.4).
5. Defines `abc-select-reset` to clear the stored state.
6. Uses `abc_pending` to prevent concurrent selector requests (see section 1.5).

### 1.4 Selector Commands

Each selector command follows this pattern:

```kak
define-command abc-select-chords -docstring "Select all chord nodes" %{
    evaluate-commands %sh{
        # 0. Check pending flag first to prevent concurrent requests
        if [ "$kak_opt_abc_pending" = "true" ]; then
            echo "echo -markup '{Information}Selector request in progress'"
            exit 0
        fi
        echo "set-option buffer abc_pending true"

        # 1. Create temp file for buffer content (created after pending check to avoid orphans)
        tmpfile=$(mktemp)
        echo "set-option buffer abc_tmpfile '$tmpfile'"
    }

    # Capture buffer content to temp file (handles unsaved changes)
    execute-keys -draft '%' "<a-|>cat > %opt{abc_tmpfile}<ret>"

    evaluate-commands %sh{
        # 2. Read current state
        selections_desc="$kak_selections_desc"
        uri="file://${kak_buffile}"
        cursor_node_ids="$kak_opt_abc_cursor_node_ids"

        # 3. Build and send request via abc-kak-client
        # The client reads buffer content from --buffer-file for UTF-16/byte conversion
        result=$("$kak_opt_abc_client_cmd" \
            --socket="$kak_opt_abc_socket_path" \
            --uri="$uri" \
            --selector="selectChords" \
            --args="[]" \
            --cursor-ids="$cursor_node_ids" \
            --scope="$selections_desc" \
            --buffer-file="$kak_opt_abc_tmpfile" \
            --timeout="$kak_opt_abc_timeout")
        exit_code=$?

        # 4. Clean up temp file
        rm -f "$kak_opt_abc_tmpfile"

        # 5. Clear pending flag
        echo "set-option buffer abc_pending false"

        # 6. Handle result
        if [ $exit_code -ne 0 ]; then
            echo "echo -markup '{Error}$result'"
            exit 0
        fi

        # Result format: line 1 = selection descriptors, line 2 = cursorNodeIds JSON
        new_selections=$(echo "$result" | head -n1)
        new_ids=$(echo "$result" | tail -n1)

        if [ -n "$new_selections" ]; then
            echo "select $new_selections"
            echo "set-option buffer abc_cursor_node_ids '$new_ids'"
            echo "set-option buffer abc_last_selections '$new_selections'"
        else
            echo "echo -markup '{Information}No matches found'"
        fi
    }
}
```

The command checks the pending flag first, then creates the temp file. This avoids orphaned temp files if the command is invoked while another request is in flight. The buffer content is captured to the temp file before invoking `abc-kak-client`, ensuring the UTF-16-to-byte conversion uses the same content that the LSP server has (synced via kak-lsp's `didChange`).

The commands defined:
- `abc-select-chords` -- selector: `selectChords`
- `abc-select-notes` -- selector: `selectNotes`
- `abc-select-non-chord-notes` -- selector: `selectNonChordNotes` (notes not inside chords)
- `abc-select-chord-notes` -- selector: `selectChordNotes` (notes inside chords)
- `abc-select-rests` -- selector: `selectRests`
- `abc-select-tune` -- selector: `selectTune` (scopes to individual tunes in multi-tune files)
- `abc-select-top` -- selector: `selectTop` (selects the top note of each chord)
- `abc-select-bottom` -- selector: `selectBottom` (selects the bottom note of each chord)
- `abc-select-nth-from-top` -- selector: `selectNthFromTop`, requires argument (see below)
- `abc-select-all-but-top` -- selector: `selectAllButTop`
- `abc-select-all-but-bottom` -- selector: `selectAllButBottom`
- `abc-select-reset` -- clears `abc_cursor_node_ids`, does not change selections

### 1.4.1 Commands with Arguments

For selectors that require arguments (like `selectNthFromTop`), the command accepts a parameter:

```kak
define-command abc-select-nth-from-top -params 1 \
    -docstring "Select the Nth note from top (0-indexed)" %{
    # ... same pattern as above, but with:
    # --selector="selectNthFromTop" --args="[$1]"
}
```

Usage: `:abc-select-nth-from-top 1` selects the second note from the top (0-indexed).

For convenience, `abc-select-top` and `abc-select-bottom` are parameterless shortcuts that call `selectTop` and `selectBottom` directly (which always select the first/last note).

### 1.5 Concurrent Request Protection

The `abc_pending` flag prevents race conditions when the user rapidly invokes selector commands. If a request is already in flight, subsequent invocations display an informational message and return without sending a new request. The flag is cleared after the `%sh{}` block completes (success or error).

---

## Phase 2: kak-lsp Configuration for Standard Features

kak-lsp handles diagnostics, completions, hover, formatting, and semantic tokens out of the box. We only need to configure it.

### 2.1 kak-lsp.toml Configuration

The socket path is fixed per-user (see section 1.2), so no wrapper script is needed. The server computes the socket path itself based on `$XDG_RUNTIME_DIR` or falls back to `/tmp/abc-lsp-$USER/`.

```toml
[language_server.abc-lsp]
filetypes = ["abc"]
roots = [".git"]
command = "node"
args = ["/path/to/abc-lsp-server/out/server.js", "--stdio", "--socket=auto"]
```

The `--socket=auto` argument tells the server to compute the socket path using the same logic as the Kakoune plugin (section 1.2). Both the server and the plugin independently derive the same path from `$XDG_RUNTIME_DIR` or `$USER`, so no coordination file is needed.

Alternative: specify the socket path explicitly if the user wants a custom location:
```toml
args = ["/path/to/abc-lsp-server/out/server.js", "--stdio", "--socket=/custom/path/abc-lsp.sock"]
```

The Kakoune plugin must be configured to match:
```kak
set-option global abc_socket_path "/custom/path/abc-lsp.sock"
```

### 2.2 Filetype Registration

Add to the Kakoune plugin:
```kak
hook global BufCreate .*\.(abc|abcx) %{
    set-option buffer filetype abc
}

hook global WinSetOption filetype=abc %{
    lsp-enable-window
}
```

This enables kak-lsp for all ABC buffers. Standard features (diagnostics inline, completions, hover via `lsp-hover`, formatting via `lsp-formatting`) work without additional code.

### 2.3 Semantic Token Face Mapping

Add a `[semantic_tokens]` section to `kak-lsp.toml` that maps the ABC LSP server's token types to Kakoune faces:

```toml
[language_server.abc-lsp.semantic_tokens]
variable = "variable"
keyword = "keyword"
string = "string"
number = "value"
comment = "comment"
operator = "operator"
```

The exact mapping depends on which semantic token types the ABC LSP server emits.

---

## Phase 3: Preview Server Integration

The preview server from the Neovim plugin (`abc-lsp.nvim/preview-server/`) is reused as-is. The Kakoune plugin:

1. Starts the preview server process on `:abc-preview-open`:
   ```kak
   define-command abc-preview-open %{
       evaluate-commands %sh{
           node /path/to/preview-server/dist/server.js --port=8088 &
           echo $! > /tmp/abc-preview-$kak_session.pid
           disown
       }
   }
   ```
2. On `NormalIdle` and `InsertIdle`, sends the buffer content to the preview server's stdin (via a named pipe or the process's stdin if kept open).
3. Opens the browser to `http://localhost:<port>/<slug>`.

The preview server stdin communication uses the same JSON line protocol as the Neovim plugin: `{"type": "content", "path": "/path/to/file.abc", "content": "..."}`.

Because the preview server is a separate process from the LSP server, it does not benefit from kak-lsp's document sync. The Kakoune plugin must send buffer content updates to it independently (via `NormalIdle`/`InsertIdle` hooks that pipe the buffer content).

---

## Selection Mapping (UTF-16 to Bytes)

ABC content can contain UTF-8 characters (in titles, lyrics, annotations). The LSP protocol uses UTF-16 code unit offsets, and Kakoune uses byte offsets. The conversion requires knowing the line content.

### Conversion Algorithm

Given an LSP range `{start: {line, character}, end: {line, character}}`:

1. The Kakoune plugin passes the buffer file path to `abc-kak-client` via `--buffer-file`.
2. `abc-kak-client` (a Node.js script) reads the file and performs the conversion:
   - For each line referenced in a range, read the line content from the buffer.
   - Convert the UTF-16 code unit offset to a byte offset. In Node.js, strings are UTF-16 internally, so `line.slice(0, utf16Offset)` gives the prefix, and `Buffer.byteLength(prefix, 'utf8')` gives the byte offset.
   - Produce the Kakoune descriptor: `(line+1).(byte_col+1),(end_line+1).(end_byte_col)`.

3. The `end` position is exclusive in LSP but Kakoune's cursor position is inclusive. The conversion is:
   - Find the byte offset of `end.character` (exclusive end).
   - Subtract 1 to get the inclusive end byte.
   - If the result is 0 (end was at column 0), the inclusive end is the last byte of the previous line.

The subtraction happens in byte space after UTF-16-to-byte conversion, not in UTF-16 code unit space.

### Reverse Conversion (Kakoune to LSP for Scope)

When converting Kakoune selections to LSP ranges for the `scope` parameter:
1. Parse each Kakoune descriptor: `line.col,line.col` (1-indexed, byte offsets, inclusive).
2. For each line, read the content and convert byte offsets to UTF-16 code unit offsets.
3. Convert inclusive end to exclusive end by adding 1 (in codepoint space, then to UTF-16).

This reverse conversion is also performed by `abc-kak-client`, which accepts `--scope` as Kakoune descriptors and includes the converted LSP ranges in the request JSON.

### Edge Cases

- Empty ranges (start == end in LSP): discarded (no selection can represent zero width).
- End at line start (character == 0): the inclusive end is the last byte of the previous line. `abc-kak-client` must look up the previous line's byte length.
- Ranges spanning multiple lines: anchor is on the start line, cursor is on the end line. No special handling needed beyond the per-line conversion.
- Characters outside BMP (emoji, etc.): These occupy 2 UTF-16 code units (surrogate pairs). Node.js handles this correctly with `String.prototype.slice()`. Kakoune uses byte offsets, so a 4-byte emoji (2 UTF-16 units) converts correctly.
- CRLF line endings: The LSP server normalizes line endings internally to LF. Kakoune also uses LF internally (CRLF files are displayed with `^M` markers). Because both the temp file (written by Kakoune) and the LSP document state use LF, line endings do not cause offset mismatches. If a file has CRLF on disk but Kakoune normalizes it, the temp file will have LF, matching the LSP state.

---

## Scope and Narrowing

### How Scope Works

When the user has active selections before calling an ABC selector, those selections define the scope. The flow:

1. The `%sh{}` block reads `$kak_selections_desc` (e.g., `2.1,5.30 8.1,12.15`).
2. These Kakoune descriptors are converted to LSP ranges (byte offsets to UTF-16) and sent as a `scope` parameter alongside the selector request.
3. The LSP server (or the socket handler) filters results: a range is included only if it is fully contained within at least one scope range. Partial overlaps are excluded — we do not want half-selected nodes.
4. The filtered cursorNodeIds are also pruned to match: only IDs whose ranges passed the scope filter are stored for subsequent narrowing.

This ensures that the stored `cursorNodeIds` always correspond exactly to the visible Kakoune selections, preventing the mismatch where stored IDs reference nodes outside the user's view.

### How Narrowing Works

1. First call (cursorNodeIds empty): the selector applies to the entire document, then scope filters the results.
2. Subsequent calls (cursorNodeIds non-empty): the LSP server narrows within those nodes, then scope filters again.
3. On buffer modification (`NormalIdle` detects buffer has changed): cursorNodeIds are cleared. The current Kakoune selections remain until the user moves or types, because selections in Kakoune are not invalidated by content changes (they track positions).
4. `abc-select-reset` explicitly clears cursorNodeIds without changing selections.

### Direction Normalization

Kakoune selection descriptors can have the anchor after the cursor (backwards selections). Before converting to LSP ranges for the scope, the plugin normalizes each descriptor so that start <= end.

---

## Socket Client Tool

The `%sh{}` block needs a way to connect to the Unix socket, send a request, and read the response. We bundle a Node.js script (`abc-kak-client.js`) that handles all communication and conversion.

### Command-Line Interface

```
abc-kak-client.js [options]

Options:
  --socket=PATH         Unix socket path (required)
  --uri=URI             Document URI (required)
  --selector=NAME       Selector name (required)
  --args=JSON           Selector arguments as JSON array (default: [])
  --cursor-ids=JSON     Current cursor node IDs as JSON array (default: [])
  --scope=DESC          Kakoune selection descriptors, space-separated (optional)
  --buffer-file=PATH    Path to temp file containing buffer content (required)
  --timeout=MS          Request timeout in milliseconds (default: 5000)
```

### Processing Steps

1. Read socket path from `--socket`.
2. Read the buffer file (temp file with current buffer content) to get line contents for offset conversion.
3. If `--scope` is provided, parse Kakoune descriptors and convert to LSP ranges (byte to UTF-16).
4. Build the JSON request with all parameters including converted scope.
5. Connect to the Unix socket.
6. Write the request JSON + newline.
7. Read until a complete JSON line is received (or timeout).
8. Parse the response. If error, write error message to stderr and exit with code 1.
9. Convert returned LSP ranges (UTF-16) to Kakoune descriptors (bytes).
10. Output to stdout:
    - Line 1: space-separated Kakoune selection descriptors.
    - Line 2: JSON array of cursorNodeIds (for storage in buffer option).
11. Exit with code 0.

### Output Format

On success (exit 0):
```
2.5,2.10 3.1,3.8 5.12,5.20
[42,87,123]
```

On error (exit 1), stderr contains the error message:
```
Document not ready - wait for LSP to connect
```

### Performance Note

Node.js cold start is approximately 50-100ms. This latency is acceptable for user-initiated selector commands, which are not invoked per-keystroke. For workflows requiring many rapid selector invocations, the user can chain them in a single command macro.

### Configuration

The script is bundled with the plugin and its path is configured via a Kakoune option:
```kak
declare-option str abc_client_cmd "node /path/to/abc-kak/bin/abc-kak-client.js"
```

---

## Error Handling and Edge Cases

### LSP Server Not Running

If the socket does not exist when a selector command is invoked, the client script exits with an error. The `%sh{}` block detects the non-zero exit code and displays an error:
```kak
echo -markup "{Error}ABC LSP server not running (socket not found)"
```

### LSP Server Crashes

kak-lsp detects the server crash (child process exits) and can be configured to restart it. On restart, the server creates a new socket. The Kakoune plugin's next selector call will connect successfully because it opens a fresh connection each time.

If the socket file is stale (server crashed without cleanup), the client script's connection attempt will fail immediately (ECONNREFUSED or ENOENT). The script reports an error. The user can restart the LSP server by running `:lsp-stop` followed by `:lsp-start`, which will spawn a fresh server that creates a new socket.

### Timeout

The client script has a configurable timeout (default: 5 seconds). If the server does not respond within this window, the script exits with an error and the `%sh{}` block reports it. This prevents Kakoune from hanging indefinitely.

### No Matches

If the selector returns zero ranges, the plugin does not issue a `select` command (which would be invalid with zero arguments). Instead, it echoes an informational message and leaves the current selections unchanged.

### Empty Buffer

If the buffer is empty (newly created file with no content), the LSP server returns zero ranges. The plugin handles this the same as "no matches."

### Overlapping Ranges

If the LSP server returns overlapping ranges (possible with certain selector combinations), Kakoune merges them automatically. This is correct behavior. The stored cursorNodeIds may contain more entries than visible selections after merging, but this does not cause problems because the cursorNodeIds are passed back to the server for narrowing, and the server operates on node IDs, not on the visual selections.

### Configurable Timeout

The timeout is configurable via a Kakoune option:
```kak
declare-option int abc_timeout 5000
```

The selector commands pass this value to `abc-kak-client` via `--timeout=$kak_opt_abc_timeout`. The default (5 seconds) is sufficient for typical files; users editing very large ABC files can increase it.

### Stale Socket Detection

The LSP server handles stale socket detection during startup (see section 1.2). If it finds an existing socket file, it attempts to connect:
- If connection succeeds, another server is running; this instance skips socket creation.
- If connection fails (ECONNREFUSED), the socket is stale; the server unlinks it after verifying ownership.

The Kakoune plugin does not need to detect stale sockets because `abc-kak-client` will receive a connection error if no server is listening. The client reports this as "LSP server not running" and exits with a non-zero code.

For ownership verification during unlink (in the server):
```typescript
// Only unlink if we own the socket (prevent symlink attacks)
const stats = fs.statSync(socketPath);
if (stats.uid === process.getuid()) {
    fs.unlinkSync(socketPath);
}
```

---

## Plugin Structure

```
abc-kak/
  rc/
    abc.kak                  -- Filetype detection, hooks, option declarations
    abc-selectors.kak        -- Selector command definitions
    abc-preview.kak          -- Preview server integration (Phase 3)
  bin/
    abc-kak-client.js        -- Socket client + UTF-16/byte conversion
  spec/
    mock-abc-kak-client.sh   -- Mock client for kak-spec tests
    abc-selectors.kak-spec   -- kak-spec tests for selector commands
    abc-state.kak-spec       -- kak-spec tests for state management
  kak-lsp.toml.example       -- Example kak-lsp configuration snippet
  README.md
```

The plugin does not contain a daemon or its own LSP client. It relies on:
- kak-lsp (external, user-installed) for standard LSP features.
- The ABC LSP server's built-in socket listener (activated with `--socket=auto`) for custom methods.
- The bundled `abc-kak-client.js` for socket communication.

---

## Build Integration

### LSP Server Changes

The socket listener is added to the `abc-lsp-server` package (already a workspace in the monorepo). No new workspace is needed. The changes:

- `abc-lsp-server/src/server.ts`: add socket listener setup after LSP initialization.
- `abc-lsp-server/src/socketHandler.ts`: new file, handles incoming socket connections and dispatches selector requests.

These are compiled by the existing `npm run build:lsp` script.

### Kakoune Plugin

The `abc-kak/` directory lives at the top level of the monorepo (sibling to `abc-lsp-server/`, `parse/`, etc.). It is not a Node.js workspace because the `.kak` files are not compiled. The `bin/abc-kak-client.js` is a standalone script with no dependencies beyond Node.js stdlib (`net`, `readline`, `fs`).

The root `package.json` does not need modification. The Kakoune plugin is installed by the user adding the `rc/` directory to their Kakoune `autoload` path.

### Testing

Testing is split into three layers:

1. **LSP Server Socket Handler** (Node.js, `npm run test`):
   - Unit tests in `abc-lsp-server` test suite
   - Tests socket protocol, error codes, scope filtering
   - No Kakoune required

2. **abc-kak-client.js** (Node.js, standalone test script):
   - Tests UTF-16/byte conversion with mock socket server
   - Tests Kakoune descriptor parsing and output format
   - No Kakoune required

3. **Kakoune Plugin** (kak-spec, automated):
   - Tests `.kak` files using the [kak-spec](https://github.com/jbomanson/kak-spec.kak) framework
   - Uses a mock client script to simulate LSP responses
   - Tests plugin logic without requiring a running LSP server

---

## Kakoune Plugin Testing with kak-spec

The [kak-spec](https://github.com/jbomanson/kak-spec.kak) framework enables automated testing of Kakoune scripts. Tests run in isolated temporary Kakoune sessions.

### What kak-spec Can Test

With a mock `abc-kak-client` that returns predefined responses, the implementer can test:

1. **Selection parsing**: Given mock client output, verify the plugin sets correct Kakoune selections
2. **State management**: Verify `abc_cursor_node_ids` is set/cleared correctly
3. **Pending flag**: Verify concurrent requests are blocked
4. **Timestamp-based clearing**: Verify state clears when buffer is modified
5. **Selection-based clearing**: Verify state clears when selections change
6. **Error handling**: Verify error messages display correctly when client exits non-zero
7. **Option initialization**: Verify default values for `abc_socket_path`, `abc_timeout`, etc.

### What Requires Manual Integration Testing

- Actual LSP server communication (real socket, real selectors)
- End-to-end selector workflows with real ABC files
- kak-lsp integration (diagnostics, completions, hover)
- Preview server integration

### Mock Client Script

Create `abc-kak/spec/mock-abc-kak-client.sh` that returns predefined responses based on arguments:

```bash
#!/bin/bash
# Mock client for kak-spec tests
# Returns predefined responses based on --selector argument

selector=""
for arg in "$@"; do
    case "$arg" in
        --selector=*) selector="${arg#--selector=}" ;;
    esac
done

case "$selector" in
    "selectChords")
        echo "1.3,1.7 1.10,1.14"
        echo "[42,87]"
        ;;
    "selectNotes")
        echo "1.1,1.2 1.5,1.6"
        echo "[10,20]"
        ;;
    "_error")
        echo "Mock error message" >&2
        exit 1
        ;;
    *)
        echo ""
        echo "[]"
        ;;
esac
```

### Example kak-spec Tests

Test file: `abc-kak/spec/abc-selectors.kak-spec`

```kak
# Test: abc-select-chords sets selections from client output
kak-spec -title "abc-select-chords parses client output" \
    -input "X:1\nK:C\n[CEG] A [DFA]" \
    -eval %{
        set-option buffer filetype abc
        set-option global abc_client_cmd "%sh{echo $PWD}/spec/mock-abc-kak-client.sh"
        set-option global abc_socket_path "/tmp/mock.sock"
        abc-select-chords
    } \
    -expect-%val(selections_desc) "1.3,1.7 1.10,1.14"

# Test: abc_cursor_node_ids is set after successful selection
kak-spec -title "abc-select-chords stores cursor node IDs" \
    -input "X:1\nK:C\n[CEG]" \
    -eval %{
        set-option buffer filetype abc
        set-option global abc_client_cmd "%sh{echo $PWD}/spec/mock-abc-kak-client.sh"
        abc-select-chords
    } \
    -expect-%opt(abc_cursor_node_ids) "[42,87]"

# Test: pending flag blocks concurrent requests
kak-spec -title "concurrent requests are blocked" \
    -input "test" \
    -eval %{
        set-option buffer abc_pending true
        abc-select-chords
    } \
    -expect-%val(selections_desc) "1.1,1.4"  # unchanged from initial

# Test: error from client displays message
kak-spec -title "client error displays message" \
    -input "test" \
    -eval %{
        set-option global abc_client_cmd "%sh{echo $PWD}/spec/mock-abc-kak-client.sh"
        # Force error by using _error selector (mock returns exit 1)
        evaluate-commands %sh{
            echo "set-option global abc_test_selector '_error'"
        }
    } \
    -expect-%val(error) regex(".*Mock error.*")

# Test: state clears on buffer modification
kak-spec -title "cursor_node_ids clears on buffer change" \
    -input "test" \
    -eval %{
        set-option buffer abc_cursor_node_ids "[1,2,3]"
        set-option buffer abc_last_timestamp 100
        # Simulate NormalIdle detecting timestamp change
        evaluate-commands %sh{
            if [ "$kak_timestamp" != "$kak_opt_abc_last_timestamp" ]; then
                echo "set-option buffer abc_cursor_node_ids ''"
            fi
        }
    } \
    -expect-%opt(abc_cursor_node_ids) ""
```

### Running kak-spec Tests

```bash
cd abc-kak
kak-spec spec/*.kak-spec
```

The tests run in headless Kakoune sessions and report pass/fail status. This enables CI integration without manual intervention.

---

## To Do

Phase 1 (core selectors):
- Add `--socket=PATH` and `--socket=auto` CLI argument parsing to `abc-lsp-server/src/server.ts`.
- Implement socket path computation in server: use `$XDG_RUNTIME_DIR/abc-lsp.sock` or `/tmp/abc-lsp-$USER/lsp.sock`.
- Implement "first server wins" socket creation:
  - If socket doesn't exist, create and listen.
  - If socket exists, try to connect; if connection succeeds, skip socket creation; if ECONNREFUSED, unlink (after ownership check) and create.
- Create `abc-lsp-server/src/socketHandler.ts`:
  - Parse newline-delimited JSON requests.
  - Validate request format (method must be `abct2.applySelector`, validate params).
  - Whitelist valid selector names.
  - Check if document exists; return error code `-32001` if not.
  - Check if document is AbcDocument (not AbcxDocument); return error code `-32002` if not.
  - Dispatch to existing `abct2.applySelector` handler.
  - Implement scope filtering: accept a `scope` parameter (array of LSP ranges), filter returned ranges to those fully contained within at least one scope range, prune cursorNodeIds to match.
  - Format and send JSON response.
- Write `abc-kak/bin/abc-kak-client.js`:
  - Parse command-line arguments (socket, uri, selector, args, cursor-ids, scope, buffer-file, timeout).
  - Read temp buffer file for UTF-16/byte conversion.
  - Convert Kakoune scope descriptors to LSP ranges (byte to UTF-16).
  - Connect to socket, send request, receive response with timeout.
  - Handle error responses (output to stderr, exit 1).
  - Convert LSP ranges to Kakoune descriptors (UTF-16 to byte).
  - Output selection descriptors and cursorNodeIds to stdout.
- Write `abc-kak/rc/abc.kak`:
  - Filetype detection for `.abc` files.
  - Buffer-scoped options: `abc_cursor_node_ids`, `abc_last_selections`, `abc_last_timestamp`, `abc_pending`, `abc_tmpfile`.
  - Global options: `abc_client_cmd`, `abc_socket_path`, `abc_timeout`.
  - Compute `abc_socket_path` using same logic as server.
  - `NormalIdle` hook that clears `abc_cursor_node_ids` when `%val{timestamp}` or `%val{selections_desc}` changes.
- Write `abc-kak/rc/abc-selectors.kak`:
  - Define all selector commands using the pattern from section 1.4.
  - Capture buffer to temp file before invoking client (handles unsaved changes).
  - Include concurrent request protection via `abc_pending` flag.
  - Commands: `abc-select-chords`, `abc-select-notes`, `abc-select-non-chord-notes`, `abc-select-chord-notes`, `abc-select-rests`, `abc-select-tune`, `abc-select-top`, `abc-select-bottom`, `abc-select-nth-from-top`, `abc-select-all-but-top`, `abc-select-all-but-bottom`, `abc-select-reset`.
- Write `abc-kak/spec/mock-abc-kak-client.sh`:
  - Mock client script that returns predefined responses based on `--selector` argument.
  - Supports `_error` pseudo-selector to test error handling.
- Write `abc-kak/spec/abc-selectors.kak-spec`:
  - Test selection parsing from mock client output.
  - Test `abc_cursor_node_ids` storage after successful selection.
  - Test pending flag blocks concurrent requests.
  - Test error display when client exits non-zero.
- Write `abc-kak/spec/abc-state.kak-spec`:
  - Test state clears on buffer modification (timestamp change).
  - Test state clears on selection change.
  - Test option initialization defaults.
- Add socket handler tests to `abc-lsp-server` test suite:
  - Test document-not-found error.
  - Test ABCx file error.
  - Test unknown method error.
  - Test invalid selector name error.
  - Test scope filtering (fully contained, partial overlap excluded).
  - Test successful selector response format.
- Add UTF-16/byte conversion tests to `abc-kak/bin/` (standalone Node.js test script):
  - Test ASCII-only content.
  - Test UTF-8 multi-byte characters.
  - Test surrogate pairs (emoji).
  - Test edge cases (end at line start, empty ranges).
- Manual integration test: open an ABC file in Kakoune, verify kak-lsp connects, verify selector commands produce correct multi-selections, verify narrowing workflow, verify state clears on edit and selection change.

Phase 2 (kak-lsp standard features):
- Write `abc-kak/kak-lsp.toml` snippet for the ABC LSP server configuration using `--socket=auto`.
- Document the semantic token face mapping.
- Verify diagnostics, completions, hover, and formatting work with no additional code.

Phase 3 (preview):
- Write `abc-kak/rc/abc-preview.kak`: start preview server (keep stdin open), send buffer content on `NormalIdle`/`InsertIdle` via fifo, open browser.
- Verify preview updates live as the user edits.

Final verification:
- `npm run build` from monorepo root passes (LSP server socket changes compile).
- `npm run test` from monorepo root passes (socket handler tests pass).
- `kak-spec abc-kak/spec/*.kak-spec` passes (Kakoune plugin tests pass).
- Manual Kakoune integration test passes (real LSP server, real ABC files).
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
