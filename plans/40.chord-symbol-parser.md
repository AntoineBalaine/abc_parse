# Chord Symbol Parser and Music Theory Module

## Table of Contents

1. [Goal](#goal)
2. [Context](#context)
3. [Design Overview](#design-overview)
4. [Phase 1: Types and Data Structures](#phase-1-types-and-data-structures)
5. [Phase 2: Shared Key Utilities](#phase-2-shared-key-utilities)
6. [Phase 3: Chord Symbol Scanner](#phase-3-chord-symbol-scanner)
7. [Phase 4: Chord Symbol Parser](#phase-4-chord-symbol-parser)
8. [Phase 5: Chord to Pitches Conversion](#phase-5-chord-to-pitches-conversion)
9. [Phase 6: Backtrack Selector](#phase-6-backtrack-selector)
10. [Phase 7: Integration Helper](#phase-7-integration-helper)
11. [To Do List](#to-do-list)

---

## Goal

We are implementing a chord symbol parser that converts jazz chord notation strings (like "Am7", "Cmaj7#11", "Dm7b5/A") into structured data, and then into MIDI pitches. This module enables harmonization transforms described in plan 39.

The approach reuses the existing scanner/parser infrastructure patterns. If scanning or parsing fails on an annotation's text, we know the annotation does not contain a valid chord symbol.

---

## Context

### Existing Infrastructure

The codebase already has:

- `pChordSymbol` regex in `parse/parsers/scan_abcx_tunebody.ts:49` that matches chord symbols as a single token (note: this regex does not include `+`, `sus2`, or `sus4` - it treats `Csus4` as quality `sus` + extension `4`)
- `parseKeyRoot(char)` in `parse/analyzers/info-line-analyzer.ts:215` that parses note letters A-G (local function, not exported)
- `parseKeyAccidental(str)` in `parse/analyzers/info-line-analyzer.ts:238` that parses #/b (local function, not exported)
- `toMidiPitch(pitch)` and `fromMidiPitch(midi, ctx)` for pitch conversion
- `KeyRoot` and `KeyAccidental` enums in `parse/types/abcjs-ast.ts`
- Scanner context pattern in `parse/parsers/scan2.ts`

### Chord Symbol Grammar (Jazz Notation)

```
chord_symbol := root accidental? quality? extensions? alterations? bass?
root         := [A-Ga-g]
accidental   := '#' | 'b'
quality      := 'maj' | 'min' | 'dim' | 'aug' | 'sus2' | 'sus4' | 'sus' | 'add' | 'm' | 'M' | '+' | '-' | '°' | 'ø' | 'Ø'
extensions   := [0-9]+                    // 5, 6, 7, 9, 11, 13, 69
alterations  := ('#' | 'b') [0-9]+        // #5, b9, #11, b13 (can repeat)
bass         := '/' root accidental?      // /E, /Bb
```

Note: Both uppercase and lowercase root letters are accepted. Lowercase letters are normalized to uppercase during parsing.

Examples:
- `C` - C major triad
- `Am` - A minor triad
- `G7` - G dominant seventh
- `Cmaj7` - C major seventh
- `C+` or `Caug` - C augmented
- `Dm7b5` - D half-diminished (minor 7 flat 5)
- `Cdim7` - C fully diminished seventh
- `F#m7` - F# minor seventh
- `Bb/D` - Bb major with D bass
- `Cmaj7#11` - C major seventh sharp eleven
- `Csus2` - C suspended second
- `Csus4` or `Csus` - C suspended fourth
- `C5` - C power chord
- `Cadd9` - C major with added 9th (no 7th)

---

## Design Overview

### File Structure

```
parse/utils/
  keyUtils.ts             // Shared parseKeyRoot, parseKeyAccidental (extracted)

parse/music-theory/
  types.ts                // ParsedChord, ChordQuality, ChordTT enum
  scanChordSymbol.ts      // tokenize chord symbol string
  parseChordSymbol.ts     // tokens → ParsedChord
  chordPitches.ts         // ParsedChord → MIDI pitches
  index.ts                // re-exports

abct2/src/selectors/
  backtrackSelector.ts    // functional backtrack, selectPreviousChordSymbol
```

### Flow

```
annotation.text
  → stripQuotes(text)
  → scanChordSymbol(str)
  → parseChordSymbol(tokens)
  → ParsedChord | null

ParsedChord
  → chordToPitches(parsed, baseOctave)
  → number[]  // MIDI pitches
```

---

## Phase 1: Types and Data Structures

### 1.1 Location

`parse/music-theory/types.ts`

### 1.2 ChordQuality Enum

Because chord quality differs from key mode (chord "m" means minor triad structure, mode "m" means minor scale), we define a separate enum:

```typescript
export enum ChordQuality {
  Major = "major",           // C, Cmaj
  Minor = "minor",           // Cm, Cmin, C-
  Dominant = "dominant",     // C7 (major triad + minor 7th)
  Diminished = "diminished", // Cdim, C°
  Augmented = "augmented",   // Caug, C+
  HalfDiminished = "half-diminished", // Cø, Cm7b5
  Suspended2 = "sus2",       // Csus2
  Suspended4 = "sus4",       // Csus4, Csus
  Power = "power",           // C5 (root + fifth only)
  Add = "add",               // Cadd9, Cadd11 (triad + extension, no 7th)
}
```

### 1.3 ParsedChord Interface

```typescript
import { KeyRoot, KeyAccidental } from "../types/abcjs-ast";

export interface ChordAlteration {
  type: "sharp" | "flat";
  degree: number;  // 5, 9, 11, 13
}

export interface ParsedChord {
  root: KeyRoot;
  rootAccidental: KeyAccidental;
  quality: ChordQuality;
  qualityExplicit: boolean;        // true if quality was explicitly specified (not inferred)
  extension: number | null;        // 5, 6, 7, 9, 11, 13, 69 (null if none)
  alterations: ChordAlteration[];  // [{ type: "flat", degree: 5 }]
  bass: {
    root: KeyRoot;
    accidental: KeyAccidental;
  } | null;
}
```

The `qualityExplicit` field distinguishes between explicitly specified quality (e.g., "Cmaj7" has explicit Major quality) and inferred quality (e.g., "C7" has no quality token, so Dominant is inferred). This prevents the parser from incorrectly converting "Cmaj7" to Dominant.

### 1.4 Token Types for Chord Symbols

Because chord symbol tokens are only used internally by the music-theory module (not by the main ABC scanner), we define a separate enum to avoid polluting the main `TT` namespace:

```typescript
// In parse/music-theory/types.ts
export enum ChordTT {
  ROOT = "CHORD_ROOT",
  ACCIDENTAL = "CHORD_ACCIDENTAL",
  QUALITY = "CHORD_QUALITY",
  EXTENSION = "CHORD_EXTENSION",
  ALTERATION = "CHORD_ALTERATION",
  BASS_SLASH = "CHORD_BASS_SLASH",
}
```

### 1.5 ChordToken Interface

Because we do not need full Token class features (ID generation, line/position tracking) for ephemeral chord tokens, we use a lightweight token structure:

```typescript
export interface ChordToken {
  type: ChordTT;
  lexeme: string;
}
```

### 1.6 Imports Summary

| Symbol | Source | Purpose |
|--------|--------|---------|
| `KeyRoot` | `parse/types/abcjs-ast.ts` | Reuse existing note root enum |
| `KeyAccidental` | `parse/types/abcjs-ast.ts` | Reuse existing accidental enum |

---

## Phase 2: Shared Key Utilities

### 2.1 Location

`parse/utils/keyUtils.ts`

### 2.2 Rationale

The functions `parseKeyRoot` and `parseKeyAccidental` in `info-line-analyzer.ts` are local (not exported). Because we need the same logic for chord symbols, we extract these to a shared utility module rather than duplicating code.

### 2.3 Functions

```typescript
import { KeyRoot, KeyAccidental } from "../types/abcjs-ast";

/**
 * Parse a note letter (A-G, case insensitive) to KeyRoot.
 * Also handles "H" for Highland Pipes (KeyRoot.HP) for backward compatibility
 * with info-line-analyzer.ts.
 * Returns null if the character is not a valid note letter.
 *
 * Note: Both "H" and "h" map to KeyRoot.HP (not KeyRoot.Hp) because we
 * normalize to uppercase before matching. The KeyRoot.Hp variant is not
 * used by this function.
 */
export function parseKeyRoot(char: string): KeyRoot | null {
  switch (char.toUpperCase()) {
    case "A": return KeyRoot.A;
    case "B": return KeyRoot.B;
    case "C": return KeyRoot.C;
    case "D": return KeyRoot.D;
    case "E": return KeyRoot.E;
    case "F": return KeyRoot.F;
    case "G": return KeyRoot.G;
    case "H": return KeyRoot.HP;  // Highland Pipes
    default: return null;
  }
}

/**
 * Parse an accidental character (#, b) to KeyAccidental.
 * Returns KeyAccidental.None for any other input.
 *
 * Note: This uses strict equality (===) and expects a single character.
 * The existing local function in info-line-analyzer.ts uses includes(),
 * which works differently for multi-character strings. When updating
 * info-line-analyzer.ts to use this shared function, verify that all
 * call sites pass single characters.
 */
export function parseKeyAccidental(char: string): KeyAccidental {
  if (char === "#") return KeyAccidental.Sharp;
  if (char === "b") return KeyAccidental.Flat;
  return KeyAccidental.None;
}
```

### 2.4 Update info-line-analyzer.ts

After creating `keyUtils.ts`, update `info-line-analyzer.ts` to import and use the shared functions instead of its local copies. This keeps the codebase DRY.

### 2.5 Tests

Test file: `parse/tests/keyUtils.spec.ts`

Example-based tests:
- `parseKeyRoot("C")` → `KeyRoot.C`
- `parseKeyRoot("c")` → `KeyRoot.C` (case insensitive)
- `parseKeyRoot("H")` → `KeyRoot.HP` (Highland Pipes, backward compatibility)
- `parseKeyRoot("X")` → `null`
- `parseKeyAccidental("#")` → `KeyAccidental.Sharp`
- `parseKeyAccidental("b")` → `KeyAccidental.Flat`
- `parseKeyAccidental("x")` → `KeyAccidental.None`
- `parseKeyAccidental("##")` → `KeyAccidental.None` (expects single char, not substring match)

---

## Phase 3: Chord Symbol Scanner

### 3.1 Location

`parse/music-theory/scanChordSymbol.ts`

### 3.2 Interface

```typescript
import { ChordToken, ChordTT } from "./types";

export interface ScanResult {
  tokens: ChordToken[];
  consumed: number;  // Number of characters consumed from input
}

export function scanChordSymbol(input: string): ScanResult | null
```

Returns `null` if the input does not start with a valid chord root, or a `ScanResult` with the tokens and consumed length if successful.

The `consumed` field allows callers to detect partial consumption (e.g., input "Am7xyz" would return tokens for "Am7" with `consumed: 3`). Callers can decide whether partial consumption is acceptable.

### 3.3 Scanner Context

We create a minimal scanner context for chord symbols:

```typescript
interface ChordScanCtx {
  source: string;
  current: number;
  tokens: ChordToken[];
}

function createChordScanCtx(source: string): ChordScanCtx {
  return { source, current: 0, tokens: [] };
}

function pushToken(ctx: ChordScanCtx, type: ChordTT, lexeme: string): void {
  ctx.tokens.push({ type, lexeme });
}
```

### 3.4 Algorithm

The scanner processes the chord symbol string left-to-right, consuming tokens in order:

```
scanChordSymbol(input):
  if input is empty: return null

  ctx = createChordScanCtx(input)

  // 1. Root (required)
  if not scanRoot(ctx): return null

  // 2. Root accidental (optional)
  scanAccidental(ctx)

  // 3. Quality (optional)
  scanQuality(ctx)

  // 4. Extension number (optional)
  scanExtension(ctx)

  // 5. Alterations (optional, repeatable)
  while scanAlteration(ctx): pass

  // 6. Bass note (optional)
  scanBass(ctx)

  return { tokens: ctx.tokens, consumed: ctx.current }
```

### 3.5 Individual Scan Functions

```
scanRoot(ctx):
  if ctx.current >= ctx.source.length: return false
  char = ctx.source[ctx.current]
  // Accept both uppercase and lowercase (A-G, a-g)
  if char.toUpperCase() in "ABCDEFG":
    pushToken(ctx, ChordTT.ROOT, char.toUpperCase())  // Normalize to uppercase
    ctx.current += 1
    return true
  return false

scanAccidental(ctx):
  if ctx.current >= ctx.source.length: return false
  char = ctx.source[ctx.current]
  if char == '#' or char == 'b':
    pushToken(ctx, ChordTT.ACCIDENTAL, char)
    ctx.current += 1
    return true
  return false

scanQuality(ctx):
  if ctx.current >= ctx.source.length: return false
  remaining = ctx.source.substring(ctx.current)

  // Order matters: longest match first
  // sus4 and sus2 must come before sus
  qualities = ["maj", "min", "dim", "aug", "sus4", "sus2", "sus", "add", "M", "m", "+", "-", "°", "ø", "Ø"]
  for q in qualities:
    if remaining.startsWith(q):
      pushToken(ctx, ChordTT.QUALITY, q)
      ctx.current += q.length
      return true
  return false

scanExtension(ctx):
  if ctx.current >= ctx.source.length: return false
  remaining = ctx.source.substring(ctx.current)

  // Match one or more digits
  match = /^[0-9]+/.exec(remaining)
  if match:
    pushToken(ctx, ChordTT.EXTENSION, match[0])
    ctx.current += match[0].length
    return true
  return false

scanAlteration(ctx):
  if ctx.current >= ctx.source.length: return false
  remaining = ctx.source.substring(ctx.current)

  // Match #N or bN where N is one or more digits
  match = /^[#b][0-9]+/.exec(remaining)
  if match:
    pushToken(ctx, ChordTT.ALTERATION, match[0])
    ctx.current += match[0].length
    return true
  return false

scanBass(ctx):
  if ctx.current >= ctx.source.length: return false
  if ctx.source[ctx.current] != '/': return false

  pushToken(ctx, ChordTT.BASS_SLASH, "/")
  ctx.current += 1

  // Bass root (required after slash)
  if not scanRoot(ctx):
    // Invalid: slash without bass root. Roll back the slash token.
    ctx.tokens.pop()
    ctx.current -= 1
    return false

  // Bass accidental (optional)
  scanAccidental(ctx)

  return true
```

### 3.6 Tests

Test file: `parse/tests/scanChordSymbol.spec.ts`

Example-based tests:
- `"C"` → `{ tokens: [ROOT("C")], consumed: 1 }`
- `"Am"` → `{ tokens: [ROOT("A"), QUALITY("m")], consumed: 2 }`
- `"G7"` → `{ tokens: [ROOT("G"), EXTENSION("7")], consumed: 2 }`
- `"F#m7"` → `{ tokens: [ROOT("F"), ACCIDENTAL("#"), QUALITY("m"), EXTENSION("7")], consumed: 4 }`
- `"Cmaj7"` → `{ tokens: [ROOT("C"), QUALITY("maj"), EXTENSION("7")], consumed: 5 }`
- `"Dm7b5"` → `{ tokens: [ROOT("D"), QUALITY("m"), EXTENSION("7"), ALTERATION("b5")], consumed: 5 }`
- `"Cmaj7#11"` → `{ tokens: [ROOT("C"), QUALITY("maj"), EXTENSION("7"), ALTERATION("#11")], consumed: 8 }`
- `"C7#9#11"` → `{ tokens: [ROOT("C"), EXTENSION("7"), ALTERATION("#9"), ALTERATION("#11")], consumed: 7 }` (multiple alterations)
- `"Bb/D"` → `{ tokens: [ROOT("B"), ACCIDENTAL("b"), BASS_SLASH("/"), ROOT("D")], consumed: 4 }`
- `"C°7"` → `{ tokens: [ROOT("C"), QUALITY("°"), EXTENSION("7")], consumed: 3 }`
- `"Cø7"` → `{ tokens: [ROOT("C"), QUALITY("ø"), EXTENSION("7")], consumed: 3 }`
- `"C+"` → `{ tokens: [ROOT("C"), QUALITY("+")], consumed: 2 }` (augmented with + symbol)
- `"Csus2"` → `{ tokens: [ROOT("C"), QUALITY("sus2")], consumed: 5 }`
- `"Csus4"` → `{ tokens: [ROOT("C"), QUALITY("sus4")], consumed: 5 }`
- `"Csus"` → `{ tokens: [ROOT("C"), QUALITY("sus")], consumed: 4 }` (defaults to sus4 in parser)
- `"C5"` → `{ tokens: [ROOT("C"), EXTENSION("5")], consumed: 2 }` (power chord)
- `"Cadd9"` → `{ tokens: [ROOT("C"), QUALITY("add"), EXTENSION("9")], consumed: 5 }`
- `"Cmaj"` → `{ tokens: [ROOT("C"), QUALITY("maj")], consumed: 4 }` (quality without extension)
- `"am7"` → `{ tokens: [ROOT("A"), QUALITY("m"), EXTENSION("7")], consumed: 3 }` (lowercase root normalized)
- `"Am7xyz"` → `{ tokens: [...], consumed: 3 }` (partial consumption, xyz not consumed)
- `"xyz"` → `null` (invalid, no root)
- `""` → `null` (empty)

Property-based tests:
- For any valid chord symbol matching `pChordSymbol`, `scanChordSymbol` returns non-null (note: `pChordSymbol` does not include `+`, `sus2`, or `sus4` as distinct patterns, so test only the symbols that `pChordSymbol` recognizes)
- For symbols using `+`, `sus2`, `sus4` notation, verify `scanChordSymbol` returns non-null even though `pChordSymbol` does not match these exactly
- The concatenation of all token lexemes equals the consumed portion of input

---

## Phase 4: Chord Symbol Parser

### 4.1 Location

`parse/music-theory/parseChordSymbol.ts`

### 4.2 Interface

```typescript
import { ChordToken, ParsedChord } from "./types";

export function parseChordSymbol(tokens: ChordToken[]): ParsedChord | null
```

### 4.3 Algorithm

The parser consumes tokens in order, building the `ParsedChord` structure. The key improvement is tracking whether quality was explicitly specified to avoid incorrect inference.

```
parseChordSymbol(tokens):
  if tokens.length == 0: return null

  index = 0
  qualityExplicit = false

  result = {
    root: KeyRoot.C,
    rootAccidental: KeyAccidental.None,
    quality: ChordQuality.Major,
    qualityExplicit: false,
    extension: null,
    alterations: [],
    bass: null
  }

  // 1. Root (required, first token)
  if tokens[index].type != ChordTT.ROOT: return null
  result.root = parseKeyRoot(tokens[index].lexeme)
  if result.root == null: return null
  index += 1

  // 2. Root accidental (optional)
  if index < tokens.length and tokens[index].type == ChordTT.ACCIDENTAL:
    result.rootAccidental = parseKeyAccidental(tokens[index].lexeme)
    index += 1

  // 3. Quality (optional)
  if index < tokens.length and tokens[index].type == ChordTT.QUALITY:
    result.quality = parseQuality(tokens[index].lexeme)
    qualityExplicit = true
    index += 1

  // 4. Extension (optional)
  // Only valid extensions are accepted: 5, 6, 7, 9, 11, 13, 69.
  // If the extension is not in this set, parsing fails (returns null).
  if index < tokens.length and tokens[index].type == ChordTT.EXTENSION:
    ext = parseInt(tokens[index].lexeme)
    if ext not in [5, 6, 7, 9, 11, 13, 69]:
      return null  // Invalid extension
    result.extension = ext
    index += 1

  // 5. Apply quality inference rules (only if quality was not explicit)
  if not qualityExplicit:
    result = applyQualityInference(result)

  result.qualityExplicit = qualityExplicit

  // 6. Alterations (optional, repeatable)
  while index < tokens.length and tokens[index].type == ChordTT.ALTERATION:
    alteration = parseAlteration(tokens[index].lexeme)
    result.alterations.push(alteration)
    index += 1

  // 7. Bass (optional)
  if index < tokens.length and tokens[index].type == ChordTT.BASS_SLASH:
    index += 1  // skip slash
    if index >= tokens.length or tokens[index].type != ChordTT.ROOT:
      return null  // invalid: slash without bass root
    bassRoot = parseKeyRoot(tokens[index].lexeme)
    if bassRoot == null: return null
    index += 1
    bassAcc = KeyAccidental.None
    if index < tokens.length and tokens[index].type == ChordTT.ACCIDENTAL:
      bassAcc = parseKeyAccidental(tokens[index].lexeme)
      index += 1
    result.bass = { root: bassRoot, accidental: bassAcc }

  return result
```

### 4.4 Helper Functions

```
parseQuality(lexeme):
  switch lexeme:
    case "maj", "M": return ChordQuality.Major
    case "min", "m", "-": return ChordQuality.Minor
    case "dim", "°": return ChordQuality.Diminished
    case "aug", "+": return ChordQuality.Augmented
    case "ø", "Ø": return ChordQuality.HalfDiminished
    case "sus": return ChordQuality.Suspended4  // sus alone defaults to sus4
    case "sus2": return ChordQuality.Suspended2
    case "sus4": return ChordQuality.Suspended4
    case "add": return ChordQuality.Add
  return ChordQuality.Major  // fallback

parseAlteration(lexeme):
  // lexeme is like "#5", "b9", "#11"
  type = lexeme[0] == "#" ? "sharp" : "flat"
  degree = parseInt(lexeme.substring(1))
  return { type, degree }
```

### 4.5 Quality Inference Rules

The `applyQualityInference` function applies rules only when quality was not explicitly specified:

```
applyQualityInference(result):
  ext = result.extension

  // Power chord: extension 5 with no explicit quality
  if ext == 5:
    result.quality = ChordQuality.Power
    return result

  // Dominant: extension 7, 9, 11, or 13 with no explicit quality
  // (e.g., "G7" becomes Dominant, not Major)
  if ext in [7, 9, 11, 13]:
    result.quality = ChordQuality.Dominant
    return result

  // Everything else stays Major (triads, 6th chords, etc.)
  return result
```

### 4.6 Quality Inference Summary

| Input | Quality Token | Extension | Inferred Quality |
|-------|---------------|-----------|------------------|
| `C` | none | none | Major |
| `C6` | none | 6 | Major (6th chord) |
| `C7` | none | 7 | Dominant |
| `C9` | none | 9 | Dominant |
| `C5` | none | 5 | Power |
| `Cmaj7` | maj | 7 | Major (explicit, no inference) |
| `Cm7` | m | 7 | Minor (explicit, no inference) |
| `Cdim7` | dim | 7 | Diminished (explicit, no inference) |

### 4.7 Tests

Test file: `parse/tests/parseChordSymbol.spec.ts`

Example-based tests:
- `"C"` → `{ root: C, quality: Major, qualityExplicit: false, extension: null }`
- `"Am"` → `{ root: A, quality: Minor, qualityExplicit: true, extension: null }`
- `"G7"` → `{ root: G, quality: Dominant, qualityExplicit: false, extension: 7 }`
- `"Cmaj7"` → `{ root: C, quality: Major, qualityExplicit: true, extension: 7 }` (NOT Dominant)
- `"Cmaj9"` → `{ root: C, quality: Major, qualityExplicit: true, extension: 9 }` (NOT Dominant)
- `"Cm7"` → `{ root: C, quality: Minor, qualityExplicit: true, extension: 7 }`
- `"C5"` → `{ root: C, quality: Power, qualityExplicit: false, extension: 5 }`
- `"Cdim7"` → `{ root: C, quality: Diminished, qualityExplicit: true, extension: 7 }`
- `"Cø7"` → `{ root: C, quality: HalfDiminished, qualityExplicit: true, extension: 7 }`
- `"Dm7b5"` → `{ root: D, quality: Minor, extension: 7, alterations: [{ flat, 5 }] }`
- `"Csus2"` → `{ root: C, quality: Suspended2, qualityExplicit: true }`
- `"Csus4"` → `{ root: C, quality: Suspended4, qualityExplicit: true }`
- `"Csus"` → `{ root: C, quality: Suspended4, qualityExplicit: true }` (sus defaults to sus4)
- `"Cadd9"` → `{ root: C, quality: Add, qualityExplicit: true, extension: 9 }`
- `"Cadd6"` → `{ root: C, quality: Add, qualityExplicit: true, extension: 6 }`
- `"C+"` → `{ root: C, quality: Augmented, qualityExplicit: true }`
- `"F#m7"` → `{ root: F, rootAccidental: Sharp, quality: Minor, extension: 7 }`
- `"Bb/D"` → `{ root: B, rootAccidental: Flat, quality: Major, bass: { root: D } }`
- `"Cmaj"` → `{ root: C, quality: Major, qualityExplicit: true, extension: null }` (quality without extension)
- `"Cadd7"` → `{ root: C, quality: Add, qualityExplicit: true, extension: 7 }` (unusual but valid)
- `"C3"` → `null` (invalid extension, rejected)
- `"C99"` → `null` (invalid extension, rejected)
- `"C0"` → `null` (invalid extension, rejected)

Integration tests (scan + parse):
- Round-trip: for valid chord symbols, `parseChordSymbol(scanChordSymbol(str).tokens)` produces a valid `ParsedChord`

---

## Phase 5: Chord to Pitches Conversion

### 5.1 Location

`parse/music-theory/chordPitches.ts`

### 5.2 Interface

```typescript
import { ParsedChord } from "./types";

export function chordToPitches(chord: ParsedChord, baseOctave: number = 4): number[] | null
```

Returns an array of MIDI pitch numbers for the chord tones, sorted ascending. Returns `null` if the chord root is not a standard note (A-G). Highland Pipes roots (KeyRoot.HP, KeyRoot.Hp) are rejected because they do not correspond to a specific pitch.

### 5.3 Interval Tables

We define interval patterns for each chord quality in semitones from the root:

```typescript
import { ChordQuality, ParsedChord } from "./types";
import { KeyRoot, KeyAccidental } from "../types/abcjs-ast";

const QUALITY_INTERVALS: Record<ChordQuality, number[]> = {
  [ChordQuality.Major]: [0, 4, 7],              // 1, 3, 5
  [ChordQuality.Minor]: [0, 3, 7],              // 1, b3, 5
  [ChordQuality.Dominant]: [0, 4, 7, 10],       // 1, 3, 5, b7
  [ChordQuality.Diminished]: [0, 3, 6],         // 1, b3, b5 (triad only)
  [ChordQuality.Augmented]: [0, 4, 8],          // 1, 3, #5
  [ChordQuality.HalfDiminished]: [0, 3, 6, 10], // 1, b3, b5, b7
  [ChordQuality.Suspended2]: [0, 2, 7],         // 1, 2, 5
  [ChordQuality.Suspended4]: [0, 5, 7],         // 1, 4, 5
  [ChordQuality.Power]: [0, 7],                 // 1, 5
  [ChordQuality.Add]: [0, 4, 7],                // 1, 3, 5 (extension added separately)
};

// Only standard note roots are supported. KeyRoot.HP and KeyRoot.Hp (Highland Pipes)
// are not included because they do not map to a specific pitch.
const ROOT_TO_SEMITONE: Partial<Record<KeyRoot, number>> = {
  [KeyRoot.C]: 0,
  [KeyRoot.D]: 2,
  [KeyRoot.E]: 4,
  [KeyRoot.F]: 5,
  [KeyRoot.G]: 7,
  [KeyRoot.A]: 9,
  [KeyRoot.B]: 11,
};

// Maps scale degrees to their natural interval in semitones.
// Note: Degree 6 is not included because 6th alterations (#6, b6) are uncommon
// in jazz chord notation. Alterations on degree 6 will be silently ignored.
const DEGREE_TO_INTERVAL: Record<number, number> = {
  3: 4,    // major 3rd
  5: 7,    // perfect 5th
  7: 11,   // major 7th
  9: 14,   // major 9th (= major 2nd + octave)
  11: 17,  // perfect 11th (= perfect 4th + octave)
  13: 21,  // major 13th (= major 6th + octave)
};
```

### 5.4 Algorithm

```
chordToPitches(chord, baseOctave = 4):
  // 0. Validate root is a standard note (reject Highland Pipes)
  if chord.root not in ROOT_TO_SEMITONE:
    return null

  // 1. Calculate root MIDI pitch
  // MIDI pitch formula: (octave + 1) * 12 + semitone
  // This places C4 at MIDI 60: (4 + 1) * 12 + 0 = 60
  rootSemitone = ROOT_TO_SEMITONE[chord.root]
  if chord.rootAccidental == KeyAccidental.Sharp: rootSemitone += 1
  if chord.rootAccidental == KeyAccidental.Flat: rootSemitone -= 1
  rootMidi = (baseOctave + 1) * 12 + rootSemitone

  // 2. Get base intervals from quality
  intervals = [...QUALITY_INTERVALS[chord.quality]]

  // 3. Add extension intervals based on chord type and extension
  if chord.extension != null:
    intervals = addExtensionIntervals(intervals, chord)

  // 4. Apply alterations
  for alt in chord.alterations:
    intervals = applyAlteration(intervals, alt)

  // 5. Convert intervals to MIDI pitches
  pitches = []
  for interval in intervals:
    pitches.push(rootMidi + interval)

  return pitches.sort((a, b) => a - b)
```

### 5.5 Extension Interval Logic

```
addExtensionIntervals(intervals, chord):
  ext = chord.extension
  quality = chord.quality

  // Special case: Add quality just adds the extension to triad (no stacked extensions)
  // For "add" chords, we add only the specified extension without intermediate tones.
  if quality == ChordQuality.Add:
    if ext == 6: intervals.push(9)    // add6 (same as C6, but with explicit "add")
    if ext == 7: intervals.push(11)   // add7 (unusual, but adds major 7th to triad)
    if ext == 9: intervals.push(14)   // add9
    if ext == 11: intervals.push(17)  // add11
    if ext == 13: intervals.push(21)  // add13
    return intervals

  // Power chord: no additional intervals
  if quality == ChordQuality.Power:
    return intervals

  // 6th chord: add major 6th
  if ext == 6:
    intervals.push(9)  // major 6th = 9 semitones
    return intervals

  // 69 chord: add major 6th and major 9th
  if ext == 69:
    intervals.push(9, 14)
    return intervals

  // 7th and beyond: add appropriate 7th first
  if ext >= 7:
    // Diminished 7th chord uses diminished 7th interval (9 semitones)
    if quality == ChordQuality.Diminished:
      if 9 not in intervals:
        intervals.push(9)  // diminished 7th
    // Major quality with 7th uses major 7th (11 semitones)
    else if quality == ChordQuality.Major:
      if 11 not in intervals:
        intervals.push(11)  // major 7th
    // All others (Dominant, Minor, etc.) use minor 7th (10 semitones)
    else:
      if 10 not in intervals:
        intervals.push(10)  // minor 7th

  // 9th and beyond: add 9th
  if ext >= 9:
    intervals.push(14)  // major 9th

  // 11th and beyond: add 11th
  if ext >= 11:
    intervals.push(17)  // perfect 11th

  // 13th: add 13th
  if ext >= 13:
    intervals.push(21)  // major 13th

  return intervals
```

### 5.6 Alteration Logic

```
applyAlteration(intervals, alt):
  degree = alt.degree

  // Get the natural interval for this degree
  if degree not in DEGREE_TO_INTERVAL:
    return intervals  // Unknown degree, skip

  naturalInterval = DEGREE_TO_INTERVAL[degree]

  if alt.type == "sharp":
    alteredInterval = naturalInterval + 1
  else:  // flat
    alteredInterval = naturalInterval - 1

  // Replace natural with altered if present, otherwise add altered
  newIntervals = []
  found = false
  for interval in intervals:
    if interval == naturalInterval:
      newIntervals.push(alteredInterval)
      found = true
    else:
      newIntervals.push(interval)

  // If natural interval was not present, add the altered interval anyway
  // (e.g., Cmaj7#11 adds #11 even though 11 wasn't explicitly present)
  if not found:
    newIntervals.push(alteredInterval)

  return newIntervals
```

### 5.7 Tests

Test file: `parse/tests/chordPitches.spec.ts`

Example-based tests (using C4 = 60 as reference):
- `C` (C major) → `[60, 64, 67]` (C, E, G)
- `Cm` (C minor) → `[60, 63, 67]` (C, Eb, G)
- `C7` (C dominant 7) → `[60, 64, 67, 70]` (C, E, G, Bb)
- `Cmaj7` (C major 7) → `[60, 64, 67, 71]` (C, E, G, B)
- `Cm7` (C minor 7) → `[60, 63, 67, 70]` (C, Eb, G, Bb)
- `Cdim` (C diminished triad) → `[60, 63, 66]` (C, Eb, Gb)
- `Cdim7` (C diminished 7) → `[60, 63, 66, 69]` (C, Eb, Gb, Bbb/A) - uses dim 7th (9 semitones)
- `Cø7` (C half-diminished) → `[60, 63, 66, 70]` (C, Eb, Gb, Bb) - uses minor 7th (10 semitones)
- `Cm7b5` → `[60, 63, 66, 70]` (same as half-diminished via alteration)
- `Caug` or `C+` → `[60, 64, 68]` (C, E, G#)
- `Csus2` → `[60, 62, 67]` (C, D, G)
- `Csus4` → `[60, 65, 67]` (C, F, G)
- `C5` (power chord) → `[60, 67]` (C, G)
- `C6` → `[60, 64, 67, 69]` (C, E, G, A)
- `C69` → `[60, 64, 67, 69, 74]` (C, E, G, A, D)
- `Cadd9` → `[60, 64, 67, 74]` (C, E, G, D - no 7th)
- `Cadd6` → `[60, 64, 67, 69]` (C, E, G, A - same as C6 but with explicit "add")
- `Cadd7` → `[60, 64, 67, 71]` (C, E, G, B - triad plus major 7th, unusual but valid; note: produces same pitches as Cmaj7)
- `Cmaj7#11` → `[60, 64, 67, 71, 78]` (C, E, G, B, F#)
- `C7b9` → `[60, 64, 67, 70, 73]` (C, E, G, Bb, Db)
- `C7#9#11` → `[60, 64, 67, 70, 75, 78]` (C, E, G, Bb, D#, F#) - multiple alterations
- `Am` at octave 4 → `[69, 72, 76]` (A4, C5, E5)
- `Am` at octave 3 → `[57, 60, 64]` (A3, C4, E4)
- Chord with `root: KeyRoot.HP` → `null` (Highland Pipes rejected)

Property-based tests:
- All returned pitches are in valid MIDI range [0, 127]
- Pitches are sorted ascending
- The first pitch corresponds to the root pitch (rootMidi)
- Pitch count >= 2 for all chords (at minimum root + one other note)

---

## Phase 6: Backtrack Selector

### 6.1 Location

`abct2/src/selectors/backtrackSelector.ts`

### 6.2 Interface

```typescript
import { Selection } from "../selection";
import { CSNode } from "../csTree/types";
import { ParsedChord } from "abc-parser/music-theory";

export interface ChordSymbolMatch {
  node: CSNode;
  parsed: ParsedChord;
}

export function selectPreviousChordSymbol(
  selection: Selection,
  samePhysicalLine: boolean = true
): ChordSymbolMatch | null
```

The `samePhysicalLine` parameter controls whether to stop at physical line breaks (EOL tokens). When `true`, the search only considers chord symbols on the same physical line as the target node. When `false`, the search continues across line breaks.

Note: This uses physical lines (delimited by EOL tokens), not logical music lines (which may span physical lines via `\` continuation). For most use cases, physical line boundaries are the appropriate stopping point.

### 6.3 Algorithm (Functional Approach)

We use the functional approach: walk from root to target, collect nodes in order, then reverse-iterate to find the chord symbol. This avoids storing prev pointers that would become stale after tree modifications.

```
selectPreviousChordSymbol(selection, samePhysicalLine = true):
  // Get the target node from the first cursor
  if selection.cursors.length == 0: return null
  cursor = selection.cursors[0]
  targetNodes = findNodesById(selection.root, cursor)
  if targetNodes.length == 0: return null
  targetNode = targetNodes[0]

  // Collect all nodes before target in depth-first traversal order
  nodesBeforeTarget = collectNodesBefore(selection.root, targetNode)

  // Reverse iterate to find chord symbol
  for i from nodesBeforeTarget.length - 1 down to 0:
    node = nodesBeforeTarget[i]

    // If samePhysicalLine is true, stop at line boundaries
    if samePhysicalLine and isEOL(node):
      return null

    // Check if node is an Annotation or ChordSymbol
    if node.tag == TAGS.Annotation or node.tag == TAGS.ChordSymbol:
      text = extractChordText(node)
      if text == null: continue

      scanResult = scanChordSymbol(text)
      if scanResult == null: continue

      parsed = parseChordSymbol(scanResult.tokens)
      if parsed != null:
        return { node, parsed }

  return null

collectNodesBefore(root, target):
  result = []
  walkAndCollect(root, target, result)
  return result

walkAndCollect(node, target, result):
  if node === target: return true  // Found target, stop collecting

  result.push(node)

  // Recurse into children (depth-first)
  current = node.firstChild
  while current != null:
    if walkAndCollect(current, target, result):
      return true
    current = current.nextSibling

  return false

extractChordText(node):
  // Both ChordSymbol and Annotation nodes have a single Token child node.
  // The Token child has tag TAGS.Token and its data contains the lexeme.
  // We use isTokenNode guard before calling getTokenData for safety.

  if node.tag == TAGS.ChordSymbol:
    firstChild = node.firstChild
    if firstChild == null: return null
    if not isTokenNode(firstChild): return null
    return getTokenData(firstChild).lexeme

  if node.tag == TAGS.Annotation:
    firstChild = node.firstChild
    if firstChild == null: return null
    if not isTokenNode(firstChild): return null
    text = getTokenData(firstChild).lexeme
    // Strip surrounding double quotes (ABC annotations use double quotes only)
    if text.length >= 2 and text.startsWith('"') and text.endsWith('"'):
      return text.slice(1, -1)
    return text

  return null

isEOL(node):
  // Check if node is an EOL token
  if not isTokenNode(node): return false
  data = getTokenData(node)
  return data.tokenType == TT.EOL
```

### 6.4 Tests

Test file: `abct2/tests/backtrackSelector.spec.ts`

Example-based tests using parsed ABC source:

```
// Test 1: Basic chord symbol lookup
Input: X:1\nK:C\n"Am" C D E|\n
Cursor on: E note
Expected: { node: Am annotation, parsed: { root: A, quality: Minor } }

// Test 2: Multiple chord symbols, returns nearest
Input: X:1\nK:C\n"Am" C "G7" D E|\n
Cursor on: E note
Expected: { node: G7 annotation, parsed: { root: G, quality: Dominant, extension: 7 } }

// Test 3: Chord symbol on different line (samePhysicalLine=true)
Input: X:1\nK:C\n"Am" C D|\nE F G|\n
Cursor on: E note (second line)
Expected: null (Am is on previous line)

// Test 4: Chord symbol on different line (samePhysicalLine=false)
Input: X:1\nK:C\n"Am" C D|\nE F G|\n
Cursor on: E note (second line)
Expected: { node: Am annotation, parsed: { root: A, quality: Minor } }

// Test 5: No chord symbol in source
Input: X:1\nK:C\nC D E|\n
Cursor on: E note
Expected: null

// Test 6: Non-chord annotation is skipped
Input: X:1\nK:C\n"hello" C "Am" D E|\n
Cursor on: E note
Expected: { node: Am annotation } (skips "hello" because it's not a valid chord)

// Test 7: ChordSymbol node (from ABCx format)
Input: (ABCx source with ChordSymbol nodes)
Expected: Works the same as annotations
```

---

## Phase 7: Integration Helper

### 7.1 Location

`parse/music-theory/index.ts`

### 7.2 Convenience Function

We provide a single entry point that combines scanning, parsing, and pitch generation:

```typescript
import { scanChordSymbol } from "./scanChordSymbol";
import { parseChordSymbol } from "./parseChordSymbol";
import { chordToPitches } from "./chordPitches";
import { ParsedChord } from "./types";

export interface ChordInfo {
  parsed: ParsedChord;
  pitches: number[];
}

export function analyzeChordSymbol(
  text: string,
  baseOctave: number = 4
): ChordInfo | null {
  const scanResult = scanChordSymbol(text);
  if (!scanResult) return null;

  const parsed = parseChordSymbol(scanResult.tokens);
  if (!parsed) return null;

  const pitches = chordToPitches(parsed, baseOctave);

  return { parsed, pitches };
}
```

### 7.3 Re-exports

The `index.ts` file defines `analyzeChordSymbol` and `ChordInfo` directly (as shown in section 7.2), and re-exports the other symbols:

```typescript
// Re-export from submodules
export { scanChordSymbol, ScanResult } from "./scanChordSymbol";
export { parseChordSymbol } from "./parseChordSymbol";
export { chordToPitches } from "./chordPitches";
export {
  ParsedChord,
  ChordQuality,
  ChordAlteration,
  ChordTT,
  ChordToken
} from "./types";

// Re-export shared key utilities for external consumers (like abct2)
export { parseKeyRoot, parseKeyAccidental } from "../utils/keyUtils";

// analyzeChordSymbol and ChordInfo are defined in this file (see section 7.2)
// and exported directly, not re-exported from another module
```

---

## To Do List

### Phase 1: Types and Data Structures
- Create `parse/music-theory/` directory
- Create `parse/music-theory/types.ts` with `ChordQuality`, `ChordAlteration`, `ParsedChord`, `ChordTT`, `ChordToken`
- Run `npm run build` to verify no type errors

### Phase 2: Shared Key Utilities
- Create `parse/utils/` directory (if it does not exist)
- Create `parse/utils/keyUtils.ts` with `parseKeyRoot` (including H for Highland Pipes), `parseKeyAccidental`
- Create `parse/tests/keyUtils.spec.ts` with tests (including H case and single-char verification)
- Audit call sites of `parseKeyAccidental` in `info-line-analyzer.ts`:
  - Search for all calls to `parseKeyAccidental` in the file
  - For each call site, trace what string is being passed
  - The existing function uses `str.includes()`, so it works with multi-char strings
  - The new function uses strict equality `===`, so it expects single chars
  - If a call site passes a multi-char string (e.g., "C#" or "Bb"), update it to:
    - Extract just the accidental character (index 1 for "C#" format), or
    - Use a different approach if the accidental position varies
  - Document any call site changes in a code comment
- Update `parse/analyzers/info-line-analyzer.ts` to import from `keyUtils.ts` instead of using local copies
- Run `npm run test` to verify tests pass

### Phase 3: Chord Symbol Scanner
- Create `parse/music-theory/scanChordSymbol.ts`
- Implement `ChordScanCtx`, `createChordScanCtx`, `pushToken`
- Implement `scanRoot` (with lowercase normalization), `scanAccidental`, `scanQuality` (with sus2, sus4, +), `scanExtension`, `scanAlteration`, `scanBass`
- Implement `scanChordSymbol` main function returning `ScanResult`
- Create `parse/tests/scanChordSymbol.spec.ts` with example-based tests
- Run `npm run test`

### Phase 4: Chord Symbol Parser
- Create `parse/music-theory/parseChordSymbol.ts`
- Import `parseKeyRoot`, `parseKeyAccidental` from `parse/utils/keyUtils.ts`
- Implement `parseQuality` (handle sus, sus2, sus4, +, add), `parseAlteration`
- Implement `applyQualityInference` (Dominant for 7/9/11/13, Power for 5)
- Implement `parseChordSymbol` with `qualityExplicit` tracking and extension validation
- Add extension validation: only accept 5, 6, 7, 9, 11, 13, 69; return null for invalid extensions
- Create `parse/tests/parseChordSymbol.spec.ts` with example-based tests
- Verify `Cmaj7` stays Major (not Dominant) due to explicit quality
- Verify `Cmaj` (quality without extension) parses correctly
- Verify `Cadd7` parses correctly (unusual but valid)
- Verify `C3`, `C99`, `C0` return null (invalid extensions rejected)
- Add integration tests (scan + parse)
- Run `npm run test`

### Phase 5: Chord to Pitches Conversion
- Create `parse/music-theory/chordPitches.ts`
- Define `QUALITY_INTERVALS`, `ROOT_TO_SEMITONE` (partial, excluding HP/Hp), `DEGREE_TO_INTERVAL` tables
- Add validation at start of `chordToPitches` to return null for Highland Pipes roots
- Implement `addExtensionIntervals` with special cases for Add (including add6, add7), Power, dim7
- Implement `applyAlteration` with replace-or-add logic
- Implement `chordToPitches` function returning `number[] | null`
- Create `parse/tests/chordPitches.spec.ts` with example-based tests
- Verify `Cdim7` produces diminished 7th (9 semitones), not minor 7th
- Verify `Cadd6` produces triad plus 6th
- Verify `Cadd7` produces triad plus major 7th
- Verify chord with `KeyRoot.HP` returns null
- Add property-based tests for MIDI range and sorting
- Run `npm run test`

### Phase 6: Backtrack Selector
- Create `abct2/src/selectors/backtrackSelector.ts`
- Import from `abc-parser/music-theory` (verify package exports)
- Import `isTokenNode`, `getTokenData`, `TAGS`, `CSNode` from `../csTree/types`
- Import `TT` from `abc-parser` for EOL token type check
- Verify that EOL tokens appear in the CSTree after parsing (add a test case that parses multi-line ABC and checks for EOL token nodes)
- Implement `collectNodesBefore`, `walkAndCollect` helpers
- Implement `extractChordText` (handle both Annotation and ChordSymbol tags; use `isTokenNode` guard before calling `getTokenData`)
- Implement `isEOL` (use only `TT.EOL`, not `TT.NEWLINE`)
- Implement `selectPreviousChordSymbol` with `samePhysicalLine` parameter
- Create `abct2/tests/backtrackSelector.spec.ts` using full parse pipeline (parse ABC string, convert to CSTree, create Selection, call selector)
- Run `npm run test`

### Phase 7: Integration
- Create `parse/music-theory/index.ts` with `analyzeChordSymbol` and re-exports
- Include re-export of `parseKeyRoot`, `parseKeyAccidental` from `../utils/keyUtils` for external consumers
- Update `parse/index.ts` to export music-theory module
- Run `npm run build` and `npm run test`

### Final Steps
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Critical Files Reference

| File | Purpose |
|------|---------|
| `parse/types/abcjs-ast.ts` | KeyRoot, KeyAccidental enums |
| `parse/analyzers/info-line-analyzer.ts` | Update to use shared keyUtils |
| `parse/parsers/scan_abcx_tunebody.ts:49` | pChordSymbol regex (reference) |
| `parse/parsers/scan2.ts` | TT enum (reference for TT.EOL) |
| `abct2/src/csTree/types.ts` | CSNode, TAGS, getTokenData, isTokenNode |
| `abct2/src/transforms/types.ts` | findNodesById |
| `abct2/src/selection.ts` | Selection type |
