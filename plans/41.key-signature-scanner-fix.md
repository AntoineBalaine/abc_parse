# K: Info Line Scanner Fix

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Current State Analysis](#current-state-analysis)
3. [Design](#design)
4. [Implementation Plan](#implementation-plan)
5. [Files to Modify](#files-to-modify)
6. [Verification](#verification)
7. [To Do List](#to-do-list)

---

## Problem Statement

For "K:C#m clef=treble", the current scanner produces:
```
K:    → TT.INF_HDR
C     → TT.NOTE_LETTER
#     → TT.ACCIDENTAL
m     → TT.IDENTIFIER   ← WRONG: mode split from root!
clef  → TT.IDENTIFIER
...
```

The mode "m" is separated from the root "C#" because `absolutePitch()` only captures octave digits, not mode identifiers. The semantic analyzer must then piece together separate tokens.

We should tokenize as:
```
K:    → TT.INF_HDR
C#m   → TT.KEY_SIGNATURE (single token, dedicated type)
clef  → TT.IDENTIFIER
...
```

---

## Current State Analysis

### K: Info Line Scanner (The Problem)
- `scanInfoLine2.ts`: `absolutePitch()` captures NOTE_LETTER + ACCIDENTAL + optional octave
- Mode identifiers (m, maj, min, dorian, etc.) fall through to `identifier()`
- Semantic analyzer must reconstruct key signature from separate tokens

### Key Signature Grammar
```
Key Signature:  Root[Accidental]?[Mode]?
                C#m, Dmaj, F#, Bb, Gdor, Amix, Ephr, Blyd
                HP, Hp (Highland Pipes)
                none
```

### Critical Context Issue
The `scanInfoLine2.ts` scanner is GENERIC for all info lines (K:, M:, L:, Q:, V:). If we add `keySignature()` to this generic scanner, it would incorrectly match in non-K: contexts:
- `V:DMix` would be incorrectly tokenized as KEY_SIGNATURE("DMix") instead of IDENTIFIER("DMix")
- `M:C` should be SPECIAL_LITERAL("C"), not KEY_SIGNATURE("C")

Solution: Create a dedicated `scanKeyInfoLine()` function or pass context to the scanner.

---

## Design

Create a dedicated `TT.KEY_SIGNATURE` token type with context-aware scanning:

1. Add `TT.KEY_SIGNATURE` token type to the main scanner
2. Create a dedicated `scanKeyInfoLine()` function (not modify the generic `scanInfoLine2()`)
3. Update `scan2.ts` to dispatch K: info lines to `scanKeyInfoLine()` instead of `scanInfoLine2()`

This approach:
- Keeps key signatures and chord symbols semantically distinct
- Avoids context confusion (K: vs M: vs V:)
- Simplifies the semantic analyzer (no context-based interpretation needed)
- Does not affect other info line types

---

## Implementation Plan

1. **Add `TT.KEY_SIGNATURE` token type**
   - File: `parse/parsers/scan2.ts` (line ~291, near CHORD_SYMBOL)
   - Add: `KEY_SIGNATURE, // Key signature (e.g., C#m, Dmaj, F#, Gdor, HP, none)`

2. **Create `scanKeyInfoLine()` function**
   - File: `parse/parsers/infoLines/scanKeyInfoLine.ts` (NEW FILE)
   - Dedicated scanner for K: info lines only
   - Contains `keySignature()` function with pattern:
     ```
     /^([A-Ga-g][#b]?(m(aj(or)?|in(or)?|ix(olydian)?)?|dor(ian)?|phr(ygian)?|lyd(ian)?|loc(rian)?|ion(ian)?|aeo(lian)?)?|HP|Hp|none)(?=[=\s%\n\]|]|$)/i
     ```
   - Pattern covers:
     - Note roots A-G (case insensitive)
     - Accidentals # and b
     - All mode variants: m, maj, major, min, minor, mix, mixolydian, dor, dorian, etc.
     - Highland Pipes: HP, Hp
     - None: none
   - Reuse existing helpers: `WS()`, `identifier()`, `singleChar()`, etc. from scanInfoLine2.ts

3. **Update `scan2.ts` dispatch logic**
   - File: `parse/parsers/scan2.ts` (line ~356)
   - Change K: dispatch from `scanInfoLine2(ctx)` to `scanKeyInfoLine(ctx)`
   - Keep M:, L:, Q:, V: using `scanInfoLine2(ctx)`

4. **Update `info-line-analyzer.ts` analyzeKeyInfo function**
   - File: `parse/analyzers/info-line-analyzer.ts`
   - Handle `TT.KEY_SIGNATURE` token type as first token
   - Parse pattern: `^([A-Ga-g])([#b])?(.*)$` to split "C#m" into ("C", "#", "m")
   - Handle special cases: "HP", "Hp", "none"
   - Continue using existing `parseKeyRoot()` and `parseKeyMode()` helpers
   - The semantic analyzer output format (KeyInfo) remains unchanged

5. **Create `genKeySignature` generator for PBT**
   - File: `parse/tests/scn_infoln_generators.ts`
   - Generator produces `TT.KEY_SIGNATURE` tokens with valid key signature lexemes
   - Must cover all variants:
     - Note roots: A-G (uppercase)
     - Accidentals: #, b (or none)
     - Modes: m, maj, major, min, minor, mix, mixolydian, dor, dorian, phr, phrygian, lyd, lydian, loc, locrian, ion, ionian, aeo, aeolian (or none)
     - Special: HP, Hp, none
   - Examples: "C", "Am", "F#m", "Bbmaj", "Gdor", "Amix", "HP", "none"

6. **Update `genKeyInfoLine2` generator**
   - File: `parse/tests/scn_infoln_generators.ts`
   - Replace current multi-token approach (NOTE_LETTER + ACCIDENTAL + IDENTIFIER)
   - Use new `genKeySignature` generator to produce single KEY_SIGNATURE token
   - Keep modifier handling (clef=treble, transpose=0, etc.) unchanged

7. **Update `genKeyExprArray` generator**
   - File: `parse/tests/scn_infoln_generators.ts`
   - Update to handle KEY_SIGNATURE token type instead of separate tokens

8. **Add example-based scanner tests**
   - File: `parse/tests/scanInfoLine2.spec.ts`
   - Test cases: "K:C", "K:C#m", "K:Dmaj", "K:Gdor", "K:F# clef=bass"
   - Verify single KEY_SIGNATURE token for key signature

9. **Verify PBT round-trip tests pass**
   - File: `parse/tests/scanInfoLine2.spec.ts` - "should handle key info lines"
   - File: `parse/tests/parseInfoLine2.spec.ts` - "should handle specific info lines"
   - These tests use `genKeyInfoLine2` and must pass with new generator

10. **Verify parser integration PBT tests pass**
    - File: `parse/tests/prs_pbt.spec.ts`
    - File: `parse/tests/interpreter-comparison/interpreter-comparison.pbt.spec.ts`
    - These tests use info line generators and must pass

11. **Interpreter unchanged**
    - The interpreter receives `KeyInfo` from semantic analyzer
    - Since the `KeyInfo` structure is unchanged, no interpreter changes are needed

---

## Files to Modify

| File | Action |
|------|--------|
| `parse/parsers/scan2.ts` | Add `TT.KEY_SIGNATURE` token type, update K: dispatch to use `scanKeyInfoLine()` |
| `parse/parsers/infoLines/scanKeyInfoLine.ts` | NEW FILE: dedicated K: info line scanner with `keySignature()` function |
| `parse/analyzers/info-line-analyzer.ts` | Handle `TT.KEY_SIGNATURE` in `analyzeKeyInfo()` |
| `parse/tests/scn_infoln_generators.ts` | Add `genKeySignature`, update `genKeyInfoLine2`, update `genKeyExprArray` |
| `parse/tests/scanInfoLine2.spec.ts` | Add example-based tests for KEY_SIGNATURE tokenization |
| `parse/tests/info-line-analyzer-key.spec.ts` | Update tests to use `TT.KEY_SIGNATURE` tokens |

---

## Verification

1. **Scanner produces KEY_SIGNATURE tokens for K: lines**:
   - "K:C" → `[TT.INF_HDR("K:"), TT.KEY_SIGNATURE("C")]`
   - "K:C#m" → `[TT.INF_HDR("K:"), TT.KEY_SIGNATURE("C#m")]`
   - "K:Gdor clef=treble" → `[TT.INF_HDR("K:"), TT.KEY_SIGNATURE("Gdor"), TT.IDENTIFIER("clef"), TT.EQL, TT.IDENTIFIER("treble")]`
   - "K:HP" → `[TT.INF_HDR("K:"), TT.KEY_SIGNATURE("HP")]`
   - "K:none" → `[TT.INF_HDR("K:"), TT.KEY_SIGNATURE("none")]`
   - "K:Bbmajor" → `[TT.INF_HDR("K:"), TT.KEY_SIGNATURE("Bbmajor")]`

2. **Analyzer produces correct KeyInfo**:
   - "K:C#m" → `{ keySignature: { root: KeyRoot.C, acc: KeyAccidental.Sharp, mode: KeyMode.Minor } }`
   - "K:HP" → `{ keySignature: { root: KeyRoot.HP, acc: KeyAccidental.None, mode: undefined } }`
   - "K:none" → handled as special case (no key signature)

3. **Other info lines NOT affected** (context isolation):
   - "M:C" → `[TT.INF_HDR("M:"), TT.SPECIAL_LITERAL("C")]` (not KEY_SIGNATURE)
   - "V:DMix" → `[TT.INF_HDR("V:"), TT.IDENTIFIER("DMix")]` (not KEY_SIGNATURE)
   - "Q:1/4=120" → unchanged
   - "L:1/8" → unchanged

---

## To Do List

1. Copy this plan file to `abc_parse/plans/41.key-signature-scanner-fix.md`
2. Add `TT.KEY_SIGNATURE` to `parse/parsers/scan2.ts`
3. Create `parse/parsers/infoLines/scanKeyInfoLine.ts` with `keySignature()` function
4. Update `scan2.ts` dispatch to use `scanKeyInfoLine()` for K: info lines
5. Update `analyzeKeyInfo()` in `parse/analyzers/info-line-analyzer.ts` to handle `TT.KEY_SIGNATURE`
6. Create `genKeySignature` generator in `parse/tests/scn_infoln_generators.ts`
7. Update `genKeyInfoLine2` generator to use `genKeySignature`
8. Update `genKeyExprArray` generator to handle `TT.KEY_SIGNATURE`
9. Update `parse/tests/info-line-analyzer-key.spec.ts` to use `TT.KEY_SIGNATURE` tokens
10. Add example-based scanner tests in `parse/tests/scanInfoLine2.spec.ts`
11. Run `npm run test` to verify all tests pass (including PBT round-trip tests)
12. Final verification: build and tests both pass.
13. Call the code review agent. Address any feedback.
14. Commit once the build passes and all tests pass.
