# Plan 43: Diatonic Harmonize Transform

## Table of Contents

1. [Overview](#overview)
2. [Algorithm Design](#algorithm-design)
3. [Phase 1: Visitor Implementation](#phase-1-visitor-implementation)
4. [Phase 2: LSP Server Integration](#phase-2-lsp-server-integration)
5. [Phase 3: Neovim Plugin Integration](#phase-3-neovim-plugin-integration)
6. [Phase 4: VSCode Extension Integration](#phase-4-vscode-extension-integration)
7. [Testing Strategy](#testing-strategy)
8. [To Do List](#to-do-list)

---

## Overview

We implement a diatonic harmonization transform that adds a parallel harmony voice to selected notes. Because we use a purely diatonic approach (without key signature context), we operate on the pitch sequence where:

- Uppercase letters `C D E F G A B` represent octave 4
- Lowercase letters `c d e f g a b` represent octave 5
- Each comma `,` suffix lowers the pitch by one octave (e.g., `C,` is octave 3, `C,,` is octave 2)
- Each apostrophe `'` suffix raises the pitch by one octave (e.g., `c'` is octave 6, `c''` is octave 7)

The full ascending sequence is: `C, D, E, F, G, A, B, C D E F G A B c d e f g a b c' d' e' f' g' a' b' c''` ...

The transform supports 8 commands (4 intervals x 2 directions):
- `harmonize3rdUp`, `harmonize3rdDown` (interval of 2 diatonic steps)
- `harmonize4thUp`, `harmonize4thDown` (interval of 3 diatonic steps)
- `harmonize5thUp`, `harmonize5thDown` (interval of 4 diatonic steps)
- `harmonize6thUp`, `harmonize6thDown` (interval of 5 diatonic steps)

### Special Cases

When the selection contains chords, we insert one harmonized note per chord note inside the chord:
- Input: `[CA]` with 3rd up harmonization
- Output: `[CEAc]`

---

## Algorithm Design

### The Diatonic Pitch Sequence

The diatonic scale is represented as a circular sequence of 7 note names:

```
Index:  0   1   2   3   4   5   6
Name:   C   D   E   F   G   A   B
```

An ABC pitch consists of:
- A note letter (C-B uppercase for octave 4, c-b lowercase for octave 5)
- Optional octave modifiers: `,` lowers octave, `'` raises octave
- Optional alteration (accidentals) which we preserve but do not use for diatonic stepping

### Conversion Functions

#### `pitchToDiatonic(pitch: Pitch): { index: number, octave: number }`

Converts an ABC Pitch AST node to a diatonic index (0-6) and octave number.

```
letter = pitch.noteLetter.lexeme
baseIndex = indexOf(letter.toUpperCase()) in "CDEFGAB"

if letter is lowercase
  baseOctave = 5
else
  baseOctave = 4

octaveOffset = count("'") minus count(",") in pitch.octave?.lexeme

return { index: baseIndex, octave: baseOctave + octaveOffset }
```

#### `diatonicToPitch(index: number, octave: number, alteration: Token | undefined, ctx: ABCContext): Pitch`

Converts a diatonic index and octave back to an ABC Pitch AST node.

```
letters = "CDEFGAB"
letter = letters[index % 7]

if octave >= 5
  letter = letter.toLowerCase()
  octaveStr = "'" repeated (octave - 5) times
else
  letter stays uppercase
  octaveStr = "," repeated (4 - octave) times

return new Pitch with:
  - alteration (preserved from original)
  - noteLetter token with letter
  - octave token with octaveStr (or undefined if empty string)
```

#### `stepDiatonic(pitch: Pitch, steps: number, ctx: ABCContext): Pitch`

Steps a pitch diatonically by the given number of steps (positive = up, negative = down).

```
{ index, octave } = pitchToDiatonic(pitch)

newIndex = index + steps
octaveShift = floor(newIndex / 7)
newIndex = ((newIndex % 7) + 7) % 7   // handle negative modulo

return diatonicToPitch(newIndex, octave + octaveShift, pitch.alteration, ctx)
```

### Interval Step Mapping

| Interval | Steps |
|----------|-------|
| 3rd up   | +2    |
| 3rd down | -2    |
| 4th up   | +3    |
| 4th down | -3    |
| 5th up   | +4    |
| 5th down | -4    |
| 6th up   | +5    |
| 6th down | -5    |

---

## Phase 1: abct2 Transform Implementation

### File to Create

`abct2/src/transforms/harmonize.ts`

### Imports

```typescript
import { Selection } from "../selection";
import { CSNode, TAGS, createCSNode } from "../csTree/types";
import { ABCContext, Pitch, TT, Token, Note } from "abc-parser";
import { toAst } from "../csTree/toAst";
import { fromAst } from "../csTree/fromAst";
import { findNodesById } from "./types";
import { findChildByTag, findParent, findTieChild, removeChild } from "./treeUtils";
```

### Helper Functions (module-level)

```typescript
const DIATONIC_LETTERS = "CDEFGAB";

function pitchToDiatonic(pitch: Pitch): { index: number; octave: number }
  letter = pitch.noteLetter.lexeme
  baseIndex = DIATONIC_LETTERS.indexOf(letter.toUpperCase())

  if letter is lowercase
    baseOctave = 5
  else
    baseOctave = 4

  octaveOffset = 0
  if pitch.octave exists
    for each char in pitch.octave.lexeme
      if char is "'" then octaveOffset++
      else if char is "," then octaveOffset--

  return { index: baseIndex, octave: baseOctave + octaveOffset }


function diatonicToPitch(index: number, octave: number, alteration: Token | undefined, ctx: ABCContext): Pitch
  normalizedIndex = ((index % 7) + 7) % 7
  letter = DIATONIC_LETTERS[normalizedIndex]

  octaveToken = undefined

  if octave >= 5
    letter = letter.toLowerCase()
    octaveOffset = octave - 5
    if octaveOffset > 0
      octaveToken = new Token(TT.OCTAVE, "'".repeat(octaveOffset), ctx.generateId())
  else
    octaveOffset = 4 - octave
    if octaveOffset > 0
      octaveToken = new Token(TT.OCTAVE, ",".repeat(octaveOffset), ctx.generateId())

  noteLetterToken = new Token(TT.NOTE_LETTER, letter, ctx.generateId())

  return new Pitch(ctx.generateId(), {
    alteration: alteration,
    noteLetter: noteLetterToken,
    octave: octaveToken,
  })


function stepDiatonic(pitch: Pitch, steps: number, ctx: ABCContext): Pitch
  { index, octave } = pitchToDiatonic(pitch)

  newIndex = index + steps
  octaveShift = Math.floor(newIndex / 7)
  normalizedIndex = ((newIndex % 7) + 7) % 7

  return diatonicToPitch(normalizedIndex, octave + octaveShift, pitch.alteration, ctx)
```

### Main Transform Function

```typescript
export function harmonize(selection: Selection, steps: number, ctx: ABCContext): Selection
  if steps === 0
    return selection

  for each cursor in selection.cursors
    nodes = findNodesById(selection.root, cursor)
    for each csNode in nodes
      if csNode.tag === TAGS.Note
        wrapNoteInChord(selection.root, csNode, steps, ctx)
      else if csNode.tag === TAGS.Chord
        harmonizeChord(csNode, steps, ctx)

  return selection
```

### `wrapNoteInChord`: wrap a standalone note in a chord with its harmony

```typescript
function wrapNoteInChord(root: CSNode, noteNode: CSNode, steps: number, ctx: ABCContext): void
  pitchResult = findChildByTag(noteNode, TAGS.Pitch)
  if pitchResult is null
    return

  // Find parent before we modify anything
  parentResult = findParent(root, noteNode)
  if parentResult is null
    return

  // Compute the harmony pitch
  pitchExpr = toAst(pitchResult.node) as Pitch
  harmonyPitchExpr = stepDiatonic(pitchExpr, steps, ctx)

  // Create harmony note (pitch only, no rhythm/tie)
  harmonyNoteExpr = new Note(ctx.generateId(), {
    pitch: harmonyPitchExpr,
    rhythm: undefined,
    tie: undefined,
  })
  harmonyNoteCSNode = fromAst(harmonyNoteExpr)

  // Extract rhythm and tie from original note (will move to chord level)
  rhythmNode = null
  tieNode = null

  rhythmResult = findChildByTag(noteNode, TAGS.Rhythm)
  if rhythmResult exists
    rhythmNode = rhythmResult.node
    removeChild(noteNode, rhythmResult.prev, rhythmResult.node)

  tieResult = findTieChild(noteNode)
  if tieResult exists
    tieNode = tieResult.node
    removeChild(noteNode, tieResult.prev, tieResult.node)

  // Create chord CSNode
  chordCSNode = createCSNode(TAGS.Chord, ctx.generateId(), { type: "empty" })

  // Create bracket tokens
  leftBracketCSNode = fromAst(new Token(TT.LBRACKET, "[", ctx.generateId()))
  rightBracketCSNode = fromAst(new Token(TT.RBRACKET, "]", ctx.generateId()))

  // Save original note's sibling (chord will take its place in the tree)
  originalNextSibling = noteNode.nextSibling
  noteNode.nextSibling = null

  // Build chord's child linked list: leftBracket -> note -> harmonyNote -> rightBracket -> rhythm? -> tie?
  chordCSNode.firstChild = leftBracketCSNode
  leftBracketCSNode.nextSibling = noteNode
  noteNode.nextSibling = harmonyNoteCSNode
  harmonyNoteCSNode.nextSibling = rightBracketCSNode

  lastChild = rightBracketCSNode
  if rhythmNode exists
    lastChild.nextSibling = rhythmNode
    lastChild = rhythmNode
  if tieNode exists
    lastChild.nextSibling = tieNode
    lastChild = tieNode

  // The chord takes the note's position in the tree
  chordCSNode.nextSibling = originalNextSibling

  // Update parent to point to chord instead of note
  if parentResult.prev is null
    parentResult.parent.firstChild = chordCSNode
  else
    parentResult.prev.nextSibling = chordCSNode
```

### `harmonizeChord`: add harmony notes inside an existing chord

```typescript
function harmonizeChord(chordNode: CSNode, steps: number, ctx: ABCContext): void
  // Collect all notes in the chord first (to avoid modifying while iterating)
  notesToHarmonize = []
  current = chordNode.firstChild
  while current is not null
    if current.tag === TAGS.Note
      notesToHarmonize.push(current)
    current = current.nextSibling

  // For each note, create a harmony note and append it at the end of chord's children
  // (formatter will reorder by pitch)
  for each noteNode in notesToHarmonize
    pitchResult = findChildByTag(noteNode, TAGS.Pitch)
    if pitchResult is null
      continue

    pitchExpr = toAst(pitchResult.node) as Pitch
    harmonyPitchExpr = stepDiatonic(pitchExpr, steps, ctx)

    harmonyNoteExpr = new Note(ctx.generateId(), {
      pitch: harmonyPitchExpr,
      rhythm: undefined,
      tie: undefined,
    })
    harmonyNoteCSNode = fromAst(harmonyNoteExpr)

    // Find end of chord's child list (before right bracket, rhythm, tie)
    // Actually, we can just append after the last Note in the chord
    // Find the last Note's position and insert after it
    prev = null
    current = chordNode.firstChild
    lastNote = null
    lastNotePrev = null
    while current is not null
      if current.tag === TAGS.Note
        lastNote = current
        lastNotePrev = prev
      prev = current
      current = current.nextSibling

    // Insert harmony note after the last note we found
    if lastNote is not null
      harmonyNoteCSNode.nextSibling = lastNote.nextSibling
      lastNote.nextSibling = harmonyNoteCSNode
```

### Export Update

Add to `abct2/src/transforms/index.ts`:

```typescript
export { harmonize } from "./harmonize";
```

### To Do for Phase 1

- Create `abct2/src/transforms/harmonize.ts` with the implementation above
- Add export to `abct2/src/transforms/index.ts`
- Create `abct2/src/transforms/harmonize.spec.ts` with unit tests
- Run `npm run test` to verify all tests pass
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass

---

## Phase 2: LSP Server Integration

### Files to Create

#### `abc-lsp-server/src/transformLookup.ts`

Following the pattern of `selectorLookup.ts`:

```typescript
import { Selection } from "../../abct2/src/selection";
import { ABCContext } from "abc-parser";
import { harmonize } from "../../abct2/src/transforms/harmonize";

type TransformFn = (sel: Selection, ctx: ABCContext, ...args: number[]) => Selection;

const TRANSFORM_MAP: Record<string, TransformFn> = {
  harmonize: (sel, ctx, steps) => harmonize(sel, steps, ctx),
};

export function lookupTransform(name: string): TransformFn | null {
  return TRANSFORM_MAP[name] ?? null;
}
```

### Files to Modify

#### `abc-lsp-server/src/server.ts`

Add imports (around line 28-31 where other abct2 imports are):

```typescript
import { lookupTransform } from "./transformLookup";
import { toAst } from "../../abct2/src/csTree/toAst";
import { AbcFormatter, File_structure } from "abc-parser";
```

Add interface (after `ApplySelectorResult`, around line 80):

```typescript
interface ApplyTransformParams {
  uri: string;
  transform: string;
  args: number[];
  cursorNodeIds: number[];
}

interface ApplyTransformResult {
  text: string;
  ranges: Array<{ start: { line: number; character: number }; end: { line: number; character: number } }>;
  cursorNodeIds: number[];
}
```

Add request handler (after `abct2.applySelector` handler, around line 246):

```typescript
connection.onRequest("abct2.applyTransform", (params: ApplyTransformParams): ApplyTransformResult => {
  const doc = abcServer.abcDocuments.get(params.uri);
  if (!doc || !(doc instanceof AbcDocument) || !doc.AST || !doc.ctx) {
    return { text: "", ranges: [], cursorNodeIds: [] };
  }

  const root = getCsTree(doc.AST);

  let selection;
  if (params.cursorNodeIds.length === 0) {
    selection = createSelection(root);
  } else {
    selection = {
      root,
      cursors: params.cursorNodeIds.map((id) => new Set([id])),
    };
  }

  const transformFn = lookupTransform(params.transform);
  if (!transformFn) {
    throw new ResponseError(-1, `Unknown transform: "${params.transform}"`);
  }

  selection = transformFn(selection, doc.ctx, ...(params.args ?? []));

  // Convert modified CSTree back to AST, then format to string
  const modifiedAst = toAst(selection.root) as File_structure;
  const formatter = new AbcFormatter(doc.ctx);
  const text = formatter.stringify(modifiedAst);

  const ranges = resolveSelectionRanges(selection);
  const cursorNodeIds = selection.cursors.map((cursor) => [...cursor][0]);

  return { text, ranges, cursorNodeIds };
});
```

### To Do for Phase 2

- Create `abc-lsp-server/src/transformLookup.ts`
- Add imports to `server.ts`
- Add `ApplyTransformParams` and `ApplyTransformResult` interfaces to `server.ts`
- Add `abct2.applyTransform` request handler to `server.ts`
- Run `npm run test` to verify all tests pass
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass

---

## Phase 3: VSCode Extension Integration

### Files to Create

#### `vscode-extension/src/transformCommands.ts`

Following the pattern of `selectorCommands.ts`:

```typescript
import * as vscode from "vscode";
import { LanguageClient } from "vscode-languageclient/node";

interface ApplyTransformResult {
  text: string;
  ranges: Array<{ start: { line: number; character: number }; end: { line: number; character: number } }>;
  cursorNodeIds: number[];
}

export function registerTransformCommands(context: vscode.ExtensionContext, client: LanguageClient): void {
  const cursorStateByUri = new Map<string, number[]>();

  // Clear cursor state on user-initiated selection changes
  context.subscriptions.push(
    vscode.window.onDidChangeTextEditorSelection((event) => {
      if (event.textEditor.document.languageId !== "abc") return;
      if (event.kind !== vscode.TextEditorSelectionChangeKind.Keyboard &&
          event.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {
        return;
      }
      const uri = event.textEditor.document.uri.toString();
      cursorStateByUri.delete(uri);
    })
  );

  // Clear cursor state on document changes
  context.subscriptions.push(
    vscode.workspace.onDidChangeTextDocument((event) => {
      if (event.document.languageId !== "abc") return;
      cursorStateByUri.delete(event.document.uri.toString());
    })
  );

  // Define harmonize commands: [commandId, transformName, args, description]
  const transformCommands: Array<[string, string, number[], string]> = [
    ["abc.harmonize3rdUp", "harmonize", [2], "3rd up"],
    ["abc.harmonize3rdDown", "harmonize", [-2], "3rd down"],
    ["abc.harmonize4thUp", "harmonize", [3], "4th up"],
    ["abc.harmonize4thDown", "harmonize", [-3], "4th down"],
    ["abc.harmonize5thUp", "harmonize", [4], "5th up"],
    ["abc.harmonize5thDown", "harmonize", [-4], "5th down"],
    ["abc.harmonize6thUp", "harmonize", [5], "6th up"],
    ["abc.harmonize6thDown", "harmonize", [-5], "6th down"],
  ];

  for (const [commandId, transformName, args, description] of transformCommands) {
    context.subscriptions.push(
      vscode.commands.registerCommand(commandId, async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor || editor.document.languageId !== "abc") return;

        const uri = editor.document.uri.toString();
        const cursorNodeIds = cursorStateByUri.get(uri) ?? [];

        try {
          const result = await client.sendRequest<ApplyTransformResult>("abct2.applyTransform", {
            uri,
            transform: transformName,
            args,
            cursorNodeIds,
          });

          if (result.text) {
            // Replace entire document with transformed text
            const fullRange = new vscode.Range(
              new vscode.Position(0, 0),
              editor.document.lineAt(editor.document.lineCount - 1).range.end
            );
            await editor.edit((editBuilder) => {
              editBuilder.replace(fullRange, result.text);
            });

            // Update cursor state
            if (result.cursorNodeIds.length > 0) {
              cursorStateByUri.set(uri, result.cursorNodeIds);
            } else {
              cursorStateByUri.delete(uri);
            }

            vscode.window.showInformationMessage(`Harmonized ${description}`);
          }
        } catch (error) {
          vscode.window.showErrorMessage(`Transform failed: ${error}`);
        }
      })
    );
  }
}
```

### Files to Modify

#### `vscode-extension/src/extension.ts`

Add import (around line 14):

```typescript
import { registerTransformCommands } from "./transformCommands";
```

Add registration call (after `registerSelectorCommands`, around line 77):

```typescript
registerTransformCommands(context, client);
```

#### `vscode-extension/package.json`

Add commands to the `contributes.commands` array (after the selector commands, around line 177):

```json
{ "command": "abc.harmonize3rdUp", "title": "ABC: Harmonize 3rd Up", "category": "ABC" },
{ "command": "abc.harmonize3rdDown", "title": "ABC: Harmonize 3rd Down", "category": "ABC" },
{ "command": "abc.harmonize4thUp", "title": "ABC: Harmonize 4th Up", "category": "ABC" },
{ "command": "abc.harmonize4thDown", "title": "ABC: Harmonize 4th Down", "category": "ABC" },
{ "command": "abc.harmonize5thUp", "title": "ABC: Harmonize 5th Up", "category": "ABC" },
{ "command": "abc.harmonize5thDown", "title": "ABC: Harmonize 5th Down", "category": "ABC" },
{ "command": "abc.harmonize6thUp", "title": "ABC: Harmonize 6th Up", "category": "ABC" },
{ "command": "abc.harmonize6thDown", "title": "ABC: Harmonize 6th Down", "category": "ABC" }
```

Add menu contributions to `contributes.menus.commandPalette` (after the selector menu items):

```json
{ "command": "abc.harmonize3rdUp", "when": "editorLangId == abc" },
{ "command": "abc.harmonize3rdDown", "when": "editorLangId == abc" },
{ "command": "abc.harmonize4thUp", "when": "editorLangId == abc" },
{ "command": "abc.harmonize4thDown", "when": "editorLangId == abc" },
{ "command": "abc.harmonize5thUp", "when": "editorLangId == abc" },
{ "command": "abc.harmonize5thDown", "when": "editorLangId == abc" },
{ "command": "abc.harmonize6thUp", "when": "editorLangId == abc" },
{ "command": "abc.harmonize6thDown", "when": "editorLangId == abc" }
```

### To Do for Phase 3

- Create `vscode-extension/src/transformCommands.ts`
- Add import and registration call in `vscode-extension/src/extension.ts`
- Add command and menu contributions in `vscode-extension/package.json`
- Run `npm run build` from the vscode-extension directory
- Manually test in VSCode with an ABC file
- Final verification: build passes
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass

---

## Testing Strategy

### Unit Tests for the Harmonizer

Create `abct2/src/transforms/harmonize.spec.ts`:

#### Test Cases for Helper Functions

1. `pitchToDiatonic` tests:
   - `C` returns `{ index: 0, octave: 4 }`
   - `c` returns `{ index: 0, octave: 5 }`
   - `G,` returns `{ index: 4, octave: 3 }`
   - `d'` returns `{ index: 1, octave: 6 }`
   - `B,,` returns `{ index: 6, octave: 2 }`

2. `diatonicToPitch` tests:
   - `{ index: 0, octave: 4 }` produces `C`
   - `{ index: 0, octave: 5 }` produces `c`
   - `{ index: 4, octave: 3 }` produces `G,`
   - `{ index: 1, octave: 6 }` produces `d'`

3. `stepDiatonic` tests:
   - `C` stepped by +2 produces `E`
   - `A` stepped by +2 produces `c` (octave wrap up)
   - `c` stepped by -2 produces `A` (octave wrap down)
   - `B` stepped by +1 produces `c`
   - `c` stepped by -1 produces `B`
   - Accidentals preserved: `^C` stepped by +2 produces `^E`

#### Test Cases for Harmonizer Transform

1. Single note harmonization:
   - Input: `C`, steps: +2 -> Output: `[CE]`
   - Input: `A`, steps: +2 -> Output: `[Ac]`
   - Input: `E`, steps: +4 -> Output: `[EB]` (5th up)

2. Chord harmonization:
   - Input: `[CA]`, steps: +2 -> Output: `[CEAc]`

3. Note with rhythm:
   - Input: `C2`, steps: +2 -> Output: `[CE]2` (rhythm on chord)

4. Note with accidental:
   - Input: `^C`, steps: +2 -> Output: `[^C^E]` (accidental preserved)

### Property-Based Tests

Using fast-check for property-based testing:

#### Roundtrip Properties

1. `pitchToDiatonic` and `diatonicToPitch` are inverses:
   - For any valid ABC pitch string, `diatonicToPitch(pitchToDiatonic(pitch))` produces an equivalent pitch (same note letter case, same octave modifiers)

2. `stepDiatonic` is reversible:
   - For any pitch and step value N, stepping up by N then down by N returns the original pitch

#### Invariant Properties

3. Diatonic index is always in range:
   - For any pitch, `pitchToDiatonic(pitch).index` is in `[0, 6]`

4. Stepping preserves accidentals:
   - For any pitch with an accidental, `stepDiatonic(pitch, N).alteration` equals the original accidental

5. Octave boundaries are correct:
   - Stepping `B` up by 1 produces a pitch in octave+1
   - Stepping `c` down by 1 produces a pitch in octave-1

#### Structural Properties

6. Harmonizing a note produces a chord:
   - For any single note input, the output has tag `TAGS.Chord`

7. Harmonizing a chord increases note count:
   - For any chord with N notes, harmonizing adds exactly N more notes

8. Steps of 0 is identity:
   - For any input, `harmonize(selection, 0, ctx)` produces identical output

#### Generators

```
pitchGen: generates random ABC pitch strings like "C", "c", "G,", "d'", "^F", "_B,,"
stepsGen: generates integers in range [-7, 7]
noteGen: generates Note CSNodes with random pitches
chordGen: generates Chord CSNodes with 2-4 random notes
```

---

## To Do List

### Phase 1: abct2 Transform Implementation

- Create `abct2/src/transforms/harmonize.ts` with helper functions and main transform
- Add export to `abct2/src/transforms/index.ts`
- Create `abct2/src/transforms/harmonize.spec.ts` with unit tests and property-based tests
- Run `npm run test` to verify all tests pass
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass

### Phase 2: LSP Server Integration

- Create `abc-lsp-server/src/transformLookup.ts`
- Add imports to `server.ts`
- Add `ApplyTransformParams` and `ApplyTransformResult` interfaces to `server.ts`
- Add `abct2.applyTransform` request handler to `server.ts`
- Run `npm run test` to verify all tests pass
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass

### Phase 3: VSCode Extension Integration

- Create `vscode-extension/src/transformCommands.ts`
- Add import and registration call in `vscode-extension/src/extension.ts`
- Add command and menu contributions in `vscode-extension/package.json`
- Run `npm run build` from the vscode-extension directory
- Manually test in VSCode with an ABC file
- Final verification: build passes
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass
