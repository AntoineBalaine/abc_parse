# Plan 43: Wrap Selection in Crescendo/Decrescendo Transform

## Table of Contents

1. [Overview](#overview)
2. [Design Decisions](#design-decisions)
3. [Phase 1: Create the wrapDynamic Transform](#phase-1-create-the-wrapdynamic-transform)
4. [Phase 2: Register the Transform in the Lookup](#phase-2-register-the-transform-in-the-lookup)
5. [Phase 3: Add LSP Command Handlers](#phase-3-add-lsp-command-handlers)
6. [Phase 4: Extension Commands and package.json](#phase-4-extension-commands-and-packagejson)
7. [Phase 5: Tests](#phase-5-tests)
8. [To Do List](#to-do-list)

---

## Overview

The goal is to implement a transform that wraps a selection of ABC music elements (notes, chords, rests) in dynamic markings. The transform inserts a start decoration before the first selected element and an end decoration after the last selected element.

### Supported Dynamics

| Dynamic | Start Decoration | End Decoration |
|---------|------------------|----------------|
| Crescendo | `!<(!` | `!<)!` |
| Decrescendo | `!>(!` | `!>)!` |

### LSP Commands to Expose

| Command ID | Description |
|------------|-------------|
| `abc.wrapCrescendo` | Wraps selection with crescendo hairpin |
| `abc.wrapDecrescendo` | Wraps selection with decrescendo hairpin |

---

## Design Decisions

### 1. Decoration Insertion Strategy

Because ABC decorations attach to notes/chords (they appear immediately before the element they decorate), we insert the start decoration as a sibling immediately before the first selected element, and the end decoration immediately after the last selected element.

### 2. Decoration Node Creation

We create Decoration CSNodes with TT.SYMBOL tokens. The structure is:

```
Decoration (tag: "Decoration")
  Token (data: { lexeme: "!<(!", tokenType: TT.SYMBOL })
```

### 3. Parent Container Identification

We use the `findParent` utility from `treeUtils.ts` to locate where to insert decorations.

### 4. Selection Ordering

We assume nodes within a cursor are in document order (as they are in practice). Tests verify this assumption.

### 5. Empty and Single-Element Selections

- If the selection is empty, the transform returns the selection unchanged.
- If the selection contains a single element, both start and end decorations are placed around that single element.

---

## Phase 1: Create the wrapDynamic Transform

### File to Create

`abct2/src/transforms/wrapDynamic.ts`

### Implementation

```typescript
import { Selection } from "../selection";
import { CSNode, TAGS, createCSNode } from "../csTree/types";
import { findParent, insertBefore, appendChild } from "./treeUtils";
import { findNodesById } from "./types";
import { ABCContext, TT } from "abc-parser";

export type DynamicType = "crescendo" | "decrescendo";

const DYNAMIC_DECORATIONS: Record<DynamicType, { start: string; end: string }> = {
  crescendo: { start: "!<(!", end: "!<)!" },
  decrescendo: { start: "!>(!", end: "!>)!" },
};

export function wrapDynamic(
  selection: Selection,
  dynamicType: DynamicType,
  ctx: ABCContext
): Selection {
  // Collect all selected nodes from all cursors
  const selectedNodes: CSNode[] = [];
  for (const cursor of selection.cursors) {
    const nodes = findNodesById(selection.root, cursor);
    selectedNodes.push(...nodes);
  }

  if (selectedNodes.length === 0) {
    return selection;
  }

  const firstNode = selectedNodes[0];
  const lastNode = selectedNodes[selectedNodes.length - 1];
  const decorations = DYNAMIC_DECORATIONS[dynamicType];

  // Insert start decoration before the first node
  insertDecorationBefore(selection.root, firstNode, decorations.start, ctx);

  // Insert end decoration after the last node
  insertDecorationAfter(selection.root, lastNode, decorations.end, ctx);

  return selection;
}

function createDecorationNode(lexeme: string, ctx: ABCContext): CSNode {
  const tokenNode = createCSNode(TAGS.Token, ctx.generateId(), {
    type: "token",
    lexeme: lexeme,
    tokenType: TT.SYMBOL,
    line: 0,
    position: 0,
  });

  const decorationNode = createCSNode(TAGS.Decoration, ctx.generateId(), { type: "empty" });
  decorationNode.firstChild = tokenNode;

  return decorationNode;
}

function insertDecorationBefore(root: CSNode, targetNode: CSNode, lexeme: string, ctx: ABCContext): void {
  const parentResult = findParent(root, targetNode);
  if (parentResult === null) return;

  const decorationNode = createDecorationNode(lexeme, ctx);
  insertBefore(parentResult.parent, parentResult.prev, targetNode, decorationNode);
}

function insertDecorationAfter(root: CSNode, targetNode: CSNode, lexeme: string, ctx: ABCContext): void {
  const parentResult = findParent(root, targetNode);
  if (parentResult === null) return;

  const decorationNode = createDecorationNode(lexeme, ctx);

  if (targetNode.nextSibling !== null) {
    // Insert before the next sibling (which places it after targetNode)
    insertBefore(parentResult.parent, targetNode, targetNode.nextSibling, decorationNode);
  } else {
    // Append at the end of the parent
    appendChild(parentResult.parent, decorationNode);
  }
}
```

### Update Exports

In `abct2/src/transforms/index.ts`, add:

```typescript
export { wrapDynamic, DynamicType } from "./wrapDynamic";
```

---

## Phase 2: Register the Transform in the Lookup

### File to Modify

`abc-lsp-server/src/transformLookup.ts`

### Changes

Import the new transform:

```typescript
import { wrapDynamic, DynamicType } from "../../abct2/src/transforms";
```

Add entries to `TRANSFORM_MAP`:

```typescript
const TRANSFORM_MAP: Record<string, TransformFn> = {
  // ... existing transforms ...
  wrapCrescendo: (sel, ctx) => wrapDynamic(sel, "crescendo", ctx),
  wrapDecrescendo: (sel, ctx) => wrapDynamic(sel, "decrescendo", ctx),
};
```

---

## Phase 3: LSP Command Handlers

### Server Side

The existing `abct2.applyTransform` handler in `abc-lsp-server/src/server.ts` already handles arbitrary transform names via `lookupTransform`. Because we registered `wrapCrescendo` and `wrapDecrescendo` in Phase 2, no additional server code is needed - the server will route these transform requests to the correct function.

### Client Side (covered in Phase 4)

The VSCode extension needs to:
1. Register commands with VSCode (`abc.wrapCrescendo`, `abc.wrapDecrescendo`)
2. When invoked, call the LSP server with the transform name

This is handled in Phase 4, where we update `transformCommands.ts` and `package.json`.

### Note on Command Discovery

Currently, available transforms are implicitly defined by:
- Server: entries in `TRANSFORM_MAP` in `transformLookup.ts`
- Client: command registrations in `transformCommands.ts` and `package.json`

Both sides must be kept in sync manually. There is no dynamic discovery mechanism.

---

## Phase 4: Extension Commands and package.json

### File to Modify

`vscode-extension/src/transformCommands.ts`

Add the new commands to the `simpleTransforms` array (these transforms take no additional arguments):

```typescript
const simpleTransforms: Array<[string, string]> = [
  // ... existing transforms ...
  ["abc.wrapCrescendo", "wrapCrescendo"],
  ["abc.wrapDecrescendo", "wrapDecrescendo"],
];
```

### File to Modify

`vscode-extension/package.json`

Add command definitions under `contributes.commands`:

```json
{
  "command": "abc.wrapCrescendo",
  "title": "ABC: Wrap Selection in Crescendo",
  "category": "ABC"
},
{
  "command": "abc.wrapDecrescendo",
  "title": "ABC: Wrap Selection in Decrescendo",
  "category": "ABC"
}
```

Add command palette visibility under `contributes.menus.commandPalette`:

```json
{ "command": "abc.wrapCrescendo", "when": "editorLangId == abc" },
{ "command": "abc.wrapDecrescendo", "when": "editorLangId == abc" }
```

---

## Phase 5: Tests

### File to Create

`abct2/tests/wrapDynamic.spec.ts`

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import * as fc from "fast-check";
import { wrapDynamic } from "../src/transforms/wrapDynamic";
import { Selection } from "../src/selection";
import { TAGS } from "../src/csTree/types";
import { toCSTreeWithContext, findByTag, formatSelection, genAbcTune } from "./helpers";

describe("wrapDynamic transform", () => {
  describe("wrapCrescendo", () => {
    it("wraps a single note in crescendo", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC|\n");
      const notes = findByTag(root, TAGS.Note);
      const sel: Selection = { root, cursors: notes.map(n => new Set([n.id])) };

      wrapDynamic(sel, "crescendo", ctx);
      const result = formatSelection(sel);

      expect(result).to.contain("!<(!");
      expect(result).to.contain("!<)!");
    });

    it("wraps multiple notes with decorations at first and last", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC D E|\n");
      const notes = findByTag(root, TAGS.Note);
      const sel: Selection = { root, cursors: notes.map(n => new Set([n.id])) };

      wrapDynamic(sel, "crescendo", ctx);
      const result = formatSelection(sel);

      expect(result).to.contain("!<(!");
      expect(result).to.contain("!<)!");
    });

    it("returns unchanged selection when empty", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC|\n");
      const sel: Selection = { root, cursors: [] };

      wrapDynamic(sel, "crescendo", ctx);
      const result = formatSelection(sel);

      expect(result).to.not.contain("!<(!");
    });
  });

  describe("wrapDecrescendo", () => {
    it("wraps notes in decrescendo", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC D|\n");
      const notes = findByTag(root, TAGS.Note);
      const sel: Selection = { root, cursors: notes.map(n => new Set([n.id])) };

      wrapDynamic(sel, "decrescendo", ctx);
      const result = formatSelection(sel);

      expect(result).to.contain("!>(!");
      expect(result).to.contain("!>)!");
    });
  });

  describe("partial selection", () => {
    it("wraps only selected notes, not the entire line", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC D E F G|\n");
      const notes = findByTag(root, TAGS.Note);
      // Select only D, E, F (middle three)
      const middleNotes = [notes[1], notes[2], notes[3]];
      const sel: Selection = { root, cursors: middleNotes.map(n => new Set([n.id])) };

      wrapDynamic(sel, "crescendo", ctx);
      const result = formatSelection(sel);

      expect(result).to.contain("!<(!");
      expect(result).to.contain("!<)!");
    });
  });

  describe("selection ordering assumption", () => {
    it("nodes collected from cursors are in document order", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC D E F|\n");
      const notes = findByTag(root, TAGS.Note);
      const sel: Selection = { root, cursors: notes.map(n => new Set([n.id])) };

      const collectedIds: number[] = [];
      for (const cursor of sel.cursors) {
        for (const id of cursor) {
          collectedIds.push(id);
        }
      }

      const noteIds = notes.map(n => n.id);
      expect(collectedIds).to.deep.equal(noteIds);
    });
  });

  describe("properties", () => {
    it("property: wrapping non-empty selection always produces both start and end markers", () => {
      fc.assert(
        fc.property(genAbcTune, (source) => {
          const { root, ctx } = toCSTreeWithContext(source);
          const notes = findByTag(root, TAGS.Note);
          if (notes.length === 0) return true;

          const sel: Selection = { root, cursors: notes.map(n => new Set([n.id])) };
          wrapDynamic(sel, "crescendo", ctx);
          const result = formatSelection(sel);

          const hasStart = result.includes("!<(!");
          const hasEnd = result.includes("!<)!");

          return hasStart && hasEnd;
        }),
        { numRuns: 100 }
      );
    });

    it("property: wrapping empty selection produces no markers", () => {
      fc.assert(
        fc.property(genAbcTune, (source) => {
          const { root, ctx } = toCSTreeWithContext(source);
          const sel: Selection = { root, cursors: [] };

          wrapDynamic(sel, "crescendo", ctx);
          const result = formatSelection(sel);

          return !result.includes("!<(!") && !result.includes("!<)!");
        }),
        { numRuns: 100 }
      );
    });

    it("property: crescendo and decrescendo use different markers", () => {
      fc.assert(
        fc.property(genAbcTune, (source) => {
          const { root: root1, ctx: ctx1 } = toCSTreeWithContext(source);
          const notes1 = findByTag(root1, TAGS.Note);
          if (notes1.length === 0) return true;

          const sel1: Selection = { root: root1, cursors: notes1.map(n => new Set([n.id])) };
          wrapDynamic(sel1, "crescendo", ctx1);
          const crescResult = formatSelection(sel1);

          const { root: root2, ctx: ctx2 } = toCSTreeWithContext(source);
          const notes2 = findByTag(root2, TAGS.Note);
          const sel2: Selection = { root: root2, cursors: notes2.map(n => new Set([n.id])) };
          wrapDynamic(sel2, "decrescendo", ctx2);
          const decrescResult = formatSelection(sel2);

          const crescHasCorrect = crescResult.includes("!<(!") && crescResult.includes("!<)!");
          const decrescHasCorrect = decrescResult.includes("!>(!") && decrescResult.includes("!>)!");

          return crescHasCorrect && decrescHasCorrect;
        }),
        { numRuns: 100 }
      );
    });

    it("property: output is valid ABC (can be re-parsed)", () => {
      fc.assert(
        fc.property(genAbcTune, (source) => {
          const { root, ctx } = toCSTreeWithContext(source);
          const notes = findByTag(root, TAGS.Note);
          if (notes.length === 0) return true;

          const sel: Selection = { root, cursors: notes.map(n => new Set([n.id])) };
          wrapDynamic(sel, "crescendo", ctx);
          const result = formatSelection(sel);

          try {
            toCSTreeWithContext(result);
            return true;
          } catch {
            return false;
          }
        }),
        { numRuns: 100 }
      );
    });
  });
});
```

---

## To Do List

### Phase 1: Create the wrapDynamic Transform
- Create `abct2/src/transforms/wrapDynamic.ts` with the `wrapDynamic` function and helper functions
- Update `abct2/src/transforms/index.ts` to export `wrapDynamic` and `DynamicType`

### Phase 2: Register the Transform in the Lookup
- Update `abc-lsp-server/src/transformLookup.ts`:
  - Import `wrapDynamic` and `DynamicType` from abct2
  - Add `wrapCrescendo` and `wrapDecrescendo` entries to `TRANSFORM_MAP`

### Phase 3: LSP Command Handlers
- Verify that the existing `abct2.applyTransform` handler handles the new transforms (no changes needed)

### Phase 4: Extension Commands and package.json
- Update `vscode-extension/src/transformCommands.ts`: add `abc.wrapCrescendo` and `abc.wrapDecrescendo` to `simpleTransforms`
- Update `vscode-extension/package.json`: add command definitions and command palette visibility entries

### Phase 5: Tests
- Create `abct2/tests/wrapDynamic.spec.ts` with unit tests and property-based tests
- Run `npm run test` to verify all tests pass

### Final Steps
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback
- Commit once the build passes and all tests pass
