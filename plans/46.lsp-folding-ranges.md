# LSP Folding Ranges for ABC Notation

## Table of Contents

1. [Overview](#overview)
2. [Canonical Fold Levels](#canonical-fold-levels)
3. [LSP Protocol](#lsp-protocol)
4. [Implementation Design](#implementation-design)
5. [Fold Detection Algorithm](#fold-detection-algorithm)
6. [Configuration](#configuration)
7. [Edge Cases](#edge-cases)
8. [To Do](#to-do)

## Overview

This plan describes the implementation of `textDocument/foldingRange` support in the ABC LSP server. Folding ranges allow editors to collapse sections of code, improving navigation in large ABC files with multiple tunes or complex structure.

## Canonical Fold Levels

The following fold levels are proposed for ABC notation, ordered from coarsest to finest granularity:

### Level 1: Tune

The entire tune from the `X:` field to the line before the next `X:` field (or end of file).

```
X:1          <-- fold start
T:My Tune
K:C
CDEF GABc|
             <-- fold end (before next X: or EOF)
X:2
...
```

Use case: Collapsing tunes in a tunebook to see the index.

### Level 2: Tune Header

The header section of a tune, from the `X:` field through the `K:` field (inclusive).

```
X:1          <-- fold start
T:My Tune
M:4/4
L:1/8
K:C          <-- fold end
CDEF GABc|
```

Use case: Hiding metadata to focus on the music.

### Level 3: Tune Body

The body section of a tune, from the first music line after `K:` to the end of the tune.

```
X:1
T:My Tune
K:C
CDEF GABc|   <-- fold start
|: DEF2 :|
             <-- fold end
```

Use case: Hiding music to review/edit metadata.

### Level 4: Voice Sections

All content belonging to a single voice, delimited by `V:` fields. In ABC, voice content can be interleaved, so each contiguous block of a voice is a separate fold.

```
V:1          <-- fold start for voice 1
CDEF|
GABc|        <-- fold end for voice 1
V:2          <-- fold start for voice 2
E2F2|
G4|          <-- fold end for voice 2
V:1          <-- another fold for voice 1
...
```

Use case: Focusing on a single voice in multi-voice scores.

### Level 5: Part/Section Markers

Sections delimited by part markers `[P:X]` or `P:X` fields.

```
P:A          <-- fold start
|:CDEF GABc:|
             <-- fold end (before next P: or end of tune)
P:B
|:cBAG FEDC:|
```

Use case: Collapsing repeated sections to see the form.

### Level 6: Comment Blocks

Contiguous lines of comments (lines starting with `%` but not `%%`).

```
% This is a      <-- fold start
% multi-line
% comment        <-- fold end
X:1
```

Use case: Hiding lengthy annotations.

### Level 7: Directive Blocks

Contiguous stylesheet directive lines (`%%directive`).

```
%%titlefont Times-Bold 16   <-- fold start
%%composerfont Times 12
%%staffsep 20               <-- fold end
X:1
```

Use case: Hiding formatting directives.

### Level 8: Inline Field Sequences

Contiguous info field lines of the same type (e.g., multiple `W:` lines for lyrics).

```
W:First verse line one    <-- fold start
W:First verse line two
W:First verse line three  <-- fold end
W:
W:Second verse line one   <-- new fold start
...
```

Use case: Collapsing lyrics blocks.

## LSP Protocol

### Request

```typescript
interface FoldingRangeParams {
  textDocument: TextDocumentIdentifier;
}
```

### Response

```typescript
interface FoldingRange {
  startLine: number;      // 0-indexed
  startCharacter?: number;
  endLine: number;        // 0-indexed
  endCharacter?: number;
  kind?: FoldingRangeKind;
  collapsedText?: string; // Optional hint for collapsed display
}

type FoldingRangeKind = 'comment' | 'imports' | 'region';
```

The LSP defines three standard kinds. We will map our fold levels as follows:

| Fold Level | LSP Kind | Rationale |
|------------|----------|-----------|
| Tune | `region` | Structural region |
| Tune Header | `region` | Structural region |
| Tune Body | `region` | Structural region |
| Voice Section | `region` | Structural region |
| Part/Section | `region` | Structural region |
| Comment Block | `comment` | Standard comment kind |
| Directive Block | `region` | Formatting/config region |
| Info Field Sequence | `region` | Structural region |

## Implementation Design

### Location in Codebase

The folding range provider will be implemented in `abc-lsp-server/src/`:

```
abc-lsp-server/src/
  foldingRangeProvider.ts   <-- new file
  server.ts                 <-- register handler
```

### Dependencies

The provider will use the existing AST from `AbcDocument`. The AST structure provides:

- `File_structure.tune[]` - array of tunes
- Each tune has `tune_header` and `tune_body`
- `tune_header` contains info fields including `X:`, `K:`
- `tune_body` contains music elements, voice markers, part markers

### Interface Design

```typescript
// foldingRangeProvider.ts

import { FoldingRange, FoldingRangeKind } from 'vscode-languageserver';
import { File_structure } from 'abc-parser';

export interface FoldingConfig {
  tune: boolean;
  tuneHeader: boolean;
  tuneBody: boolean;
  voiceSection: boolean;
  partSection: boolean;
  commentBlock: boolean;
  directiveBlock: boolean;
  infoFieldSequence: boolean;
}

export const DEFAULT_FOLDING_CONFIG: FoldingConfig = {
  tune: true,
  tuneHeader: true,
  tuneBody: true,
  voiceSection: true,
  partSection: true,
  commentBlock: true,
  directiveBlock: true,
  infoFieldSequence: false,  // disabled by default (can be noisy)
};

export function computeFoldingRanges(
  ast: File_structure,
  config: FoldingConfig
): FoldingRange[];
```

## Fold Detection Algorithm

### Tune-level folds

```
for each tune in ast.tunes:
  startLine = tune.tune_header.X_field.location.start.line
  endLine = last token of tune.location.end.line
  emit FoldingRange(startLine, endLine, 'region')
```

### Tune Header folds

```
for each tune in ast.tunes:
  startLine = tune.tune_header.X_field.location.start.line
  endLine = tune.tune_header.K_field.location.end.line
  if startLine != endLine:
    emit FoldingRange(startLine, endLine, 'region')
```

### Tune Body folds

```
for each tune in ast.tunes:
  if tune.tune_body is empty:
    continue
  startLine = first element of tune.tune_body.location.start.line
  endLine = last element of tune.tune_body.location.end.line
  if startLine != endLine:
    emit FoldingRange(startLine, endLine, 'region')
```

### Voice Section folds

```
for each tune in ast.tunes:
  voiceRanges = map<voiceId, {startLine, endLine}>

  walk tune_body elements:
    if element is voice_marker(V:id):
      if voiceRanges has current voice:
        emit fold for previous range
      set currentVoice = id
      voiceRanges[id].startLine = element.location.start.line
    else if currentVoice:
      voiceRanges[currentVoice].endLine = element.location.end.line

  emit remaining voice ranges
```

### Part/Section folds

```
for each tune in ast.tunes:
  currentPartStart = null

  walk tune elements:
    if element is part_marker(P:X) or inline_field([P:X]):
      if currentPartStart:
        emit fold from currentPartStart to previous line
      currentPartStart = element.location.start.line

  if currentPartStart:
    emit fold from currentPartStart to end of tune
```

### Comment Block folds

```
scan tokens/lines:
  inCommentBlock = false
  blockStart = null

  for each line:
    if line starts with '%' and not '%%':
      if not inCommentBlock:
        inCommentBlock = true
        blockStart = lineNumber
    else:
      if inCommentBlock:
        if lineNumber - blockStart > 1:
          emit FoldingRange(blockStart, lineNumber - 1, 'comment')
        inCommentBlock = false
```

### Directive Block folds

Same algorithm as comment blocks, but matching lines starting with `%%`.

### Info Field Sequence folds

```
scan tune_header and tune_body:
  currentFieldType = null
  sequenceStart = null

  for each info_field:
    if field.type == currentFieldType:
      continue  // extend sequence
    else:
      if sequenceStart and currentLine - sequenceStart > 1:
        emit fold
      currentFieldType = field.type
      sequenceStart = field.location.start.line
```

## Configuration

Folding configuration can be provided via:

1. LSP initialization options
2. Workspace configuration (`settings.json` in VS Code)

```json
{
  "abc.folding": {
    "tune": true,
    "tuneHeader": true,
    "tuneBody": true,
    "voiceSection": true,
    "partSection": true,
    "commentBlock": true,
    "directiveBlock": true,
    "infoFieldSequence": false
  }
}
```

## Edge Cases

### Empty tunes
A tune with only a header (no body) should still produce a tune-level fold if it spans multiple lines.

### Single-line constructs
Folds where startLine equals endLine should be omitted (nothing to fold).

### Nested folds
The LSP supports nested folds. A tune fold contains header and body folds, which may contain voice/part folds. Editors typically handle nesting correctly.

### Interleaved voices
When voices are interleaved (`V:1` / `V:2` / `V:1` / `V:2`), each contiguous block is a separate fold, not one fold per voice across the entire tune.

### Incomplete tunes
If a tune lacks a `K:` field, the header fold extends to the last info field before music content.

### File-level content
Content before the first `X:` field (file header, global directives) could be treated as a fold region, but this is low priority.

## To Do

1. Create `abc-lsp-server/src/foldingRangeProvider.ts` with the `computeFoldingRanges` function
2. Implement tune-level fold detection
3. Implement tune header fold detection
4. Implement tune body fold detection
5. Implement voice section fold detection
6. Implement part/section fold detection
7. Implement comment block fold detection
8. Implement directive block fold detection
9. Implement info field sequence fold detection (optional, behind config flag)
10. Register the `textDocument/foldingRange` handler in `server.ts`
11. Add folding configuration schema to LSP initialization
12. Write unit tests for each fold type
13. Final verification: build and tests both pass
14. Call the code review agent. Address any feedback.
15. Commit once the build passes and all tests pass.
