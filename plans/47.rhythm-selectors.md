# Rhythm Selectors Implementation Plan

## Table of Contents

1. [Overview](#overview)
2. [Requirements](#requirements)
3. [Architecture](#architecture)
4. [Implementation Details](#implementation-details)
   - [Phase 1: CSTree Type Predicate](#phase-1-cstree-type-predicate)
   - [Phase 2: Selector Functions](#phase-2-selector-functions)
   - [Phase 3: Language Server Integration](#phase-3-language-server-integration)
   - [Phase 4: VSCode Extension Commands](#phase-4-vscode-extension-commands)
   - [Phase 5: Tests](#phase-5-tests)
5. [File Changes Summary](#file-changes-summary)
6. [To Do List](#to-do-list)

---

## Overview

This plan implements two new selectors for the abct2 selection system:

1. `selectRhythmParent` - Selects Notes, Chords, Rests, and YSPACERs that have an explicit (visible) Rhythm child node in the CSTree
2. `selectRhythm` - Selects the Rhythm nodes themselves

These selectors enable workflows where the user can select all elements that carry explicit rhythm notation (like `C2`, `z/4`, `[CEG]>`) or the rhythm expressions directly.

---

## Requirements

1. `selectRhythmParent`:
   - Returns a Selection containing cursors for all Note, Chord, Rest, and YSPACER nodes that have a Rhythm child
   - Uses the existing `fanOutByPredicate` pattern with a custom predicate
   - Respects range constraints when composed with `selectRange`

2. `selectRhythm`:
   - Returns a Selection containing cursors for all Rhythm nodes in the tree
   - Uses the existing `fanOutByPredicate` pattern with a tag-based predicate

3. Both selectors must be:
   - Registered in the language server's selector lookup
   - Exposed as VSCode commands
   - Covered by property-based and example-based tests

---

## Architecture

The selector pipeline follows the established pattern:

```
User invokes command in VSCode
    |
    v
VSCode extension sends "abct2.applySelector" request
    |
    v
Language server looks up selector in selectorLookup.ts
    |
    v
Selector function (in abct2/src/selectors/) transforms Selection
    |
    v
Result ranges returned to VSCode and applied to editor
```

Data flow for the predicate:

```
CSNode (Note/Chord/Rest/YSPACER)
    |
    +-- firstChild --> Pitch/rest token/...
    |
    +-- ... --> Rhythm (if explicit rhythm present)
    |
    +-- ... --> Tie token (optional)
```

The `hasRhythmChild` predicate traverses the node's children looking for a child with `tag === TAGS.Rhythm`.

---

## Implementation Details

### Phase 1: CSTree Type Predicate

Add a helper predicate function to check if a node has a Rhythm child, and a predicate to check if a node is a Rhythm node.

File: `abct2/src/csTree/types.ts`

Add after line 103 (after the existing `isBeam` function):

```typescript
export function isRhythm(node: CSNode): boolean {
  return node.tag === TAGS.Rhythm;
}

export function isYSpacer(node: CSNode): boolean {
  return node.tag === TAGS.YSPACER;
}

export function hasRhythmChild(node: CSNode): boolean {
  let child = node.firstChild;
  while (child !== null) {
    if (child.tag === TAGS.Rhythm) {
      return true;
    }
    child = child.nextSibling;
  }
  return false;
}

export function isRhythmParent(node: CSNode): boolean {
  const isParentType =
    node.tag === TAGS.Note ||
    node.tag === TAGS.Chord ||
    node.tag === TAGS.Rest ||
    node.tag === TAGS.YSPACER;

  return isParentType && hasRhythmChild(node);
}
```

The `isRhythmParent` predicate combines two checks:
1. The node must be one of the types that can carry rhythm (Note, Chord, Rest, YSPACER)
2. The node must have a Rhythm child node

### Phase 2: Selector Functions

Add the two new selector functions to the typeSelectors module.

File: `abct2/src/selectors/typeSelectors.ts`

Update imports (line 1):

```typescript
import { isChord, isNote, isRest, isRhythm, isRhythmParent } from "../csTree/types";
```

Add after line 23 (after `selectRests`):

```typescript
export function selectRhythm(input: Selection): Selection {
  return fanOutByPredicate(input, isRhythm, "all");
}

export function selectRhythmParent(input: Selection): Selection {
  return fanOutByPredicate(input, isRhythmParent, "all");
}
```

The `"all"` walk strategy is used because:
- `selectRhythm` needs to find Rhythm nodes anywhere in the tree (including inside Chords)
- `selectRhythmParent` needs to find Notes inside Chords that have rhythm, as well as standalone Notes, Rests, Chords, and YSPACERs

### Phase 3: Language Server Integration

Register the new selectors in the lookup map.

File: `abc-lsp-server/src/selectorLookup.ts`

Update imports (lines 2-5):

```typescript
import {
  selectChords, selectNotes, selectNonChordNotes,
  selectChordNotes, selectRests, selectRhythm, selectRhythmParent
} from "../../abct2/src/selectors/typeSelectors";
```

Add to SELECTOR_MAP (after line 19, after selectRests entry):

```typescript
  selectRhythm: (sel) => selectRhythm(sel),
  selectRhythmParent: (sel) => selectRhythmParent(sel),
```

### Phase 4: VSCode Extension Commands

Register the two new commands in the VSCode extension.

File: `vscode-extension/src/selectorCommands.ts`

Add to the `selectorCommands` array (after line 64, after `selectAllButBottom` entry):

```typescript
    ["abc.selectRhythm", "selectRhythm"],
    ["abc.selectRhythmParent", "selectRhythmParent"],
```

File: `vscode-extension/package.json`

Add command contributions to the `contributes.commands` array:

```json
{
  "command": "abc.selectRhythm",
  "title": "ABC: Select Rhythm Expressions"
},
{
  "command": "abc.selectRhythmParent",
  "title": "ABC: Select Elements with Rhythm"
}
```

### Phase 5: Tests

Create tests for the new selectors following the established patterns.

File: `abct2/tests/typeSelectors.spec.ts`

Add imports for new selectors (update lines 6-11):

```typescript
import {
  selectChords,
  selectNotes,
  selectNonChordNotes,
  selectChordNotes,
  selectRests,
  selectRhythm,
  selectRhythmParent,
} from "../src/selectors/typeSelectors";
```

Add new describe blocks at the end of the file (before the final closing brace):

```typescript
describe("selectRhythm", () => {
  describe("examples", () => {
    it("C2 D E/4 F| — selectRhythm produces 2 cursors (C2 and E/4 have explicit rhythm)", () => {
      const sel = toSelection("X:1\nK:C\nC2 D E/4 F|\n");
      const result = selectRhythm(sel);
      expect(result.cursors.length).to.equal(2);
    });

    it("[CEG]2 C D| — selectRhythm produces 1 cursor (chord has rhythm)", () => {
      const sel = toSelection("X:1\nK:C\n[CEG]2 C D|\n");
      const result = selectRhythm(sel);
      expect(result.cursors.length).to.equal(1);
    });

    it("C D E F| — selectRhythm produces 0 cursors (no explicit rhythms)", () => {
      const sel = toSelection("X:1\nK:C\nC D E F|\n");
      const result = selectRhythm(sel);
      expect(result.cursors.length).to.equal(0);
    });

    it("z2 z z/2| — selectRhythm produces 2 cursors (z2 and z/2)", () => {
      const sel = toSelection("X:1\nK:C\nz2 z z/2|\n");
      const result = selectRhythm(sel);
      expect(result.cursors.length).to.equal(2);
    });

    it("every cursor in selectRhythm result contains exactly 1 ID of a Rhythm CSNode", () => {
      const sel = toSelection("X:1\nK:C\nC2 D E/4 [FA]2|\n");
      const result = selectRhythm(sel);
      for (const cursor of result.cursors) {
        expect(cursor.size).to.equal(1);
        const id = [...cursor][0];
        const node = findById(result.root, id);
        expect(node).to.not.be.null;
        expect(node!.tag).to.equal(TAGS.Rhythm);
      }
    });
  });
});

describe("selectRhythmParent", () => {
  describe("examples", () => {
    it("C2 D E/4 F| — selectRhythmParent produces 2 cursors", () => {
      const sel = toSelection("X:1\nK:C\nC2 D E/4 F|\n");
      const result = selectRhythmParent(sel);
      expect(result.cursors.length).to.equal(2);
    });

    it("[CEG]2 C D| — selectRhythmParent produces 1 cursor (the chord)", () => {
      const sel = toSelection("X:1\nK:C\n[CEG]2 C D|\n");
      const result = selectRhythmParent(sel);
      expect(result.cursors.length).to.equal(1);
      const id = [...result.cursors[0]][0];
      const node = findById(result.root, id);
      expect(node!.tag).to.equal(TAGS.Chord);
    });

    it("C D E F| — selectRhythmParent produces 0 cursors", () => {
      const sel = toSelection("X:1\nK:C\nC D E F|\n");
      const result = selectRhythmParent(sel);
      expect(result.cursors.length).to.equal(0);
    });

    it("z2 z z/2| — selectRhythmParent produces 2 cursors (rests with rhythm)", () => {
      const sel = toSelection("X:1\nK:C\nz2 z z/2|\n");
      const result = selectRhythmParent(sel);
      expect(result.cursors.length).to.equal(2);
      for (const cursor of result.cursors) {
        const id = [...cursor][0];
        const node = findById(result.root, id);
        expect(node!.tag).to.equal(TAGS.Rest);
      }
    });

    it("selectRhythmParent returns Note, Chord, Rest, or YSPACER nodes only", () => {
      const sel = toSelection("X:1\nK:C\nC2 [DF]4 z/2 y2|\n");
      const result = selectRhythmParent(sel);
      const validTags = new Set([TAGS.Note, TAGS.Chord, TAGS.Rest, TAGS.YSPACER]);
      for (const cursor of result.cursors) {
        const id = [...cursor][0];
        const node = findById(result.root, id);
        expect(validTags.has(node!.tag)).to.be.true;
      }
    });

    it("y2 y| — selectRhythmParent selects only the y2 spacer", () => {
      const sel = toSelection("X:1\nK:C\ny2 C y|\n");
      const result = selectRhythmParent(sel);
      // y2 has rhythm, C has no rhythm, y has no rhythm
      expect(result.cursors.length).to.equal(1);
      const id = [...result.cursors[0]][0];
      const node = findById(result.root, id);
      expect(node!.tag).to.equal(TAGS.YSPACER);
    });
  });

  describe("properties", () => {
    it("selectRhythm cursor count equals selectRhythmParent cursor count for tunes without chord-internal note rhythms", () => {
      // For simple cases where rhythm is only on the parent (Note/Chord/Rest),
      // not on notes inside chords, the counts should match
      const sel = toSelection("X:1\nK:C\nC2 D [EG]4 z/2|\n");
      const rhythms = selectRhythm(sel);
      const parents = selectRhythmParent(sel);
      expect(rhythms.cursors.length).to.equal(parents.cursors.length);
    });
  });
});
```

---

## File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `abct2/src/csTree/types.ts` | Add | `isRhythm`, `isYSpacer`, `hasRhythmChild`, `isRhythmParent` predicates |
| `abct2/src/selectors/typeSelectors.ts` | Add | `selectRhythm`, `selectRhythmParent` functions; update imports |
| `abc-lsp-server/src/selectorLookup.ts` | Add | Register both selectors in SELECTOR_MAP; update imports |
| `vscode-extension/src/selectorCommands.ts` | Add | Two new command entries in selectorCommands array |
| `vscode-extension/package.json` | Add | Two new command contributions |
| `abct2/tests/typeSelectors.spec.ts` | Add | Test suites for both selectors; update imports |

---

## To Do List

Phase 1: CSTree Type Predicates
- Add `isRhythm` predicate to `abct2/src/csTree/types.ts`
- Add `isYSpacer` predicate to `abct2/src/csTree/types.ts`
- Add `hasRhythmChild` helper function to `abct2/src/csTree/types.ts`
- Add `isRhythmParent` predicate to `abct2/src/csTree/types.ts`

Phase 2: Selector Functions
- Update imports in `abct2/src/selectors/typeSelectors.ts` to include new predicates
- Add `selectRhythm` function to `abct2/src/selectors/typeSelectors.ts`
- Add `selectRhythmParent` function to `abct2/src/selectors/typeSelectors.ts`

Phase 3: Language Server Integration
- Update imports in `abc-lsp-server/src/selectorLookup.ts` to include new selectors
- Add `selectRhythm` entry to SELECTOR_MAP
- Add `selectRhythmParent` entry to SELECTOR_MAP

Phase 4: VSCode Extension Commands
- Add `["abc.selectRhythm", "selectRhythm"]` to selectorCommands array in `vscode-extension/src/selectorCommands.ts`
- Add `["abc.selectRhythmParent", "selectRhythmParent"]` to selectorCommands array
- Add command contribution for `abc.selectRhythm` in `vscode-extension/package.json`
- Add command contribution for `abc.selectRhythmParent` in `vscode-extension/package.json`

Phase 5: Tests
- Update imports in `abct2/tests/typeSelectors.spec.ts` to include new selectors
- Add example-based tests for `selectRhythm`
- Add example-based tests for `selectRhythmParent`
- Add property-based tests for relationship between the two selectors

Final Steps
- Final verification: build and tests both pass.
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
