# insertVoiceLine Implementation Plan

## Table of Contents

1. [Overview](#overview)
2. [Phase 1: Core Transform Function](#phase-1-core-transform-function)
3. [Phase 2: LSP Server Integration](#phase-2-lsp-server-integration)
4. [Phase 3: VSCode Extension Command](#phase-3-vscode-extension-command)
5. [Phase 4: Kakoune Plugin Integration](#phase-4-kakoune-plugin-integration)

---

## Overview

This plan implements a voice inserter command that allows users to create voice overlays from selected notes. The user selects notes on one or more lines, calls the command, inputs a voice name, and the command duplicates each line containing selections, prefixes it with an inline voice marker `[V:name]`, and converts all non-selected notes to rests.

### Behavior Summary

- User selects notes using custom note/chord selectors
- User invokes the command and enters a voice identifier
- If the voice ID does not exist in the tune header, it is added automatically
- For each line containing at least one selection:
  - The line is duplicated and inserted immediately after the original
  - The duplicate is prefixed with `[V:userinput]`
  - Non-selected notes are converted to rests (preserving duration)
  - Chords with some selected notes keep only those notes
  - Chords with no selected notes are converted to rests
  - Grace groups before non-selected notes are removed
  - Grace groups before selected notes are preserved
  - Decorations, articulations, tuplet markers, slurs, bar lines, section indicators, and info markers are preserved

---

## Phase 1: Core Transform Function

### Overview

This phase creates the `insertVoiceLine` transform in the `abct2` package.

### Location

`/workspace/abc_parse/abct2/src/transforms/insertVoiceLine.ts`

### Dependencies

- `CSNode`, `TAGS`, `createCSNode` from `../csTree/types`
- `ABCContext`, `TT` from `abc-parser`
- `Selection` from `../selection`
- `removeChild` from `./treeUtils`
- `addVoice` from `./addVoice` (for adding voice to header if missing)

### Refactoring needed

Export `noteToRest` and `chordToRest` from `toRest.ts` (currently private).

### Transform signature

```typescript
function insertVoiceLine(
  selection: Selection,
  voiceName: string,
  ctx: ABCContext
): Selection
```

The transform uses `selection.cursors` to build a `Set<number>` of selected node IDs. Because CSNode is a plain object (no classes), we use `structuredClone` to clone lines while preserving original IDs, then reassign fresh IDs before insertion.

### Functions to create

| Function | Notes |
|----------|-------|
| `reassignIds(node: CSNode, ctx: ABCContext): void` | Recursive walk to assign fresh IDs from ctx |
| `findTargetNote(graceGroup: CSNode): CSNode \| null` | Skip Decoration, Annotation, ChordSymbol, Inline_field, Token to find target |
| `createInlineVoiceMarker(voiceName: string, ctx: ABCContext): CSNode` | Creates `[V:name]` Inline_field node |
| `chordHasSelectedNotes(chord: CSNode, selectedIds: Set<number>): boolean` | Checks if any note children are in selectedIds |
| `removeUnselectedNotesFromChord(chord: CSNode, selectedIds: Set<number>): void` | Removes note children not in selectedIds |
| `voiceExistsInHeader(root: CSNode, voiceId: string): boolean` | Checks if a V: line with the given ID exists in the tune header |

### Helper: finding the target note of a grace group

Because decorations, annotations, chord symbols, inline fields, and slur tokens can appear between a grace group and its target note, we need a helper function that skips over these intermediate elements:

```
function findTargetNote(graceGroup: CSNode): CSNode | null
  current = graceGroup.nextSibling

  while current is not null
    if current.tag in [Note, Chord, Rest]
      return current

    if current.tag in [Decoration, Annotation, ChordSymbol, Inline_field, Token]
      current = current.nextSibling
      continue

    // Structural element (BarLine, Beam, Tuplet, etc.) - no target found
    return null

  return null
```

### Main algorithm

```
selectedIds = flatten all cursor sets from selection into Set<number>

// Add voice to header if missing
if not voiceExistsInHeader(selection.root, voiceName)
  addVoice(selection, voiceName, {}, ctx)

for each music line in tree (reverse order)
  if line contains no node with ID in selectedIds
    continue

  duplicate = structuredClone(line)
  prepend createInlineVoiceMarker(voiceName, ctx) to duplicate

  prev = null
  current = first child of duplicate

  while current is not null
    next = current.nextSibling

    if current is Grace_group
      targetNote = findTargetNote(current)
      shouldRemove = false

      if targetNote is null
        shouldRemove = false
      else if targetNote is Rest
        shouldRemove = true
      else if targetNote is Note
        shouldRemove = targetNote.id not in selectedIds
      else if targetNote is Chord
        shouldRemove = not chordHasSelectedNotes(targetNote, selectedIds)

      if shouldRemove
        unlink current from duplicate
        current = next
        continue

    if current is Note
      if current.id not in selectedIds
        noteToRest(current, ctx)

    if current is Chord
      if not chordHasSelectedNotes(current, selectedIds)
        chordToRest(current, ctx)
      else
        removeUnselectedNotesFromChord(current, selectedIds)

    prev = current
    current = next

  reassignIds(duplicate, ctx)
  insert duplicate after original line in tree

return selection
```

### Why reverse iteration

We iterate lines in reverse order so that newly inserted duplicates (which appear after each original line) are never processed by subsequent iterations.

### Testing

Example-based tests:
- Basic case: single note selected, others converted to rests
- Chord with partial selection: only selected notes kept
- Chord with no selection: converted to rest
- Grace group before selected note: preserved
- Grace group before non-selected note: removed
- Grace group with intermediate decorations before target note
- Multiple lines with selections across them
- Inline voice markers already present in source
- Voice ID not in header: adds V: line to header
- Voice ID already in header: does not duplicate V: line

Property-based tests:
- For any valid music line with at least one note selected, the duplicated line has the same number of rhythmic positions
- For any duplicated line, all selected notes appear unchanged
- For any grace group in the duplicate, its target note (if found) must be selected
- The total duration of the duplicated line equals the original line's duration

### To do

- Export `noteToRest` and `chordToRest` from `toRest.ts`
- Create `insertVoiceLine.ts`
- Implement `reassignIds`
- Implement `findTargetNote`
- Implement `createInlineVoiceMarker`
- Implement `chordHasSelectedNotes`
- Implement `removeUnselectedNotesFromChord`
- Implement `voiceExistsInHeader`
- Write example-based unit tests in `abct2/tests/insertVoiceLine.spec.ts`
- Write property-based tests in `abct2/tests/insertVoiceLine.spec.ts`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: LSP Server Integration

### Overview

This phase integrates the `insertVoiceLine` transform with the LSP server. The transform uses `Selection` with node IDs, so it fits the existing transform pattern.

### Location

`/workspace/abc_parse/abc-lsp-server/src/transformLookup.ts`

### Changes to transformLookup.ts

Add import:

```typescript
import { insertVoiceLine } from "../../abct2/src/transforms/insertVoiceLine";
```

Add to `TRANSFORM_MAP`:

```typescript
insertVoiceLine: (sel, ctx, ...args) => insertVoiceLine(sel, args[0] as string, ctx),
```

### Changes to server.ts

Add `insertVoiceLine` to `TRANSFORM_NODE_TAGS` with `[TAGS.Note, TAGS.Chord]` so the handler knows which node types to look for when converting ranges to IDs.

### Request format

The extension sends the standard `abct2.applyTransform` request:

```typescript
{
  uri: string
  transform: "insertVoiceLine"
  args: [voiceName: string]
  selections: Range[]
}
```

### Export from abct2

Add `insertVoiceLine` to the exports in `/workspace/abc_parse/abct2/src/transforms/index.ts`.

### To do

- Add `insertVoiceLine` export to `abct2/src/transforms/index.ts`
- Add `insertVoiceLine` import to `transformLookup.ts`
- Add `insertVoiceLine` entry to `TRANSFORM_MAP`
- Add `insertVoiceLine` to `TRANSFORM_NODE_TAGS`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: VSCode Extension Command

### Overview

This phase adds the `insertVoiceLine` command to the VSCode extension. The command prompts the user for a voice name and sends the transform request to the LSP server.

### Location

`/workspace/abc_parse/vscode-extension/src/transformCommands.ts`

### Command registration

Register a new command `abc.insertVoiceLine` in `package.json` and in the extension activation.

### Command implementation

```typescript
async function insertVoiceLine() {
  const editor = vscode.window.activeTextEditor;
  if (!editor) return;

  const voiceName = await vscode.window.showInputBox({
    prompt: "Enter voice identifier",
    placeHolder: "e.g., V2, Tenor, RH"
  });

  if (!voiceName) return;  // user cancelled

  const selections = editor.selections.map(sel => ({
    start: { line: sel.start.line, character: sel.start.character },
    end: { line: sel.end.line, character: sel.end.character }
  }));

  const result = await client.sendRequest("abct2.applyTransform", {
    uri: editor.document.uri.toString(),
    transform: "insertVoiceLine",
    args: [voiceName],
    selections
  });

  // Apply text edits
  if (result.textEdits && result.textEdits.length > 0) {
    const workspaceEdit = new vscode.WorkspaceEdit();
    for (const edit of result.textEdits) {
      workspaceEdit.replace(
        editor.document.uri,
        new vscode.Range(
          edit.range.start.line, edit.range.start.character,
          edit.range.end.line, edit.range.end.character
        ),
        edit.newText
      );
    }
    await vscode.workspace.applyEdit(workspaceEdit);
  }
}
```

### package.json additions

Add command definition:

```json
{
  "command": "abc.insertVoiceLine",
  "title": "ABC: Insert Voice Line"
}
```

Optionally add a keybinding.

### To do

- Add command to `package.json` commands array
- Register command in extension activation
- Implement `insertVoiceLine` command handler
- Test the full flow: select notes, invoke command, enter voice name, verify result
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 4: Kakoune Plugin Integration

### Overview

This phase adds the `insertVoiceLine` command to the Kakoune plugin. Because the socket handler currently only supports `abct2.applySelector`, we also need to extend it to support transforms.

### Locations

- `/workspace/abc_parse/abc-lsp-server/src/socketHandler.ts` - extend to support transforms
- `/workspace/abc_parse/abc-kak/rc/abc-transforms.kak` (new file) - transform commands
- `/workspace/abc_parse/abc-kak/bin/abc-kak-client.js` - add transform mode
- `/workspace/abc_parse/abc-kak/rc/abc.kak` - include new file

### Socket handler changes

Currently `socketHandler.ts` only handles `abct2.applySelector`. Add support for `abct2.applyTransform`:

```typescript
if (request.method === "abct2.applySelector") {
  // existing selector logic
} else if (request.method === "abct2.applyTransform") {
  // similar to the VSCode handler:
  // 1. Parse document
  // 2. Convert ranges to node IDs
  // 3. Apply transform
  // 4. Compute text edits
  // 5. Return edits (not cursor ranges - Kakoune handles differently)
}
```

The response format for transforms:

```typescript
{
  edits: Array<{ range: Range, newText: string }>
}
```

### Client script changes

Add a new mode to `abc-kak-client.js` for transforms:

```javascript
// New CLI mode: --transform <name> --args <json>
if (args.transform) {
  const request = {
    id: 1,
    method: "abct2.applyTransform",
    params: {
      uri: args.uri,
      transform: args.transform,
      args: JSON.parse(args.transformArgs || "[]"),
      ranges: lspRanges,
    },
  };
  // Send request, receive edits, output in Kakoune-friendly format
}
```

### Kakoune commands

Create `/workspace/abc_parse/abc-kak/rc/abc-transforms.kak`:

```kak
# Helper for transform commands
define-command -hidden abc-transform-impl -params 1..2 %{
    # Similar structure to abc-select-impl but:
    # 1. Calls client with --transform flag
    # 2. Receives text edits
    # 3. Applies edits to buffer using exec/reg commands
}

define-command abc-insert-voice-line -params 1 \
    -docstring "Insert a voice line from selected notes with the given voice ID" %{
    abc-transform-impl insertVoiceLine %sh{ printf '["%s"]' "$1" }
}
```

### Applying text edits in Kakoune

Kakoune does not have a direct "apply text edits" mechanism. Options:

1. Replace entire buffer content (simple but loses undo granularity)
2. Use `execute-keys` to navigate and replace each edit region (preserves undo)
3. Use `edit -scratch` buffer for diff then apply

Recommended: option 1 for simplicity initially, can optimize later.

### Testing

Testing the Kakoune integration can be done by invoking Kakoune as a server and impersonating the client. This allows automated testing without a GUI:

```bash
# Start Kakoune in server mode
kak -s test-session -d

# Send commands via kak -p
echo "edit /path/to/test.abc" | kak -p test-session
echo "exec gg" | kak -p test-session
echo "abc-insert-voice-line V2" | kak -p test-session

# Verify buffer contents
echo "write /tmp/result.abc" | kak -p test-session

# Kill session
echo "kill" | kak -p test-session
```

### To do

- Extend `socketHandler.ts` to handle `abct2.applyTransform` method
- Add transform mode to `abc-kak-client.js` (CLI flags and request handling)
- Add text edit output formatting to client (Kakoune-friendly format)
- Create `abc-transforms.kak` with `abc-transform-impl` helper
- Add `abc-insert-voice-line` command
- Update `abc.kak` to source the new file
- Write tests in `abc-kak/spec/abc-transforms.kak-spec`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
