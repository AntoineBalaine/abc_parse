# MuseSampler Integration Plan

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Goals](#goals)
3. [Prior Art](#prior-art)
4. [Background: The MuseSampler Library](#background-the-musesampler-library)
5. [Known Constraints](#known-constraints)
6. [Architecture Overview](#architecture-overview)
7. [Data Flow](#data-flow)
8. [Implementation Phases](#implementation-phases)
9. [Phase 1: Native Binding Layer](#phase-1-native-binding-layer)
10. [Phase 2: Event Converter](#phase-2-event-converter)
11. [Phase 3: Editor Integration](#phase-3-editor-integration)
12. [Testing Strategy](#testing-strategy)
13. [Open Questions](#open-questions)
14. [Dependencies](#dependencies)
15. [Getting Started](#getting-started)

---

## Problem Statement

The abc_parse project produces ABCJS Tune structures that can be rendered visually, but there is no way to play back ABC scores with high-quality audio directly from neovim or vscode. The only current option is to open scores in MuseScore Studio, which breaks the editor workflow.

MuseScore Studio uses a library called MuseSampler to power its Muse Sounds playback engine. This library has a C API that can be accessed independently of the MuseScore application, making direct integration possible.

---

## Goals

1. Enable ABC score playback from neovim and vscode using Muse Sounds quality
2. Provide a programmatic API that accepts the output of the abc_parse interpreter
3. Keep the integration lightweight (no Qt dependencies, no full MuseScore application)
4. Support real-time playback control (play, pause, seek)

---

## Prior Art

Several projects have attempted MuseSampler integration outside of MuseScore. None have achieved production-ready status, but they provide useful reference points.

### pd-musesampler

Repository: https://github.com/charlesneimog/pd-musesampler (archived/deleted)

A PureData object wrapper for MuseSampler. The project worked with MuseSampler 0.5 but broke after version 0.6 due to API changes (`getInstrumentList()` returning nullptr). The repository appears to have been abandoned.

Lesson: The MuseSampler API is not stable across versions. We need to handle version checks carefully and potentially support multiple API versions.

### muse-sampleganger

Repository: https://github.com/zenith391/muse-sampleganger

Blog post: https://zen1th.me/posts/the-musesampleganger/

A Zig reimplementation of the MuseSampler library itself (not an integration). The author reverse-engineered the API by examining MuseScore's `apitypes.h`. Key insights from this project:

1. The API requires knowing all notes upfront (not real-time MIDI)
2. The library uses a sample-based processing model at 44,100 Hz
3. All required function signatures are documented in MuseScore's source

This project is useful as a reference for understanding the API, though it reimplements the engine rather than using the official library.

### JUCE Forum Discussion

Thread: https://forum.juce.com/t/multi-pass-audio-plugin-for-musesounds-sampler/59354

An attempt to create a VST3 wrapper for MuseSounds. The developer identified a fundamental mismatch: MuseSampler requires note durations upfront, but MIDI plugins only receive note-on/note-off events in real-time. No solution was found.

Relevance: This limitation does not affect our use case. Since abc_parse has the complete score parsed, we know all note durations before playback begins.

### MuseScore GitHub Discussion

Discussion: https://github.com/orgs/musescore/discussions/17801

A MuseScore collaborator confirmed:

- MuseSampler CAN be loaded by external programs
- No official documentation exists
- MuseScore's source code is the reference implementation
- Key files: `libhandler.h`, `musesamplersequencer.h`, `musesamplerwrapper.h`

This discussion also revealed the executable name constraint (see Known Constraints below).

---

## Background: The MuseSampler Library

MuseSampler is a dynamically loaded library distributed via MuseHub. MuseScore Studio loads it at runtime and communicates through a C API. The library handles:

- Loading instrument samples (Muse Sounds)
- Accepting note events with timing, pitch, articulation
- Rendering audio buffers

### Library Location

The library is installed by MuseHub at platform-specific paths:

- macOS: `~/Library/Application Support/MuseSampler/lib/libMuseSamplerCoreLib.dylib`
- Windows: `%APPDATA%\MuseHub\MuseSampler\lib\MuseSamplerCoreLib.dll`
- Linux: `~/.local/share/MuseHub/MuseSampler/lib/libMuseSamplerCoreLib.so`

### The C API

MuseScore loads the library dynamically and resolves function pointers. From `src/framework/musesampler/internal/libhandler.h`:

```cpp
// Lifecycle
ms_MuseSampler (* ms_MuseSampler_create)();
void (* ms_MuseSampler_destroy)(ms_MuseSampler);
ms_Result (* ms_MuseSampler_init)(ms_MuseSampler ms, double sample_rate, int block_size, int channel_count);

// Instrument discovery
ms_InstrumentList (* ms_get_instrument_list)();
ms_InstrumentInfo (* ms_InstrumentList_get_next)(ms_InstrumentList instrument_list);
int (* ms_Instrument_get_id)(ms_InstrumentInfo instrument);
const char*(* ms_Instrument_get_name)(ms_InstrumentInfo);
const char*(* ms_Instrument_get_category)(ms_InstrumentInfo);

// Track management
ms_Track (* ms_MuseSampler_add_track)(ms_MuseSampler ms, int instrument_id);
ms_Result (* ms_MuseSampler_finalize_track)(ms_MuseSampler ms, ms_Track track);
ms_Result (* ms_MuseSampler_clear_track)(ms_MuseSampler ms, ms_Track track);

// Event submission
ms_Result (* ms_MuseSampler_add_track_note_event_6)(ms_MuseSampler ms, ms_Track track, ms_NoteEvent_5 evt, long long& event_id);
ms_Result (* ms_MuseSampler_add_track_dynamics_event_2)(ms_MuseSampler ms, ms_Track track, ms_DynamicsEvent_2 evt);
ms_Result (* ms_MuseSampler_add_track_pedal_event_2)(ms_MuseSampler ms, ms_Track track, ms_PedalEvent_2 evt);

// Playback control
void (* ms_MuseSampler_set_position)(ms_MuseSampler, long long samples);
void (* ms_MuseSampler_set_playing)(ms_MuseSampler, int playing);
ms_Result (* ms_MuseSampler_process)(ms_MuseSampler, ms_OutputBuffer, long long samples);
ms_Result (* ms_MuseSampler_all_notes_off)(ms_MuseSampler);
```

### The NoteEvent Structure

From `src/framework/musesampler/internal/apitypes.h`:

```cpp
typedef struct ms_NoteEvent_5
{
    int _voice;                        // 0-3
    long long _location_us;            // microseconds from start
    long long _duration_us;            // duration in microseconds
    int _pitch;                        // MIDI pitch (60 = C4)
    double _tempo;                     // BPM
    int _offset_cents;                 // microtonal adjustment (-50 = quarter flat)
    ms_NoteArticulation _articulation; // bitflags for articulations
    ms_NoteArticulation2 _articulation_2; // additional articulation flags
    ms_NoteHead _notehead;             // notehead style
} ms_NoteEvent_5;
```

### Articulation Flags

From `src/framework/musesampler/internal/apitypes.h`:

```cpp
enum ms_NoteArticulation : uint64_t
{
    ms_NoteArticulation_None = 0,
    ms_NoteArticulation_Staccato = 1LL << 0,
    ms_NoteArticulation_Staccatissimo = 1LL << 1,
    ms_NoteArticulation_Accent = 1LL << 2,
    ms_NoteArticulation_Tenuto = 1LL << 3,
    ms_NoteArticulation_Marcato = 1LL << 4,
    ms_NoteArticulation_Harmonics = 1LL << 5,
    ms_NoteArticulation_Mute = 1LL << 6,
    ms_NoteArticulation_Trill = 1LL << 7,
    // ... many more
    ms_NoteArticulation_Pizzicato = 1LL << 37,
    ms_NoteArticulation_Glissando = 1LL << 39,
    ms_NoteArticulation_Pedal = 1LL << 40,
    ms_NoteArticulation_Slur = 1LL << 41,
    // ...
};
```

### Dynamics Events

```cpp
typedef struct ms_DynamicsEvent_2
{
    long long _location_us;
    double _value; // 0.0 - 1.0
} ms_DynamicsEvent_2;
```

### Output Buffer

```cpp
typedef struct ms_OutputBuffer
{
    float** _channels;
    int _num_data_pts;
    int _num_channels;
} ms_OutputBuffer;
```

---

## Known Constraints

### Executable Name Validation

MuseSampler validates that the calling executable is named `mscore`. This check is performed inside the closed-source library itself (not in MuseScore's open-source code). On macOS, renaming the MuseScore binary to anything other than `mscore` causes MuseSampler initialization to fail.

Source: https://github.com/orgs/musescore/discussions/17801

This constraint affects distribution but not local development or personal use.

### Workarounds

For local use, the workarounds are trivial:

```bash
# Option 1: Name your binary mscore
mv abc-play mscore
./mscore

# Option 2: Symlink
ln -s abc-play mscore
./mscore

# Option 3: Wrapper script named mscore
#!/bin/bash
exec /path/to/real/abc-play "$@"
```

### Impact Assessment

| Use Case | Impact |
|----------|--------|
| Local development | None (rename binary) |
| Personal use | None (rename binary or symlink) |
| Power users | None (can rename binary) |
| Official distribution | Problematic (trademark, user confusion) |

For the purposes of this project, we target local/personal use. The executable can be named `mscore` or wrapped appropriately.

### API Version Instability

The pd-musesampler project broke after MuseSampler 0.6 due to API changes. MuseScore's `libhandler.h` handles this by:

1. Checking library version at load time
2. Loading different function pointers based on version
3. Providing fallback implementations for older versions

From `libhandler.h`:

```cpp
bool at_least_v_0_102 = (m_version.major() == 0 && m_version.minor() >= 102) || m_version.major() > 0;
bool at_least_v_0_103 = (m_version.major() == 0 && m_version.minor() >= 103) || m_version.major() > 0;

if (at_least_v_0_102) {
    addNoteEventInternal6 = (ms_MuseSampler_add_track_note_event_6)muse::getLibFunc(m_lib, "ms_MuseSampler_add_track_note_event_6");
} else {
    addNoteEventInternal5 = (ms_MuseSampler_add_track_note_event_5)muse::getLibFunc(m_lib, "ms_MuseSampler_add_track_note_event_5");
}
```

We should follow this pattern to support multiple MuseSampler versions.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Editor (neovim/vscode)                   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                │ ABC text
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                         abc_parse                               │
│  ┌──────────┐    ┌──────────┐    ┌────────────────────┐        │
│  │ Scanner  │ -> │  Parser  │ -> │  TuneInterpreter   │        │
│  └──────────┘    └──────────┘    └────────────────────┘        │
│                                           │                     │
│                                           │ ABCJS Tune          │
│                                           ▼                     │
│                              ┌────────────────────────┐         │
│                              │   MuseSamplerConverter │         │
│                              │   (new module)         │         │
│                              └────────────────────────┘         │
└─────────────────────────────────────────────────────────────────┘
                                │
                                │ ms_NoteEvent_5[]
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Native Binding (C++ / Node addon)             │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                  MuseSamplerWrapper                       │   │
│  │  - loadLibrary(path)                                      │   │
│  │  - getInstruments(): Instrument[]                         │   │
│  │  - createSession(sampleRate, blockSize): Session          │   │
│  │  - Session.addTrack(instrumentId): Track                  │   │
│  │  - Session.addNoteEvent(track, event)                     │   │
│  │  - Session.play() / pause() / seek(position)              │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                │ dlopen / LoadLibrary
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│              MuseSampler Library (libMuseSamplerCoreLib)        │
│                     (closed-source, from MuseHub)               │
└─────────────────────────────────────────────────────────────────┘
                                │
                                │ audio buffers
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Audio Output (PortAudio / miniaudio)       │
└─────────────────────────────────────────────────────────────────┘
```

---

## Data Flow

### Input: ABCJS Tune Structure

The abc_parse TuneInterpreter produces a `Tune` object with this structure (from `parse/types/abcjs-ast.ts`):

```typescript
interface Tune {
  systems: USystem[];        // Staff systems containing music
  metaText: MetaText;        // Title, composer, tempo, etc.
  formatting: TuneFormatting;
}

interface StaffSystem {
  staff: Staff[];
}

interface Staff {
  voices: VoiceElement[][];  // Array of voices, each containing elements
}

interface NoteElement {
  el_type: ElementType.Note;
  duration: IRational;       // Duration as fraction (e.g., {n: 1, d: 4} for quarter)
  pitches?: Pitch[];         // Array of pitches (for chords)
  rest?: RestProperties;
  decoration?: Decorations[];
  // ...
}

interface Pitch {
  pitch: number;             // Vertical position (0 = middle C line)
  name: string;              // Note name with accidentals (e.g., "^F")
  accidental?: AccidentalType;
}
```

### Output: MuseSampler Events

The converter must produce `ms_NoteEvent_5` structures:

```typescript
interface MuseSamplerNoteEvent {
  voice: number;           // 0-3
  location_us: bigint;     // microseconds from start
  duration_us: bigint;     // duration in microseconds
  pitch: number;           // MIDI pitch (60 = C4)
  tempo: number;           // BPM
  offset_cents: number;    // microtonal offset
  articulation: bigint;    // bitflags
  articulation_2: bigint;  // additional flags
  notehead: number;        // notehead style enum
}
```

### Conversion Logic

The converter must:

1. Walk through all systems, staves, and voices
2. Track cumulative time position
3. Convert ABC pitch notation to MIDI pitch
4. Convert ABC duration (fraction) to microseconds using tempo
5. Map ABC decorations to MuseSampler articulation flags

---

## Implementation Phases

### Phase 1: Native Binding Layer

Create a C++ wrapper that loads the MuseSampler library and exposes it to Node.js.

### Phase 2: Event Converter

Create a TypeScript module that converts ABCJS Tune to MuseSampler events.

### Phase 3: Editor Integration

Integrate with vscode-extension and neovim-extension to provide playback commands.

---

## Phase 1: Native Binding Layer

### Files to Create

```
abc_parse/
  native/
    binding.gyp              # Node-gyp build config
    src/
      musesampler_wrapper.h  # C++ header
      musesampler_wrapper.cpp # C++ implementation
      addon.cpp              # Node.js binding
    lib/
      index.ts               # TypeScript interface
      index.d.ts             # Type declarations
```

### The Wrapper Class

Based on MuseScore's `MuseSamplerLibHandler`, we need a simplified wrapper:

```cpp
// musesampler_wrapper.h
class MuseSamplerWrapper {
public:
    bool loadLibrary(const std::string& path);
    bool isLoaded() const;

    // Instrument discovery
    std::vector<InstrumentInfo> getInstruments();

    // Session management
    SessionHandle createSession(double sampleRate, int blockSize, int channels);
    void destroySession(SessionHandle session);

    // Track management
    TrackHandle addTrack(SessionHandle session, int instrumentId);
    void finalizeTrack(SessionHandle session, TrackHandle track);

    // Event submission
    void addNoteEvent(SessionHandle session, TrackHandle track, const NoteEvent& event);
    void addDynamicsEvent(SessionHandle session, TrackHandle track, int64_t location_us, double value);

    // Playback control
    void setPosition(SessionHandle session, int64_t samples);
    void setPlaying(SessionHandle session, bool playing);
    void process(SessionHandle session, float** outputBuffers, int sampleCount);

private:
    // Function pointers (loaded from library)
    ms_MuseSampler_create_t m_create = nullptr;
    ms_MuseSampler_destroy_t m_destroy = nullptr;
    // ... etc

    void* m_lib = nullptr;
};
```

### Loading Pattern

From MuseScore's `libhandler.h`:

```cpp
bool loadApi(const Version& minSupportedVersion, bool useLegacyAudition = false)
{
    IF_ASSERT_FAILED(m_lib) {
        return false;
    }

    auto getVersionMajor = (ms_get_version_major)muse::getLibFunc(m_lib, "ms_get_version_major");
    auto getVersionMinor = (ms_get_version_minor)muse::getLibFunc(m_lib, "ms_get_version_minor");
    auto getVersionRevision = (ms_get_version_revision)muse::getLibFunc(m_lib, "ms_get_version_revision");

    // Invalid...
    if (!getVersionMajor || !getVersionMinor || !getVersionRevision) {
        return false;
    }

    m_version = Version(getVersionMajor(), getVersionMinor(), getVersionRevision());

    if (m_version < minSupportedVersion) {
        LOGE() << "MuseSampler " << m_version.toString() << " is not supported";
        return false;
    }

    // Load all function pointers
    initLib = (ms_init)muse::getLibFunc(m_lib, "ms_init");
    getInstrumentList = (ms_get_instrument_list)muse::getLibFunc(m_lib, "ms_get_instrument_list");
    create = (ms_MuseSampler_create)muse::getLibFunc(m_lib, "ms_MuseSampler_create");
    destroy = (ms_MuseSampler_destroy)muse::getLibFunc(m_lib, "ms_MuseSampler_destroy");
    // ... etc

    return isValid();
}
```

### Node.js Binding

Using Node-API (N-API) for stable ABI:

```cpp
// addon.cpp
#include <napi.h>
#include "musesampler_wrapper.h"

class MuseSamplerAddon : public Napi::ObjectWrap<MuseSamplerAddon> {
public:
    static Napi::Object Init(Napi::Env env, Napi::Object exports);
    MuseSamplerAddon(const Napi::CallbackInfo& info);

private:
    Napi::Value LoadLibrary(const Napi::CallbackInfo& info);
    Napi::Value GetInstruments(const Napi::CallbackInfo& info);
    Napi::Value CreateSession(const Napi::CallbackInfo& info);
    Napi::Value AddTrack(const Napi::CallbackInfo& info);
    Napi::Value AddNoteEvent(const Napi::CallbackInfo& info);
    Napi::Value Play(const Napi::CallbackInfo& info);
    Napi::Value Pause(const Napi::CallbackInfo& info);
    Napi::Value Seek(const Napi::CallbackInfo& info);

    MuseSamplerWrapper m_wrapper;
};
```

### Audio Output

For audio output, we need a cross-platform solution. Options:

1. miniaudio (single-header, MIT license)
2. PortAudio (widely used, MIT license)
3. RtAudio (C++, MIT license)

Recommendation: miniaudio for simplicity (single header, no dependencies).

---

## Phase 2: Event Converter

### Files to Create

```
abc_parse/
  parse/
    playback/
      converter.ts           # ABCJS Tune to MuseSampler events
      types.ts               # TypeScript types for events
      articulation-map.ts    # ABC decoration to articulation mapping
      pitch-utils.ts         # Pitch conversion utilities
```

### Pitch Conversion

ABC pitch to MIDI pitch conversion:

```typescript
// pitch-utils.ts

/**
 * We convert ABC pitch notation to MIDI pitch number.
 *
 * ABC uses a vertical position system where 0 = middle C (C4).
 * MIDI uses absolute numbers where 60 = C4.
 *
 * The ABCJS Pitch.pitch field is the vertical position:
 *   C4 = 0, D4 = 1, E4 = 2, F4 = 3, G4 = 4, A4 = 5, B4 = 6
 *   C5 = 7, etc.
 *
 * We need to convert this to MIDI pitch:
 *   C4 = 60, D4 = 62, E4 = 64, F4 = 65, G4 = 67, A4 = 69, B4 = 71
 */

const PITCH_CLASS_TO_SEMITONE: Record<number, number> = {
  0: 0,   // C
  1: 2,   // D
  2: 4,   // E
  3: 5,   // F
  4: 7,   // G
  5: 9,   // A
  6: 11,  // B
};

export function abcPitchToMidi(verticalPos: number, accidental?: AccidentalType): number {
  // Each octave is 7 positions
  const octave = Math.floor(verticalPos / 7);
  const pitchClass = ((verticalPos % 7) + 7) % 7; // Handle negative positions

  // Base MIDI pitch (C4 = 60, so C0 = 12)
  const baseMidi = 60 + (octave * 12) + PITCH_CLASS_TO_SEMITONE[pitchClass];

  // Apply accidental
  let offset = 0;
  if (accidental === AccidentalType.Sharp) offset = 1;
  else if (accidental === AccidentalType.Flat) offset = -1;
  else if (accidental === AccidentalType.DblSharp) offset = 2;
  else if (accidental === AccidentalType.DblFlat) offset = -2;

  return baseMidi + offset;
}
```

### Duration Conversion

ABC duration (fraction) to microseconds:

```typescript
// converter.ts

/**
 * We convert ABC duration fractions to microseconds using tempo.
 *
 * The ABCJS NoteElement.duration is an IRational (e.g., {n: 1, d: 4} for quarter note).
 *
 * To get microseconds:
 *   1. Calculate beats = duration * beat_length (from L: field, default 1/8)
 *   2. Calculate seconds = beats * 60 / bpm
 *   3. Convert to microseconds
 */

export function durationToMicroseconds(
  duration: IRational,
  bpm: number,
  beatLength: IRational  // From L: field
): bigint {
  // Duration in whole notes
  const wholeNotes = (duration.n / duration.d);

  // Beat length in whole notes (e.g., 1/8 = 0.125)
  const beatLengthWholeNotes = beatLength.n / beatLength.d;

  // Duration in beats
  const beats = wholeNotes / beatLengthWholeNotes;

  // Duration in seconds
  const seconds = (beats * 60) / bpm;

  // Convert to microseconds
  return BigInt(Math.round(seconds * 1_000_000));
}
```

### Articulation Mapping

Map ABC decorations to MuseSampler articulation flags:

```typescript
// articulation-map.ts

/**
 * We map ABC decorations (from ABCJS) to MuseSampler articulation flags.
 *
 * From MuseScore's apitypes.h:
 *   ms_NoteArticulation_Staccato = 1LL << 0
 *   ms_NoteArticulation_Accent = 1LL << 2
 *   ms_NoteArticulation_Tenuto = 1LL << 3
 *   etc.
 */

export const ARTICULATION_MAP: Record<string, bigint> = {
  [Decorations.Staccato]: 1n << 0n,       // ms_NoteArticulation_Staccato
  [Decorations.Accent]: 1n << 2n,         // ms_NoteArticulation_Accent
  [Decorations.Tenuto]: 1n << 3n,         // ms_NoteArticulation_Tenuto
  [Decorations.Marcato]: 1n << 4n,        // ms_NoteArticulation_Marcato
  [Decorations.Fermata]: 0n,              // No direct mapping, handle separately
  [Decorations.Trill]: 1n << 7n,          // ms_NoteArticulation_Trill
  [Decorations.UpperMordent]: 1n << 8n,   // ms_NoteArticulation_MordentSemi
  [Decorations.LowerMordent]: 1n << 10n,  // ms_NoteArticulation_MordentInvertedSemi
  [Decorations.Turn]: 1n << 12n,          // ms_NoteArticulation_TurnSemiWhole
  [Decorations.Arpeggio]: 1n << 20n,      // ms_NoteArticulation_ArpeggioUp
  // ... etc
};

export function decorationsToArticulation(decorations: Decorations[]): bigint {
  let flags = 0n;
  for (const dec of decorations) {
    if (ARTICULATION_MAP[dec]) {
      flags |= ARTICULATION_MAP[dec];
    }
  }
  return flags;
}
```

### The Main Converter

```typescript
// converter.ts

export interface ConversionResult {
  events: MuseSamplerNoteEvent[];
  dynamicsEvents: MuseSamplerDynamicsEvent[];
  totalDuration_us: bigint;
  tempo: number;
}

export function convertTuneToMuseSamplerEvents(tune: Tune): ConversionResult {
  const events: MuseSamplerNoteEvent[] = [];
  const dynamicsEvents: MuseSamplerDynamicsEvent[] = [];

  // Get tempo from metaText
  const tempo = tune.metaText.tempo?.bpm ?? 120;

  // Get beat length (default 1/8)
  const beatLength = getBeatLength(tune);

  let currentPosition_us = 0n;

  for (const system of tune.systems) {
    if (!isMusicLine(system)) continue;

    for (const staff of system.staff) {
      let voiceIndex = 0;

      for (const voice of staff.voices) {
        let voicePosition_us = currentPosition_us;

        for (const element of voice) {
          if (isNoteElement(element)) {
            const duration_us = durationToMicroseconds(element.duration, tempo, beatLength);

            if (element.pitches) {
              // Handle notes (including chords)
              for (const pitch of element.pitches) {
                events.push({
                  voice: voiceIndex % 4,
                  location_us: voicePosition_us,
                  duration_us,
                  pitch: abcPitchToMidi(pitch.pitch, pitch.accidental),
                  tempo,
                  offset_cents: 0,
                  articulation: decorationsToArticulation(element.decoration ?? []),
                  articulation_2: 0n,
                  notehead: 0, // Normal
                });
              }
            } else if (element.rest) {
              // Rests just advance time, no event
            }

            voicePosition_us += duration_us;
          }
        }

        voiceIndex++;
      }
    }
  }

  return {
    events,
    dynamicsEvents,
    totalDuration_us: /* calculate max position */,
    tempo,
  };
}
```

---

## Phase 3: Editor Integration

### VSCode Extension

Add playback commands to `vscode-extension/`:

```typescript
// commands/playback.ts

import { MuseSamplerBinding } from '../native';
import { convertTuneToMuseSamplerEvents } from '../../parse/playback/converter';

let sampler: MuseSamplerBinding | null = null;

export async function initializePlayback() {
  sampler = new MuseSamplerBinding();
  const libPath = getMuseSamplerLibraryPath();

  if (!await sampler.loadLibrary(libPath)) {
    vscode.window.showErrorMessage('MuseSampler not found. Install Muse Sounds via MuseHub.');
    return false;
  }

  return true;
}

export async function playCurrentDocument() {
  const editor = vscode.window.activeTextEditor;
  if (!editor || !sampler) return;

  const abcText = editor.document.getText();
  const tune = parseTune(abcText);
  const { events, tempo } = convertTuneToMuseSamplerEvents(tune);

  const session = sampler.createSession(44100, 512, 2);
  const track = sampler.addTrack(session, getDefaultInstrumentId());

  for (const event of events) {
    sampler.addNoteEvent(session, track, event);
  }

  sampler.finalizeTrack(session, track);
  sampler.play(session);
}
```

### Neovim Extension

Add Lua bindings for neovim:

```lua
-- lua/abc-play/init.lua

local M = {}

-- The native binding will be loaded via LuaJIT FFI or a Lua C module

function M.play()
  local buf = vim.api.nvim_get_current_buf()
  local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
  local abc_text = table.concat(lines, "\n")

  -- Call native module
  local native = require("abc-play.native")
  native.play(abc_text)
end

function M.stop()
  local native = require("abc-play.native")
  native.stop()
end

return M
```

---

## Testing Strategy

### Unit Tests

1. Pitch conversion: verify ABC pitch to MIDI mapping
2. Duration conversion: verify fraction to microseconds calculation
3. Articulation mapping: verify decoration to flag conversion

### Integration Tests

1. Load MuseSampler library (requires MuseHub installed)
2. Enumerate instruments
3. Create session and add events
4. Verify audio output (render to buffer, check non-silence)

### Manual Tests

1. Play simple single-voice tune
2. Play multi-voice tune
3. Play tune with articulations
4. Verify playback control (pause, seek)

---

## Open Questions

1. Should we support offline rendering to audio files (WAV/MP3)?
   - MuseSampler has `ms_MuseSampler_start_offline_mode` for this

2. How do we handle instrument selection?
   - Should we auto-detect from ABC V: voice declarations?
   - Should we provide a UI for manual selection?

3. How do we handle multi-track/multi-instrument scores?
   - Need to map ABC voices to MuseSampler tracks
   - Need to handle instrument changes (I: field)

4. Should we cache the compiled events for faster replay?
   - Re-parsing on every play might be slow for large scores

5. How do we handle the `mscore` executable name constraint for the vscode/neovim extensions?
   - The native addon itself is loaded by Node.js/Lua, not executed directly
   - We may need a helper binary named `mscore` that loads the library
   - Alternatively, investigate if the check is on argv[0] or the actual binary name

---

## Dependencies

### Required (users must install)

- MuseHub + Muse Sounds (for the MuseSampler library)

### Build Dependencies

- node-gyp (for building native addon)
- C++ compiler (gcc/clang/MSVC)
- miniaudio header (vendored, MIT license)

### Runtime Dependencies

- Node.js (for vscode extension)
- LuaJIT or Lua 5.1+ (for neovim extension)

---

## Getting Started

This section helps newcomers set up their environment and verify everything works before writing code.

### 1. Install MuseHub and Muse Sounds

Download and install MuseHub from https://www.musehub.com/

After installation, open MuseHub and install at least one Muse Sounds instrument pack (e.g., "Muse Strings"). This will also install the MuseSampler library.

### 2. Locate the MuseSampler Library

Verify the library exists at the expected path:

```bash
# macOS
ls ~/Library/Application\ Support/MuseSampler/lib/libMuseSamplerCoreLib.dylib

# Linux
ls ~/.local/share/MuseHub/MuseSampler/lib/libMuseSamplerCoreLib.so

# Windows (PowerShell)
ls $env:APPDATA\MuseHub\MuseSampler\lib\MuseSamplerCoreLib.dll
```

### 3. Clone and Build abc_parse

```bash
git clone <abc_parse_repo_url>
cd abc_parse
npm install
npm run build
npm run test  # Verify existing tests pass
```

### 4. MuseScore Source Reference

The MuseScore source code is cloned at `/workspace/musescore-src`. This is the authoritative reference for the MuseSampler API.

Key files to study:

| File | Purpose |
|------|---------|
| `src/framework/musesampler/internal/apitypes.h` | All C structs and function typedefs |
| `src/framework/musesampler/internal/libhandler.h` | Library loading and version handling |
| `src/framework/musesampler/internal/musesamplersynthesiser.cpp` | How events are submitted |
| `src/framework/mpe/events.h` | MuseScore's internal event format |
| `src/framework/mpe/mpetypes.h` | Type definitions for pitch, duration, etc. |

### 5. Verify MuseSampler Loads (Quick Test)

Before writing the full integration, create a minimal C program to verify the library loads:

```c
// test_load.c
#include <stdio.h>
#include <dlfcn.h>

typedef int (*ms_get_version_major_t)();
typedef int (*ms_get_version_minor_t)();

int main() {
    // Adjust path for your platform
    void* lib = dlopen(
        "path/to/libMuseSamplerCoreLib.dylib",
        RTLD_NOW
    );

    if (!lib) {
        printf("Failed to load: %s\n", dlerror());
        return 1;
    }

    ms_get_version_major_t get_major = dlsym(lib, "ms_get_version_major");
    ms_get_version_minor_t get_minor = dlsym(lib, "ms_get_version_minor");

    if (get_major && get_minor) {
        printf("MuseSampler version: %d.%d\n", get_major(), get_minor());
    }

    dlclose(lib);
    return 0;
}
```

Compile and run (the binary must be named `mscore`):

```bash
gcc -o mscore test_load.c -ldl
./mscore
```

If this prints a version number, the library loads correctly and the executable name check passes.

### 6. Understand the abc_parse Output

Before writing the converter, familiarize yourself with the ABCJS Tune structure:

1. Read `parse/types/abcjs-ast.ts` for type definitions
2. Read `parse/interpreter/TuneInterpreter.ts` for how the AST is converted
3. Run the parser on a sample ABC file and inspect the output:

```typescript
import { Scanner } from './parse/parsers/scan2';
import { Parser2 } from './parse/parsers/parse2';
import { TuneInterpreter } from './parse/interpreter/TuneInterpreter';
import { ABCContext } from './parse/parsers/Context';

const abc = `X:1
T:Test
M:4/4
L:1/8
K:C
CDEF GABc|]`;

const ctx = new ABCContext();
const tokens = Scanner(abc, ctx);
const ast = Parser2(tokens, ctx);
const interpreter = new TuneInterpreter(ctx);
const tune = interpreter.interpretFileStructure(ast);

console.log(JSON.stringify(tune, null, 2));
```

### 7. Suggested First Task

Start with Phase 2 (the TypeScript converter) since it requires no native code:

1. Create `parse/playback/types.ts` with the MuseSampler event interfaces
2. Create `parse/playback/pitch-utils.ts` with the pitch conversion function
3. Write unit tests for pitch conversion
4. Create `parse/playback/converter.ts` with a minimal implementation
5. Test with a simple single-voice ABC tune

This lets you validate the conversion logic before tackling the native binding layer.
