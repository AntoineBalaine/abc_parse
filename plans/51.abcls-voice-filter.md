# Voice Filter Directive (%%abcls show/hide)

## Table of Contents

1. [Overview](#overview)
2. [Design Requirements](#design-requirements)
3. [Phase 1: Directive Recognition](#phase-1-directive-recognition-scannerparsersemanticanalyzer)
4. [Phase 2: Voice Filter Visitor](#phase-2-voice-filter-visitor)
5. [Phase 3: Rendering Pipeline Integration](#phase-3-rendering-pipeline-integration)

---

## Overview

We are adding a directive `%%abcls show/hide <voice_ids>` that filters which voices are passed to the abcjs renderer. The filtering happens by modifying the AST before stringification, similar to how ABCX conversion works.

## Design Requirements

- Directive syntax: `%%abcls show V1 V2 V3` or `%%abcls hide V1 V2`
- Keyword: `show` or `hide` (mutually exclusive)
- Voice IDs: space-separated
- Last wins: if both show and hide appear, the last one takes effect
- Scope: file header affects all tunes, tune header affects current tune only
- Overlays: treated as part of their parent voice (hiding V1 hides its overlays too)
- `%%score`/`%%staves`: left untouched (let abcjs complain if voices are missing)
- No voice ID validation: we skip validation since semantic analyzer is not in the current pipeline; add a TODO note to README instead
- MIDI: not affected
- Implementation approach: AST filtering before stringify, similar to AbcxToAbcConverter
- Needs to be integrated in the rendering pipeline when language server receives a "show preview" command

---

## Phase 1: Directive Recognition (Scanner/Parser/Semantic Analyzer)

### Goal

Make the system recognize `%%abcls show V1 V2` and `%%abcls hide V1 V2` directives and extract structured semantic data from them.

### Scanner Changes

No changes needed. The existing `scanDirective.ts` already tokenizes:
- `%%` → `STYLESHEET_DIRECTIVE`
- `abcls` → `IDENTIFIER`
- `show`/`hide` → `IDENTIFIER`
- `V1`, `V2`, etc. → `IDENTIFIER` or `NUMBER`

### Parser Changes

No changes needed. The existing `parseDirective.ts` creates:
```
Directive(
  key: Token(IDENTIFIER, "abcls"),
  values: [Token(IDENTIFIER, "show"), Token(IDENTIFIER, "V1"), Token(IDENTIFIER, "V2")]
)
```

### Semantic Analyzer Changes

File: `parse/analyzers/directive-analyzer.ts`

Add a new case in `analyzeDirective()`:

```
if directive.key.lexeme == "abcls"
  mode = first value (expect "show" or "hide")
  voiceIds = remaining values as strings

  return {
    type: "abcls",
    data: {
      mode: "show" | "hide",
      voiceIds: string[]
    }
  }
```

Type definition (add to `directive-analyzer.ts` or appropriate types file):
```
interface AbclsDirectiveData {
  mode: "show" | "hide";
  voiceIds: string[];
}
```

Error handling: If mode is neither "show" nor "hide", report a diagnostic but still return partial data.

### Tests

- Scanner: verify tokenization of `%%abcls show V1 V2`
- Parser: verify AST structure
- Semantic analyzer: verify extracted `AbclsDirectiveData`

### To Do

1. Add `AbclsDirectiveData` type definition to directive-analyzer.ts
2. Add `analyzeAbclsDirective()` function to directive-analyzer.ts
3. Add case for "abcls" in the main `analyzeDirective()` switch
4. Write scanner test for `%%abcls show V1 V2` tokenization
5. Write parser test for directive AST structure
6. Write semantic analyzer test for data extraction
7. Final verification: build and tests both pass
8. Call the code review agent. Address any feedback.
9. Commit once the build passes and all tests pass.

---

## Phase 2: Voice Filter Visitor

### Goal

Create a visitor that filters the AST to include/exclude voices based on collected `%%abcls` directives, following the "last wins" semantics.

### Design

#### Two-Pass Architecture

Pass 1 - Directive Collection: Traverse AST to collect `%%abcls` directives and determine the final filter state:
- File header directives → default filter for all tunes
- Tune header directives → override for that specific tune
- "Last wins" within each scope

Pass 2 - AST Filtering: Clone/filter the AST based on collected filter state.

#### Filter State Structure

```
interface VoiceFilterState {
  mode: "show" | "hide" | null;  // null means no filtering
  voiceIds: Set<string>;
}

interface FilterContext {
  fileDefault: VoiceFilterState;
  tuneOverrides: Map<tuneId, VoiceFilterState>;
}
```

#### What Gets Filtered

| Element | Filter Behavior |
|---------|----------------|
| `V:` info line in tune header | Remove if voice is excluded |
| `[V:id]` inline field in body | Remove if voice is excluded |
| Music content after voice switch | Remove until next included voice switch |
| `Voice_overlay` (`&`) | Remove if parent voice is excluded |
| `%%score` / `%%staves` | Keep unchanged (per requirements) |
| `%%abcls` directive itself | Remove (it's metadata, not ABC) |

#### Voice Tracking in Tune Body

The body is processed sequentially:
```
currentVoice = first declared voice (or "default")
for each element in tune_body:
  if element is V: or [V:id]:
    currentVoice = extracted voice ID

  if voiceIsIncluded(currentVoice, filterState):
    keep element
  else:
    skip element
```

#### Determining Inclusion

```
voiceIsIncluded(voiceId, state):
  if state.mode == null:
    return true  // no filtering
  if state.mode == "show":
    return voiceId in state.voiceIds
  if state.mode == "hide":
    return voiceId not in state.voiceIds
```

#### File Structure

New file: `parse/Visitors/VoiceFilterVisitor.ts`

```
class VoiceFilterCollector implements Visitor<void>
  - Collects %%abcls directives
  - Builds FilterContext

class VoiceFilterVisitor implements Visitor<Expr | null>
  - Takes FilterContext
  - Returns filtered AST (null for removed nodes)
  - Handles tune header and body filtering

function filterVoiceInAst(ast: File_structure, analyzer: SemanticAnalyzer): File_structure
  - Main entry point
  - Runs collector, then filter visitor
  - Returns new AST
```

### Tests

#### Example-Based Tests

Concrete ABC snippets with specific voices and expected filtered output:

1. Basic show filtering: `%%abcls show V1` on a 2-voice tune keeps only V1 content
2. Basic hide filtering: `%%abcls hide V1` on a 2-voice tune removes V1 content
3. File header scope: Multi-tune file with file-level `%%abcls show V1` filters all tunes
4. Tune header override: File-level `%%abcls show V1` overridden by tune-level `%%abcls show V2`
5. Overlay handling: Voice V1 with `&` overlay, `%%abcls hide V1` removes both V1 and its overlay

#### Property-Based Tests

Invariants verified across generated inputs:

1. Identity: No `%%abcls` directive → `filterVoiceInAst(ast)` returns structurally identical AST
2. Last wins: For any sequence of N `%%abcls` directives in same scope, result equals applying only the Nth directive
3. Score/staves invariance: `%%score` and `%%staves` nodes are never modified or removed by the filter
4. Idempotence: `filter(filter(ast, state), state) ≡ filter(ast, state)`
5. Show/hide duality: For a file with exactly voices {A, B}, `show {A}` produces same filtered body as `hide {B}`

### To Do

1. Create `VoiceFilterVisitor.ts` with `VoiceFilterState` and `FilterContext` types
2. Implement `VoiceFilterCollector` class (directive collection pass)
3. Implement `VoiceFilterVisitor` class (AST filtering pass)
4. Implement `filterVoiceInAst()` entry point function
5. Export from `parse/index.ts`
6. Write example-based test: basic show filtering
7. Write example-based test: basic hide filtering
8. Write example-based test: file header scope
9. Write example-based test: tune header override
10. Write example-based test: overlay handling
11. Write property-based test: identity (no directive → unchanged AST)
12. Write property-based test: last wins
13. Write property-based test: score/staves invariance
14. Write property-based test: idempotence
15. Write property-based test: show/hide duality
16. Final verification: build and tests both pass
17. Call the code review agent. Address any feedback.
18. Commit once the build passes and all tests pass.

---

## Phase 3: Rendering Pipeline Integration

### Goal

Extend the existing preview content request pattern (used by ABCT) to ABC files, so the language server returns filtered content.

### Current Flow

| File Type | Content Source |
|-----------|---------------|
| `.abct` | LSP request `abct.evaluate` → returns evaluated ABC |
| `.abcx` | Client-side `convertAbcxToAbc()` |
| `.abc` | Direct editor read `getNormalizedEditorContent()` |

### New Flow for ABC

| File Type | Content Source |
|-----------|---------------|
| `.abc` | LSP request `abc.getPreviewContent` → returns filtered ABC |

This mirrors the ABCT pattern.

### Files to Modify

#### 1. Language Server Handler

File: `abc-lsp-server/src/server.ts`

Add handler following the `abct.evaluate` pattern:

```
connection.onRequest("abc.getPreviewContent", (params: { uri: string }) => {
  document = documents.get(params.uri) as ABCDocument

  filteredAst = filterVoiceInAst(document.ast, document.analyzer)
  formatter = new AbcFormatter(document.context)
  return formatter.stringify(filteredAst)
})
```

#### 2. Renderer Client Call

File: `vscode-extension/src/renderer/AbcRenderer.ts`

Modify `getCurrentEditorContent()`:

```
current:
  if isAbct: return evaluateAbctForPreview(uri)
  if isAbcx: return convertAbcxToAbc(content)
  return getNormalizedEditorContent()  // ABC files

new:
  if isAbct: return evaluateAbctForPreview(uri)
  if isAbcx: return convertAbcxToAbc(content)
  return getAbcPreviewContent(uri)  // ABC files via LSP
```

Add helper function similar to `evaluateAbctForPreview()`:

```
async function getAbcPreviewContent(uri: string): Promise<string>
  return client.sendRequest("abc.getPreviewContent", { uri })
```

#### 3. Export from parse library

File: `parse/index.ts`

Export `filterVoiceInAst` for the language server to import.

### Tests

#### Integration Tests

1. LSP request `abc.getPreviewContent` with `%%abcls show V1` returns filtered content
2. LSP request `abc.getPreviewContent` without directive returns unchanged content
3. Preview command triggers LSP request and renders filtered content

#### Manual Testing Checklist

1. Open multi-voice ABC file
2. Add `%%abcls show V1` to header
3. Trigger "Show Preview"
4. Verify only V1 appears in rendered output

### To Do

1. Export `filterVoiceInAst` from `parse/index.ts`
2. Add `abc.getPreviewContent` handler in `server.ts`
3. Add `getAbcPreviewContent()` helper in `AbcRenderer.ts`
4. Modify `getCurrentEditorContent()` to use LSP request for `.abc` files
5. Write integration test: LSP request with show directive
6. Write integration test: LSP request without directive
7. Manual testing per checklist
8. Final verification: build and tests both pass
9. Call the code review agent. Address any feedback.
10. Commit once the build passes and all tests pass.
