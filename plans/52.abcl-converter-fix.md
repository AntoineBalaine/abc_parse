# ABCL Converter Fix

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Correct Behavior](#correct-behavior)
3. [Current Implementation Issues](#current-implementation-issues)
4. [Phase 1: Fix Voice ID Extraction](#phase-1-fix-voice-id-extraction)
5. [Phase 2: Implement Deep Clone Visitor](#phase-2-implement-deep-clone-visitor)
6. [Phase 3: Rewrite the Converter Algorithm](#phase-3-rewrite-the-converter-algorithm)
7. [Phase 4: Fix Renderer Integration](#phase-4-fix-renderer-integration)
8. [Phase 5: Comprehensive Tests](#phase-5-comprehensive-tests)

---

## Problem Statement

The current ABCL-to-ABC converter treats each "system" (voice marker cycle) as the unit of conversion. This is fundamentally wrong. The correct behavior is that each line of music content is a row in a virtual grid, and lines must be aligned across all voices.

---

## Correct Behavior

### Linear Style Semantics

In linear style, voice markers act as headers for subsequent content lines. Each line of music content under a voice marker represents one "row" of the score that must align with content from other voices.

### System Detection

A new "voice section" starts when a voice marker appears whose index is less than the last seen voice's index. Voices are discovered dynamically and added to the voice list as they appear.

### Conversion Algorithm

The converter must:
1. Parse the linear content into voice sections
2. Count the number of content lines per voice section
3. Create a grid where each row has one line from each voice
4. Fill missing cells with silenced (X rest) lines

### Example

Linear input:
```abc
V:1
abc
dfe
V:2
fga
dfe
V:3
fga
V:1
abc
```

This parses as:
- Voice section 1: V:1 (2 lines), V:2 (2 lines), V:3 (1 line)
- Voice section 2: V:1 (1 line) - starts because V:1 index (0) < V:3 index (2)

Grid alignment:
```
Row 1: V:1=abc, V:2=?, V:3=?     -> V:2 and V:3 have no content yet
Row 2: V:1=dfe, V:2=fga, V:3=?   -> V:3 has no content yet
Row 3: V:1=?, V:2=dfe, V:3=fga   -> V:1 section exhausted
Row 4: V:1=abc, V:2=?, V:3=?     -> new V:1 section, V:2/V:3 exhausted
```

Deferred output:
```abc
V:1
abc
V:2
X
V:3
X
V:1
dfe
V:2
fga
V:3
X
V:1
X
V:2
dfe
V:3
fga
V:1
abc
V:2
X
V:3
X
```

---

## Current Implementation Issues

### Issue 1: Voice ID Extraction is Brittle

Location: `parse/parsers/voices2.ts:60-72`

The `stringifyVoice` function joins all tokens in the value array:
```typescript
return expr.value.map((e) => e.lexeme).join("").trim();
```

This includes metadata like `clef=treble name="Tenor"`, producing incorrect IDs like `"Tenor clef=treble"` instead of `"Tenor"`.

The correct approach (used in `parse/analyzers/info-line-analyzer.ts:850-854`) extracts only the first token:
```typescript
const firstToken = expr.value[0];
if (isToken(firstToken)) {
  voiceId = firstToken.lexeme;
}
```

this has the flaw of potentially containing WS tokens: `const firstToken = expr.value[0];`. We want to add a check there to skip any WS tokens in the input.

### Issue 2: Wrong Conversion Unit

Location: `parse/abcl/AbclToAbcConverter.ts:214-274`

The converter iterates over "systems" (voice marker cycles) and adds silenced lines for missing voices. This treats each system as a single row, but systems can contain multiple lines of content that need separate alignment.

### Issue 3: No Deep Clone for Expressions

Location: `parse/abcl/AbclToAbcConverter.ts:80-97`

The `copyMusicLine` function passes expressions by reference. Since expressions carry unique IDs used by the formatter for multi-line score alignment, sharing references can break formatting. A proper deep clone visitor is needed.

### Issue 4: Renderer Re-parses Unnecessarily

Location: `vscode-extension/src/renderer/AbcRenderer.ts:314-322`

The renderer calls `abclToAbc()` which parses the content, but the LSP server already has the parsed AST in its document state. The renderer should request the converted content from the server instead of re-parsing.

### Issue 5: Missing Tests

The test suite does not cover:
- Voices appearing in disorder (V:2 before V:1)
- Multiple content lines per voice section
- Grid alignment across voice sections
- Voice ID extraction with metadata

---

## Phase 1: Fix Voice ID Extraction

### Changes

1. `parse/parsers/voices2.ts`
   - Update `stringifyVoice` to extract only the voice ID (first token), not metadata
   - Handle both `Info_line` and `Inline_field` cases
   - Use the same logic as `analyzeVoiceInfo` in `info-line-analyzer.ts`

```typescript
export function stringifyVoice(expr: Info_line | Inline_field): string {
  if (expr instanceof Inline_field) {
    // For inline fields like [V:Tenor clef=treble], extract just the ID
    // Skip any leading WS tokens
    const firstToken = expr.text.find(t => isToken(t) && t.type !== TT.WS);
    if (firstToken && isToken(firstToken)) {
      return firstToken.lexeme.trim();
    }
    return "";
  } else {
    // For info lines like V:Tenor clef=treble, the ID is the first non-WS token in value
    // Skip any leading WS tokens
    const firstToken = expr.value.find(t => isToken(t) && t.type !== TT.WS);
    if (firstToken && isToken(firstToken)) {
      return firstToken.lexeme.trim();
    }
    return "";
  }
}
```

2. Add tests for voice ID extraction in `parse/tests/voices2.spec.ts` (new file):
   - `V:1` extracts `"1"`
   - `V:Tenor clef=treble name="Tenor Voice"` extracts `"Tenor"`
   - `[V:S1 stem=up]` extracts `"S1"`

### To do

- Update `stringifyVoice` in `voices2.ts`
- Create `parse/tests/voices2.spec.ts` with voice ID extraction tests
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Implement Deep Clone Visitor

### Problem

The current `copyMusicLine` function in `AbclToAbcConverter.ts` passes expressions by reference. Since expressions carry unique IDs used by the formatter for multi-line score alignment, sharing references between the original content and silenced lines can break formatting.

### Solution

Create a deep clone visitor that recursively clones all expression types with new unique IDs.

### Changes

1. `parse/Visitors/CloneVisitor.ts` (new file)

```typescript
import { ABCContext } from "../parsers/Context";
import { Token } from "../parsers/scan2";
import { Expr, Note, Rest, Chord, Beam, ... } from "../types/Expr2";

/**
 * Deep clones an expression tree, generating new unique IDs for all nodes.
 */
export function cloneExpr(expr: Expr | Token, ctx: ABCContext): Expr | Token {
  if (expr instanceof Token) {
    return new Token(expr.type, expr.lexeme, ctx.generateId());
  }

  if (expr instanceof Note) {
    return new Note(
      ctx.generateId(),
      cloneExpr(expr.pitch, ctx) as Pitch,
      expr.rhythm ? cloneExpr(expr.rhythm, ctx) as Rhythm : undefined,
      expr.tie ? cloneExpr(expr.tie, ctx) as Token : undefined
    );
  }

  if (expr instanceof Chord) {
    return new Chord(
      ctx.generateId(),
      expr.contents.map(n => cloneExpr(n, ctx) as Note),
      expr.rhythm ? cloneExpr(expr.rhythm, ctx) as Rhythm : undefined,
      expr.tie ? cloneExpr(expr.tie, ctx) as Token : undefined
    );
  }

  if (expr instanceof Beam) {
    return new Beam(
      ctx.generateId(),
      expr.contents.map(e => cloneExpr(e, ctx))
    );
  }

  // ... handle all other expression types

  // Fallback: return as-is (should not happen if all types are handled)
  return expr;
}

/**
 * Deep clones an array of tune body elements.
 */
export function cloneLine(line: tune_body_code[], ctx: ABCContext): tune_body_code[] {
  return line.map(el => cloneExpr(el, ctx) as tune_body_code);
}
```

2. Update `parse/abcl/AbclToAbcConverter.ts`
   - Import `cloneLine` from `CloneVisitor`
   - Replace `copyMusicLine` with `cloneLine`

3. Add tests in `parse/tests/CloneVisitor.spec.ts` (new file)
   - Cloned expression has different ID than original
   - Cloned expression has same structure/content as original
   - Nested expressions are also cloned (not shared references)
   - All expression types are handled

### Expression Types to Handle

From `parse/types/Expr2.ts`, the following types need clone implementations:
- Token (base case)
- Note, Rest, MultiMeasureRest
- Chord, Beam, Grace_group
- Pitch, Rhythm
- Tuplet, Decoration, Annotation, Symbol
- BarLine, YSPACER
- Comment, Directive
- Info_line, Inline_field
- Any other tune_body_code types

### To do

- Create `parse/Visitors/CloneVisitor.ts` with `cloneExpr` and `cloneLine` functions
- Handle all expression types listed above
- Create `parse/tests/CloneVisitor.spec.ts` with clone tests
- Update imports in `AbclToAbcConverter.ts`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: Rewrite the Converter Algorithm

### Data Structures

```typescript
// A voice section is content under a voice marker until the next voice marker
interface VoiceSection {
  voiceId: string;
  lines: tune_body_code[][]; // Each inner array is one line of content
}

// A row in the output grid
interface GridRow {
  content: Map<string, tune_body_code[]>; // voiceId -> line content
}
```

### Algorithm

```
function convertTuneToDeferred(tune, ctx):
  1. Collect all unique voice IDs in order of first appearance
  2. Parse tune body into voice sections:
     for each element in tune body:
       if voice marker:
         if current voice section exists:
           save it
         start new voice section with this voice ID
       else if EOL:
         end current line, start new line in current section
       else:
         add to current line

  3. Build the grid:
     create iterators for each voice (tracking current section and line index)
     while any iterator has content:
       create a row
       for each voice:
         if iterator has content:
           add content to row, advance iterator
         else:
           add silenced placeholder to row
       add row to grid

  4. Convert grid to deferred-style tune body:
     for each row:
       for each voice in order:
         emit voice marker
         emit content (or silenced X rest)
         emit EOL
```

### Changes

1. `parse/abcl/AbclToAbcConverter.ts`
   - Add `VoiceSection` interface
   - Add `parseVoiceSections(tuneBody)` function to extract sections
   - Add `buildGrid(sections, allVoices)` function to align content
   - Rewrite `convertTuneToDeferred` to use the grid-based algorithm
   - Keep helper functions: `silenceLine`, `createXRest`, `createVoiceMarker`

2. Use deep clone visitor from Phase 2:
   - Import `cloneLine` from `CloneVisitor`
   - Use it when creating silenced lines

### To do

- Implement `parseVoiceSections` function
- Implement `buildGrid` function
- Rewrite `convertTuneToDeferred` with new algorithm
- Use `cloneLine` from Phase 2 for cloning content
- Update `convertFileToDeferred` if needed
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: Fix Renderer Integration

### Option A: Keep Current Architecture (Simpler)

Remove the try-catch block since the parser never throws, and keep the current approach of parsing in the renderer. This is wasteful but simpler.

### Option B: Use LSP Server AST (Better)

Add an LSP request to get converted ABCL content from the server, which already has the parsed document.

1. `abc-lsp-server/src/server.ts`
   - Add handler for `abcl/getConverted` request
   - Return the converted ABC string for `.abcl` files

2. `vscode-extension/src/renderer/AbcRenderer.ts`
   - For `.abcl` files, request converted content from LSP instead of parsing locally

### Recommendation

Implement Option A for now (remove try-catch, accept re-parsing). Option B can be a future optimization.

### To do

- Remove try-catch from `convertAbclToAbc` in `AbcRenderer.ts`
- Verify the conversion is called in correct order (after ABCL check, before voice filter)
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 4: Comprehensive Tests

### Test Categories

1. Voice ID extraction tests (`voices2.spec.ts`):
   - Simple IDs: `V:1`, `V:Tenor`
   - IDs with metadata: `V:Tenor clef=treble`, `V:1 name="Voice 1"`
   - Inline fields: `[V:S1]`, `[V:Alto stem=down]`

2. Voice section parsing tests (`abcl2abc.spec.ts`):
   - Single voice, single line
   - Single voice, multiple lines
   - Multiple voices, single line each
   - Multiple voices, varying line counts

3. Grid alignment tests (`abcl2abc.spec.ts`):
   - All voices have equal lines (no silencing needed)
   - First voice has more lines (later voices need silencing)
   - Last voice has more lines (earlier voices need silencing)
   - Voice appears mid-tune (backfill earlier rows)

4. Full conversion tests (`abcl2abc.spec.ts`):
   - Example 1: V:1 -> V:2 (single system, both voices present)
   - Example 2: V:1 -> V:2 -> V:3 (single system, all present)
   - Example 3: Complex multi-section with grid alignment
   - Verify exact string output matches expected deferred style

5. Property-based tests:
   - Every row in output has all voices
   - Silenced lines contain only X rests and barlines
   - Total content lines preserved (sum of input lines equals sum of non-silenced output lines)

### To do

- Create/update `parse/tests/voices2.spec.ts` for voice ID extraction
- Rewrite `parse/tests/abcl2abc.spec.ts` with grid alignment tests
- Add the three examples from user feedback as explicit test cases
- Add property-based tests for conversion invariants
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Summary of Files to Modify

1. `parse/parsers/voices2.ts` - Fix `stringifyVoice`
2. `parse/abcl/AbclToAbcConverter.ts` - Rewrite with grid algorithm
3. `vscode-extension/src/renderer/AbcRenderer.ts` - Remove try-catch
4. `parse/tests/voices2.spec.ts` - New file for voice ID tests
5. `parse/tests/abcl2abc.spec.ts` - Rewrite with proper test cases
