# Voice Selector Implementation Plan

## Table of Contents

1. [Overview](#overview)
2. [Requirements](#requirements)
3. [Implementation Details](#implementation-details)
   - [Phase 1: Editor Module - Voice Selector](#phase-1-editor-module---voice-selector)
   - [Phase 2: LSP Server Integration](#phase-2-lsp-server-integration)
   - [Phase 3: VS Code Extension Command](#phase-3-vs-code-extension-command)
   - [Phase 4: Tests](#phase-4-tests)
4. [To Do List](#to-do-list)

---

## Overview

We are implementing a voice selector for the editor module. The selector allows users to select all tune body elements that belong to a specific voice. Because ABC notation tracks voices through voice markers (V: info lines and [V:...] inline fields), we must walk the tune body while tracking the current voice state, and select elements that match the requested voice ID.

The algorithm must walk inside `Music_code` nodes to detect inline voice markers like `[V:2]` that appear mid-line, ensuring accurate voice tracking.

## Requirements

1. The selector respects the existing editor selection as a scope constraint. If the user has text selected, we only select voice elements within that range. We achieve this by checking cursor set membership (including descendants).
2. All tune body elements belonging to the voice are selected (not just music elements).
3. Content before any voice marker (the "default" or implicit voice) can be selected by entering either an empty string or "default" as the voice ID.
4. The voice ID is provided by user input via a VS Code input box prompt.
5. The selector is exposed as a VS Code command through the language server.
6. If the voice ID does not exist in the tune, the selector returns the input selection unchanged.
7. Voice overlays (`&` symbol) do not switch voices. The `Voice_overlay` node is a marker; notes after it are siblings in the tree, not children. Elements after a voice overlay remain assigned to the voice that was active when the overlay started.
8. Contiguous elements belonging to the same voice should be grouped into a single cursor (one Set with multiple IDs), not one cursor per element.
9. Limitation: A voice literally named "default" cannot be selected, because the string "default" is normalized to "" (empty string) for selecting content before any V: marker.

---

## Implementation Details

### Phase 1: Editor Module - Voice Selector

Create a new file `editor/src/selectors/voiceSelector.ts`.

#### Types and Imports

```typescript
import { CSNode, TAGS, isTokenNode, getTokenData } from "../csTree/types";
import { Selection, Cursor } from "../selection";
import { findByTag } from "./treeWalk";
```

#### Scope Checking via Cursor Membership (with Descendants)

Because the LSP server narrows the input Selection to contain node IDs within the user's selection (via `selectRange`), we respect scope by checking if a node's ID (or any of its descendants' IDs) is present in the input cursor sets.

Create `collectCursorIds(cursors: Cursor[]): Set<number>`:
- Iterates through all cursor sets and collects all node IDs into a single Set.
- Returns the combined Set.

```
collectCursorIds(cursors):
  result = new Set<number>()
  for each cursor in cursors:
    for each id in cursor:
      result.add(id)
  return result
```

Create `hasDescendantInScope(node: CSNode, scopeIds: Set<number>): boolean`:
- Returns true if the node's ID is in scopeIds, OR if any descendant's ID is in scopeIds.
- This ensures that if the user selected specific notes within a Music_code line, that line is considered in scope.

```
hasDescendantInScope(node, scopeIds):
  if scopeIds.has(node.id):
    return true
  child = node.firstChild
  while child is not null:
    if hasDescendantInScope(child, scopeIds):
      return true
    child = child.nextSibling
  return false
```

Create `isInScope(node: CSNode, scopeIds: Set<number>, hasScope: boolean): boolean`:
- If `hasScope` is false (no scope constraint), return true.
- Otherwise, return `hasDescendantInScope(node, scopeIds)`.

To determine if there is a scope constraint:
- If `input.cursors` is empty, there is no scope constraint.
- If `input.cursors` contains a single cursor with only the root node ID, there is no scope constraint.
- Otherwise, there is a scope constraint.

#### Voice Marker Detection

Create `isVoiceMarker(node: CSNode): boolean`:

For `Info_line` (tag === TAGS.Info_line):
- `firstChild` is the header token (e.g., "V:")
- Check that `firstChild` exists, is a token node, and its lexeme trimmed starts with "V:"

For `Inline_field` (tag === TAGS.Inline_field):
- `firstChild` is the "[" token
- `firstChild.nextSibling` is the header token (e.g., "V:")
- Check that `firstChild.nextSibling` exists, is a token node, and its lexeme trimmed starts with "V:"

```
isVoiceMarker(node):
  if node.tag === TAGS.Info_line:
    if node.firstChild is null or not isTokenNode(node.firstChild):
      return false
    return getTokenData(node.firstChild).lexeme.trim().startsWith("V:")

  if node.tag === TAGS.Inline_field:
    headerChild = node.firstChild?.nextSibling
    if headerChild is null or not isTokenNode(headerChild):
      return false
    return getTokenData(headerChild).lexeme.trim().startsWith("V:")

  return false
```

#### Voice ID Extraction

Create `extractVoiceId(node: CSNode): string | null`:

For `Info_line`:
- The voice ID token is `firstChild.nextSibling` (the token after "V:")
- Extract the lexeme, trim whitespace, and take the first whitespace-delimited word (because the rest may contain properties like `clef=treble`)

For `Inline_field`:
- The voice ID token is `firstChild.nextSibling.nextSibling` (after "[" and "V:")
- Extract the lexeme, trim whitespace, and take the first whitespace-delimited word

```
extractVoiceId(node):
  valueChild = null

  if node.tag === TAGS.Info_line:
    valueChild = node.firstChild?.nextSibling

  if node.tag === TAGS.Inline_field:
    valueChild = node.firstChild?.nextSibling?.nextSibling

  if valueChild is null or not isTokenNode(valueChild):
    return null

  lexeme = getTokenData(valueChild).lexeme.trim()
  // Take first whitespace-delimited word to ignore metadata
  firstWord = lexeme.split(/\s+/)[0]
  return firstWord or null
```

#### Context Interface

```typescript
interface VoiceWalkCtx {
  targetVoiceId: string;
  currentVoice: string;
  outputCursors: Set<number>[];
  currentRun: Set<number>;      // accumulates contiguous matching element IDs
  scopeIds: Set<number>;
  hasScope: boolean;
  foundMatch: boolean;
}
```

- `targetVoiceId`: The voice ID we are selecting (normalized: "default" becomes "").
- `currentVoice`: The currently active voice as we walk the tree.
- `outputCursors`: The collected cursors for matching elements.
- `currentRun`: Accumulates IDs of contiguous elements that match the target voice and are in scope. When we encounter a non-matching element or finish walking, we flush this to `outputCursors`.
- `scopeIds`: The set of node IDs that are in scope.
- `hasScope`: Whether there is a scope constraint.
- `foundMatch`: Tracks whether we found at least one element belonging to the target voice (used for return behavior).

#### Helper: Flush Current Run

Create `flushCurrentRun(ctx: VoiceWalkCtx): void`:
- If `currentRun` is not empty, push it to `outputCursors` and reset `currentRun` to a new empty Set.

```
flushCurrentRun(ctx):
  if ctx.currentRun.size > 0:
    ctx.outputCursors.push(ctx.currentRun)
    ctx.currentRun = new Set<number>()
```

#### Walk Function (Recursive)

The algorithm walks tune body children. When it encounters a `Music_code` node, it recurses into its children to detect inline voice markers and select individual elements. We do NOT add `Music_code` nodes themselves to the output - only their leaf children.

Create `walkChildren(ctx: VoiceWalkCtx, containerNode: CSNode): void`:

This function walks the children of a container node (Tune_Body or Music_code), tracking voice changes and selecting matching elements.

```
walkChildren(ctx, containerNode):
  child = containerNode.firstChild
  while child is not null:
    // Check for voice marker and update currentVoice
    if isVoiceMarker(child):
      extractedId = extractVoiceId(child)
      ctx.currentVoice = extractedId or ""

    // Check if this child belongs to the target voice
    targetMatches = (ctx.targetVoiceId === ctx.currentVoice)

    // Recurse into Music_code to handle inline voice markers
    // Do NOT add Music_code itself to output - only its leaf children
    if child.tag === TAGS.Music_code:
      walkChildren(ctx, child)
    else if targetMatches:
      ctx.foundMatch = true
      if isInScope(child, ctx.scopeIds, ctx.hasScope):
        ctx.currentRun.add(child.id)
      else:
        // Element matches voice but is out of scope - flush current run
        flushCurrentRun(ctx)
    else:
      // Element does not match target voice - flush current run
      flushCurrentRun(ctx)

    child = child.nextSibling
```

Create `walkForVoice(ctx: VoiceWalkCtx, root: CSNode): void`:

```
walkForVoice(ctx, root):
  tuneBodies = findByTag(root, TAGS.Tune_Body)

  for each tuneBody in tuneBodies:
    ctx.currentVoice = ""  // reset for each tune body
    walkChildren(ctx, tuneBody)
    flushCurrentRun(ctx)   // flush any remaining run after each tune body
```

#### Main Export Function

```typescript
export function selectVoice(input: Selection, voiceId: string): Selection {
  // Normalize: treat "default" as equivalent to ""
  const targetVoiceId = voiceId === "default" ? "" : voiceId;

  // Build scope ID set from input cursors
  const scopeIds = collectCursorIds(input.cursors);

  // Determine if there is a scope constraint
  const hasScope = input.cursors.length > 0 &&
    !(input.cursors.length === 1 && input.cursors[0].size === 1 && input.cursors[0].has(input.root.id));

  const outputCursors: Set<number>[] = [];
  const ctx: VoiceWalkCtx = {
    targetVoiceId,
    currentVoice: "",
    outputCursors,
    currentRun: new Set<number>(),
    scopeIds,
    hasScope,
    foundMatch: false,
  };

  walkForVoice(ctx, input.root);

  // If the voice ID was not found anywhere in the tune, return input unchanged
  if (!ctx.foundMatch) {
    return input;
  }

  return { root: input.root, cursors: outputCursors };
}
```

#### Update `editor/src/index.ts`

Add export:
```typescript
export { selectVoice } from "./selectors/voiceSelector";
```

---

### Phase 2: LSP Server Integration

Update `abc-lsp-server/src/selectorLookup.ts`:

1. Add import (update the existing import from "editor"):
```typescript
import {
  // ... existing imports ...
  selectVoice,
} from "editor";
```

2. Add entry to `SELECTOR_MAP`:
```typescript
selectVoice: (sel, voiceId) => selectVoice(sel, voiceId as string),
```

---

### Phase 3: VS Code Extension Command

Update `vscode-extension/src/selectorCommands.ts`:

Add a new command registration after the `selectMeasures` command block. This follows the same pattern as `selectMeasures` which also requires user input.

```typescript
// selectVoice requires a voice ID from user input
context.subscriptions.push(
  vscode.commands.registerCommand("abc.selectVoice", async () => {
    const editor = vscode.window.activeTextEditor;
    if (!editor || editor.document.languageId !== "abc") return;

    const input = await vscode.window.showInputBox({
      prompt: "Enter voice ID (or 'default' / empty for content before any V: marker)",
    });
    if (input === undefined) return;

    const uri = editor.document.uri.toString();
    const ranges = getSelectionRanges(editor);

    try {
      const result = await client.sendRequest<ApplySelectorResult>("abc.applySelector", {
        uri,
        selector: "selectVoice",
        args: [input],
        ranges,
      });

      if (result.ranges.length > 0) {
        applySelectionsToEditor(editor, result.ranges);
        updateStatusBar(statusBarItem, result.ranges.length);
      } else if (ranges) {
        // Silent no-op: selection provided but no matches found
      } else {
        statusBarItem.hide();
      }
    } catch (error) {
      vscode.window.showErrorMessage(`Selector command failed: ${error}`);
    }
  })
);
```

Update `vscode-extension/package.json` to register the command. Add to the `contributes.commands` array:
```json
{
  "command": "abc.selectVoice",
  "title": "ABC: Select Voice"
}
```

---

### Phase 4: Tests

Create `editor/src/selectors/__tests__/voiceSelector.test.ts`:

Test cases:

1. Single voice file (no V: markers) - selecting with "" or "default" returns all tune body elements in a single cursor.
2. Multi-voice file - selecting voice "1" returns only elements belonging to voice 1, grouped into contiguous cursors.
3. Multi-voice file - selecting voice "2" returns only elements belonging to voice 2.
4. Default voice - entering "" or "default" returns elements before any V: marker.
5. Non-existent voice ID - returns input unchanged (same object reference).
6. Scope constraint - when input has scoped cursors, only elements within that scope and belonging to the target voice are returned.
7. Inline voice markers - `[V:2]` mid-line correctly switches voice tracking. Given `V:1\nCD[V:2]EF|`, selecting voice "1" returns V:1 info line in one cursor, and C and D grouped in another cursor. Selecting voice "2" returns the inline field, E, F, and barline grouped in a single cursor.
8. Voice overlays - `&` symbol does not affect voice tracking. The Voice_overlay marker is just another element belonging to the current voice; notes after it (F, G, A) are siblings and also belong to the current voice.
9. Voice ID with metadata - `V:Soprano clef=treble name="Soprano"` correctly extracts "Soprano" as voice ID.
10. Multiple tunes - voice tracking resets for each tune body.
11. Contiguous grouping - elements belonging to the same voice that are contiguous should be in the same cursor Set.

Test structure:
```typescript
import { fromAst } from "../../csTree/fromAst";
import { parse } from "abc-parser";
import { selectVoice } from "../voiceSelector";
import { createSelection } from "../../selection";
import { selectRange } from "../rangeSelector";
import { TAGS } from "../../csTree/types";

describe("selectVoice", () => {
  it("selects all elements for a single-voice tune when using empty string", () => {
    const abc = `X:1\nT:Test\nK:C\nCDEF|GABc|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);
    const result = selectVoice(input, "");
    expect(result.cursors.length).toBeGreaterThan(0);
  });

  it("selects only elements belonging to voice 1 with contiguous grouping", () => {
    const abc = `X:1\nT:Test\nK:C\nV:1\nCDEF|\nV:2\nGABc|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);
    const result = selectVoice(input, "1");
    // Should have cursors for: V:1 info line (one cursor), CDEF| elements (one cursor with multiple IDs)
    // Should NOT include V:2 info line or GABc| music code
  });

  it("returns input unchanged for non-existent voice ID", () => {
    const abc = `X:1\nT:Test\nK:C\nV:1\nCDEF|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);
    const result = selectVoice(input, "nonexistent");
    expect(result).toBe(input);
  });

  it("respects scope constraint from input cursors", () => {
    const abc = `X:1\nT:Test\nK:C\nV:1\nCDEF|GABc|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const baseSelection = createSelection(root);
    // Narrow to a specific range (e.g., just the first few notes)
    const scoped = selectRange(baseSelection, 3, 0, 3, 4);
    const result = selectVoice(scoped, "1");
    // Verify only elements within the scoped range are selected
  });

  it("handles inline voice markers correctly", () => {
    const abc = `X:1\nT:Test\nK:C\nV:1\nCD[V:2]EF|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);

    const result1 = selectVoice(input, "1");
    // Should have: one cursor for V:1 info line, one cursor containing C and D IDs
    // Should NOT include [V:2], E, F, |

    const result2 = selectVoice(input, "2");
    // Should have: one cursor containing [V:2] inline field, E, F, and | IDs
    // Should NOT include V:1 info line, C, D
  });

  it("does not switch voice for voice overlays", () => {
    const abc = `X:1\nT:Test\nK:C\nV:1\nCDE&FGA|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);
    const result = selectVoice(input, "1");
    // All elements (including Voice_overlay marker and F, G, A after it) should be selected
    // They should be grouped into contiguous cursors
  });

  it("extracts voice ID correctly when metadata is present", () => {
    const abc = `X:1\nT:Test\nK:C\nV:Soprano clef=treble name="Soprano"\nCDEF|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);
    const result = selectVoice(input, "Soprano");
    expect(result.cursors.length).toBeGreaterThan(0);
  });

  it("resets voice tracking for each tune", () => {
    const abc = `X:1\nT:Test1\nK:C\nV:1\nCDEF|\n\nX:2\nT:Test2\nK:C\nGABc|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);

    // Second tune has no V: marker, so its content is in default voice ""
    const result = selectVoice(input, "");
    // Should include GABc| from second tune (but not CDEF| from first tune)
  });

  it("groups contiguous elements into a single cursor", () => {
    const abc = `X:1\nT:Test\nK:C\nCDEF|\n`;
    const ast = parse(abc);
    const root = fromAst(ast);
    const input = createSelection(root);
    const result = selectVoice(input, "");
    // All elements are contiguous and belong to default voice
    // They should be in a single cursor, not one cursor per element
    expect(result.cursors.length).toBe(1);
    expect(result.cursors[0].size).toBeGreaterThan(1);
  });
});
```

---

## To Do List

Phase 1: Editor Module
- Create `editor/src/selectors/voiceSelector.ts` with:
  - `collectCursorIds` function
  - `hasDescendantInScope` function
  - `isInScope` function
  - `isVoiceMarker` function
  - `extractVoiceId` function
  - `VoiceWalkCtx` interface
  - `flushCurrentRun` function
  - `walkChildren` function
  - `walkForVoice` function
  - `selectVoice` export function
- Update `editor/src/index.ts` to export `selectVoice`.

Phase 2: LSP Server
- Update `abc-lsp-server/src/selectorLookup.ts` to import `selectVoice` and add entry to `SELECTOR_MAP`.

Phase 3: VS Code Extension
- Update `vscode-extension/src/selectorCommands.ts` to add `abc.selectVoice` command with input prompt.
- Update `vscode-extension/package.json` to register the command in `contributes.commands`.

Phase 4: Tests
- Create `editor/src/selectors/__tests__/voiceSelector.test.ts` with all test cases.

Final Steps
- Run `npm run build` to verify compilation.
- Run `npm run test` to verify all tests pass.
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
