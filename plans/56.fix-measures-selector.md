# Fix Measures Selector - Split Selection by Barlines

## Table of Contents
1. [Overview](#overview)
2. [Current vs New Behavior](#current-vs-new-behavior)
3. [Implementation Details](#implementation-details)
4. [Files to Modify](#files-to-modify)
5. [To Do List](#to-do-list)

## Overview

The `selectMeasures` selector currently ignores input selections and requires start/end measure numbers. We need to change it to:
- Respect the input selection scope
- Split the selection by barlines (one cursor per measure)
- Group contiguous elements within each measure into a single cursor
- Remove the start/end parameters entirely
- Barlines are excluded from output (act as delimiters only)

## Current vs New Behavior

### Current Behavior
```
selectMeasures(selection, 2, 4)
  - Ignores input selection scope
  - Returns one cursor per element in measures 2-4
  - Requires explicit measure numbers
```

### New Behavior
```
selectMeasures(selection)
  - Respects input selection scope
  - Splits selection by barlines
  - Returns one cursor per measure (contiguous elements grouped)
  - No parameters needed
```

### Example
Input: User selects text covering `C D | E F | G A |`
Output: 3 cursors, one for each measure's content:
- Cursor 1: IDs for C, D (grouped in single Set)
- Cursor 2: IDs for E, F (grouped in single Set)
- Cursor 3: IDs for G, A (grouped in single Set)

## Implementation Details

### Shared Scope Utilities

Extract the following functions from `voiceSelector.ts` into a new file `selectors/scopeUtils.ts`:
- `collectCursorIds(cursors: Cursor[]): Set<number>`
- `collectDescendantIds(node: CSNode, result: Set<number>): void`
- `findNodeById(node: CSNode, targetId: number): CSNode | null`
- `expandScopeToDescendants(root: CSNode, scopeIds: Set<number>): Set<number>`
- `hasDescendantInScope(node: CSNode, scopeIds: Set<number>): boolean`
- `isInScope(node: CSNode, scopeIds: Set<number>, hasScope: boolean): boolean`

Both `voiceSelector.ts` and `measureSelector.ts` will import from this shared module.

### MeasureWalkCtx Interface

```typescript
interface MeasureWalkCtx {
  outputCursors: Set<number>[];
  currentRun: Set<number>;
  scopeIds: Set<number>;
  hasScope: boolean;
  foundMatch: boolean;
}
```

### Walk Algorithm

The algorithm must recurse into `Music_code` nodes because multi-line tunes have barlines inside `Music_code` children of `Tune_Body`.

```typescript
function walkChildren(ctx: MeasureWalkCtx, containerNode: CSNode): void {
  let child = containerNode.firstChild;
  while (child !== null) {
    if (child.tag === TAGS.Music_code) {
      walkChildren(ctx, child);  // Recurse into Music_code
    } else if (child.tag === TAGS.BarLine) {
      flushCurrentRun(ctx);  // Split on barline
    } else if (isMusicElement(child) && isInScope(child, ctx.scopeIds, ctx.hasScope)) {
      ctx.foundMatch = true;
      ctx.currentRun.add(child.id);
    }
    child = child.nextSibling;
  }
}

function walkForMeasures(ctx: MeasureWalkCtx, root: CSNode): void {
  const tuneBodies = findByTag(root, TAGS.Tune_Body);
  for (const tuneBody of tuneBodies) {
    walkChildren(ctx, tuneBody);
    flushCurrentRun(ctx);  // Flush remaining content after last barline
  }
}
```

### Edge Cases

1. Empty input selection (no cursors or only root): `hasScope = false`, process entire document
2. Selection spans multiple tunes: Each tune body processed independently, measure content grouped per tune
3. Selection covers partial measure: Only selected elements within that measure are included
4. No elements in scope: Return original selection (when `foundMatch` is false)
5. All elements are barlines: Return empty cursors

### Return Value

- If `foundMatch` is false (no music elements found in scope), return the original input selection
- Otherwise, return `{ root: input.root, cursors: outputCursors }`

### Server Side

Update `server.ts` to use `resolveContiguousRanges` for `selectMeasures`:

```typescript
const ranges = params.selector === "selectVoices" || params.selector === "selectMeasures"
  ? resolveContiguousRanges(newSelection)
  : resolveSelectionRanges(newSelection);
```

## Files to Modify

### New: `editor/src/selectors/scopeUtils.ts`

Create new file with shared scope utilities extracted from `voiceSelector.ts`:
- `collectCursorIds`
- `collectDescendantIds`
- `findNodeById`
- `expandScopeToDescendants`
- `hasDescendantInScope`
- `isInScope`

Export all functions for use by both selectors.

### `editor/src/selectors/voiceSelector.ts`

1. Remove the extracted scope utility functions
2. Import from `./scopeUtils`

### `editor/src/selectors/measureSelector.ts`

1. Remove `start` and `end` parameters from `selectMeasures` signature
2. Remove validation code for start/end (lines 59-67)
3. Import scope utilities from `./scopeUtils`
4. Update `MeasureWalkCtx` interface to include scope fields
5. Add `flushCurrentRun` function
6. Update `walkChildren` to recurse into `Music_code` and respect scope
7. Update `walkForMeasures` to initialize scope and flush per tune
8. Update `selectMeasures` to compute scope and handle `foundMatch`

### `editor/src/index.ts`

Export the new `scopeUtils` module if needed by external consumers.

### `editor/tests/measureSelector.spec.ts`

Complete rewrite of tests:

1. Remove all start/end parameters from test calls
2. Change expectations to one-cursor-per-measure (grouped)

Example updated tests:
```typescript
it("splits selection by barlines into separate cursors", () => {
  const sel = toSelection("X:1\nK:C\nC D | E F | G A |\n");
  const result = selectMeasures(sel);
  // 3 measures, each with 2 notes grouped into one cursor
  expect(result.cursors.length).to.equal(3);
});

it("respects input scope constraint", () => {
  const sel = toSelection("X:1\nK:C\nC | D | E | F |\n");
  const scoped = selectRange(sel, 2, 4, 2, 7); // Select "D | E"
  const result = selectMeasures(scoped);
  // Only measures 2 and 3 are in scope
  expect(result.cursors.length).to.equal(2);
});

it("groups contiguous elements within each measure", () => {
  const sel = toSelection("X:1\nK:C\nC D E | F G |\n");
  const result = selectMeasures(sel);
  expect(result.cursors.length).to.equal(2);
  // First cursor should contain multiple IDs (C, D, E)
  expect(result.cursors[0].size).to.be.greaterThan(1);
});
```

### `abc-lsp-server/src/selectorLookup.ts`

Update `selectMeasures` entry:
```typescript
// From:
selectMeasures: (sel, start, end) => selectMeasures(sel, start as number, end as number),
// To:
selectMeasures: (sel) => selectMeasures(sel),
```

### `abc-lsp-server/src/server.ts`

Update the condition for `resolveContiguousRanges`:
```typescript
const ranges = params.selector === "selectVoices" || params.selector === "selectMeasures"
  ? resolveContiguousRanges(newSelection)
  : resolveSelectionRanges(newSelection);
```

### `vscode-extension/src/selectorCommands.ts`

1. Move `selectMeasures` from the parameterized section (lines 138-191) to the simple commands list (line 54-67)
2. Add `["abc.selectMeasures", "selectMeasures"]` to `selectorCommands` array
3. Remove the entire `abc.selectMeasures` command registration block with input prompts

## To Do List

1. Create `editor/src/selectors/scopeUtils.ts` with extracted scope utilities
2. Update `voiceSelector.ts` to import from scopeUtils
3. Update `measureSelector.ts` with new scope-aware implementation
4. Update `editor/src/index.ts` exports if needed
5. Rewrite `measureSelector.spec.ts` tests for new behavior
6. Update `selectorLookup.ts` - remove args from selectMeasures
7. Update `server.ts` - use resolveContiguousRanges for selectMeasures
8. Update `selectorCommands.ts` - move to simple commands list
9. Final verification: build and tests both pass
10. Call the code review agent. Address any feedback.
11. Commit once the build passes and all tests pass.
