# Kakoune MIDI Input

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Phase 1: Create midi-core Package](#phase-1-create-midi-core-package)
4. [Phase 2: Update VS Code Extension](#phase-2-update-vs-code-extension)
5. [Phase 3: Create Kakoune MIDI Daemon](#phase-3-create-kakoune-midi-daemon)
6. [Phase 4: Add Kakoune Commands](#phase-4-add-kakoune-commands)
7. [Phase 5: Configuration and Documentation](#phase-5-configuration-and-documentation)
8. [To Do List](#to-do-list)

## Overview

This plan adds MIDI input support to the Kakoune ABC plugin. When a user presses keys on a MIDI keyboard, the corresponding ABC notation is inserted at the cursor position in Kakoune.

### Goals

- Extract MIDI-to-ABC conversion logic into a shared `midi-core` package
- Create a lightweight MIDI daemon for Kakoune that listens for MIDI input and sends text to Kakoune
- Add `:abc-start-midi`, `:abc-stop-midi`, and `:abc-restart-midi` commands to the Kakoune plugin
- Support chord detection (grouping simultaneous notes)
- Update the VS Code extension to use the shared module

### Non-Goals

- MIDI output/playback (out of scope)
- MIDI recording to files (out of scope)
- Relative mode implementation (can be added later)
- Auto-start MIDI when opening ABC files (can be added later)

## Architecture

```
┌─────────────────┐
│  MIDI Device    │
└────────┬────────┘
         │ MIDI events
         v
┌─────────────────────────────────────────┐
│  abc-midi-kak daemon (Node.js)          │
│  - Uses JZZ library for MIDI input      │
│  - Uses midi-core for conversion        │
│  - Spawned by Kakoune command           │
│  - Receives session name as argument    │
│  - Writes ready marker on successful    │
│    initialization                       │
└────────┬────────────────────────────────┘
         │ kak -p <session> -e 'execute-keys ...'
         v
┌─────────────────┐
│    Kakoune      │
└─────────────────┘
```

The daemon is a separate process from the LSP server. This separation ensures:
- Low latency (no waiting for LSP to finish parsing)
- Clean architecture (MIDI input is not a language feature)
- The daemon can be killed independently

### Runtime Directory

All runtime files (PID file, ready marker, log file) are stored in `$XDG_RUNTIME_DIR/abc-midi/` or `/tmp/abc-midi-$USER/` as a fallback. This directory is user-owned, which prevents security issues with shared `/tmp`.

### Shared Module: midi-core

The `midi-core` package contains pure conversion logic with no editor dependencies:

```
midi-core/
  src/
    index.ts          # Re-exports
    types.ts          # Accidentals, MIDIInputConfig
    conversion.ts     # Note conversion functions
    noteProcessor.ts  # Chord detection and note processing
  package.json
  tsconfig.json
```

### Module Resolution

The `abc-kak` directory is a workspace package with its own `package.json` that declares a dependency on `midi-core`. The daemon is written in TypeScript and bundled into a single JavaScript file using esbuild. Standard ES module imports are used in the source:

```typescript
import { createNoteProcessorState, notesToString, processNote } from "midi-core";
```

The `abc-kak/package.json` declares:
```json
{
  "name": "abc-kak",
  "version": "0.0.1",
  "scripts": {
    "build": "esbuild src/abc-midi-kak.ts --bundle --platform=node --outfile=dist/abc-midi-kak.js"
  },
  "dependencies": {
    "midi-core": "*",
    "jzz": "^1.8.0"
  },
  "devDependencies": {
    "esbuild": "^0.20.0",
    "typescript": "^5.8.2",
    "@types/node": "^20.0.0"
  }
}
```

The build step bundles all dependencies (`midi-core`, `jzz`) into a single self-contained JavaScript file at `abc-kak/dist/abc-midi-kak.js`. This file can be run with just `node` - no npm module resolution required at runtime.

The root `package.json` includes `abc-kak` in the workspaces array for development builds.

## Phase 1: Create midi-core Package

### 1.1 Create Package Structure

Create the following files:
- `midi-core/package.json`
- `midi-core/tsconfig.json`
- `midi-core/src/index.ts`
- `midi-core/src/types.ts`
- `midi-core/src/conversion.ts`
- `midi-core/src/noteProcessor.ts`

### 1.2 Package Configuration

`midi-core/package.json`:
```json
{
  "name": "midi-core",
  "version": "0.0.1",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "ts-mocha tests/**/*.spec.ts"
  },
  "devDependencies": {
    "typescript": "^5.8.2",
    "@types/mocha": "^10.0.0",
    "@types/sinon": "^17.0.0",
    "chai": "^4.3.0",
    "fast-check": "^3.15.0",
    "mocha": "^10.2.0",
    "sinon": "^17.0.0",
    "ts-mocha": "^10.0.0"
  }
}
```

`midi-core/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "declaration": true,
    "strict": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}
```

### 1.3 Types (midi-core/src/types.ts)

```typescript
export type Accidentals = "sharps" | "flats";

export function isValidAccidentals(value: string): value is Accidentals {
  return value === "sharps" || value === "flats";
}

export type MIDIInputConfig = {
  accidentals: Accidentals;
  relativeMode: boolean;
  chordMode: boolean;
  chordTimeWindow: number; // milliseconds
  midiChannel: number | null; // null means all channels
};

export type OutputNotesFn = (
  notes: Set<number>,
  accidentals: Accidentals,
  relativeMode: boolean
) => void;

// NoteProcessorState tracks both active (held) and pending (released, awaiting output) notes
// for chord detection. Notes move from active -> pending on release, then output after
// the chord time window expires with no new notes.
export type NoteProcessorState = {
  activeNotes: Set<number>;      // Currently held down
  pendingNotes: Set<number>;     // Released, waiting for chord window to expire
  lastNoteTime: number;
  chordTimeout: NodeJS.Timeout | null;
};

// Helper to create initial state
export function createNoteProcessorState(): NoteProcessorState {
  return {
    activeNotes: new Set(),
    pendingNotes: new Set(),
    lastNoteTime: 0,
    chordTimeout: null,
  };
}

// Helper to clear state (for cleanup). Clears all notes and cancels pending timeout.
export function clearNoteProcessorState(state: NoteProcessorState): void {
  state.activeNotes.clear();
  state.pendingNotes.clear();
  state.lastNoteTime = 0;
  if (state.chordTimeout !== null) {
    clearTimeout(state.chordTimeout);
    state.chordTimeout = null;
  }
}
```

### 1.4 Conversion Functions (midi-core/src/conversion.ts)

Extract the following functions from `vscode-extension/src/Midi/midi-in.ts`:
- `getAbsoluteOctavePostfix(octaveNum: number): string`
- `getNoteChar(noteNum: number, accidentals?: Accidentals): string`
- `midiNumberToNoteName(note: number, accidentals?: Accidentals, relativeMode?: boolean): string`
- `notesToString(notes: Set<number>, accidentals?: Accidentals, relativeMode?: boolean): string`

These functions are pure and have no VS Code dependencies. They can be copied directly with only the import of `Accidentals` changed to reference the local `types.ts`.

Behavioral change from VS Code extension: The existing `notesToString` adds a leading space before chords (` [CEG]`). This should be removed so that chords are returned without leading space (`[CEG]`), matching the behavior of single notes which have no leading space.

### 1.5 Note Processor (midi-core/src/noteProcessor.ts)

The existing `processNote` function in the VS Code extension has chord detection logic that is commented out. This plan requires implementing functional chord detection.

The chord detection algorithm:
1. When a note is pressed, it's added to `activeNotes`
2. When a note is released, it moves from `activeNotes` to `pendingNotes`
3. If a new note is pressed while notes are pending, pending notes move back to active (user is still playing)
4. When all notes are released (activeNotes empty), a timer starts
5. After the chord time window expires, all pending notes are output together
6. Chord notes are sorted by pitch (low to high) in the output

This algorithm is based on the approach used by the VSLilyPond extension (https://github.com/lhl2617/VSLilyPond). The key insight from that implementation is the two-set approach:
- `activeNotes`: Notes currently held down
- `chordNotes` (called `pendingNotes` here): Notes released while others remain pressed

VSLilyPond outputs the chord only when `activeNotes` becomes empty, meaning the user has released all keys. This approach handles the case where a user releases keys in any order while still holding others, ensuring all simultaneously-held notes are grouped together. The time window addition in our implementation allows for slight timing variations in key releases.

```typescript
import { MIDIInputConfig, NoteProcessorState, OutputNotesFn } from "./types";

export function processNote(
  MIDINoteNumber: number,
  keyDown: boolean,
  config: MIDIInputConfig,
  state: NoteProcessorState,
  outputNoteFn: OutputNotesFn
): void {
  const { accidentals, relativeMode, chordTimeWindow } = config;

  if (keyDown) {
    state.activeNotes.add(MIDINoteNumber);
    state.lastNoteTime = Date.now();

    // Cancel pending output - user is still playing
    if (state.chordTimeout !== null) {
      clearTimeout(state.chordTimeout);
      state.chordTimeout = null;
    }
    // Move any pending notes back to active (user continued playing)
    for (const note of state.pendingNotes) {
      state.activeNotes.add(note);
    }
    state.pendingNotes.clear();
  } else {
    // Note released - move to pending
    if (state.activeNotes.delete(MIDINoteNumber)) {
      state.pendingNotes.add(MIDINoteNumber);

      // If no notes are still held, start the output timer
      if (state.activeNotes.size === 0) {
        if (state.chordTimeout !== null) {
          clearTimeout(state.chordTimeout);
        }
        state.chordTimeout = setTimeout(() => {
          if (state.pendingNotes.size > 0) {
            outputNoteFn(state.pendingNotes, accidentals, relativeMode);
            state.pendingNotes.clear();
          }
          state.chordTimeout = null;
        }, chordTimeWindow);
      }
    }
  }
}
```

Note: The `notesToString` function in `conversion.ts` sorts notes by pitch before converting to ABC notation, ensuring consistent chord output regardless of release order.

### 1.6 Index File (midi-core/src/index.ts)

```typescript
export * from "./types";
export * from "./conversion";
export * from "./noteProcessor";
```

### 1.7 Update Root package.json

Add `midi-core` and `abc-kak` to the workspaces array:
```json
"workspaces": [
  "parse",
  "native",
  "abc-lsp-server",
  "abc-cli",
  "vscode-extension",
  "editor",
  "midi-core",
  "abc-kak"
]
```

Add build scripts and update the main build script:
```json
"build": "npm run build:parse && npm run build:midi-core && npm run build:abc-kak && npm run build:editor && npm run build:native && npm run build:lsp && npm run build:cli && npm run build:vscode",
"build:midi-core": "npm run build -w midi-core",
"build:abc-kak": "npm run build -w abc-kak",
```

Build order reasoning:
- `midi-core` builds after `parse` and before packages that depend on it
- `abc-kak` builds after `midi-core` because it imports from `midi-core`
- `vscode-extension` builds last because it also depends on `midi-core`

### 1.8 Tests for midi-core

Testing follows the codebase pattern: example-based tests verify specific behavior, property-based tests detect edge cases.

Create `midi-core/tests/conversion.spec.ts`:

Example-based tests:
- `getAbsoluteOctavePostfix`: octaves 0-9, boundary cases (0, 3, 4, 9)
- `getNoteChar`: all 12 notes (0-11) with sharps mode, all 12 with flats mode
- `midiNumberToNoteName`:
  - Middle C (MIDI 60) -> "c"
  - C3 (MIDI 48) -> "C"
  - C2 (MIDI 36) -> "C,"
  - C5 (MIDI 72) -> "c'"
  - Accidentals: C# with sharps -> "^c", C# with flats -> "_d"
- `notesToString`:
  - Single note returns note without brackets: "C"
  - Multiple notes returns bracketed chord without leading space: "[CEG]"
  - Notes are sorted by pitch (low to high) regardless of Set insertion order
- `isValidAccidentals`: returns true for "sharps" and "flats", false for other strings

Property-based tests:
- Octave consistency: for any two MIDI numbers in the same octave (n/12 equal), the octave marker portion of the output is identical
- Accidental mode consistency: in sharps mode, black keys (MIDI % 12 in [1,3,6,8,10]) always produce "^" prefix; in flats mode, always "_" prefix
- White key bijection: white keys (MIDI % 12 in [0,2,4,5,7,9,11]) produce note names without "^" or "_"
- Chord ordering: for any set of MIDI numbers, `notesToString` output has notes sorted by pitch (verified by parsing output and checking order)

Create `midi-core/tests/noteProcessor.spec.ts`:

Timer mocking: Tests that depend on the chord window timeout use sinon fake timers:
```typescript
import { useFakeTimers, SinonFakeTimers } from "sinon";

let clock: SinonFakeTimers;
beforeEach(() => { clock = useFakeTimers(); });
afterEach(() => { clock.restore(); });
// In tests: clock.tick(chordTimeWindow + 1);
```

Example-based tests:
- Single note: press C, release C -> outputs "C"
- Chord: press C, press E, press G, release G, release E, release C -> outputs "[CEG]"
- Release order independence: press C, press E, release C, release E -> outputs "[CE]" (not "C" then "E")
- Chord window timeout: press C, release C, wait > chordTimeWindow, press E, release E -> outputs "C" then "E"
- Continued playing: press C, release C, press E (before timeout) -> pending C moves back to active, outputs "[CE]"
- Double press same note: press C, press C again -> only one C in activeNotes (Set behavior)
- State cleanup: after `clearNoteProcessorState`, activeNotes and pendingNotes are empty, chordTimeout is null
- Release without press (example-based): releasing a note not in activeNotes does nothing

Property-based tests (using fast-check):
- State machine invariant: after any sequence of press/release events, no note appears in both `activeNotes` and `pendingNotes` simultaneously
- Timeout cleanup: after chord window expires following a complete release sequence, `pendingNotes` is empty
- Idempotent double-press: pressing the same note twice results in `activeNotes.size` equal to pressing once (Set behavior)

Generator specification for state machine tests:
- Generate sequences of `{note: number, isPress: boolean}` events
- Notes are in range 12-127 (valid MIDI range)
- Only generate valid sequences: a release event for note N is only generated if N was previously pressed and not yet released
- Track pressed notes during generation to enforce validity

Update root `package.json` test script:
```json
"test": "result=0; npm run test -w parse || result=1; npm run test -w editor || result=1; npm run test -w midi-core || result=1; exit $result",
```

## Phase 2: Update VS Code Extension

### 2.1 Add midi-core Dependency

Update `vscode-extension/package.json`:
```json
"dependencies": {
  "midi-core": "*",
  ...
}
```

### 2.2 Update Imports in midi-in.ts

Replace the local implementations with imports from `midi-core`. The specific changes:

Before:
```typescript
import { Accidentals, LogLevel, getConfiguration, logger } from "./midi-utils";
```

After:
```typescript
import {
  Accidentals,
  MIDIInputConfig,
  NoteProcessorState,
  OutputNotesFn,
  createNoteProcessorState,
  clearNoteProcessorState,
  getAbsoluteOctavePostfix,
  getNoteChar,
  midiNumberToNoteName,
  notesToString,
  processNote,
} from "midi-core";
import { LogLevel, getConfiguration, logger } from "./midi-utils";
```

### 2.3 Update midi-utils.ts

Remove the `Accidentals` type definition (line 13):
```typescript
// DELETE: export type Accidentals = `sharps` | `flats`;
```

Update any file that imports `Accidentals` from `midi-utils` to import from `midi-core` instead.

### 2.4 Adapt State Management

Replace the module-level state variables with an explicit state object:

Before:
```typescript
export const activeNotes: Set<number> = new Set();
export const chordNotes: Set<number> = new Set();
// ... in MIDIInState
```

After:
```typescript
let noteProcessorState: NoteProcessorState = createNoteProcessorState();
```

Update `stopMIDIInput` to clear state:
```typescript
export const stopMIDIInput = async () => {
  if (MIDIInState.midiInPort) {
    MIDIInState.midiInPort.disconnect();
    MIDIInState.midiInPort.close();
  }
  clearNoteProcessorState(noteProcessorState);
  MIDIInState = initialMidiInState;
  MIDIInState.active = false;
  updateMIDIStatusBarItem();
};
```

### 2.5 Remove Duplicated Code

Delete the following functions from `midi-in.ts` (lines 55-197 approximately):
- `getAbsoluteOctavePostfix` (lines 55-66)
- `getNoteChar` (lines 68-90)
- `midiNumberToNoteName` (lines 92-120)
- `notesToString` (lines 122-135)
- `processNote` (lines 157-197)

Also delete:
- `activeNotes` and `chordNotes` exports (lines 35-37)
- The `MIDIInputConfig` type (lines 17-22) - now from midi-core
- The `OutputNotesFnType` type (line 137) - now `OutputNotesFn` from midi-core

Keep the VS Code-specific functions:
- `outputNotes` (uses VS Code API to insert text)
- `getMIDIInputConfig` (reads VS Code configuration)
- `startMIDIInput`, `stopMIDIInput`, `restartMIDIInput`
- `setInputMIDIDevice`
- `initMIDIStatusBarItems`, `updateMIDIStatusBarItem`

### 2.6 Update MIDI Message Handler

Update the `midiInMsgProcessor._receive` function to use the new state:

```typescript
midiInMsgProcessor._receive = (msg: any) => {
  const statusByte: number = msg[0] & 0xf0;
  const MIDINoteNumber: number = msg[1];
  const velocity: number = msg[2];

  if ([0x80, 0x90].includes(statusByte) && MIDINoteNumber >= 12 && MIDINoteNumber <= 127) {
    const keyDown: boolean = statusByte === 0x90 && velocity > 0;
    const MIDIInputConfig = getMIDIInputConfig();
    processNote(MIDINoteNumber, keyDown, MIDIInputConfig, noteProcessorState, outputNotes);
  } else {
    logger(`Received other MIDI message: ${msg}`, LogLevel.warning, true);
  }
};
```

### 2.7 Verification

After making changes:
1. Run `npm run build:vscode` - should succeed
2. Run `npm run test` - all tests should pass
3. Manual test: open VS Code with an ABC file, connect MIDI device, verify notes are inserted

## Phase 3: Create Kakoune MIDI Daemon

### 3.1 Dependencies

The `jzz` dependency is declared in `abc-kak/package.json` (not in root), since it is only needed by the Kakoune daemon. The `jzz-midi-smf` package is not needed because SMF file operations are not required for live input.

Run `npm install` from the root to link all workspace dependencies.

### 3.2 Runtime Directory

The daemon uses a dedicated runtime directory for all its files:

```typescript
function getRuntimeDir() {
  const xdgRuntime = process.env.XDG_RUNTIME_DIR;
  if (xdgRuntime) {
    return path.join(xdgRuntime, "abc-midi");
  }
  return `/tmp/abc-midi-${process.env.USER || "unknown"}`;
}

function ensureRuntimeDir() {
  const dir = getRuntimeDir();
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { mode: 0o700 });
  }
  return dir;
}
```

Files stored in this directory:
- `<session>.pid` - Process ID
- `<session>.ready` - Ready marker (created after successful initialization)

### 3.3 Create Daemon Script

Create `abc-kak/src/abc-midi-kak.ts`:

```typescript
#!/usr/bin/env node
/**
 * abc-midi-kak.ts
 *
 * MIDI input daemon for Kakoune. Listens for MIDI input and inserts
 * ABC notation at the cursor position in the specified Kakoune session.
 *
 * Usage:
 *   abc-midi-kak --session=NAME [options]
 *
 * Options:
 *   --session=NAME       Kakoune session name (required)
 *   --device=NAME        MIDI device name (default: first available)
 *   --accidentals=MODE   "sharps" or "flats" (default: "sharps")
 *   --chord-window=MS    Chord detection window in ms (default: 50)
 *   --channel=N          MIDI channel to listen to, 1-16 (default: all)
 *   --list-devices       List available MIDI input devices and exit
 *
 * The daemon writes a .ready file after successful initialization.
 * It runs until terminated (Ctrl+C or kill signal).
 */

import * as fs from "fs";
import * as path from "path";
import { execFile } from "child_process";
import JZZ from "jzz";
import {
  Accidentals,
  MIDIInputConfig,
  NoteProcessorState,
  createNoteProcessorState,
  clearNoteProcessorState,
  notesToString,
  processNote,
  isValidAccidentals
} from "midi-core";
```

### 3.4 Argument Parsing and Validation

```typescript
type DaemonArgs = {
  session: string | null;
  device: string | null;
  accidentals: string;
  chordWindow: number;
  channel: number | null;  // null = all channels
  listDevices: boolean;
};

function parseArgs(): DaemonArgs {
  const args: DaemonArgs = {
    session: null,
    device: null,
    accidentals: "sharps",
    chordWindow: 50,
    channel: null,
    listDevices: false,
  };

  for (const arg of process.argv.slice(2)) {
    if (arg === "--list-devices") {
      args.listDevices = true;
    } else if (arg.startsWith("--session=")) {
      args.session = arg.substring("--session=".length);
    } else if (arg.startsWith("--device=")) {
      args.device = arg.substring("--device=".length);
    } else if (arg.startsWith("--accidentals=")) {
      args.accidentals = arg.substring("--accidentals=".length);
    } else if (arg.startsWith("--chord-window=")) {
      args.chordWindow = parseInt(arg.substring("--chord-window=".length), 10);
    } else if (arg.startsWith("--channel=")) {
      const ch = parseInt(arg.substring("--channel=".length), 10);
      // Channel 0 from Kakoune means all channels, represented as null internally
      if (ch >= 1 && ch <= 16) {
        args.channel = ch - 1; // Convert to 0-indexed
      }
    }
  }

  return args;
}

function validateArgs(args: DaemonArgs): void {
  if (!args.listDevices && !args.session) {
    throw new Error("--session is required");
  }
  if (args.session && !/^[a-zA-Z0-9_-]+$/.test(args.session)) {
    throw new Error(`Invalid session name '${args.session}'. Must contain only alphanumeric, dash, or underscore.`);
  }
  if (!isValidAccidentals(args.accidentals)) {
    throw new Error(`Invalid accidentals mode '${args.accidentals}'. Must be 'sharps' or 'flats'.`);
  }
  if (isNaN(args.chordWindow) || args.chordWindow < 0) {
    throw new Error("--chord-window must be a non-negative number");
  }
}
```

### 3.5 Session Validation

Before starting, verify the Kakoune session exists. The timeout is reduced to 2 seconds since session validation should be fast:

```typescript
const SESSION_VALIDATION_TIMEOUT = 2000; // 2 seconds

function validateSession(session: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error(`Timeout validating Kakoune session '${session}'`));
    }, SESSION_VALIDATION_TIMEOUT);

    execFile("kak", ["-p", session, "-e", "nop"], (error) => {
      clearTimeout(timeout);
      if (error) {
        reject(new Error(`Kakoune session '${session}' not found or not accessible`));
      } else {
        resolve();
      }
    });
  });
}
```

### 3.6 Kakoune Text Insertion

ABC notation can contain characters that need escaping for Kakoune's execute-keys command. The key names are defined in Kakoune's source (keys.cc):

```typescript
function escapeForKakoune(text: string): string {
  // Kakoune execute-keys special characters that need escaping.
  // Key names from https://github.com/mawww/kakoune/blob/master/src/keys.cc
  // Note: pipe | does NOT need escaping - it works as a literal in insert mode.

  let escaped = "";
  for (const char of text) {
    switch (char) {
      case "<": escaped += "<lt>"; break;
      case ">": escaped += "<gt>"; break;
      case "%": escaped += "<percent>"; break;
      case '"': escaped += "<dquote>"; break;
      case "'": escaped += "<quote>"; break;
      case ";": escaped += "<semicolon>"; break;
      case "\\": escaped += "\\\\"; break;
      default: escaped += char;
    }
  }
  return escaped;
}

function insertText(session: string, text: string): void {
  const escaped = escapeForKakoune(text);

  // Use execFile (async) to avoid blocking on rapid MIDI input.
  // Note: With async execution, rapid notes may arrive out of order.
  // This is accepted as a limitation; chord detection mitigates most cases.
  execFile("kak", ["-p", session, "-e", `execute-keys -draft i${escaped}<esc>`], (error) => {
    if (error) {
      logToKakoune(session, `Failed to insert text: ${error.message}`);
    }
  });
}

// Log a message to Kakoune's debug buffer. Used for daemon status and errors.
function logToKakoune(session: string, message: string): void {
  const escaped = message.replace(/'/g, "''");
  execFile("kak", ["-p", session, "-e", `echo -debug '[abc-midi] ${escaped}'`]);
}
```

Note: We use `execFile` (async) instead of `execSync` to prevent note events from queuing up during fast passages.

### 3.7 PID and Ready File Management

```typescript
// Type guard for NodeJS ErrnoException
function isErrnoException(err: unknown): err is NodeJS.ErrnoException {
  return err instanceof Error && "code" in err;
}

function writePidFile(runtimeDir: string, session: string): string {
  const pidFile = path.join(runtimeDir, `${session}.pid`);

  // Use exclusive flag to prevent race conditions
  try {
    fs.writeFileSync(pidFile, String(process.pid), { flag: "wx" });
  } catch (err) {
    if (isErrnoException(err) && err.code === "EEXIST") {
      // Check if the existing process is still running
      const existingPid = parseInt(fs.readFileSync(pidFile, "utf8"), 10);
      try {
        process.kill(existingPid, 0); // Signal 0 = check if process exists
        throw new Error(`MIDI daemon already running for session '${session}' (PID ${existingPid})`);
      } catch (killErr) {
        if (isErrnoException(killErr) && killErr.code === "ESRCH") {
          // Process doesn't exist, remove stale PID file
          fs.unlinkSync(pidFile);
          fs.writeFileSync(pidFile, String(process.pid));
        } else {
          throw killErr;
        }
      }
    } else {
      throw err;
    }
  }

  return pidFile;
}

type ReadyInfo = {
  device: string;
  pid: number;
  accidentals: Accidentals;
  chordWindow: number;
  channel: number | null;
};

function writeReadyFile(runtimeDir: string, session: string, info: ReadyInfo): string {
  const readyFile = path.join(runtimeDir, `${session}.ready`);
  // Use JSON for extensibility (can add more fields later without breaking readers)
  fs.writeFileSync(readyFile, JSON.stringify(info));
  return readyFile;
}

function readReadyFile(runtimeDir: string, session: string): ReadyInfo | null {
  const readyFile = path.join(runtimeDir, `${session}.ready`);
  try {
    return JSON.parse(fs.readFileSync(readyFile, "utf8")) as ReadyInfo;
  } catch {
    return null;
  }
}

function cleanup(pidFile: string, readyFile: string, state: NoteProcessorState): void {
  clearNoteProcessorState(state);

  try { fs.unlinkSync(pidFile); } catch {}
  try { fs.unlinkSync(readyFile); } catch {}
}
```

### 3.8 Device Connection and Disconnection Handling

JZZ requires explicit async initialization. The `JZZ()` call returns a promise-like object that must be awaited before accessing device info:

```typescript
async function listMidiDevices() {
  const jzz = await JZZ();
  const info = jzz.info();
  return info.inputs.map(x => x.name);
}

async function connectMidiDevice(deviceName) {
  const jzz = await JZZ();
  const info = jzz.info();
  const inputs = info.inputs.map(x => x.name);

  if (inputs.length === 0) {
    throw new Error("No MIDI input devices found");
  }

  let selectedDevice;
  if (deviceName) {
    // Find device by name (substring match)
    selectedDevice = inputs.find(name => name.includes(deviceName));
    if (!selectedDevice) {
      throw new Error(`MIDI device '${deviceName}' not found. Available: ${inputs.join(", ")}`);
    }
  } else {
    selectedDevice = inputs[0];
  }

  const port = jzz.openMidiIn(selectedDevice)
    .or(function() {
      throw new Error(`Failed to open MIDI device '${selectedDevice}'`);
    });

  return { port, deviceName: selectedDevice, jzz };
}

// Device disconnect handler creation.
// Because JZZ's onChange requires a callback, we create a handler that checks
// if the disconnected device matches our device name and calls the disconnect function.
function createDisconnectHandler(
  deviceName: string,
  onDisconnect: () => void
): (change: { inputs: { removed: Array<{ name: string }> } }) => void {
  return (change) => {
    if (change.inputs.removed.some(dev => dev.name === deviceName)) {
      onDisconnect();
    }
  };
}

// Register a handler for device disconnection using JZZ's onChange API.
function registerDisconnectHandler(jzz: any, deviceName: string, onDisconnect: () => void): void {
  const handler = createDisconnectHandler(deviceName, onDisconnect);
  jzz.onChange(handler);
}
```

### 3.9 Context Type and Handler Functions

To avoid nested functions, we define a context type that holds all state needed by handlers, and define handlers as top-level functions that receive this context.

```typescript
// Context holds all state needed by the daemon's event handlers.
// Passed to handler functions to avoid nested function closures.
type DaemonContext = {
  session: string;
  state: NoteProcessorState;
  config: MIDIInputConfig;
  pidFile: string;
  readyFile: string;
  midiIn: any;
  outputFn: OutputNotesFn;  // Created once at startup, reused for all MIDI messages
};

// Output notes as text in Kakoune. Called when chord window expires or note is released.
function outputNotesToKakoune(session: string, notes: Set<number>, accidentals: Accidentals, relativeMode: boolean): void {
  const text = notesToString(notes, accidentals, relativeMode);
  if (text) {
    insertText(session, text);
  }
}

// Create the output function for a given session. Called once at startup.
function createOutputFn(session: string): OutputNotesFn {
  return (notes: Set<number>, accidentals: Accidentals, relativeMode: boolean) =>
    outputNotesToKakoune(session, notes, accidentals, relativeMode);
}

// Handle incoming MIDI messages. Filters by channel and processes note on/off events.
function handleMidiMessage(ctx: DaemonContext, msg: number[]): void {
  const statusByte = msg[0] & 0xf0;
  const channel = msg[0] & 0x0f;
  const noteNumber = msg[1];
  const velocity = msg[2];

  // Filter by channel if specified
  if (ctx.config.midiChannel !== null && channel !== ctx.config.midiChannel) {
    return;
  }

  // Clamp note number to valid MIDI range
  const clampedNote = Math.max(12, Math.min(127, noteNumber));

  // Handle note on/off
  if ([0x80, 0x90].includes(statusByte)) {
    const keyDown = statusByte === 0x90 && velocity > 0;
    processNote(clampedNote, keyDown, ctx.config, ctx.state, ctx.outputFn);
  }
}

// Handle device disconnection. Closes MIDI port, cleans up files, and exits.
function handleDeviceDisconnect(ctx: DaemonContext): void {
  logToKakoune(ctx.session, "MIDI device disconnected");
  ctx.midiIn.close();
  cleanup(ctx.pidFile, ctx.readyFile, ctx.state);
  process.exit(1);
}

// Handle shutdown signals (SIGTERM, SIGINT). Closes MIDI port, cleans up files, and exits.
function handleShutdown(ctx: DaemonContext): void {
  ctx.midiIn.close();
  cleanup(ctx.pidFile, ctx.readyFile, ctx.state);
  process.exit(0);
}
```

### 3.10 Main Function

```typescript
async function main() {
  const args = parseArgs();

  // List devices mode (before validation since --session not required)
  if (args.listDevices) {
    const inputs = await listMidiDevices();
    if (inputs.length === 0) {
      console.log("No MIDI input devices found");
    } else {
      console.log("Available MIDI input devices:");
      inputs.forEach((name, i) => console.log(`  ${i + 1}. ${name}`));
    }
    process.exit(0);
  }

  // Validate arguments (includes session name format validation)
  try {
    validateArgs(args);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    console.error(`Error: ${message}`);
    process.exit(1);
  }

  // Validate session exists
  try {
    await validateSession(args.session);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    console.error(message);
    process.exit(1);
  }

  // Setup runtime directory and file paths
  // Computing readyFile path early ensures cleanup can remove stale files even if connection fails
  const runtimeDir = ensureRuntimeDir();
  const readyFile = path.join(runtimeDir, `${args.session}.ready`);

  let pidFile: string;
  try {
    pidFile = writePidFile(runtimeDir, args.session);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    console.error(message);
    process.exit(1);
  }

  // Setup state and config
  // After validateArgs, args.accidentals is guaranteed to be a valid Accidentals value
  const state = createNoteProcessorState();
  const config: MIDIInputConfig = {
    accidentals: args.accidentals as Accidentals,
    relativeMode: false,
    chordMode: true,
    chordTimeWindow: args.chordWindow,
    midiChannel: args.channel,
  };

  // Connect to MIDI device
  let midiIn: any;
  let deviceName: string;
  let jzz: any;
  try {
    const result = await connectMidiDevice(args.device);
    midiIn = result.port;
    deviceName = result.deviceName;
    jzz = result.jzz;
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    console.error(message);
    cleanup(pidFile, readyFile, state);
    process.exit(1);
  }

  // Build context for handler functions
  // Create outputFn once here to avoid creating a closure on every MIDI message
  const ctx: DaemonContext = {
    session: args.session,
    state,
    config,
    pidFile,
    readyFile,
    midiIn,
    outputFn: createOutputFn(args.session),
  };

  // Register handler for device disconnection
  registerDisconnectHandler(jzz, deviceName, () => handleDeviceDisconnect(ctx));

  // Write ready file with JSON info (signals successful initialization)
  const readyInfo = {
    device: deviceName,
    pid: process.pid,
    accidentals: args.accidentals,
    chordWindow: args.chordWindow,
    channel: args.channel,
  };
  writeReadyFile(runtimeDir, args.session, readyInfo);

  // Setup signal handlers
  process.on("SIGTERM", () => handleShutdown(ctx));
  process.on("SIGINT", () => handleShutdown(ctx));

  // Connect MIDI message handler
  midiIn.connect((msg: number[]) => handleMidiMessage(ctx, msg));

  // Log startup info to Kakoune debug buffer
  logToKakoune(ctx.session, `MIDI input active. Device: ${deviceName}`);
}

main().catch((err) => {
  const message = err instanceof Error ? err.message : String(err);
  console.error(message);
  process.exit(1);
});
```

### 3.11 Manual Testing

To test the daemon before Kakoune integration:

1. Start a Kakoune session: `kak -s test`
2. In another terminal: `node abc-kak/bin/abc-midi-kak.js --session=test`
3. Verify the ready file exists: `ls $XDG_RUNTIME_DIR/abc-midi/` (or `/tmp/abc-midi-$USER/`)
4. Play notes on MIDI keyboard, verify they appear in Kakoune
5. Test chord detection by pressing multiple notes
6. Test Ctrl+C shutdown, verify PID and ready files are removed
7. Test device disconnection handling

## Phase 4: Add Kakoune Commands

### 4.1 Create abc-midi.kak

Create `abc-kak/rc/abc-midi.kak` with the MIDI commands.

### 4.2 Runtime Directory Helper

```kak
# Get the runtime directory path
declare-option -hidden str abc_midi_runtime_dir %sh{
    if [ -n "$XDG_RUNTIME_DIR" ]; then
        echo "$XDG_RUNTIME_DIR/abc-midi"
    else
        echo "/tmp/abc-midi-$USER"
    fi
}
```

### 4.3 Options

```kak
# Path to the bundled abc-midi-kak.js daemon script
# User must set this to the location of their abc_parse checkout
declare-option -docstring "Path to the ABC MIDI daemon script" \
    str abc_midi_daemon_path ""

# MIDI device name (empty = default device)
declare-option -docstring "MIDI input device name" \
    str abc_midi_device ""

# Accidentals mode: "sharps" or "flats"
declare-option -docstring "Accidentals mode for MIDI input (sharps or flats)" \
    str abc_midi_accidentals "sharps"

# Chord detection window in milliseconds
declare-option -docstring "Chord detection time window in milliseconds" \
    int abc_midi_chord_window 50

# MIDI channel (0 = all channels, 1-16 = specific channel)
declare-option -docstring "MIDI channel to listen to (0 for all, 1-16 for specific)" \
    int abc_midi_channel 0
```

### 4.4 Start Command

The daemon is invoked via `node` with the path to the bundled script. Output is redirected to `/dev/null`; errors are reported via Kakoune's debug buffer.

```kak
define-command abc-start-midi -docstring "Start MIDI input for ABC notation" %{
    evaluate-commands %sh{
        # Check that daemon path is configured
        if [ -z "$kak_opt_abc_midi_daemon_path" ]; then
            echo 'echo -markup "{Error}abc_midi_daemon_path not set. Set it to the path of abc-midi-kak.js"'
            exit 0
        fi
        if [ ! -f "$kak_opt_abc_midi_daemon_path" ]; then
            echo "echo -markup \"{Error}Daemon not found at: $kak_opt_abc_midi_daemon_path\""
            exit 0
        fi

        runtime_dir="$kak_opt_abc_midi_runtime_dir"
        pidfile="$runtime_dir/${kak_session}.pid"
        readyfile="$runtime_dir/${kak_session}.ready"

        # Ensure runtime directory exists
        mkdir -p "$runtime_dir"
        chmod 700 "$runtime_dir"

        # Check if already running
        if [ -f "$pidfile" ]; then
            pid=$(cat "$pidfile")
            if kill -0 "$pid" 2>/dev/null; then
                echo 'echo -markup "{Error}MIDI input already running (use abc-restart-midi to restart)"'
                exit 0
            else
                # Stale PID file
                rm -f "$pidfile" "$readyfile"
            fi
        fi

        # Start daemon in background
        # The process is backgrounded and will be orphaned when the shell exits,
        # becoming a child of init/launchd. No setsid needed.
        node "$kak_opt_abc_midi_daemon_path" \
            "--session=$kak_session" \
            "--accidentals=$kak_opt_abc_midi_accidentals" \
            "--chord-window=$kak_opt_abc_midi_chord_window" \
            ${kak_opt_abc_midi_device:+"--device=$kak_opt_abc_midi_device"} \
            $([ "$kak_opt_abc_midi_channel" -gt 0 ] && echo "--channel=$kak_opt_abc_midi_channel") \
            > /dev/null 2>&1 &

        # Wait briefly for initialization and check for ready file
        sleep 0.3

        if [ -f "$readyfile" ]; then
            # Ready file is JSON, extract device name
            device_name=$(cat "$readyfile" | sed -n 's/.*"device":"\([^"]*\)".*/\1/p')
            echo "echo -markup \"{Information}MIDI input started: $device_name\""
        elif [ -f "$pidfile" ]; then
            # Process started but not ready yet - might still be initializing
            echo 'echo -markup "{Information}MIDI input starting... (check abc-midi-status if issues)"'
        else
            echo 'echo -markup "{Error}MIDI daemon failed to start"'
        fi
    }
}
```

### 4.5 Stop Command

```kak
define-command abc-stop-midi -docstring "Stop MIDI input" %{
    evaluate-commands %sh{
        runtime_dir="$kak_opt_abc_midi_runtime_dir"
        pidfile="$runtime_dir/${kak_session}.pid"
        readyfile="$runtime_dir/${kak_session}.ready"

        if [ -f "$pidfile" ]; then
            pid=$(cat "$pidfile")
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid"
                # Wait for cleanup
                sleep 0.1
                echo 'echo -markup "{Information}MIDI input stopped"'
            else
                rm -f "$pidfile" "$readyfile"
                echo 'echo -markup "{Information}MIDI daemon was not running (cleaned up stale files)"'
            fi
        else
            echo 'echo -markup "{Error}MIDI input not running"'
        fi
    }
}
```

### 4.6 Restart Command

```kak
define-command abc-restart-midi -docstring "Restart MIDI input with current settings" %{
    abc-stop-midi
    abc-start-midi
}
```

### 4.7 Status Command

```kak
define-command abc-midi-status -docstring "Show MIDI input status" %{
    evaluate-commands %sh{
        runtime_dir="$kak_opt_abc_midi_runtime_dir"
        pidfile="$runtime_dir/${kak_session}.pid"
        readyfile="$runtime_dir/${kak_session}.ready"
        logfile="$runtime_dir/${kak_session}.log"

        if [ -f "$pidfile" ]; then
            pid=$(cat "$pidfile")
            if kill -0 "$pid" 2>/dev/null; then
                if [ -f "$readyfile" ]; then
                    # Ready file is JSON, extract fields
                    device=$(cat "$readyfile" | sed -n 's/.*"device":"\([^"]*\)".*/\1/p')
                    accidentals=$(cat "$readyfile" | sed -n 's/.*"accidentals":"\([^"]*\)".*/\1/p')
                    chord_window=$(cat "$readyfile" | sed -n 's/.*"chordWindow":\([0-9]*\).*/\1/p')
                    echo "info %{MIDI input active
PID: $pid
Device: $device
Accidentals: $accidentals
Chord window: ${chord_window}ms}"
                else
                    echo "info %{MIDI daemon running but not ready (PID: $pid)}"
                fi
            else
                echo 'info %{MIDI daemon not running (stale PID file)}'
            fi
        else
            echo 'info %{MIDI input not running}'
        fi
    }
}
```

### 4.8 List Devices Command

```kak
define-command abc-list-midi-devices -docstring "List available MIDI input devices" %{
    evaluate-commands %sh{
        devices=$(node "$kak_opt_abc_midi_daemon_path" --list-devices 2>&1)
        if [ $? -eq 0 ]; then
            # Escape for Kakoune info box
            escaped=$(printf '%s' "$devices" | sed 's/%/%%/g')
            echo "info %{$escaped}"
        else
            echo 'echo -markup "{Error}Failed to list MIDI devices"'
        fi
    }
}
```

### 4.9 Set Device Command

The command provides tab-completion by querying the daemon for available devices.

```kak
define-command abc-set-midi-device -docstring "Set MIDI input device" \
    -shell-script-candidates %{
        # Query daemon for available devices, extract device names
        if [ -n "$kak_opt_abc_midi_daemon_path" ] && [ -f "$kak_opt_abc_midi_daemon_path" ]; then
            node "$kak_opt_abc_midi_daemon_path" --list-devices 2>/dev/null | \
                sed -n 's/^  [0-9]*\. //p'
        fi
    } \
    -params 1 %{
    set-option global abc_midi_device %arg{1}
    echo -markup "{Information}MIDI device set to: %arg{1}"
}
```

### 4.10 Graceful Shutdown Hook

Add a hook to stop MIDI input when Kakoune exits:

```kak
hook global KakEnd .* %{
    evaluate-commands %sh{
        runtime_dir="$kak_opt_abc_midi_runtime_dir"
        pidfile="$runtime_dir/${kak_session}.pid"

        if [ -f "$pidfile" ]; then
            pid=$(cat "$pidfile")
            kill "$pid" 2>/dev/null
        fi
    }
}
```

### 4.11 Update Main Plugin

Update `abc-kak/rc/abc.kak` to document that abc-midi.kak is loaded automatically:

```kak
# ============================================================================
# Include Selector, Transform, and MIDI Commands
# ============================================================================

# The selector commands are defined in abc-selectors.kak
# The transform commands are defined in abc-transforms.kak
# The MIDI input commands are defined in abc-midi.kak
# They are loaded automatically if placed in the same rc/ directory
```

## Phase 5: Configuration and Documentation

### 5.1 Update abc-kak/README.md

Add a new section:

```markdown
## MIDI Input

The plugin supports MIDI input for entering ABC notation directly from a MIDI keyboard.

### Commands

- `abc-start-midi` - Start MIDI input daemon
- `abc-stop-midi` - Stop MIDI input daemon
- `abc-restart-midi` - Restart with current settings
- `abc-midi-status` - Show current MIDI input status
- `abc-list-midi-devices` - List available MIDI input devices
- `abc-set-midi-device <name>` - Set the MIDI device to use

### Configuration

Add to your kakrc:

    # Set preferred accidentals (sharps or flats)
    set-option global abc_midi_accidentals "flats"

    # Set chord detection window (milliseconds)
    set-option global abc_midi_chord_window 75

    # Set specific MIDI device (substring match)
    set-option global abc_midi_device "My Keyboard"

    # Listen to specific MIDI channel (1-16, or 0 for all)
    set-option global abc_midi_channel 0

### Requirements

- Node.js (same version as ABC LSP server)
- MIDI device accessible to user

### Troubleshooting

#### No MIDI devices found

On Linux, ensure your user is in the `audio` group:

    sudo usermod -a -G audio $USER

Then log out and back in.

#### Permission denied

MIDI devices may require udev rules. Create `/etc/udev/rules.d/99-midi.rules`:

    SUBSYSTEM=="snd", GROUP="audio", MODE="0660"

Then reload udev:

    sudo udevadm control --reload-rules
    sudo udevadm trigger

#### Device disconnection

If the MIDI device is unplugged while the daemon is running, the daemon will exit automatically. Use `abc-start-midi` to restart after reconnecting the device.
```

### 5.2 Platform-Specific Notes

Add a subsection for platform considerations:

```markdown
### Platform Notes

#### Linux
- Requires ALSA (libasound2)
- User must be in `audio` group for device access

#### macOS
- Uses CoreMIDI, no additional setup required
- Grant Terminal/Kakoune access to MIDI devices if prompted

#### Windows
- Uses WinMM
- Most MIDI devices work without additional configuration
```

## To Do List

### Phase 1: Create midi-core Package
- [ ] Create directory structure: `midi-core/src/`, `midi-core/package.json`, `midi-core/tsconfig.json`
- [ ] Create `midi-core/src/types.ts` with:
  - `Accidentals` type
  - `isValidAccidentals` type guard function
  - `MIDIInputConfig` type (with `midiChannel` field)
  - `OutputNotesFn` type
  - `NoteProcessorState` type (with `pendingNotes` field for chord detection)
  - `createNoteProcessorState` helper
  - `clearNoteProcessorState` helper
- [ ] Create `midi-core/src/conversion.ts` with conversion functions extracted from VS Code extension
- [ ] Create `midi-core/src/noteProcessor.ts` with the `processNote` function implementing chord detection (the VS Code version has this commented out, so we implement it fresh)
- [ ] Create `midi-core/src/index.ts` with re-exports
- [ ] Update root `package.json`: add `midi-core` and `abc-kak` to workspaces, add `build:midi-core` script, update main `build` script to: `build:parse && build:midi-core && build:editor && ...`
- [ ] Update root `package.json` test script to include `midi-core`
- [ ] Create tests in `midi-core/tests/conversion.spec.ts` (see section 1.8 for detailed test cases)
- [ ] Create tests in `midi-core/tests/noteProcessor.spec.ts` for chord detection logic (see section 1.8 for detailed test cases)
- [ ] Verify build: `npm run build:midi-core`
- [ ] Final verification: build and tests both pass
- [ ] Call the code review agent. Address any feedback.
- [ ] Commit once the build passes and all tests pass.

### Phase 2: Update VS Code Extension
- [ ] Add `midi-core` dependency to `vscode-extension/package.json`
- [ ] Update imports in `vscode-extension/src/Midi/midi-in.ts`:
  - Import `Accidentals`, `MIDIInputConfig`, `NoteProcessorState`, `OutputNotesFn`, `createNoteProcessorState`, `clearNoteProcessorState`, `getAbsoluteOctavePostfix`, `getNoteChar`, `midiNumberToNoteName`, `notesToString`, `processNote` from `midi-core`
  - Keep importing `LogLevel`, `getConfiguration`, `logger` from `./midi-utils`
- [ ] Update `vscode-extension/src/Midi/midi-utils.ts`: remove `Accidentals` type definition (line 13)
- [ ] Replace module-level state with explicit `NoteProcessorState` object
- [ ] Update `stopMIDIInput` to call `clearNoteProcessorState`
- [ ] Update `midiInMsgProcessor._receive` to pass state to `processNote`
- [ ] Remove duplicated functions: `getAbsoluteOctavePostfix`, `getNoteChar`, `midiNumberToNoteName`, `notesToString`, `processNote`, `activeNotes`, `chordNotes`, `MIDIInputConfig` type, `OutputNotesFnType` type
- [ ] Verify VS Code extension builds: `npm run build:vscode`
- [ ] Manual test: MIDI input in VS Code still works
- [ ] Final verification: build and tests both pass
- [ ] Call the code review agent. Address any feedback.
- [ ] Commit once the build passes and all tests pass.

### Phase 3: Create Kakoune MIDI Daemon
- [ ] Create `abc-kak/package.json` with `midi-core`, `jzz`, and `esbuild` dependencies
- [ ] Create `abc-kak/src/abc-midi-kak.ts` with:
  - Argument parsing (session, device, accidentals, chord-window, channel, list-devices)
  - Argument validation using `isValidAccidentals` from midi-core
  - Runtime directory management using `$XDG_RUNTIME_DIR/abc-midi/` or `/tmp/abc-midi-$USER/`
  - Session validation via `kak -p <session> -e nop` with 2-second timeout
  - PID file with atomic creation (EEXIST handling for race condition prevention)
  - Ready file written as JSON after successful initialization (includes device, pid, accidentals, chordWindow, channel)
  - Kakoune text escaping for all ABC and Kakoune special characters
  - Async text insertion via `execFile` (not `execSync`)
  - MIDI channel filtering option
  - Explicit JZZ async initialization (`await JZZ()`)
  - Device disconnection handling via `jzz.onChange()` - exits on disconnect
  - Signal handlers (SIGTERM, SIGINT) that clean up files
- [ ] Run `npm install` from root to link workspace dependencies
- [ ] Build the daemon: `npm run build -w abc-kak` (runs esbuild, outputs bundled JS to `dist/`)
- [ ] Test daemon manually:
  - Start Kakoune session, run daemon from terminal
  - Verify ready file created as JSON with device name
  - Play single notes, verify insertion
  - Play chords, verify grouped insertion
  - Test Ctrl+C cleanup
  - Test with --channel option
  - Test device disconnection (unplug and verify exit)
  - Test invalid accidentals argument (should error)
  - Test invalid session name (should error with timeout if session doesn't exist)
- [ ] Final verification: build and tests both pass
- [ ] Call the code review agent. Address any feedback.
- [ ] Commit once the build passes and all tests pass.

### Phase 4: Add Kakoune Commands
- [ ] Create `abc-kak/rc/abc-midi.kak` with:
  - Runtime directory option `abc_midi_runtime_dir`
  - Configuration options: `abc_midi_daemon_path`, `abc_midi_device`, `abc_midi_accidentals`, `abc_midi_chord_window`, `abc_midi_channel`
  - `abc-start-midi` command with:
    - Validates `abc_midi_daemon_path` is set and file exists
    - Invokes daemon via `node "$kak_opt_abc_midi_daemon_path"`
    - Startup verification (checks JSON ready file)
    - Extracts device name from JSON for display
  - `abc-stop-midi` command
  - `abc-restart-midi` command
  - `abc-midi-status` command (reads from JSON ready file)
  - `abc-list-midi-devices` command
  - `abc-set-midi-device` command
  - `KakEnd` hook for graceful shutdown
- [ ] Update `abc-kak/rc/abc.kak` to document that abc-midi.kak is auto-loaded
- [ ] Test commands in Kakoune:
  - `abc-start-midi` shows device name on success
  - `abc-start-midi` while running shows error
  - `abc-stop-midi` stops daemon and cleans files
  - `abc-restart-midi` works correctly
  - `abc-midi-status` shows correct info (from JSON)
  - Closing Kakoune stops daemon automatically
  - Test with special characters in session name
- [ ] Final verification: build and tests both pass
- [ ] Call the code review agent. Address any feedback.
- [ ] Commit once the build passes and all tests pass.

### Phase 5: Configuration and Documentation
- [ ] Update `abc-kak/README.md` with MIDI input section:
  - Commands reference
  - Configuration options
  - Requirements (Node.js, MIDI device)
  - Troubleshooting (audio group, udev rules, device disconnection)
  - Platform notes (Linux ALSA, macOS CoreMIDI)
- [ ] Final verification: build and tests both pass
- [ ] Call the code review agent. Address any feedback.
- [ ] Commit once the build passes and all tests pass.
