# Linear Directive Implementation

## Table of Contents

1. [Overview](#overview)
2. [Phase 1: Scanner Integration](#phase-1-scanner-integration)
3. [Phase 2: Parser Integration](#phase-2-parser-integration)
4. [Phase 3: Directive Specs Integration](#phase-3-directive-specs-integration)
5. [Phase 4: Directive Analyzer Integration](#phase-4-directive-analyzer-integration)
6. [Phase 5: Semantic Analyzer Integration](#phase-5-semantic-analyzer-integration)
7. [Phase 6: Update Extension-Based Infrastructure](#phase-6-update-extension-based-infrastructure)

---

## Overview

This plan converts the ABCL format detection from extension-based (`.abcl` files) to directive-based (`%%linear true/false` in file or tune header).

### Current Behavior

- `.abcl` extension triggers `parseAbcl()` which passes `{ linear: true }` to the parser
- The `linear` flag is determined externally before parsing starts

### New Behavior

- `%%linear true` or `%%linear false` directive in file header or tune header controls parsing mode
- ABC scoping rules apply: tune header overrides file header (narrower scope takes precedence)
- The parser detects the directive during header parsing and sets internal flags
- The `linear` option is removed from `ParseOptions`

### Directive Semantics

- Syntax: `%%linear true` or `%%linear false`
- Valid locations: file header, tune header
- Effect: when `true`, the tune body is parsed using linear-style voice grouping
- Scoping: tune header value overrides file header value

---

## Phase 1: Scanner Integration

### Rationale

Because all new features must start at the scanner level, we need to verify that `%%linear true` and `%%linear false` are tokenized correctly before proceeding to the parser.

### Current Scanner Behavior

The scanner already handles stylesheet directives generically:
- `%%` is tokenized as `TT.STYLESHEET_DIRECTIVE`
- The directive name following `%%` is tokenized as an identifier
- Parameters following the name are tokenized according to their form

### Verification Needed

We need to confirm that `%%linear true` and `%%linear false` produce the expected token sequence:
```
TT.STYLESHEET_DIRECTIVE  "%%"
TT.IDENTIFIER            "linear"
TT.WS                    " "
TT.IDENTIFIER            "true" (or "false")
TT.EOL
```

### Changes

If the scanner already produces this sequence, no code changes are needed - only tests to document the expected behavior.

### Tests

Location: `parse/tests/scanner.spec.ts`

Example-based tests:
- `%%linear true` produces expected token sequence: `[STYLESHEET_DIRECTIVE, IDENTIFIER("linear"), WS, IDENTIFIER("true"), EOL]`
- `%%linear false` produces expected token sequence: `[STYLESHEET_DIRECTIVE, IDENTIFIER("linear"), WS, IDENTIFIER("false"), EOL]`
- `%%linear true` with extra whitespace: `%%linear   true` still produces valid tokens
- `%%linear` without parameter produces: `[STYLESHEET_DIRECTIVE, IDENTIFIER("linear"), EOL]`

Property-based tests:
- Not applicable at scanner level for this directive (the token sequence is deterministic)

### To do

- Add example-based scanner tests in `parse/tests/scanner.spec.ts` for `%%linear true` and `%%linear false`
- Verify the token sequence matches expectations
- Document any adjustments needed if tokenization differs from expected
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Parser Integration

### Rationale

Because the parser processes headers before bodies, we can detect `%%linear true/false` in the file header or tune header and store the effective value on the AST nodes. This allows downstream consumers (like `getPreviewContent()`) to check each tune's `linear` flag independently.

### AST Node Changes

#### 1. `parse/types/Expr2.ts` - File_structure class (line 178-189)

Add `linear` field:

```
class File_structure extends Expr
  file_header: File_header | null
  contents: Array<Tune | Token>
  linear: boolean = false  // NEW: file-level linear flag

  constructor(id, file_header, tune, linear = false)
    super(id)
    this.file_header = file_header
    this.contents = tune
    this.linear = linear
```

#### 2. `parse/types/Expr2.ts` - Tune class (line 366-377)

Add `linear` field:

```
class Tune extends Expr
  tune_header: Tune_header
  tune_body?: Tune_Body
  linear: boolean = false  // NEW: per-tune linear flag

  constructor(id, tune_header, tune_body, linear = false)
    super(id)
    this.tune_header = tune_header
    this.tune_body = tune_body || undefined
    this.linear = linear
```

### Parser Context Changes

#### 3. `parse/parsers/Context.ts` - ABCContext class (lines 31-54)

Add tracking fields for directive detection during parsing:

```
linear: boolean = false        // file-level value from %%linear in file header
tuneLinear: boolean = false    // current tune's effective value
```

### Parser Logic Changes

#### 4. `parse/parsers/parse2.ts` - Helper function (new)

Add helper to extract linear value from a directive:

```
function checkLinearDirective(directive: Directive, ctx: ParseCtx, target: "file" | "tune"): void
  if directive.key.lexeme.toLowerCase() !== "linear"
    return

  if directive.values.length === 0
    return  // no value, semantic analyzer will report error

  value = directive.values[0]
  boolValue: boolean | null = null

  if value is Token
    lexeme = value.lexeme.toLowerCase()
    if lexeme === "true" or lexeme === "1"
      boolValue = true
    else if lexeme === "false" or lexeme === "0"
      boolValue = false

  if boolValue === null
    return  // invalid value, semantic analyzer will report error

  if target === "file"
    ctx.abcContext.linear = boolValue
  else
    ctx.abcContext.tuneLinear = boolValue
```

#### 5. `parse/parsers/parse2.ts` - File header directive handling

Location: `parseFileHeader()` at line 173, after `parseDirective(ctx, contents)` returns

Note: `parseDirective()` returns a boolean and appends the directive to the `contents` array. We access the last element to get the directive.

```
if parseDirective(ctx, contents)
  lastElement = contents[contents.length - 1]
  if lastElement instanceof Directive
    checkLinearDirective(lastElement, ctx, "file")
```

#### 6. `parse/parsers/parse2.ts` - Tune initialization

Location: `parse()` at line 128-131, before calling `parseTune()`

```
// Initialize tune's linear flag from file-level value
ctx.abcContext.tuneLinear = ctx.abcContext.linear
```

#### 7. `parse/parsers/parse2.ts` - Tune header directive handling

Location: `prsTuneHdr()` at line 229, after `parseDirective(ctx, infoLines)` returns

Note: Same pattern as file header - `parseDirective()` returns boolean, directive is in array.

```
if parseDirective(ctx, infoLines)
  lastElement = infoLines[infoLines.length - 1]
  if lastElement instanceof Directive
    checkLinearDirective(lastElement, ctx, "tune")
```

#### 8. `parse/parsers/parse2.ts` - Tune construction

Location: where `Tune` is constructed (around line 213)

Pass the effective linear flag to the Tune constructor:

```
tune = new Tune(id, tuneHeader, tuneBody, ctx.abcContext.tuneLinear)
```

#### 9. `parse/parsers/parse2.ts` - File_structure construction

Location: where `File_structure` is constructed (end of `parse()`)

Pass the file-level linear flag to the File_structure constructor:

```
fileStructure = new File_structure(id, fileHeader, tunes, ctx.abcContext.linear)
```

#### 10. `parse/parsers/parse2.ts` - Remove linear parameter propagation

- `parse()`: remove `const linear = options?.linear ?? false` and remove `linear` argument from `parseTune()` call
- `parseTune()`: remove `linear` parameter, use `ctx.abcContext.tuneLinear` when calling `prsBody()`
- `prsBody()`: remove `linear` parameter, read from `ctx.abcContext.tuneLinear`
- `prsSystems()`: remove `linear` parameter, read from context

#### 11. `parse/parsers/parse2.ts` - Remove ParseOptions.linear

Remove `linear` from `ParseOptions` interface (line 111)

### Tests

Location: `parse/tests/linear-directive.spec.ts` (new file)

Example-based tests:
- File with `%%linear true` in file header: `fileStructure.linear === true`
- File with `%%linear false` in file header: `fileStructure.linear === false`
- Tune inherits file-level value: file has `%%linear true`, tune has no directive -> `tune.linear === true`
- Tune overrides file-level value: file has `%%linear false`, tune header has `%%linear true` -> `tune.linear === true`
- Tune overrides file-level value (reverse): file has `%%linear true`, tune header has `%%linear false` -> `tune.linear === false`
- Multiple tunes with mixed values: file has `%%linear true`, tune 1 has no directive, tune 2 has `%%linear false` -> tune 1 `linear === true`, tune 2 `linear === false`
- Multiple directives in tune header: tune header has `%%linear true` then `%%linear false` -> last one wins, `tune.linear === false`
- No directive anywhere: `fileStructure.linear === false`, `tune.linear === false`
- Invalid value `%%linear foo`: flags remain at their default/inherited values

Property-based tests:
- For any valid ABC with `%%linear true` in file header and no tune overrides, all tunes have `linear === true`
- For any tune, its `linear` value equals: tune header value if present, else file header value if present, else `false`

### To do

- Add `linear: boolean` field to `File_structure` class in `Expr2.ts`
- Add `linear: boolean` field to `Tune` class in `Expr2.ts`
- Update `File_structure` constructor to accept `linear` parameter
- Update `Tune` constructor to accept `linear` parameter
- Add `linear` and `tuneLinear` fields to `ABCContext` in `Context.ts`
- Create `checkLinearDirective()` helper function in `parse2.ts`
- Insert `tuneLinear` initialization before `parseTune()` call
- Insert directive check after `parseDirective()` in `parseFileHeader()`
- Insert directive check after `parseDirective()` in `prsTuneHdr()`
- Pass `ctx.abcContext.tuneLinear` to `Tune` constructor
- Pass `ctx.abcContext.linear` to `File_structure` constructor
- Remove `linear` parameter from `parseTune()`, `prsBody()`, `prsSystems()`
- Remove `linear` from `ParseOptions` interface
- Update call sites that used `linear: true` option (search for `parseAbcl` usages)
- Create `parse/tests/linear-directive.spec.ts` with example-based tests
- Add property-based tests for flag propagation invariants
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: Directive Specs Integration

### Rationale

Because the directive specs define validation rules and parameter types for each directive, we need to add an entry for `linear` so that it can be validated and analyzed consistently with other directives.

### Changes

1. `parse/types/directive-specs.ts`
   - Location: `DIRECTIVE_SPECS` record (line 107)
   - Add entry in the "Simple Parameter Directives" section (around line 150, near `graceslurs`):
     ```
     linear: { params: [{ type: "boolean" }] },
     ```

### Tests

Location: `parse/tests/directive-specs.spec.ts` (or existing directive test file)

Example-based tests:
- `DIRECTIVE_SPECS["linear"]` exists and has `params` array with one entry of type `"boolean"`
- Validation accepts `%%linear true`
- Validation accepts `%%linear false`
- Validation rejects `%%linear` with no parameter (if validation enforces required params)
- Validation rejects `%%linear foo` where `foo` is not a valid boolean

Property-based tests:
- Not applicable at this level (specs are static configuration)

### To do

- Add `linear` entry to `DIRECTIVE_SPECS` in `directive-specs.ts`
- Add example-based tests for the directive spec validation
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 4: Directive Analyzer Integration

### Rationale

Because the directive analyzer produces typed semantic data from parsed directives, we need to add handling for `%%linear` so that it produces a `DirectiveSemanticData` with the boolean value.

### Changes

1. `parse/types/directive-specs.ts`
   - Location: `DirectiveSemanticData` union type, "Boolean value directives" section (around line 464)
   - Add: `| { type: "linear"; data: boolean }`

2. `parse/analyzers/directive-analyzer.ts`
   - Location: `analyzeDirective()` switch statement (line 26)
   - Add case in the boolean value directives section (around line 113-118, near `graceslurs`):
     ```
     case "linear":
       return parseBooleanValue(directive, analyzer);
     ```

### Tests

Location: `parse/tests/directive-analyzer.spec.ts` (or existing directive analyzer test file)

Example-based tests:
- `%%linear true` produces `{ type: "linear", data: true }`
- `%%linear false` produces `{ type: "linear", data: false }`
- `%%linear 1` produces `{ type: "linear", data: true }`
- `%%linear 0` produces `{ type: "linear", data: false }`
- `%%linear foo` produces `null` and reports an error
- `%%linear` (no parameter) produces `null` and reports an error

Property-based tests:
- For any valid boolean input (`true`, `false`, `0`, `1`), the analyzer produces a non-null result with the correct boolean value

### To do

- Add `| { type: "linear"; data: boolean }` to `DirectiveSemanticData` in `directive-specs.ts`
- Add `case "linear"` to `analyzeDirective()` switch in `directive-analyzer.ts`
- Add example-based tests for directive analysis
- Add property-based test for boolean parsing consistency
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 5: Semantic Analyzer Integration

### Rationale

The semantic analyzer visits directives and delegates to `analyzeDirective()` (updated in Phase 4). Because the `%%linear` directive is already handled at the parser level (Phase 2) for controlling parse behavior, the semantic analyzer's role is to validate the directive and store semantic data for downstream consumers (language server hover info, diagnostics, etc.).

### Current Behavior

The `SemanticAnalyzer.visitDirectiveExpr()` method (line 86-102 in `semantic-analyzer.ts`):
1. Calls `analyzeDirective(expr, this)`
2. Stores the result in `this.data.set(expr.id, result)` if non-null
3. Returns the result

Since Phase 4 adds the `case "linear"` to `analyzeDirective()`, the semantic analyzer will automatically handle `%%linear` directives without code changes.

### Changes

No code changes required in `semantic-analyzer.ts` - the existing visitor infrastructure handles it.

### Tests

Location: `parse/tests/semantic-analyzer.spec.ts` (or existing semantic analyzer test file)

Example-based tests:
- Parsing and analyzing a file with `%%linear true` stores `{ type: "linear", data: true }` in the semantic data map
- Parsing and analyzing a file with `%%linear false` stores `{ type: "linear", data: false }` in the semantic data map
- The semantic data is associated with the correct directive node ID
- Invalid `%%linear foo` produces an analyzer error diagnostic

Property-based tests:
- For any valid ABC file containing `%%linear` directives, each directive node has corresponding semantic data in the map

### To do

- Verify no code changes are needed in `semantic-analyzer.ts`
- Add example-based tests for semantic data storage
- Add property-based test for semantic data presence
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 6: Remove ABCL Extension and Unify Under ABC

### Rationale

Because the `%%linear` directive now controls parsing behavior and the `linear` flag is stored on each `Tune` AST node, the `.abcl` file extension is no longer needed. Users should use `.abc` files with `%%linear true` in the file header or tune headers. This phase removes all `.abcl`-specific infrastructure, renames the `abcl` module to `linear`, and unifies everything under the `.abc` extension.

### Changes

#### 1. Remove `.abcl` from VSCode extension language registration

File: `vscode-extension/package.json`

Current (lines 585-589):
```json
"extensions": [
  ".abc",
  ".abcx",
  ".abcl"
]
```

New:
```json
"extensions": [
  ".abc",
  ".abcx"
]
```

#### 2. Remove `.abcl` check and update comment in renderer

File: `vscode-extension/src/renderer/AbcRenderer.ts`

Line 28 - Update comment:
```
// Current: The server handles all conversions (ABCL to deferred, ABCx to ABC, etc.)
// New: The server handles all conversions (linear to deferred, ABCx to ABC, etc.)
```

Line 251 - Remove `.abcl` check:
```
// Current: if (filePath.endsWith(".abc") || filePath.endsWith(".abcl") || filePath.endsWith(".abcx"))
// New: if (filePath.endsWith(".abc") || filePath.endsWith(".abcx"))
```

#### 3. Delete `AbclDocument` class

File: `abc-lsp-server/src/AbclDocument.ts`

Delete this file entirely.

#### 4. Update `AbcLspServer.ts`

File: `abc-lsp-server/src/AbcLspServer.ts`

Remove:
- Line 5: Import of `AbclDocument`
- Lines 22-24: `isAbclDocument` type guard
- Line 27-29: Update `hasCtx` to remove `AbclDocument` reference
- Lines 64-68: `isAbclFile()` helper method
- Lines 83-84: `AbclDocument` creation branch
- Line 141: Update comment to remove "ABCL"
- Lines 186, 195-196, 203-204: Remove ABCL-specific handling in `getPreviewContent()`

Update:
- Line 9-10: Remove `AbclDocument` from `DocumentType` union

#### 5. Rewrite `getPreviewContent()` for per-tune conversion

File: `abc-lsp-server/src/AbcLspServer.ts`

```
getPreviewContent(uri: string): string
  abcDocument = this.abcDocuments.get(uri)
  if !abcDocument or !abcDocument.AST
    return ""

  // ABCx files: return formatted content directly
  if isAbcxDocument(abcDocument)
    formatter = new AbcFormatter(abcDocument.ctx)
    return formatter.stringify(abcDocument.AST)

  // ABC files: convert linear tunes to deferred style
  ast = abcDocument.AST
  convertedContents: Array<Tune | Token> = []

  for content of ast.contents
    if content instanceof Tune
      if content.linear === true
        convertedContents.push(convertTuneToDeferred(content, abcDocument.ctx))
      else
        convertedContents.push(content)
    else
      convertedContents.push(content)

  convertedAst = new File_structure(
    abcDocument.ctx.generateId(),
    ast.file_header,
    convertedContents,
    ast.linear
  )

  formatter = new AbcFormatter(abcDocument.ctx)
  return formatter.stringify(convertedAst)
```

#### 6. Rename `parse/abcl/` directory to `parse/linear/`

Using git (to preserve history):
```
git mv parse/abcl parse/linear
```

#### 7. Rename converter file

Using git (to preserve history):
```
git mv parse/linear/AbclToAbcConverter.ts parse/linear/LinearToDeferredConverter.ts
```

Update file header comment:
```
// Current: AbclToAbcConverter - Converts ABCL (linear style) to ABC (deferred style)
// New: LinearToDeferredConverter - Converts linear style to deferred style
```

#### 8. Rename and update `parse/linear/index.ts`

Current exports:
- `parseAbcl` - REMOVE
- `abclToAbcAst` - RENAME to `linearToAbcAst`
- `abclToAbc` - RENAME to `linearToAbc`
- Re-exports from converter - UPDATE import path

Update module comment:
```
// Current: ABCL (Linear Style) Support Module
// New: Linear Style Support Module
```

Update function comments to remove ABCL references.

#### 9. Update `parse/index.ts`

Line 19-20:
```
// Current:
// ABCL linear style support
export * from "./abcl";

// New:
// Linear style support (for converting linear to deferred style)
export * from "./linear";
```

#### 10. Update imports in language server

File: `abc-lsp-server/src/AbcLspServer.ts`

Add imports:
```
import { convertTuneToDeferred } from "abc-parser"
import { File_structure, Tune } from "abc-parser"
```

#### 11. Update test file imports and names

File: `parse/tests/abcl2abc.spec.ts` -> Rename to `parse/tests/linear2deferred.spec.ts`

Using git (to preserve history):
```
git mv parse/tests/abcl2abc.spec.ts parse/tests/linear2deferred.spec.ts
```

Update imports:
```
// Current: import { abclToAbc, convertFileToDeferred, getAllVoices } from "../abcl";
// New: import { linearToAbc, convertFileToDeferred, getAllVoices } from "../linear";
```

Update test suite name:
```
// Current: describe("ABCL to ABC Converter", () => {
// New: describe("Linear to Deferred Converter", () => {
```

Update all `abclToAbc` calls to `linearToAbc`.

File: `parse/tests/voices2.spec.ts`

Line 63:
```
// Current: import { getAllVoices } from "../abcl";
// New: import { getAllVoices } from "../linear";
```

#### 12. Update exports in `parse/index.ts`

Ensure these are exported:
- `convertTuneToDeferred`
- `convertFileToDeferred`
- `linearToAbc`
- `linearToAbcAst`
- `getAllVoices`

Remove export of `parseAbcl`.

#### 13. Update `CloneVisitor` to preserve linear flag

File: `parse/Visitors/CloneVisitor.ts`

Line 258 - Update `Tune` instantiation to preserve the `linear` flag:

```
// Current:
return new Tune(this.ctx.generateId(), newHeader, newBody);

// New:
return new Tune(this.ctx.generateId(), newHeader, newBody, tune.linear);
```

Also update the method that clones `File_structure` to preserve its `linear` flag.

#### 14. Update `VoiceFilterVisitor` to preserve linear flag

File: `parse/Visitors/VoiceFilterVisitor.ts`

Line 274 - Update `Tune` instantiation to preserve the `linear` flag:

```
// Current:
return new Tune(this.context.generateId(), filteredHeader, filteredBody || null);

// New:
return new Tune(this.context.generateId(), filteredHeader, filteredBody || null, tune.linear);
```

### Summary of file operations

Deletions:
- `abc-lsp-server/src/AbclDocument.ts`

Renames (using `git mv` to preserve history):
- `parse/abcl/` -> `parse/linear/`
- `parse/linear/AbclToAbcConverter.ts` -> `parse/linear/LinearToDeferredConverter.ts`
- `parse/tests/abcl2abc.spec.ts` -> `parse/tests/linear2deferred.spec.ts`

### Tests

Example-based tests:
- File with `%%linear true` parsed via `parse()` produces AST with `linear === true`
- `getPreviewContent()` with mixed tunes: only tunes with `linear === true` are converted
- `linearToAbc()` produces valid ABC output from linear-style input with `%%linear true`

Property-based tests:
- For any file with mixed linear/deferred tunes, `getPreviewContent()` produces valid ABC

### To do

- Remove `.abcl` from extensions list in `vscode-extension/package.json`
- Remove `.abcl` check from `getCurrentEditorContent()` in `AbcRenderer.ts`
- Update comment in `AbcRenderer.ts` (line 28) to remove ABCL reference
- Delete `abc-lsp-server/src/AbclDocument.ts`
- Remove all `AbclDocument` references from `AbcLspServer.ts`
- Remove `isAbclFile()` and `isAbclDocument()` from `AbcLspServer.ts`
- Update `DocumentType` union to remove `AbclDocument`
- Rewrite `getPreviewContent()` for per-tune linear conversion
- Add imports for `convertTuneToDeferred`, `File_structure`, `Tune` in `AbcLspServer.ts`
- Rename `parse/abcl/` directory to `parse/linear/` using `git mv`
- Rename `AbclToAbcConverter.ts` to `LinearToDeferredConverter.ts` using `git mv`
- Update comments in `LinearToDeferredConverter.ts`
- Rename `parseAbcl` to remove (no replacement needed)
- Rename `abclToAbcAst` to `linearToAbcAst`
- Rename `abclToAbc` to `linearToAbc`
- Update module comment in `parse/linear/index.ts`
- Update `parse/index.ts` export and comment
- Rename `parse/tests/abcl2abc.spec.ts` to `parse/tests/linear2deferred.spec.ts` using `git mv`
- Update imports and function calls in renamed test file
- Update import in `parse/tests/voices2.spec.ts`
- Update exports in `parse/index.ts`
- Update `CloneVisitor.ts` to preserve `linear` flag when cloning `Tune` and `File_structure`
- Update `VoiceFilterVisitor.ts` to preserve `linear` flag when filtering `Tune`
- Add tests for mixed linear/deferred tunes in `getPreviewContent()`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
