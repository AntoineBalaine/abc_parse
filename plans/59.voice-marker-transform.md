# Voice Marker Transform: Convert Between Info Line and Inline Forms

## Table of Contents

1. [Overview](#overview)
2. [Background](#background)
3. [Design](#design)
4. [Phase 1: Core Transform Functions](#phase-1-core-transform-functions)
5. [Phase 2: LSP and Extension Integration](#phase-2-lsp-and-extension-integration)
6. [To Do List](#to-do-list)

---

## Overview

This plan implements bidirectional transforms to convert voice markers between their two syntactic forms:

- Info line form: `V:1 clef=treble` (appears on its own line)
- Inline form: `[V:1 clef=treble]` (appears within music code)

Two transforms will be created:

1. `voiceInfoLineToInline`: Converts `V:...` info lines to `[V:...]` inline fields
2. `voiceInlineToInfoLine`: Converts `[V:...]` inline fields to `V:...` info lines

Both transforms operate on all voice markers within a Selection range, following the established transform pattern in the editor module.

---

## Background

### Voice Marker Types in the AST

The ABC parser represents voice markers in two AST node types:

`Info_line` (from `parse/types/Expr2.ts:232`):
```
class Info_line extends Expr {
  key: Token;           // "V:"
  value: Array<Token>;  // ["1", "clef=treble", ...]
  value2?: Array<Expr>; // Parsed expressions
}
```

`Inline_field` (from `parse/types/Expr2.ts:521`):
```
class Inline_field extends Expr {
  leftBracket?: Token;   // "[" (TT.INLN_FLD_LFT_BRKT)
  rightBracket?: Token;  // "]" (TT.INLN_FLD_RGT_BRKT)
  field: Token;          // "V:" (TT.INF_HDR)
  text: Array<Token>;    // [field, id, params...] (text[0] === field)
  value2?: Array<Expr>;  // Parsed expressions
}
```

### CSTree Representation

The editor transforms operate on CSNode trees (from `editor/src/csTree/types.ts`). The relevant tags are:

- `TAGS.Info_line`: For line-level voice markers
- `TAGS.Inline_field`: For inline voice markers
- `TAGS.Token`: For individual tokens

### Existing Reference Implementations

- `editor/src/transforms/insertVoiceLine.ts`: Contains `createInlineVoiceMarker()` helper (lines 200-240) that creates inline voice markers from scratch
- `editor/src/transforms/toRest.ts`: Shows the pattern for mutating CSNode structures
- `editor/src/csTree/toAst.ts`: The `buildInlineField()` function (lines 319-335) shows expected children structure

### Token Types Required

From `parse/parsers/scan2.ts`:

- `TT.INLN_FLD_LFT_BRKT`: Left bracket `[`
- `TT.INLN_FLD_RGT_BRKT`: Right bracket `]`
- `TT.INF_HDR`: Info line header like `V:`
- `TT.INFO_STR`: Info line content
- `TT.EOL`: End of line token
- `TT.WS`: Whitespace token

---

## Design

### Transform Behavior: voiceInfoLineToInline

Input:
```
V:1 clef=treble
CDEF|
```

Output:
```
[V:1 clef=treble] CDEF|
```

Algorithm:
1. Find all `Info_line` nodes with `V:` key within the selection
2. For each voice info line:
   a. Locate the EOL token following this info line
   b. Create a new `Inline_field` node with the same content
   c. Insert the inline field at the start of the next music content
   d. Remove the original `Info_line` node and its trailing EOL
3. Apply standard formatting

### Transform Behavior: voiceInlineToInfoLine

Input:
```
[V:1 clef=treble] CDEF|
```

Output:
```
V:1 clef=treble
CDEF|
```

Algorithm:
1. Find all `Inline_field` nodes with `V:` field within the selection
2. For each voice inline field:
   a. Create a new `Info_line` node with the same content
   b. Insert the info line before the current line (before the first element on this line)
   c. Add an EOL token after the info line
   d. Remove the original `Inline_field` node
3. Apply standard formatting

### Helper Functions

The following helper functions will be created in `editor/src/transforms/voiceMarkerTransform.ts`:

```
isVoiceInfoLine(node: CSNode): boolean
  // Returns true if node is Info_line with V: key
  // Check: node.tag === TAGS.Info_line && first child token has lexeme "V:"

isVoiceInlineField(node: CSNode): boolean
  // Returns true if node is Inline_field with V: field
  // Check: node.tag === TAGS.Inline_field && field token (after left bracket) has lexeme "V:"

isEOLorWS(node: CSNode): boolean
  // Returns true if node is a Token with type TT.EOL or TT.WS

extractVoiceContent(node: CSNode): CSNode[]
  // Extracts the voice content CSNodes (id, params) from either form
  // For Info_line: children after the key token (V:)
  // For Inline_field: children after left bracket and field token, before right bracket
  // Uses structuredClone() on each node to avoid sharing between old and new structures

createInfoLineFromContent(voiceContent: CSNode[], ctx: ABCContext): CSNode
  // Creates an Info_line CSNode from voice content
  // Children: [V: token, ...voiceContent] linked via nextSibling

createInlineFieldFromContent(voiceContent: CSNode[], ctx: ABCContext): CSNode
  // Creates an Inline_field CSNode from voice content
  // Children: [left bracket, V: token, ...voiceContent, right bracket]
  // Uses createCSNode() directly for bracket/field tokens

findPrev(parent: CSNode, target: CSNode): CSNode | null
  // Finds the predecessor of target in parent's child list
  // Returns null if target is firstChild

findLineStart(tuneBody: CSNode, target: CSNode): CSNode | null
  // Finds the first element after the most recent EOL token before target
  // Traverse forward from tuneBody.firstChild, track element after last EOL
  // Stop when we reach target, return the tracked element
  // If no EOL found before target, return tuneBody.firstChild

removeNodeAndTrailingEOL(parent: CSNode, prev: CSNode | null, node: CSNode): void
  // Removes node from sibling chain using removeChild(parent, prev, node)
  // Then removes any immediately following EOL/WS tokens

removeNodeAndLeadingWS(parent: CSNode, prev: CSNode | null, node: CSNode): void
  // First removes any WS token immediately before node (if prev is WS)
  // Then removes node itself from sibling chain
```

### Imports Required

From `editor/src/transforms/treeUtils.ts`:
- `findParent`, `insertBefore`, `removeChild`, `appendChild`

From `editor/src/transforms/types.ts`:
- `findNodesById`

From `editor/src/csTree/types.ts`:
- `CSNode`, `TAGS`, `createCSNode`, `isTokenNode`, `getTokenData`

From `abc-parser`:
- `ABCContext`, `TT`

---

## Phase 1: Core Transform Functions

### Files to Create

`editor/src/transforms/voiceMarkerTransform.ts`:
- `voiceInfoLineToInline(selection: Selection, ctx: ABCContext): Selection`
- `voiceInlineToInfoLine(selection: Selection, ctx: ABCContext): Selection`
- Helper functions as listed above

### Implementation Details

#### voiceInfoLineToInline

```
function voiceInfoLineToInline(selection: Selection, ctx: ABCContext): Selection {
  // Process each cursor (each cursor contains one voice info line ID)
  for (const cursor of selection.cursors) {
    const nodes = findNodesById(selection.root, cursor)

    for (const voiceLine of nodes) {
      // Skip if not a voice info line (defensive check)
      if (!isVoiceInfoLine(voiceLine)) continue

      // Find parent (Tune_Body) and predecessor for tree manipulation
      const parentInfo = findParent(selection.root, voiceLine)
      if (!parentInfo) continue
      const { parent: tuneBody, prev } = parentInfo

      // Extract voice content (children after V: token)
      const voiceContent = extractVoiceContent(voiceLine)

      // Create inline field with brackets
      const inlineField = createInlineFieldFromContent(voiceContent, ctx)

      // Find next music content (skip EOL/WS tokens)
      let nextMusic = voiceLine.nextSibling
      while (nextMusic && isEOLorWS(nextMusic)) {
        nextMusic = nextMusic.nextSibling
      }

      // Insert first, then remove (prev stays valid throughout)
      if (nextMusic) {
        // Find predecessor of nextMusic
        const nextPrev = findPrev(tuneBody, nextMusic)

        // Create space token
        const spaceToken = createCSNode(TAGS.Token, ctx.generateId(), {
          type: "token", lexeme: " ", tokenType: TT.WS, line: 0, position: 0
        })

        // Insert inline field and space before next music content
        insertBefore(tuneBody, nextPrev, nextMusic, inlineField)
        insertBefore(tuneBody, inlineField, nextMusic, spaceToken)
      } else {
        // No following content - append inline field
        appendChild(tuneBody, inlineField)
      }

      // Now remove voice info line and trailing EOL/WS (prev still valid)
      removeNodeAndTrailingEOL(tuneBody, prev, voiceLine)
    }
  }

  return selection
}
```

#### voiceInlineToInfoLine

```
function voiceInlineToInfoLine(selection: Selection, ctx: ABCContext): Selection {
  // Process each cursor (each cursor contains one inline field ID)
  for (const cursor of selection.cursors) {
    const nodes = findNodesById(selection.root, cursor)

    for (const inlineField of nodes) {
      // Skip if not a voice inline field (defensive check)
      if (!isVoiceInlineField(inlineField)) continue

      // Find parent (Tune_Body) and predecessor for tree manipulation
      const parentInfo = findParent(selection.root, inlineField)
      if (!parentInfo) continue
      const { parent: tuneBody, prev } = parentInfo

      // Extract voice content (children between brackets, excluding V: token)
      const voiceContent = extractVoiceContent(inlineField)

      // Create info line
      const infoLine = createInfoLineFromContent(voiceContent, ctx)

      // Create EOL token
      const eolToken = createCSNode(TAGS.Token, ctx.generateId(), {
        type: "token", lexeme: "\n", tokenType: TT.EOL, line: 0, position: 0
      })

      // Find line start: traverse forward from tuneBody.firstChild,
      // track the element after the last EOL before inlineField
      const lineStart = findLineStart(tuneBody, inlineField)

      // Insert first, then remove (prev stays valid throughout)
      if (lineStart) {
        const lineStartPrev = findPrev(tuneBody, lineStart)
        insertBefore(tuneBody, lineStartPrev, lineStart, infoLine)
        insertBefore(tuneBody, infoLine, lineStart, eolToken)
      } else {
        // Insert at beginning of tuneBody
        const firstChild = tuneBody.firstChild
        if (firstChild) {
          insertBefore(tuneBody, null, firstChild, infoLine)
          insertBefore(tuneBody, infoLine, firstChild, eolToken)
        } else {
          appendChild(tuneBody, infoLine)
          appendChild(tuneBody, eolToken)
        }
      }

      // Now remove inline field and any leading whitespace (prev still valid)
      removeNodeAndLeadingWS(tuneBody, prev, inlineField)
    }
  }

  return selection
}
```

### Testing for Phase 1

#### Example-Based Tests

File: `editor/tests/voiceMarkerTransform.spec.ts`

Test cases for `voiceInfoLineToInline`:

1. Single voice marker conversion:
   - Input: `"X:1\nK:C\nV:1\nCDEF|"`
   - Expected: `"X:1\nK:C\n[V:1] CDEF|"`

2. Voice marker with parameters:
   - Input: `"X:1\nK:C\nV:1 clef=treble stem=up\nCDEF|"`
   - Expected: `"X:1\nK:C\n[V:1 clef=treble stem=up] CDEF|"`

3. Voice marker with quoted name:
   - Input: `"X:1\nK:C\nV:S1 name=\"Soprano\"\nCDEF|"`
   - Expected: `"X:1\nK:C\n[V:S1 name=\"Soprano\"] CDEF|"`

4. Multiple voice markers in selection:
   - Input: `"X:1\nK:C\nV:1\nCDEF|\nV:2\nGABc|"`
   - Expected: `"X:1\nK:C\n[V:1] CDEF|\n[V:2] GABc|"`

5. Voice marker followed by empty line (edge case):
   - Input: `"X:1\nK:C\nV:1\n\nCDEF|"`
   - Expected: `"X:1\nK:C\n[V:1] CDEF|"` (empty line is removed)

6. Voice marker at end of tune (edge case):
   - Input: `"X:1\nK:C\nCDEF|\nV:1"`
   - Expected: `"X:1\nK:C\nCDEF|\n[V:1]"` (no following content to merge with)

Test cases for `voiceInlineToInfoLine`:

1. Single inline voice marker:
   - Input: `"X:1\nK:C\n[V:1] CDEF|"`
   - Expected: `"X:1\nK:C\nV:1\nCDEF|"`

2. Inline marker with parameters:
   - Input: `"X:1\nK:C\n[V:1 clef=bass] CDEF|"`
   - Expected: `"X:1\nK:C\nV:1 clef=bass\nCDEF|"`

3. Inline marker mid-line:
   - Input: `"X:1\nK:C\nCDEF [V:2] GABc|"`
   - Expected: `"X:1\nK:C\nCDEF\nV:2\nGABc|"`

4. Multiple inline markers on same line (nested case):
   - Input: `"X:1\nK:C\n[V:1] CDEF [V:2] GABc|"`
   - Expected: `"X:1\nK:C\nV:1\nCDEF\nV:2\nGABc|"`

5. Multiple inline markers on different lines:
   - Input: `"X:1\nK:C\n[V:1] CDEF|\n[V:2] GABc|"`
   - Expected: `"X:1\nK:C\nV:1\nCDEF|\nV:2\nGABc|"`

6. Inline marker at start of line (no space):
   - Input: `"X:1\nK:C\n[V:1]CDEF|"`
   - Expected: `"X:1\nK:C\nV:1\nCDEF|"`

#### Property-Based Tests

File: `editor/tests/voiceMarkerTransform.pbt.spec.ts`

Properties to test:

1. Roundtrip preservation: For any ABC with voice info lines, applying `voiceInfoLineToInline` then `voiceInlineToInfoLine` produces semantically equivalent ABC (same voice structure, same music content).

2. Voice ID preservation: The transform preserves voice IDs exactly (no modification of identifiers).

3. Parameter preservation: All voice parameters (clef, stem, name, etc.) are preserved through the transform.

4. Music content preservation: Notes, rests, barlines, and other music content are unchanged by the transform.

5. No orphaned markers: After transform, all voice markers are properly attached to their containing structure.

Generator for voice content:
```
const voiceIdGen = fc.stringOf(fc.constantFrom(...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'), { minLength: 1, maxLength: 8 });

const voiceParamGen = fc.constantFrom(
  'clef=treble', 'clef=bass', 'clef=alto',
  'stem=up', 'stem=down', 'stem=auto',
  'name="Voice 1"', 'name="Soprano"'
);

const voiceInfoLineGen = fc.tuple(voiceIdGen, fc.array(voiceParamGen, { maxLength: 3 }))
  .map(([id, params]) => `V:${id}${params.length > 0 ? ' ' + params.join(' ') : ''}`);
```

### Imports to Update

`editor/src/transforms/index.ts`:
- Add export for `voiceInfoLineToInline`
- Add export for `voiceInlineToInfoLine`

`editor/src/index.ts`:
- Add re-export for the new transforms

### Phase 1 To Do

1. Create `editor/src/transforms/voiceMarkerTransform.ts` with helper functions
2. Implement `voiceInfoLineToInline` transform
3. Implement `voiceInlineToInfoLine` transform
4. Create example-based tests in `editor/tests/voiceMarkerTransform.spec.ts`
5. Create property-based tests in `editor/tests/voiceMarkerTransform.pbt.spec.ts`
6. Update exports in `editor/src/transforms/index.ts`
7. Update exports in `editor/src/index.ts`
8. Final verification: build and tests both pass
9. Call the code review agent. Address any feedback.
10. Commit once the build passes and all tests pass.

---

## Phase 2: LSP and Extension Integration

### Files to Modify

`abc-lsp-server/src/transformLookup.ts`:
- Add entries for `voiceInfoLineToInline` and `voiceInlineToInfoLine`

`vscode-extension/src/transformCommands.ts`:
- Add commands `abc.voiceInfoLineToInline` and `abc.voiceInlineToInfoLine`

`vscode-extension/package.json`:
- Add command definitions and keybindings (if desired)

### Implementation Details

#### transformLookup.ts Changes

Location: `abc-lsp-server/src/transformLookup.ts`

Add imports:
```typescript
import {
  // ... existing imports ...
  voiceInfoLineToInline,
  voiceInlineToInfoLine,
} from "editor";
```

Add to TRANSFORM_MAP (around line 31):
```typescript
const TRANSFORM_MAP: Record<string, TransformFn> = {
  // ... existing entries ...
  voiceInfoLineToInline: (sel, ctx) => voiceInfoLineToInline(sel, ctx),
  voiceInlineToInfoLine: (sel, ctx) => voiceInlineToInfoLine(sel, ctx),
};
```

#### server.ts and socketHandler.ts Changes

Add to `TRANSFORM_NODE_TAGS` in both files:
```typescript
const TRANSFORM_NODE_TAGS: Record<string, string[]> = {
  // ... existing entries ...
  voiceInfoLineToInline: [TAGS.Info_line],
  voiceInlineToInfoLine: [TAGS.Inline_field],
};
```

This tells the server which node types to search for when resolving selection ranges to cursors.

#### transformCommands.ts Changes

Location: `vscode-extension/src/transformCommands.ts`

Add to simpleTransforms array (around line 83):
```typescript
const simpleTransforms: Array<[string, string]> = [
  // ... existing entries ...
  ["abc.voiceInfoLineToInline", "voiceInfoLineToInline"],
  ["abc.voiceInlineToInfoLine", "voiceInlineToInfoLine"],
];
```

#### package.json Changes

Location: `vscode-extension/package.json`

Add to `contributes.commands`:
```json
{
  "command": "abc.voiceInfoLineToInline",
  "title": "ABC: Convert Voice Line to Inline",
  "category": "ABC"
},
{
  "command": "abc.voiceInlineToInfoLine",
  "title": "ABC: Convert Inline Voice to Line",
  "category": "ABC"
}
```

### Testing for Phase 2

#### Integration Tests

File: `abc-lsp-server/src/transformIntegration.spec.ts`

Add test cases:

1. Transform lookup resolves both transforms:
```typescript
it("should lookup voiceInfoLineToInline transform", () => {
  const fn = lookupTransform("voiceInfoLineToInline");
  expect(fn).to.not.be.null;
});

it("should lookup voiceInlineToInfoLine transform", () => {
  const fn = lookupTransform("voiceInlineToInfoLine");
  expect(fn).to.not.be.null;
});
```

2. End-to-end transform via LSP request:
```typescript
it("should apply voiceInfoLineToInline via LSP", async () => {
  const abc = "X:1\nK:C\nV:1\nCDEF|";
  const result = await applyTransformRequest("voiceInfoLineToInline", abc, /* selection range */);
  expect(result.text).to.include("[V:1]");
});
```

### Phase 2 To Do

1. Update imports in `abc-lsp-server/src/transformLookup.ts`
2. Add transform entries to TRANSFORM_MAP
3. Add commands to simpleTransforms in `vscode-extension/src/transformCommands.ts`
4. Add command definitions to `vscode-extension/package.json`
5. Add integration tests to `abc-lsp-server/src/transformIntegration.spec.ts`
6. Final verification: build and tests both pass
7. Call the code review agent. Address any feedback.
8. Commit once the build passes and all tests pass.

---

## To Do List

### Phase 1: Core Transform Functions

1. Create `editor/src/transforms/voiceMarkerTransform.ts`:
   - Implement helper functions (`isVoiceInfoLine`, `isVoiceInlineField`, `isEOLorWS`, `extractVoiceContent`, `createInfoLineFromContent`, `createInlineFieldFromContent`, `findPrev`, `findLineStart`, `removeNodeAndTrailingEOL`, `removeNodeAndLeadingWS`)
   - Implement `voiceInfoLineToInline` transform
   - Implement `voiceInlineToInfoLine` transform

2. Create example-based tests in `editor/tests/voiceMarkerTransform.spec.ts`:
   - Test single voice marker conversion (info line to inline)
   - Test voice marker with parameters
   - Test voice marker with quoted name
   - Test multiple voice markers
   - Test edge cases (empty line, end of tune)
   - Test single inline marker conversion
   - Test inline marker mid-line
   - Test multiple inline markers on same line (nested)
   - Test multiple inline markers on different lines
   - Test inline marker at start of line

3. Create property-based tests in `editor/tests/voiceMarkerTransform.pbt.spec.ts`:
   - Test roundtrip preservation
   - Test voice ID preservation
   - Test parameter preservation
   - Test music content preservation

4. Update `editor/src/transforms/index.ts` with exports

5. Update `editor/src/index.ts` with re-exports

6. Final verification: build and tests both pass.

7. Call the code review agent. Address any feedback.

8. Commit once the build passes and all tests pass.

### Phase 2: LSP and Extension Integration

1. Update `abc-lsp-server/src/transformLookup.ts`:
   - Add imports for new transforms
   - Add entries to TRANSFORM_MAP

2. Update `abc-lsp-server/src/server.ts` and `abc-lsp-server/src/socketHandler.ts`:
   - Add entries to TRANSFORM_NODE_TAGS for both transforms

3. Update `vscode-extension/src/transformCommands.ts`:
   - Add commands to simpleTransforms array

4. Update `vscode-extension/package.json`:
   - Add command definitions

5. Add integration tests to `abc-lsp-server/src/transformIntegration.spec.ts`

6. Final verification: build and tests both pass.

7. Call the code review agent. Address any feedback.

8. Commit once the build passes and all tests pass.
