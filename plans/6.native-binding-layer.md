# Phase 1: Native Binding Layer - Implementation Plan

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Directory Structure](#directory-structure)
4. [Implementation Steps](#implementation-steps)
5. [The mscore Binary](#the-mscore-binary)
6. [TypeScript Wrapper](#typescript-wrapper)
7. [Build System](#build-system)
8. [Testing](#testing)
9. [Verification](#verification)

---

## Overview

We implement a native binding layer for MuseSampler using a standalone binary approach. Because the MuseSampler library validates that the calling process is named `mscore`, we build a separate C++ executable that loads the library and communicates with Node.js via JSON over stdin/stdout.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Node.js / TypeScript                      │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              MuseSamplerClient (TypeScript)            │  │
│  │  - spawn('mscore')                                     │  │
│  │  - send JSON commands via stdin                        │  │
│  │  - receive JSON responses via stdout                   │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │ stdin/stdout (JSON)
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    mscore binary (C++)                       │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              MuseSamplerWrapper                        │  │
│  │  - loadLibrary() via dlopen                           │  │
│  │  - getInstruments()                                    │  │
│  │  - createSession()                                     │  │
│  │  - addNoteEvent()                                      │  │
│  │  - process() -> audio buffers                          │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              AudioOutput (miniaudio)                   │  │
│  │  - initialize audio device                             │  │
│  │  - play rendered buffers                               │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │ dlopen
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              libMuseSamplerCoreLib (closed-source)           │
└─────────────────────────────────────────────────────────────┘
```

## Directory Structure

```
abc_parse/
  native/
    CMakeLists.txt              # CMake build configuration
    src/
      main.cpp                  # Entry point, JSON command loop
      musesampler_wrapper.h     # MuseSampler library wrapper header
      musesampler_wrapper.cpp   # Library loading and API calls
      audio_output.h            # Audio output abstraction
      audio_output.cpp          # miniaudio implementation
      json_protocol.h           # JSON command/response types
      json_protocol.cpp         # JSON parsing and serialization
    vendor/
      miniaudio.h               # Single-header audio library (MIT)
      nlohmann/json.hpp         # Single-header JSON library (MIT)
    lib/
      index.ts                  # TypeScript client API
      types.ts                  # TypeScript types for IPC protocol
      client.ts                 # Process spawning and communication
```

## Implementation Steps

### Step 1: Create directory structure and vendor dependencies

Create the `native/` directory with subdirectories. Download vendor headers:
- miniaudio.h from https://github.com/mackron/miniaudio
- nlohmann/json.hpp from https://github.com/nlohmann/json

Files to create:
- `native/CMakeLists.txt`
- `native/src/` directory
- `native/vendor/` directory
- `native/lib/` directory

### Step 2: Implement the MuseSampler wrapper (C++)

Port the loading pattern from MuseScore's `libhandler.h` to a simplified wrapper.

File: `native/src/musesampler_wrapper.h` and `.cpp`

Key functions:
```cpp
class MuseSamplerWrapper {
public:
    bool loadLibrary(const std::string& path);
    std::string getVersion();
    std::vector<InstrumentInfo> getInstruments();

    SessionHandle createSession(double sampleRate, int blockSize, int channels);
    void destroySession(SessionHandle session);

    TrackHandle addTrack(SessionHandle session, int instrumentId);
    void finalizeTrack(SessionHandle session, TrackHandle track);
    void clearTrack(SessionHandle session, TrackHandle track);

    void addNoteEvent(SessionHandle session, TrackHandle track, const NoteEvent& event);
    void addDynamicsEvent(SessionHandle session, TrackHandle track, int64_t location_us, double value);

    void setPosition(SessionHandle session, int64_t samples);
    void setPlaying(SessionHandle session, bool playing);
    bool process(SessionHandle session, float** outputBuffers, int sampleCount);
};
```

### Step 3: Implement audio output (C++)

Use miniaudio for cross-platform audio output.

File: `native/src/audio_output.h` and `.cpp`

```cpp
class AudioOutput {
public:
    bool initialize(int sampleRate, int channels, int blockSize);
    void shutdown();

    // Callback-based: miniaudio calls this to get audio data
    void setDataCallback(std::function<void(float*, int)> callback);

    void start();
    void stop();
};
```

### Step 4: Implement JSON protocol (C++)

Define the IPC protocol for communication with Node.js.

File: `native/src/json_protocol.h` and `.cpp`

Commands (Node.js -> mscore):
```json
{"cmd": "load_library", "path": "/path/to/libMuseSamplerCoreLib.dylib"}
{"cmd": "get_instruments"}
{"cmd": "create_session", "sample_rate": 44100, "block_size": 512, "channels": 2}
{"cmd": "add_track", "session_id": 1, "instrument_id": 123}
{"cmd": "add_note_event", "session_id": 1, "track_id": 1, "event": {...}}
{"cmd": "finalize_track", "session_id": 1, "track_id": 1}
{"cmd": "play", "session_id": 1}
{"cmd": "pause", "session_id": 1}
{"cmd": "seek", "session_id": 1, "position_us": 0}
{"cmd": "stop", "session_id": 1}
{"cmd": "quit"}
```

Responses (mscore -> Node.js):
```json
{"ok": true, "version": "0.104.0"}
{"ok": true, "instruments": [{id: 1, name: "Piano", category: "Keyboard"}, ...]}
{"ok": true, "session_id": 1}
{"ok": true, "track_id": 1}
{"ok": false, "error": "Library not loaded"}
```

### Step 5: Implement main command loop (C++)

File: `native/src/main.cpp`

```cpp
int main() {
    MuseSamplerWrapper wrapper;
    AudioOutput audio;

    std::string line;
    while (std::getline(std::cin, line)) {
        auto cmd = json::parse(line);
        auto response = handleCommand(cmd, wrapper, audio);
        std::cout << response.dump() << std::endl;
    }

    return 0;
}
```

### Step 6: Implement TypeScript client

File: `native/lib/client.ts`

```typescript
export class MuseSamplerClient {
    private process: ChildProcess | null = null;

    async start(): Promise<void>;
    async loadLibrary(path: string): Promise<string>;  // returns version
    async getInstruments(): Promise<InstrumentInfo[]>;
    async createSession(sampleRate?: number): Promise<Session>;
    async quit(): Promise<void>;
}

export class Session {
    async addTrack(instrumentId: number): Promise<Track>;
    async play(): Promise<void>;
    async pause(): Promise<void>;
    async seek(position_us: bigint): Promise<void>;
    async stop(): Promise<void>;
}

export class Track {
    async addNoteEvent(event: NoteEvent): Promise<void>;
    async addDynamicsEvent(location_us: bigint, value: number): Promise<void>;
    async finalize(): Promise<void>;
}
```

### Step 7: CMake build configuration

File: `native/CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.16)
project(mscore_helper)

set(CMAKE_CXX_STANDARD 17)

add_executable(mscore
    src/main.cpp
    src/musesampler_wrapper.cpp
    src/audio_output.cpp
    src/json_protocol.cpp
)

# Platform-specific linking
if(APPLE)
    target_link_libraries(mscore "-framework AudioToolbox" "-framework CoreAudio")
elseif(UNIX)
    target_link_libraries(mscore pthread dl m)
elseif(WIN32)
    target_link_libraries(mscore winmm)
endif()
```

### Step 8: Add npm scripts for building

Update `native/package.json`:
```json
{
  "name": "abc-musesampler-native",
  "scripts": {
    "build:native": "cmake -B build && cmake --build build",
    "build": "npm run build:native && tsc"
  }
}
```

## The mscore Binary

The binary must be named exactly `mscore` because MuseSampler validates the process name. The build produces:
- macOS: `native/build/mscore`
- Linux: `native/build/mscore`
- Windows: `native/build/mscore.exe`

The TypeScript client locates this binary relative to its own path.

## TypeScript Wrapper

The wrapper provides a clean async API that hides the IPC complexity:

```typescript
import { MuseSamplerClient } from './native/lib';

const client = new MuseSamplerClient();
await client.start();
await client.loadLibrary(getMuseSamplerPath());

const instruments = await client.getInstruments();
const session = await client.createSession();
const track = await session.addTrack(instruments[0].id);

for (const event of noteEvents) {
    await track.addNoteEvent(event);
}

await track.finalize();
await session.play();
```

## Build System

We use CMake for the native build because:
1. Cross-platform support (macOS, Linux, Windows)
2. Better handling of platform-specific linking
3. No dependency on Node.js for the native binary

The native build is independent of Node.js. The TypeScript wrapper is built with the standard npm/tsc toolchain.

## Testing

### Unit tests for TypeScript client
- Mock the mscore process with a fake implementation
- Test command serialization and response parsing
- Test error handling

### Integration tests (require MuseHub installed)
- Test library loading
- Test instrument enumeration
- Test session creation and playback

### Manual verification
- Play a simple scale
- Verify audio output

## Verification

To verify the implementation works end-to-end:

1. Build the native binary:
   ```bash
   cd native && cmake -B build && cmake --build build
   ```

2. Test the binary directly:
   ```bash
   echo '{"cmd": "load_library", "path": "..."}' | ./build/mscore
   ```

3. Run the TypeScript integration test:
   ```bash
   npm run test -- --grep "MuseSamplerClient"
   ```

4. Play a test tune:
   ```typescript
   import { playTune } from './native/lib';
   import { parseTune } from './parse';

   const tune = parseTune('X:1\nK:C\nCDEF|');
   await playTune(tune);  // Should hear C-D-E-F
   ```

## Critical Files to Modify/Create

| File | Action | Purpose |
|------|--------|---------|
| `native/CMakeLists.txt` | Create | CMake build config |
| `native/src/main.cpp` | Create | Entry point and command loop |
| `native/src/musesampler_wrapper.h` | Create | Library wrapper header |
| `native/src/musesampler_wrapper.cpp` | Create | Library loading implementation |
| `native/src/audio_output.h` | Create | Audio abstraction header |
| `native/src/audio_output.cpp` | Create | miniaudio implementation |
| `native/src/json_protocol.h` | Create | IPC protocol types |
| `native/src/json_protocol.cpp` | Create | JSON parsing |
| `native/vendor/miniaudio.h` | Create | Vendor library |
| `native/vendor/nlohmann/json.hpp` | Create | Vendor library |
| `native/lib/index.ts` | Create | TypeScript exports |
| `native/lib/types.ts` | Create | TypeScript types |
| `native/lib/client.ts` | Create | Process communication |
| `native/package.json` | Create | Package config |
| `native/tsconfig.json` | Create | TypeScript config |
| `package.json` | Modify | Add native workspace |

## Reference Files

From MuseScore source (`/workspace/musescore-src`):
- `src/framework/musesampler/internal/apitypes.h` - C struct definitions
- `src/framework/musesampler/internal/libhandler.h` - Library loading pattern
