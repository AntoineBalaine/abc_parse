# System Separator Comments

## Table of Contents

1. [Overview](#overview)
2. [Phase 1: Add Formatter Configuration to AST](#phase-1-add-formatter-configuration-to-ast)
3. [Phase 2: Scanner Integration](#phase-2-scanner-integration)
4. [Phase 3: Parser Integration](#phase-3-parser-integration)
5. [Phase 4: Comment Detection Logic](#phase-4-comment-detection-logic)
6. [Phase 5: Comment Insertion in Formatter](#phase-5-comment-insertion-in-formatter)
7. [Phase 6: LSP Custom Command](#phase-6-lsp-custom-command)

---

## Overview

This plan implements a formatter feature that inserts empty comment lines between systems in multi-voice linear tunes when no comment already exists at the system boundary.

### Feature Requirements

- Comment content: Empty comment (`%`) followed by EOL
- Detection rule: A comment is considered present if it appears at the end of a system OR at the start of the next system (either position counts)
- Scope: Linear tunes with multiple systems (where `tune.linear === true` and `tune.tune_body.sequence.length >= 2`). Multiple systems implies multi-voice for linear tunes since system boundaries are detected by voice order reversal.
- Activation methods:
  1. Stylesheet directive: `%%abcls-fmt system-comments` in file header or tune header
  2. LSP custom command: `abcls/insertSystemComments`

### Dependencies

This plan depends on:

1. Plan 58 (linear-directive.md) which added:
   - `linear: boolean` field to `File_structure` and `Tune` AST nodes
   - `linear` and `tuneLinear` fields to `ABCContext`
   - `checkLinearDirective()` function in `parseDirective.ts` that handles `%%linear` directive
   - `HeaderContext` type ("file" | "tune") for directive context tracking

2. Plan 61 (unify-linear-system-detection.md) which added:
   - `buildLinearSystems()` function in `voices2.ts` that detects system boundaries at parse time for linear tunes
   - System boundaries are now correctly provided by the parser for both linear and deferred styles
   - Dynamic voice discovery (voices declared only in the body are tracked during boundary detection)

### Architectural Notes

Because Plan 61 unified system boundary detection, the parser now provides correct `System[]` for both linear and deferred styles. This means:
- We no longer need a separate "system grouping" step in the formatter for ABCL tunes
- We no longer need to track body-declared voices separately (handled by `buildLinearSystems()`)
- The multi-voice check can use `tune.tune_body.sequence.length >= 2` instead of checking header voice count (since multiple systems implies multiple voices for linear tunes)

---

## Phase 1: Add Formatter Configuration to AST

### Rationale

Because the formatter needs to know which formatting options are enabled, we need a configuration structure that can be populated from directives and passed to the formatter. This configuration will live on the AST nodes so it can be set per-file or per-tune.

Note: The `linear` field already exists on `File_structure` and `Tune` (added by Plan 58). We only need to add the `formatterConfig` field.

### Changes

#### 1. `parse/types/Expr2.ts` - Add FormatterConfig type (new, around line 55)

```
type FormatterConfig = {
  systemComments: boolean  // Insert % comments between systems
}

const DEFAULT_FORMATTER_CONFIG: FormatterConfig = {
  systemComments: false
}
```

#### 2. `parse/types/Expr2.ts` - File_structure class (line 178-191)

Add `formatterConfig` field to existing class:

```
class File_structure extends Expr
  file_header: File_header | null
  contents: Array<Tune | Token>
  linear: boolean                                              // Already exists
  formatterConfig: FormatterConfig = DEFAULT_FORMATTER_CONFIG  // NEW

  constructor(id, file_header, tune, linear = false, formatterConfig = DEFAULT_FORMATTER_CONFIG)
    super(id)
    this.file_header = file_header
    this.contents = tune
    this.linear = linear
    this.formatterConfig = formatterConfig
```

#### 3. `parse/types/Expr2.ts` - Tune class (around line 368-381)

Add `formatterConfig` field to existing class:

```
class Tune extends Expr
  tune_header: Tune_header
  tune_body?: Tune_Body
  linear: boolean                                              // Already exists
  formatterConfig: FormatterConfig = DEFAULT_FORMATTER_CONFIG  // NEW

  constructor(id, tune_header, tune_body, linear = false, formatterConfig = DEFAULT_FORMATTER_CONFIG)
    super(id)
    this.tune_header = tune_header
    this.tune_body = tune_body || undefined
    this.linear = linear
    this.formatterConfig = formatterConfig
```

#### 4. `parse/types/Expr2.ts` - Export the type and default

Add to exports:

```
export { FormatterConfig, DEFAULT_FORMATTER_CONFIG }
```

#### 5. `parse/Visitors/CloneVisitor.ts` - Update to preserve formatterConfig

Location: `visitFile_structureExpr()` method

```
visitFile_structureExpr(expr: File_structure): Expr
  // ... existing cloning logic ...
  cloned.formatterConfig = { ...expr.formatterConfig }
  return cloned
```

Location: `visitTuneExpr()` method

```
visitTuneExpr(expr: Tune): Expr
  // ... existing cloning logic ...
  cloned.formatterConfig = { ...expr.formatterConfig }
  return cloned
```

#### 6. `parse/Visitors/VoiceFilterVisitor.ts` - Update to preserve formatterConfig

Location: where `File_structure` is created (if applicable)

```
// Preserve formatterConfig when creating filtered File_structure
```

Location: where `Tune` is created (if applicable)

```
// Preserve formatterConfig when creating filtered Tune
```

### Tests

Location: `parse/tests/formatter-config.spec.ts` (new file)

Example-based tests:
- `DEFAULT_FORMATTER_CONFIG.systemComments === false`
- `File_structure` constructor with default config has `formatterConfig.systemComments === false`
- `Tune` constructor with default config has `formatterConfig.systemComments === false`
- `File_structure` constructor with custom config preserves the config
- `Tune` constructor with custom config preserves the config

Property-based tests:
- For any valid ABC file, all tunes have a non-null `formatterConfig` object

### To do

- Add `FormatterConfig` type definition to `Expr2.ts`
- Add `DEFAULT_FORMATTER_CONFIG` constant to `Expr2.ts`
- Add `formatterConfig` field to `File_structure` class
- Add `formatterConfig` field to `Tune` class
- Update `File_structure` constructor to accept `formatterConfig` parameter
- Update `Tune` constructor to accept `formatterConfig` parameter
- Export `FormatterConfig` and `DEFAULT_FORMATTER_CONFIG`
- Update `CloneVisitor.visitFile_structureExpr()` to preserve `formatterConfig`
- Update `CloneVisitor.visitTuneExpr()` to preserve `formatterConfig`
- Update `VoiceFilterVisitor` to preserve `formatterConfig` when creating `File_structure` and `Tune`
- Create `parse/tests/formatter-config.spec.ts` with example-based tests
- Add test: cloned `File_structure` preserves `formatterConfig`
- Add test: cloned `Tune` preserves `formatterConfig`
- Add property-based test for config presence
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Scanner Integration

### Rationale

Because all new features must start at the scanner level, we need to verify that `%%abcls-fmt system-comments` is tokenized correctly before proceeding to the parser. The scanner already handles stylesheet directives generically, so we expect no code changes - only tests to document the expected behavior.

### Current Scanner Behavior

The scanner handles stylesheet directives as follows:
- `%%` is tokenized as `TT.STYLESHEET_DIRECTIVE`
- The identifier following `%%` is tokenized as `TT.IDENTIFIER`
- Whitespace is tokenized as `TT.WS`
- Subsequent identifiers are tokenized as `TT.IDENTIFIER`
- Line ending is tokenized as `TT.EOL`

### Verification Needed

We need to confirm that `%%abcls-fmt system-comments` produces the expected token sequence.

### Changes

No code changes expected. If the scanner does not produce the expected tokens, we will need to investigate and potentially adjust.

### Tests

Location: `parse/tests/scn_abcls_fmt.spec.ts` (new file)

Example-based tests:

```
describe("Scanner - %%abcls-fmt directive")

  it("tokenizes %%abcls-fmt system-comments")
    input: "%%abcls-fmt system-comments\n"
    expected:
      [0] { type: TT.STYLESHEET_DIRECTIVE, lexeme: "%%" }
      [1] { type: TT.IDENTIFIER, lexeme: "abcls-fmt" }
      [2] { type: TT.WS, lexeme: " " }
      [3] { type: TT.IDENTIFIER, lexeme: "system-comments" }
      [4] { type: TT.EOL, lexeme: "\n" }

  it("tokenizes %%abcls-fmt with no parameter")
    input: "%%abcls-fmt\n"
    expected:
      [0] { type: TT.STYLESHEET_DIRECTIVE, lexeme: "%%" }
      [1] { type: TT.IDENTIFIER, lexeme: "abcls-fmt" }
      [2] { type: TT.EOL, lexeme: "\n" }

  it("tokenizes %%abcls-fmt with multiple spaces before parameter")
    input: "%%abcls-fmt   system-comments\n"
    expected:
      [0] { type: TT.STYLESHEET_DIRECTIVE, lexeme: "%%" }
      [1] { type: TT.IDENTIFIER, lexeme: "abcls-fmt" }
      [2] { type: TT.WS, lexeme: "   " }
      [3] { type: TT.IDENTIFIER, lexeme: "system-comments" }
      [4] { type: TT.EOL, lexeme: "\n" }

  it("tokenizes %%abcls-fmt in file header context")
    input: "%%abcls-fmt system-comments\n\nX:1\n"
    expected (first 5 tokens):
      [0] { type: TT.STYLESHEET_DIRECTIVE, lexeme: "%%" }
      [1] { type: TT.IDENTIFIER, lexeme: "abcls-fmt" }
      [2] { type: TT.WS, lexeme: " " }
      [3] { type: TT.IDENTIFIER, lexeme: "system-comments" }
      [4] { type: TT.EOL, lexeme: "\n" }

  it("tokenizes %%abcls-fmt in tune header context")
    input: "X:1\n%%abcls-fmt system-comments\nK:C\n"
    expected (tokens 3-7, after X:1 line):
      { type: TT.STYLESHEET_DIRECTIVE, lexeme: "%%" }
      { type: TT.IDENTIFIER, lexeme: "abcls-fmt" }
      { type: TT.WS, lexeme: " " }
      { type: TT.IDENTIFIER, lexeme: "system-comments" }
      { type: TT.EOL, lexeme: "\n" }
```

Property-based tests:
- Not applicable at scanner level for this directive (the token sequence is deterministic for fixed input)

### To do

- Create `parse/tests/scn_abcls_fmt.spec.ts`
- Add test: `%%abcls-fmt system-comments` produces expected 5-token sequence
- Add test: `%%abcls-fmt` with no parameter produces expected 3-token sequence
- Add test: `%%abcls-fmt` with multiple spaces produces expected tokens
- Add test: `%%abcls-fmt` in file header context tokenizes correctly
- Add test: `%%abcls-fmt` in tune header context tokenizes correctly
- Run tests and verify scanner behavior matches expectations
- Document any discrepancies found
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: Parser Integration

### Rationale

Because the parser processes tokens into AST nodes, we need to verify that `%%abcls-fmt system-comments` parses into a correct `Directive` AST node. The parser already handles stylesheet directives via `parseDirective()` in `parseDirective.ts`. Following the pattern established by Plan 58's `checkLinearDirective()`, we add a `checkFormatterDirective()` function that is called inside `parseDirective()` when a `headerContext` is provided.

### Current Parser Behavior

Plan 58 established the following pattern in `parseDirective.ts`:
- `parseDirective()` accepts an optional `headerContext?: HeaderContext` parameter
- After creating the `Directive` node, it calls `checkLinearDirective(rv, ctx, headerContext)` if `headerContext` is provided
- `checkLinearDirective()` checks if the directive is `%%linear` and updates `ctx.abcContext.linear` or `ctx.abcContext.tuneLinear` accordingly

We follow this same pattern for `%%abcls-fmt`.

### Changes

#### 1. `parse/parsers/Context.ts` - Add formatterConfig tracking to ABCContext

Location: ABCContext class (around line 31-54), add after `tuneLinear` field

```
formatterConfig: FormatterConfig = DEFAULT_FORMATTER_CONFIG
tuneFormatterConfig: FormatterConfig = DEFAULT_FORMATTER_CONFIG
```

Add import at top of file:
```
import { FormatterConfig, DEFAULT_FORMATTER_CONFIG } from "../types/Expr2"
```

#### 2. `parse/parsers/infoLines/parseDirective.ts` - Add checkFormatterDirective function

Location: after `checkLinearDirective()` function (around line 52)

```
/**
 * Check if a directive is %%abcls-fmt and update the context accordingly.
 * This is called internally by parseDirective when a headerContext is provided.
 *
 * @param directive - The directive to check
 * @param ctx - The parsing context
 * @param headerContext - Whether this is in a "file" header or "tune" header
 */
function checkFormatterDirective(directive: Directive, ctx: ParseCtx, headerContext: HeaderContext): void
  if directive.key.lexeme.toLowerCase() !== "abcls-fmt"
    return

  for value of directive.values
    if value instanceof Token && value.lexeme.toLowerCase() === "system-comments"
      if headerContext === "file"
        ctx.abcContext.formatterConfig = { ...ctx.abcContext.formatterConfig, systemComments: true }
      else
        ctx.abcContext.tuneFormatterConfig = { ...ctx.abcContext.tuneFormatterConfig, systemComments: true }
      return
```

Add import at top of file:
```
import { FormatterConfig, DEFAULT_FORMATTER_CONFIG } from "../../types/Expr2"
```

#### 3. `parse/parsers/infoLines/parseDirective.ts` - Call checkFormatterDirective in parseDirective

Location: inside `parseDirective()`, after the existing `checkLinearDirective()` call (around line 117-118)

```
// Check for %%linear directive and update context before pushing to parent array
if (headerContext) {
  checkLinearDirective(rv, ctx, headerContext);
  checkFormatterDirective(rv, ctx, headerContext);
}
```

Note: We do NOT add this call to `parseTextDirective()` because text directives handle specific keys (`begintext`, `text`, `center`, `header`, `footer`) and `abcls-fmt` is not a text directive.

#### 4. `parse/parsers/parse2.ts` - Initialize tuneFormatterConfig before each tune

Location: in `parse()` before calling `parseTune()`, alongside the existing `tuneLinear` initialization

```
ctx.abcContext.tuneLinear = ctx.abcContext.linear
ctx.abcContext.tuneFormatterConfig = { ...ctx.abcContext.formatterConfig }
```

#### 5. `parse/parsers/parse2.ts` - Pass formatterConfig to constructors

Location: where `Tune` is constructed (around line 213)

```
tune = new Tune(id, tuneHeader, tuneBody, ctx.abcContext.tuneLinear, ctx.abcContext.tuneFormatterConfig)
```

Location: where `File_structure` is constructed (end of `parse()`)

```
fileStructure = new File_structure(id, fileHeader, tunes, ctx.abcContext.linear, ctx.abcContext.formatterConfig)
```

### Tests

Location: `parse/tests/prs_abcls_fmt.spec.ts` (new file)

Example-based tests:

```
describe("Parser - %%abcls-fmt directive")

  it("parses %%abcls-fmt system-comments into Directive node")
    input: "%%abcls-fmt system-comments\n"
    expected:
      directive instanceof Directive
      directive.key.lexeme === "abcls-fmt"
      directive.values.length === 1
      directive.values[0] instanceof Token
      directive.values[0].lexeme === "system-comments"

  it("parses %%abcls-fmt with no parameter into Directive node")
    input: "%%abcls-fmt\n"
    expected:
      directive instanceof Directive
      directive.key.lexeme === "abcls-fmt"
      directive.values.length === 0

  it("sets fileStructure.formatterConfig when directive is in file header")
    input: "%%abcls-fmt system-comments\n\nX:1\nK:C\nCDEF|\n"
    expected:
      fileStructure.formatterConfig.systemComments === true

  it("sets tune.formatterConfig when directive is in tune header")
    input: "X:1\n%%abcls-fmt system-comments\nK:C\nCDEF|\n"
    expected:
      tune.formatterConfig.systemComments === true

  it("tune inherits formatterConfig from file header")
    input: "%%abcls-fmt system-comments\n\nX:1\nK:C\nCDEF|\n"
    expected:
      fileStructure.formatterConfig.systemComments === true
      tune.formatterConfig.systemComments === true

  it("multiple tunes inherit formatterConfig from file header")
    input: "%%abcls-fmt system-comments\n\nX:1\nK:C\nCDEF|\n\nX:2\nK:G\nGABC|\n"
    expected:
      fileStructure.formatterConfig.systemComments === true
      tunes[0].formatterConfig.systemComments === true
      tunes[1].formatterConfig.systemComments === true

  Note: Because `checkFormatterDirective()` only sets `systemComments` to true when the parameter is present, there is no way to disable the feature via tune header directive once enabled at file level. This is intentional - the directive is additive only.

  it("formatterConfig defaults to systemComments false when no directive")
    input: "X:1\nK:C\nCDEF|\n"
    expected:
      fileStructure.formatterConfig.systemComments === false
      tune.formatterConfig.systemComments === false
```

Property-based tests:
- For any file with `%%abcls-fmt system-comments` in file header and no tune-level override, all tunes have `formatterConfig.systemComments === true`

### To do

- Add `formatterConfig` and `tuneFormatterConfig` fields to `ABCContext` in `Context.ts`
- Add import for `FormatterConfig` and `DEFAULT_FORMATTER_CONFIG` in `Context.ts`
- Add `checkFormatterDirective()` function in `parseDirective.ts` (following `checkLinearDirective()` pattern)
- Add import for `FormatterConfig` and `DEFAULT_FORMATTER_CONFIG` in `parseDirective.ts`
- Call `checkFormatterDirective()` in `parseDirective()` after `checkLinearDirective()`
- Initialize `tuneFormatterConfig` from `formatterConfig` before parsing each tune in `parse2.ts`
- Update `Tune` constructor call to pass `tuneFormatterConfig`
- Update `File_structure` constructor call to pass `formatterConfig`
- Create `parse/tests/prs_abcls_fmt.spec.ts`
- Add test: directive parses into correct `Directive` node
- Add test: directive with no parameter parses correctly
- Add test: file header directive sets `fileStructure.formatterConfig`
- Add test: tune header directive sets `tune.formatterConfig`
- Add test: tune inherits file-level config
- Add test: multiple tunes inherit file-level config
- Add test: tune header overrides file header
- Add test: default config when no directive present
- Add property-based test for config inheritance
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 4: Comment Detection Logic

### Rationale

Before we can insert comments between systems, we need a function that detects whether a comment already exists at the boundary between two systems. Because the user specified "either position counts," we check both the end of the previous system and the start of the next system.

### Changes

#### 1. `parse/Visitors/Formatter2.ts` - Add helper function

Location: after the `AbcFormatter` class, before any other helper functions (around line 580)

```
/**
 * Checks whether a comment exists at the boundary between two systems.
 * A comment is considered present if:
 * 1. The last non-EOL/non-WS element of the previous system is a Comment, OR
 * 2. The first non-WS element of the next system is a Comment
 *
 * @param prevSystem - The previous system (array of tune_body_code)
 * @param nextSystem - The next system (array of tune_body_code)
 * @returns true if a comment exists at the boundary
 */
export function hasCommentAtBoundary(prevSystem: System, nextSystem: System): boolean
  // Check end of previous system (skip trailing EOL and WS tokens)
  for i = prevSystem.length - 1; i >= 0; i--
    element = prevSystem[i]
    if isToken(element)
      if element.type === TT.EOL || element.type === TT.WS
        continue
      break
    if element instanceof Comment
      return true
    break

  // Check start of next system (skip leading WS tokens)
  for i = 0; i < nextSystem.length; i++
    element = nextSystem[i]
    if isToken(element) && element.type === TT.WS
      continue
    if element instanceof Comment
      return true
    break

  return false
```

#### 2. `parse/Visitors/Formatter2.ts` - Add imports

Location: top of file, add to existing imports from `../types/Expr2`

```
import { Comment, System } from "../types/Expr2"
```

### Tests

Location: `parse/tests/fmt2_hasCommentAtBoundary.spec.ts` (new file)

Example-based tests:

```
describe("hasCommentAtBoundary")

  it("returns true when previous system ends with Comment")
    prevSystem: [Note(...), Comment("%test")]
    nextSystem: [Note(...)]
    expected: true

  it("returns true when previous system ends with Comment followed by EOL")
    prevSystem: [Note(...), Comment("%test"), Token(EOL, "\n")]
    nextSystem: [Note(...)]
    expected: true

  it("returns true when previous system ends with Comment followed by WS and EOL")
    prevSystem: [Note(...), Comment("%test"), Token(WS, " "), Token(EOL, "\n")]
    nextSystem: [Note(...)]
    expected: true

  it("returns true when next system starts with Comment")
    prevSystem: [Note(...), Token(EOL, "\n")]
    nextSystem: [Comment("%test"), Note(...)]
    expected: true

  it("returns true when next system starts with WS then Comment")
    prevSystem: [Note(...), Token(EOL, "\n")]
    nextSystem: [Token(WS, " "), Comment("%test"), Note(...)]
    expected: true

  it("returns false when neither system has Comment at boundary")
    prevSystem: [Note(...), Token(EOL, "\n")]
    nextSystem: [Note(...)]
    expected: false

  it("returns false when Comment exists in middle of previous system")
    prevSystem: [Comment("%test"), Note(...), Token(EOL, "\n")]
    nextSystem: [Note(...)]
    expected: false

  it("returns false when Comment exists in middle of next system")
    prevSystem: [Note(...), Token(EOL, "\n")]
    nextSystem: [Note(...), Comment("%test"), Note(...)]
    expected: false

  it("returns true when both systems have Comments at boundary")
    prevSystem: [Note(...), Comment("%end"), Token(EOL, "\n")]
    nextSystem: [Comment("%start"), Note(...)]
    expected: true

  it("handles empty previous system")
    prevSystem: []
    nextSystem: [Comment("%test"), Note(...)]
    expected: true

  it("handles empty next system")
    prevSystem: [Note(...), Comment("%test"), Token(EOL, "\n")]
    nextSystem: []
    expected: true

  it("returns false when both systems are empty")
    prevSystem: []
    nextSystem: []
    expected: false
```

Property-based tests:

```
it("property: returns true when prevSystem ends with Comment before trailing EOL/WS")
  generate: prevSystem ending with [Comment, optional WS*, optional EOL]
  generate: nextSystem without Comment at start
  expected: hasCommentAtBoundary returns true

it("property: returns true when nextSystem starts with Comment after leading WS")
  generate: prevSystem without Comment at end
  generate: nextSystem starting with [optional WS*, Comment]
  expected: hasCommentAtBoundary returns true

it("property: returns false when neither boundary has Comment")
  generate: prevSystem ending with non-Comment element (Note, Barline, etc.)
  generate: nextSystem starting with non-Comment element
  expected: hasCommentAtBoundary returns false
```

### To do

- Add `Comment` and `System` to imports in `Formatter2.ts` (verify what is already imported)
- Implement `hasCommentAtBoundary()` function in `Formatter2.ts`
- Export `hasCommentAtBoundary` for testing
- Create `parse/tests/fmt2_hasCommentAtBoundary.spec.ts`
- Add test: previous system ends with Comment
- Add test: previous system ends with Comment followed by EOL
- Add test: previous system ends with Comment followed by WS and EOL
- Add test: next system starts with Comment
- Add test: next system starts with WS then Comment
- Add test: neither system has Comment at boundary
- Add test: Comment in middle of previous system (not at boundary)
- Add test: Comment in middle of next system (not at boundary)
- Add test: both systems have Comments at boundary
- Add test: empty previous system
- Add test: empty next system
- Add test: both systems empty
- Add property-based tests for boundary detection
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 5: Comment Insertion in Formatter

### Rationale

Now that we have comment detection (Phase 4), we can implement the actual comment insertion. Because Plan 61 unified system boundary detection, the parser now provides correct system boundaries for both linear and deferred styles - we no longer need a separate system grouping step. This phase adds a step in `format()` that inserts empty comment lines between systems when `formatterConfig.systemComments === true` and no comment already exists at the boundary.

### Changes

#### 1. `parse/Visitors/Formatter2.ts` - Add insertSystemComments function

Location: after `hasCommentAtBoundary()` function

```
/**
 * Inserts empty comment lines between systems where no comment already exists.
 * Modifies tune_body.sequence in place.
 *
 * Only operates when:
 * - formatterConfig.systemComments === true
 * - tune is linear (linear === true)
 * - tune has multiple systems (sequence.length >= 2, which implies multi-voice for linear tunes)
 *
 * @param tune - The tune to process
 * @param ctx - The ABC context for generating node IDs
 */
export function insertSystemComments(tune: Tune, ctx: ABCContext): void
  if !tune.formatterConfig.systemComments
    return

  if !tune.linear
    return

  tune_body = tune.tune_body
  if !tune_body || tune_body.sequence.length < 2
    return

  // Process from end to start so insertions don't affect indices
  for i = tune_body.sequence.length - 1; i > 0; i--
    prevSystem = tune_body.sequence[i - 1]
    currentSystem = tune_body.sequence[i]

    if !hasCommentAtBoundary(prevSystem, currentSystem)
      // Create comment token and expression
      commentToken = new Token(TT.COMMENT, "%", ctx.generateId())
      eolToken = new Token(TT.EOL, "\n", ctx.generateId())
      commentExpr = new Comment(ctx.generateId(), commentToken)

      // Insert at the beginning of the current system
      currentSystem.unshift(commentExpr, eolToken)
```

#### 2. `parse/Visitors/Formatter2.ts` - Call insertSystemComments in format()

Location: `format()` method, before rules resolution

```
format(ast: Tune): string
  this.no_format = false

  // 1. Insert system comments if enabled (system boundaries provided by parser per Plan 61)
  insertSystemComments(ast, this.ctx)

  // 2. Rules resolution phase
  withRules = resolveRules(ast, this.ctx)

  // 3. Align multi-voices tunes
  alignedTune = alignTune(withRules, this.ctx, this)

  // 4. Print using visitor
  return this.stringify(alignedTune, false)
```

#### 3. `parse/Visitors/Formatter2.ts` - Add imports

Location: top of file

```
import { Comment, Tune, Token, TT } from "../types/Expr2"
```

Verify `Token` and `TT` are imported from the correct location (may be from `../parsers/scan2`).

### Tests

Location: `parse/tests/fmt2_insertSystemComments.spec.ts` (new file)

Example-based tests:

```
describe("insertSystemComments")

  it("inserts comment between systems when systemComments is true and tune is linear")
    input tune:
      linear = true
      formatterConfig.systemComments = true
      tune_body.sequence = [
        [V:1, CDEF|, V:2, GABC|, EOL],
        [V:1, EFGA|, V:2, BCDE|, EOL]
      ]

    after insertSystemComments():
      tune_body.sequence[1] starts with [Comment("%"), EOL, V:1, ...]

  it("does not insert comment when systemComments is false")
    input tune:
      linear = true
      formatterConfig.systemComments = false
      two systems

    after insertSystemComments():
      tune_body.sequence unchanged

  it("does not insert comment for non-linear (deferred) tune")
    input tune:
      linear = false
      formatterConfig.systemComments = true
      two systems

    after insertSystemComments():
      tune_body.sequence unchanged

  it("does not insert comment when only one system")
    input tune:
      linear = true
      formatterConfig.systemComments = true
      one system

    after insertSystemComments():
      tune_body.sequence unchanged

  it("does not insert duplicate when comment already at end of previous system")
    input tune:
      linear = true
      formatterConfig.systemComments = true
      tune_body.sequence = [
        [V:1, CDEF|, V:2, GABC|, Comment("%existing"), EOL],
        [V:1, EFGA|, V:2, BCDE|, EOL]
      ]

    after insertSystemComments():
      tune_body.sequence[1] does NOT start with new Comment

  it("does not insert duplicate when comment already at start of next system")
    input tune:
      linear = true
      formatterConfig.systemComments = true
      tune_body.sequence = [
        [V:1, CDEF|, V:2, GABC|, EOL],
        [Comment("%existing"), EOL, V:1, EFGA|, V:2, BCDE|, EOL]
      ]

    after insertSystemComments():
      tune_body.sequence[1] still starts with single Comment("%existing")

  it("inserts comments between all system boundaries that need them")
    input tune:
      linear = true
      formatterConfig.systemComments = true
      three systems, no existing comments

    after insertSystemComments():
      system[1] starts with Comment
      system[2] starts with Comment

  it("inserted comment is empty percent sign")
    input tune with systemComments = true

    after insertSystemComments():
      inserted Comment token has lexeme === "%"

describe("format() with systemComments")

  it("formatted output contains comment line between systems")
    input:
      X:1
      %%abcls-fmt system-comments
      %%linear true
      V:1
      V:2
      K:C
      V:1
      CDEF|
      V:2
      GABC|
      V:1
      EFGA|
      V:2
      BCDE|

    formatted output contains:
      GABC|
      %
      V:1

  it("formatted output does not duplicate existing comments")
    input with existing % comment between systems
    formatted output has exactly one comment at boundary
```

Property-based tests:

```
it("property: after insertion, every system boundary has exactly one comment")
  generate: linear tune with systemComments = true
  expected: for each pair of adjacent systems, hasCommentAtBoundary returns true

it("property: insertion preserves all original content")
  generate: linear tune with systemComments = true
  expected: all original elements still present (only Comment/EOL added)

it("property: number of inserted comments equals boundaries without comments")
  generate: linear tune with some existing comments at boundaries
  count boundaries without comments before insertion
  expected: number of new Comments equals that count
```

### To do

- Implement `insertSystemComments()` function in `Formatter2.ts`
- Add call to `insertSystemComments()` in `format()` method
- Verify all necessary imports are present
- Export `insertSystemComments` for testing
- Create `parse/tests/fmt2_insertSystemComments.spec.ts`
- Add test: inserts comment between systems when enabled and tune is linear
- Add test: does not insert when systemComments is false
- Add test: does not insert for non-linear (deferred) tune
- Add test: does not insert when only one system
- Add test: does not duplicate when comment at end of previous system
- Add test: does not duplicate when comment at start of next system
- Add test: inserts between all boundaries that need them
- Add test: inserted comment is empty percent sign
- Add test: formatted output contains comment line
- Add test: formatted output does not duplicate existing comments
- Add property-based tests
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 6: LSP Custom Command

### Rationale

In addition to the stylesheet directive `%%abcls-fmt system-comments`, we want to provide an LSP custom command that allows users to trigger comment insertion from their editor without modifying the source file's directives. This command will format the document with `systemComments: true` regardless of what the file's `formatterConfig` says. Because the feature only applies to linear tunes (per the requirements), the command will only have an effect on ABCL-format files.

### Changes

#### 1. `abc-lsp-server/src/AbcLspServer.ts` - Add command handler

Location: after `onFormat()` method (around line 161)

```
/**
 * Handler for insertSystemComments command.
 *
 * Formats the document with systemComments enabled, inserting empty comment
 * lines between systems in multi-voice tunes.
 *
 * @param uri - The document URI
 * @returns Array of TextEdits to apply, or empty array if no changes needed
 */
onInsertSystemComments(uri: string): HandlerResult<TextEdit[], void>
  abcDocument = this.abcDocuments.get(uri)
  if !abcDocument || !abcDocument.tokens
    return []

  if !hasCtx(abcDocument)
    return []

  if abcDocument.ctx.errorReporter.hasErrors()
    return []

  // Clone the AST to avoid modifying the cached version
  // Then override formatterConfig for each tune
  ast = abcDocument.AST!
  for content of ast.contents
    if content instanceof Tune
      content.formatterConfig = { ...content.formatterConfig, systemComments: true }

  formatted = new AbcFormatter(abcDocument.ctx).formatFile(ast)
  edit = TextEdit.replace(
    Range.create(Position.create(0, 0), Position.create(Number.MAX_VALUE, Number.MAX_VALUE)),
    formatted
  )
  return [edit]
```

#### 2. `abc-lsp-server/src/server.ts` - Register command

Location: in the `connection.onInitialize` handler, add to capabilities

```
executeCommandProvider: {
  commands: ["abcls.insertSystemComments"]
}
```

Location: add command handler registration

```
connection.onExecuteCommand((params) => {
  if params.command === "abcls.insertSystemComments"
    uri = params.arguments?.[0] as string
    if uri
      return server.onInsertSystemComments(uri)
  return null
})
```

#### 3. `abc-lsp-server/src/AbcLspServer.ts` - Add imports

Location: top of file

```
import { Tune } from "abc-parser"
```

Verify `TextEdit`, `Range`, `Position` are already imported from `vscode-languageserver`.

### Tests

Location: `abc-lsp-server/tests/insertSystemComments.spec.ts` (new file)

Example-based tests:

```
describe("onInsertSystemComments command")

  it("returns text edits that insert comments between systems for linear tune")
    setup: document with linear multi-voice tune, no systemComments directive
    input: uri of document

    result: TextEdit array with single edit
    edit.newText contains % comment lines between systems

  it("returns empty array for document with errors")
    setup: document with parse errors
    input: uri of document

    result: []

  it("returns empty array for non-existent document")
    input: uri that does not exist in abcDocuments

    result: []

  it("returns unchanged edit for non-linear (deferred) tune")
    setup: document with deferred-style multi-voice tune
    input: uri of document

    result: TextEdit with formatting but no comment insertions (feature only applies to linear tunes)

  it("does not duplicate existing comments at boundaries")
    setup: document with existing % comments between systems
    input: uri of document

    result: TextEdit with no additional comments inserted

  it("processes multiple linear tunes in file")
    setup: document with two linear multi-voice tunes
    input: uri of document

    result: TextEdit with comments inserted in both tunes
```

Property-based tests:

```
it("property: command result is valid TextEdit array")
  generate: valid ABC document
  expected: result is array (possibly empty) of valid TextEdit objects

it("property: applying edit produces parseable ABC")
  generate: valid ABC document
  apply returned TextEdit
  expected: resulting text parses without errors
```

### To do

- Add `onInsertSystemComments()` method to `AbcLspServer.ts`
- Add `executeCommandProvider` to server capabilities in `server.ts`
- Register `connection.onExecuteCommand` handler in `server.ts`
- Import `Tune` from `abc-parser` in `AbcLspServer.ts`
- Create `abc-lsp-server/tests/insertSystemComments.spec.ts`
- Add test: returns text edits that insert comments for linear tune
- Add test: returns empty array for document with errors
- Add test: returns empty array for non-existent document
- Add test: returns unchanged edit for non-linear (deferred) tune
- Add test: does not duplicate existing comments
- Add test: processes multiple linear tunes in file
- Add property-based tests
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
