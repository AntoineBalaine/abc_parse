# Plan 62: Outer System Selector

## Table of Contents

1. [Overview](#overview)
2. [Phase 1: Preserve System Boundaries in CSTree](#phase-1-preserve-system-boundaries-in-cstree)
3. [Phase 2: Editor Module - systemSelector.ts](#phase-2-editor-module---systemselectorts)
4. [Phase 3: LSP Server and VS Code Extension Integration](#phase-3-lsp-server-and-vs-code-extension-integration)
5. [Phase 4: Kakoune Plugin Integration](#phase-4-kakoune-plugin-integration)

---

## Overview

This plan implements an "outer system" selector for the editor module. The selector expands a selection to cover the entire system(s) it touches:

- If the selection is within a single system, it expands to cover the whole system
- If the selection spans multiple systems, it splits into multiple cursors (one per system)
- Cursors that end up in the same system are merged
- Preceding info lines that apply to a system are included (but not comments)
- The selector works across all tunes in the selection

---

## Phase 1: Preserve System Boundaries in CSTree

### Overview

The CSTree currently flattens `Tune_Body.sequence` (which is `System[]`) into a single child list, losing system boundary information. We will add a `System` tag so that each system is represented as a distinct node in the CSTree.

### 1.1 Update `editor/src/csTree/types.ts`

Add `System` to the `TAGS` object:

```
TAGS = {
  ...existing tags...
  System: "System",
}
```

### 1.2 Update `editor/src/csTree/fromAst.ts`

The `fromAst` function currently uses a visitor pattern that returns children arrays. We need to pass an `ABCContext` to generate proper IDs for System nodes.

Update the function signature:

```
export function fromAst(node: Expr | Token, ctx: ABCContext): CSNode
```

When processing a `Tune_Body` node, instead of flattening `expr.sequence`, iterate over each `System` in the sequence and create a wrapper CSNode with tag `TAGS.System`:

```
if node is Tune_Body:
  tuneBodyNode = createCSNode(TAGS.Tune_Body, node.id, { type: "empty" })
  for each system in node.sequence:
    systemNode = createCSNode(TAGS.System, ctx.generateId(), { type: "empty" })
    for each element in system:
      childNode = fromAst(element, ctx)
      append childNode as sibling chain under systemNode
    append systemNode as sibling chain under tuneBodyNode
  return tuneBodyNode
```

This requires modifying `visitTuneBodyExpr` to not flatten, and handling the special case in the main conversion logic.

All callers of `fromAst` must be updated to pass an `ABCContext`.

### 1.3 Update `editor/src/csTree/toAst.ts`

System nodes exist only in the CSTree, not in the AST. We do not add a generic `TAGS.System` case to the `buildExpr` switch. Instead, we handle System nodes specially in `buildTuneBody`.

The `toAstNode` function calls `collectChildren` which recursively converts children via `buildExpr`. We need to intercept this for Tune_Body nodes so that System children are not passed through `buildExpr` directly.

Modify the Tune_Body handling:

1. In `toAstNode` or a helper, detect when processing a Tune_Body node
2. For each System child of Tune_Body:
   - Collect the System node's own children
   - Convert each of those children via `buildExpr`
   - Group them into a `System` array (which is `tune_body_code[]`)
3. Pass the array of System arrays to `buildTuneBody`

```
// Pseudocode for Tune_Body special handling:
if node.tag === TAGS.Tune_Body:
  systems = []
  systemChild = node.firstChild
  while systemChild is not null:
    if systemChild.tag === TAGS.System:
      systemElements = []
      element = systemChild.firstChild
      while element is not null:
        systemElements.push(buildExpr(element))
        element = element.nextSibling
      systems.push(systemElements)
    systemChild = systemChild.nextSibling
  return new Tune_Body(node.id, systems)
```

This ensures that the `System[]` structure is reconstructed correctly without needing a generic System handler.

### 1.4 Tests

Location: `editor/tests/csTree/systemBoundaries.test.ts`

Example-based tests:

1. Single system tune - CSTree has one System node under Tune_Body
2. Multi-system tune (deferred style) - CSTree has multiple System nodes
3. Multi-system tune (linear style with `ctx.tuneLinear = true`) - CSTree has multiple System nodes matching parser boundaries
4. Round-trip preservation - parse ABC, convert to CSTree, convert back to AST, verify `tune_body.sequence.length` matches original
5. Empty system handling - systems with only whitespace/EOL tokens

Property-based tests:

1. For any valid ABC input, the number of System nodes in CSTree equals `tune_body.sequence.length`
2. Round-trip invariant: for any ABC, converting to CSTree and back preserves the number of systems
3. All elements within a System node in CSTree correspond to elements within the same system in the original AST

### To Do

- Add `System: "System"` to `TAGS` in `types.ts`
- Update `fromAst` signature to accept `ABCContext`
- Modify `fromAst` to create System wrapper nodes for each system in `Tune_Body.sequence`
- Update all callers of `fromAst` to pass `ABCContext`
- Modify `toAst` to handle System nodes and reconstruct `System[]` in `buildTuneBody`
- Create `editor/tests/csTree/systemBoundaries.test.ts` with example-based and property-based tests
- Run `npm run test` to verify all tests pass
- Run `npm run build` to verify compilation
- Call the code review agent and address any feedback
- Commit once the build passes and all tests pass

---

## Phase 2: Editor Module - systemSelector.ts

### Overview

Create `editor/src/selectors/systemSelector.ts` with the `selectSystem` function that expands selections to cover entire systems.

### 2.1 Algorithm

```
selectSystem(input: Selection): Selection

1. Collect all input cursor IDs into a scopeIds Set using collectCursorIds()

2. Find all Tune_Body nodes using findByTag()

3. For each Tune_Body:
   - Iterate its direct children (which are System nodes after Phase 1)
   - For each System child:
     - If hasDescendantInScope(system, scopeIds):
       - Mark this System as matched
       - Find preceding Info_line siblings (excluding Comments)
       - Collect all IDs from the System and its preceding Info_lines into a cursor

4. Build output:
   - One cursor per matched System
   - If no Systems matched, return input unchanged

Return { root: input.root, cursors: outputCursors }
```

### 2.2 Helper Functions

`findPrecedingInfoLines(systemNode: CSNode, parentNode: CSNode): CSNode[]`

Because CSNode has no `previousSibling` pointer, we first build an array of siblings preceding `systemNode`, then walk backwards through it:

```
findPrecedingInfoLines(systemNode, parentNode):
  // Build array of siblings before systemNode
  siblings = []
  current = parentNode.firstChild
  while current != systemNode and current != null:
    siblings.push(current)
    current = current.nextSibling

  // Walk backwards, collecting Info_lines
  infoLines = []
  for i from siblings.length - 1 down to 0:
    node = siblings[i]
    if node.tag == TAGS.Comment:
      continue  // skip comments but keep walking
    if node.tag == TAGS.Info_line:
      infoLines.unshift(node)  // prepend to maintain document order
    else if node.tag == TAGS.System:
      break  // hit another system, stop
    else:
      break  // hit non-info-line/non-comment, stop
  return infoLines
```

### 2.3 Imports and Reuse

From `scopeUtils.ts`:
- `collectCursorIds(cursors: Cursor[]): Set<number>`
- `hasDescendantInScope(node: CSNode, scopeIds: Set<number>): boolean`
- `collectDescendantIds(node: CSNode, result: Set<number>): void` - collects node ID and all descendant IDs

From `treeWalk.ts`:
- `findByTag(root: CSNode, tag: string): CSNode[]`

### 2.4 Edge Cases

- Selection entirely outside any System (e.g., in tune header): return input unchanged
- Selection spanning multiple tunes: each tune's systems are handled independently
- Empty input cursors: return input unchanged
- Single cursor containing IDs from multiple systems: produces separate output cursors (one per system)
- Adjacent systems with no info lines between them: each system gets its own cursor with no preceding info lines
- Tune with no Tune_Body (header-only tune): no systems to select, returns input unchanged

### 2.5 File Structure

```typescript
// editor/src/selectors/systemSelector.ts

import { CSNode, TAGS } from "../csTree/types";
import { Selection, Cursor } from "../selection";
import { findByTag } from "./treeWalk";
import { collectCursorIds, hasDescendantInScope, collectDescendantIds } from "./scopeUtils";

function findPrecedingInfoLines(systemNode: CSNode, parentNode: CSNode): CSNode[] { ... }

export function selectSystem(input: Selection): Selection { ... }
```

### 2.6 Update `editor/src/index.ts`

Add export:
```typescript
export { selectSystem } from "./selectors/systemSelector";
```

### 2.7 Tests

Location: `editor/tests/systemSelector.test.ts`

Example-based tests:

1. Single element selected within a system - expands to entire system
2. Multiple elements selected within same system - expands to entire system (one cursor)
3. Selection spanning two systems - produces two cursors
4. Selection spanning three systems - produces three cursors
5. Two separate cursors in same system - merged into one cursor
6. Two separate cursors in different systems - remain as two cursors
7. Selection in tune header (outside any system) - returns input unchanged
8. Multi-tune file with selection in both tunes - expands systems in both tunes
9. Preceding info lines included - V: and other info lines before system are included
10. Comments not included - comments preceding system are excluded
11. Info lines between systems - only includes info lines that directly precede the selected system

Property-based tests:

1. Output cursors never overlap (no ID appears in multiple cursors)
2. Every ID in output belongs to a System node or a preceding Info_line
3. For any input with selection inside a System, output covers exactly one complete System plus its preceding info lines per cursor
4. Idempotence: `selectSystem(selectSystem(input))` equals `selectSystem(input)`

### To Do

- Create `editor/src/selectors/systemSelector.ts` with helper functions and main export
- Update `editor/src/index.ts` to export `selectSystem`
- Create `editor/tests/systemSelector.test.ts` with example-based and property-based tests
- Run `npm run test` to verify all tests pass
- Run `npm run build` to verify compilation
- Call the code review agent and address any feedback
- Commit once the build passes and all tests pass

---

## Phase 3: LSP Server and VS Code Extension Integration

### Overview

Register `selectSystem` in the LSP server's selector lookup and add a VS Code command for invoking it.

### 3.1 Update `abc-lsp-server/src/selectorLookup.ts`

Add import:
```typescript
import {
  // ... existing imports ...
  selectSystem,
} from "editor";
```

Add entry to `SELECTOR_MAP`:
```typescript
selectSystem: (sel) => selectSystem(sel),
```

### 3.2 Update `vscode-extension/src/selectorCommands.ts`

Since `selectSystem` takes no arguments, add it to the existing `selectorCommands` array:

```typescript
const selectorCommands: Array<[string, string]> = [
  // ... existing entries ...
  ["abc.selectSystem", "selectSystem"],
];
```

### 3.3 Update `vscode-extension/package.json`

Add to `contributes.commands` array:
```json
{
  "command": "abc.selectSystem",
  "title": "ABC: Select System"
}
```

### 3.4 Tests

Location: `abc-lsp-server/src/selectorIntegration.spec.ts`

Add integration tests:

1. Apply selectSystem to a single-system tune - returns full system range
2. Apply selectSystem to a multi-system tune with selection in one system - returns that system's range
3. Apply selectSystem to a multi-system tune with selection spanning systems - returns multiple ranges
4. Apply selectSystem with scoped input ranges - respects scope and expands within it

### To Do

- Update `abc-lsp-server/src/selectorLookup.ts` to import and register `selectSystem`
- Update `vscode-extension/src/selectorCommands.ts` to add `abc.selectSystem` command
- Update `vscode-extension/package.json` to register the command
- Add integration tests to `abc-lsp-server/src/selectorIntegration.spec.ts`
- Run `npm run test` to verify all tests pass
- Run `npm run build` to verify compilation
- Call the code review agent and address any feedback
- Commit once the build passes and all tests pass

---

## Phase 4: Kakoune Plugin Integration

### Overview

Add the `abc-select-system` command to the kakoune plugin.

### 4.1 Update `abc-kak/rc/abc-selectors.kak`

Add to the Structure Selectors section (after `abc-select-measures`):

```kak
define-command abc-select-system \
    -docstring "Expand selection to cover entire system(s)" %{
    abc-select-impl selectSystem
}
```

### 4.2 Tests

Manual testing with a real kakoune server session:

1. Build the ABC LSP server:
   ```bash
   cd /path/to/abc_parse
   npm run build
   ```

2. Ensure kak-lsp is configured with the ABC LSP server in `~/.config/kak-lsp/kak-lsp.toml`:
   ```toml
   [language_server.abc-lsp]
   filetypes = ["abc"]
   roots = [".git"]
   command = "node"
   args = ["/path/to/abc_parse/abc-lsp-server/out/server.js", "--stdio", "--socket=auto"]
   ```

3. Start a kakoune server session:
   ```bash
   kak -d -s abc-test
   ```

4. Connect a client to the session:
   ```bash
   kak -c abc-test /path/to/test.abc
   ```

5. Wait for the LSP to connect (the `--socket=auto` flag creates the Unix socket for selector commands).

6. Run test cases:
   - Place cursor inside a system, run `:abc-select-system` - selection expands to entire system
   - Select across two systems, run `:abc-select-system` - get two separate selections
   - Verify preceding info lines are included in selection

7. Kill the server session when done:
   ```bash
   kak -c abc-test -e "kill"
   ```

### To Do

- Update `abc-kak/rc/abc-selectors.kak` to add `abc-select-system` command
- Start kakoune server session (`kak -d -s abc-test`) and connect client for manual testing
- Manual testing by interacting with the server through kakoune client
- Run `npm run test` to verify no regressions
- Run `npm run build` to verify compilation
- Call the code review agent and address any feedback
- Commit once the build passes and all tests pass
