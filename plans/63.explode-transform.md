# Explode Transform

## Table of Contents

1. [Overview](#overview)
2. [Phase 1: Core explode function](#phase-1-core-explode-function)
3. [Phase 2: Handling edge cases](#phase-2-handling-edge-cases)
4. [Phase 3: Preset commands and integration](#phase-3-preset-commands-and-integration)
5. [Phase 4: LSP server and client integration](#phase-4-lsp-server-and-client-integration)

---

## Overview

The explode transform takes a melody line containing chords and breaks it into separate voice lines, where each line contains only the notes belonging to that voice part. The original line is preserved, and new lines are inserted after it.

Example input: `[ceg]abc [dfa]bcd`

Example output with partCount=3:
```
[ceg]abc [dfa]bcd     <- original (untouched)
gabc abcd             <- part 0 (top notes + melody)
ezzz fzzz             <- part 1
czzz dzzz             <- part 2
```

Key design decisions:
- Crude version only: no voice markers, explosion produces unnamed lines
- Slurs are left in all parts (orphaned slurs are acceptable)
- Original line is untouched; we work off copies
- Part 0 keeps standalone notes; parts 1+ convert them to rests
- Chords with fewer notes than partCount produce rests for the missing parts

---

## Phase 1: Core explode function

### Overview

Implement `explode(selection: Selection, partCount: number, ctx: ABCContext): Selection` that creates `partCount` copies of the selected line(s), where each copy retains only the notes belonging to that voice part.

### Function signature

```typescript
// File: editor/src/transforms/explode.ts

import { Selection } from "../selection";
import { ABCContext } from "abc-parser";

export function explode(
  selection: Selection,
  partCount: number,
  ctx: ABCContext
): Selection
```

### Algorithm

```
1. find all Tune_Body children that contain selected nodes
2. group these children by source line number
3. sort line numbers in descending order (to insert from end to start)
4. for each source line:
    for partIndex from partCount-1 down to 0:
        - clone all elements on this line using structuredClone
        - reassign IDs to cloned elements
        - walk the cloned elements:
            if Chord:
                call filterChordToPart(chord, partIndex)
                if chord now has 1 note, call unwrapSingle on it
            if Note (standalone):
                if partIndex > 0, call noteToRest
            if Beam:
                recurse into children with same logic
        - insert cloned line after the original line's last element
```

### Functions to create

1. `explode(selection, partCount, ctx)` - main entry point

2. `filterChordToPart(chordNode: CSNode, partIndex: number, ctx: ABCContext): void`
   - Collects all Note children from the chord
   - Computes `noteIndex = (noteCount - 1) - partIndex`
   - If `noteIndex < 0`: converts entire chord to rest via `chordToRest`
   - Otherwise: removes all notes except the one at `noteIndex`

3. `walkAndFilter(node: CSNode, partIndex: number, ctx: ABCContext): void`
   - Walks sibling chain starting from `node`
   - For each element, applies the filtering logic
   - Recurses into Beam children

### Functions to reuse

From `unwrapSingle.ts`:
- `unwrapSingle(selection)` - unwraps single-note chords

From `toRest.ts`:
- `noteToRest(csNode, ctx)` - converts a note to rest
- `chordToRest(csNode, ctx)` - converts a chord to rest

From `insertVoiceLine.ts` (to be extracted to shared utility):
- `groupElementsBySourceLine(tuneBody): Map<number, CSNode[]>`
- `getSourceLineNumber(node: CSNode): number`
- `reassignIds(node: CSNode, ctx: ABCContext): void`
- `findTuneBody(root: CSNode): CSNode | null`

From `chordSelectors.ts`:
- Pattern from `collectNoteChildren` for gathering notes from a chord

### Example walkthrough

Input: `[ceg]ab [df]` with partCount=2

Part 0 (partIndex=0):
- `[ceg]`: noteCount=3, noteIndex=(3-1)-0=2, keep note[2] (g), unwrap to `g`
- `a`: partIndex=0, keep
- `b`: keep
- `[df]`: noteCount=2, noteIndex=(2-1)-0=1, keep note[1] (f), unwrap to `f`
- Result: `gab f`

Part 1 (partIndex=1):
- `[ceg]`: noteIndex=(3-1)-1=1, keep note[1] (e), unwrap to `e`
- `a`: partIndex>0, convert to rest as `z`
- `b`: convert to rest as `z`
- `[df]`: noteIndex=(2-1)-1=0, keep note[0] (d), unwrap to `d`
- Result: `ezz d`

Final output:
```
[ceg]ab [df]
gab f
ezz d
```

### Testing

#### Example-based tests (`editor/tests/explode.spec.ts`)

1. Single chord with 3 notes, partCount=3:
   - Input: `[ceg]`
   - Expected: original + `g` + `e` + `c`

2. Mixed chords and standalone notes, partCount=2:
   - Input: `[ceg]ab [df]`
   - Expected: original + `gab f` + `ezz d`

3. Chord with fewer notes than partCount:
   - Input: `[ce]`, partCount=3
   - Expected: original + `e` + `c` + `z`

4. Beamed notes with chords:
   - Input: `[ceg][df]` (beamed)
   - Expected: beam structure preserved in each part

5. Rhythm preservation:
   - Input: `[ceg]2`
   - Expected: original + `g2` + `e2` + `c2`

#### Property-based tests

1. Element count property: each exploded part has the same count of rhythm-bearing elements (notes, chords, rests) as the original line

2. Rhythm preservation property: the total duration of each exploded part equals the total duration of the original line

### To do list

- Extract shared utilities from `insertVoiceLine.ts` to `lineUtils.ts`
- Implement `filterChordToPart` function
- Implement `walkAndFilter` function
- Implement main `explode` function
- Write example-based tests
- Write property-based tests
- Export `explode` from `editor/src/transforms/index.ts`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Handling edge cases

### Overview

Extend the core explode function to handle edge cases that appear in real ABC notation: grace groups, decorations, annotations, and rests.

### Edge cases to handle

#### 1. Grace groups

Grace groups precede their target note/chord. A grace group ornamenting a chord ornaments its top note. When we explode, grace groups stay with part 0 (top voice) only. Parts 1+ have grace groups removed.

Example:
- Input: `{g}[ceg]ab` with partCount=2
- Part 0: `{g}gab` (grace group kept, it ornaments the top note)
- Part 1: `ezz` (grace group removed)

#### 2. Decorations

Decorations (staccato `.`, fermata `H`, trill `T`, etc.) are attached to notes/chords. Decorations stay in all parts. If a note becomes a rest, the decoration remains (it will be ignored during playback but preserved in the source). This matches how we handle slurs.

#### 3. Annotations and chord symbols

Annotations (`"^text"`) and chord symbols (`"Cmaj7"`) are positioning markers. They stay in all parts since they're not tied to specific pitches.

#### 4. Rests in the original

Rests in the original line are preserved as-is in all parts.

### Functions to modify

1. `walkAndFilter(node, partIndex, ctx)` - add logic to handle grace groups:
   - When partIndex > 0, remove grace groups that precede the current element
   - Reuse pattern from `removeUnselectedGraceGroups` in `insertVoiceLine.ts`

### Functions to reuse

From `insertVoiceLine.ts`:
- `findTargetNote(graceGroup)` - finds the note/chord that a grace group ornaments

### Algorithm update for grace groups

```
walkAndFilter(node, partIndex, ctx):
    prev = null
    current = node
    while current != null:
        next = current.nextSibling

        if current is Grace_group and partIndex > 0:
            remove current from sibling chain
            current = next
            continue

        if current is Chord:
            filterChordToPart(current, partIndex, ctx)
            if chord now has 1 note:
                unwrapSingle on current

        if current is Note and partIndex > 0:
            noteToRest(current, ctx)

        if current is Beam:
            walkAndFilter(current.firstChild, partIndex, ctx)

        prev = current
        current = next
```

### Testing

#### Example-based tests

1. Grace group before chord, partCount=2:
   - Input: `{g}[ceg]ab`
   - Part 0: `{g}gab` (grace kept)
   - Part 1: `ezz` (grace removed)

2. Grace group before standalone note, partCount=2:
   - Input: `{g}a[ce]`
   - Part 0: `{g}a e` (grace kept)
   - Part 1: `z c` (grace removed, note became rest)

3. Decoration on chord:
   - Input: `.[ceg]`
   - Part 0: `.g`
   - Part 1: `.e` (decoration preserved)

4. Rest in original:
   - Input: `[ce]z[df]`, partCount=2
   - Part 0: `e z f`
   - Part 1: `c z d`

5. Multiple grace groups:
   - Input: `{g}[ce] {a}[df]`, partCount=2
   - Part 0: `{g}e {a}f`
   - Part 1: `c d` (both grace groups removed)

#### Property-based tests

1. No grace groups before rests: after explosion, no part should have a grace group immediately preceding a rest

2. Grace group count in part 0: part 0 should have the same number of grace groups as the original

### To do list

- Update `walkAndFilter` to remove grace groups for partIndex > 0
- Write example-based tests for grace groups
- Write example-based tests for decorations
- Write example-based tests for rests in original
- Write property-based test for grace group placement
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: Preset commands and integration

### Overview

Create convenience wrapper functions (`explode2`, `explode3`, `explode4`) that call the core `explode` function with preset part counts, and integrate everything into the editor module's exports.

### Functions to create

```typescript
// File: editor/src/transforms/explode.ts (additions)

export function explode2(selection: Selection, ctx: ABCContext): Selection {
  return explode(selection, 2, ctx);
}

export function explode3(selection: Selection, ctx: ABCContext): Selection {
  return explode(selection, 3, ctx);
}

export function explode4(selection: Selection, ctx: ABCContext): Selection {
  return explode(selection, 4, ctx);
}
```

### Integration

#### Export from transforms index

Update `editor/src/transforms/index.ts`:

```typescript
export { explode, explode2, explode3, explode4 } from "./explode";
```

#### Export from editor module

Update `editor/src/index.ts` to include the new exports in the transforms object.

### Testing

#### Example-based tests

1. `explode2` produces 2 parts:
   - Input: `[ce]`
   - Expected: original + `e` + `c`

2. `explode3` produces 3 parts:
   - Input: `[ceg]`
   - Expected: original + `g` + `e` + `c`

3. `explode4` produces 4 parts:
   - Input: `[cegb]`
   - Expected: original + `b` + `g` + `e` + `c`

4. `explode4` on 2-note chord produces 2 notes + 2 rests:
   - Input: `[ce]`
   - Expected: original + `e` + `c` + `z` + `z`

#### Property-based tests

1. Preset functions produce correct part count: `explodeN` always produces exactly N new lines per source line

### To do list

- Implement `explode2`, `explode3`, `explode4` wrapper functions
- Update `editor/src/transforms/index.ts` exports
- Update `editor/src/index.ts` exports
- Write example-based tests for each preset
- Write property-based test for part count correctness
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 4: LSP server and client integration

### Overview

Integrate the explode transform commands into the LSP server so they can be invoked from editor clients. Implement command registration in the VSCode extension and Kakoune plugin.

### 1. LSP Server Integration

#### File: `abc-lsp-server/src/transformLookup.ts`

Add imports for the new explode functions:

```typescript
import {
  // ... existing imports ...
  explode,
  explode2,
  explode3,
  explode4,
} from "editor";
```

Add entries to `TRANSFORM_MAP`:

```typescript
const TRANSFORM_MAP: Record<string, TransformFn> = {
  // ... existing entries ...
  explode: (sel, ctx, ...args) => explode(sel, args[0] as number, ctx),
  explode2: (sel, ctx) => explode2(sel, ctx),
  explode3: (sel, ctx) => explode3(sel, ctx),
  explode4: (sel, ctx) => explode4(sel, ctx),
};
```

The `explode` entry takes a single argument (the part count as a number), while the preset entries (`explode2`, `explode3`, `explode4`) take no additional arguments.

### 2. VSCode Extension Integration

#### File: `vscode-extension/src/transformCommands.ts`

Add preset commands to the `simpleTransforms` array:

```typescript
const simpleTransforms: Array<[string, string]> = [
  // ... existing entries ...
  ["abc.explode2", "explode2"],
  ["abc.explode3", "explode3"],
  ["abc.explode4", "explode4"],
];
```

Add a command with prompt for custom part count:

```typescript
// explode: prompt for part count
context.subscriptions.push(
  vscode.commands.registerCommand("abc.explode", async () => {
    const input = await vscode.window.showInputBox({
      prompt: "Number of parts to explode into (2-8)",
      validateInput: v => {
        const n = Number(v);
        if (isNaN(n) || !Number.isInteger(n)) return "Must be an integer";
        if (n < 2 || n > 8) return "Must be between 2 and 8";
        return null;
      },
    });
    if (input === undefined) return;
    await applyTransform(client, "explode", [Number(input)], statusBarItem);
  })
);
```

#### File: `vscode-extension/package.json`

Add command declarations in `contributes.commands`:

```json
{
  "command": "abc.explode",
  "title": "ABC: Explode Chords to Parts",
  "category": "ABC"
},
{
  "command": "abc.explode2",
  "title": "ABC: Explode to 2 Parts",
  "category": "ABC"
},
{
  "command": "abc.explode3",
  "title": "ABC: Explode to 3 Parts",
  "category": "ABC"
},
{
  "command": "abc.explode4",
  "title": "ABC: Explode to 4 Parts",
  "category": "ABC"
}
```

Add menu entries in `contributes.menus.commandPalette`:

```json
{
  "command": "abc.explode",
  "when": "editorLangId == abc"
},
{
  "command": "abc.explode2",
  "when": "editorLangId == abc"
},
{
  "command": "abc.explode3",
  "when": "editorLangId == abc"
},
{
  "command": "abc.explode4",
  "when": "editorLangId == abc"
}
```

### 3. Kakoune Plugin Integration

#### File: `abc-kak/rc/abc-transforms.kak`

Add a new section for explode commands:

```kak
# ============================================================================
# Explode Transform Commands
# ============================================================================

define-command abc-explode -params 1 \
    -docstring "abc-explode <parts>: Explode chords into the specified number of voice parts" %{
    abc-transform-impl explode "[$1]"
}

define-command abc-explode2 \
    -docstring "Explode chords into 2 voice parts" %{
    abc-transform-impl explode2
}

define-command abc-explode3 \
    -docstring "Explode chords into 3 voice parts" %{
    abc-transform-impl explode3
}

define-command abc-explode4 \
    -docstring "Explode chords into 4 voice parts" %{
    abc-transform-impl explode4
}
```

### Testing

Because the LSP server and clients do not have automated tests for individual commands, we verify integration manually:

1. Build the LSP server: `npm run build` in `abc-lsp-server/`
2. Build the VSCode extension: `npm run build` in `vscode-extension/`
3. Launch VSCode with the extension loaded
4. Open an ABC file containing chords
5. Select a line with chords
6. Run "ABC: Explode to 2 Parts" from the command palette
7. Verify that 2 new lines are inserted after the selection

For Kakoune:
1. Start the LSP server with socket support
2. Open an ABC file in Kakoune
3. Select a line with chords
4. Run `:abc-explode2`
5. Verify that 2 new lines are inserted

### To do list

- Update `abc-lsp-server/src/transformLookup.ts`:
  - Add imports for `explode`, `explode2`, `explode3`, `explode4`
  - Add entries to `TRANSFORM_MAP`
- Update `vscode-extension/src/transformCommands.ts`:
  - Add `explode2`, `explode3`, `explode4` to `simpleTransforms` array
  - Add `abc.explode` command with input prompt
- Update `vscode-extension/package.json`:
  - Add command declarations for `abc.explode`, `abc.explode2`, `abc.explode3`, `abc.explode4`
  - Add corresponding menu entries in `commandPalette`
- Update `abc-kak/rc/abc-transforms.kak`:
  - Add `abc-explode`, `abc-explode2`, `abc-explode3`, `abc-explode4` commands
- Final verification: build and tests both pass
- Manual testing of VSCode extension commands
- Commit once the build passes and all tests pass
