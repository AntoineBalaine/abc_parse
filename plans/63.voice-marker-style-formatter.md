# Voice Marker Style Formatter Configuration

## Table of Contents

1. [Goal](#goal)
2. [Phase 1: Extend FormatterConfig and Directive Parsing](#phase-1-extend-formatterconfig-and-directive-parsing)
3. [Phase 2: Implement VoiceMarkerStyleVisitor](#phase-2-implement-voicemarkerstylevisitor)
4. [Phase 3: Integrate Visitor into Formatter](#phase-3-integrate-visitor-into-formatter)

## Goal

Add a formatter configuration option that allows converting between inline voice markers (`[V:1]`) and infoline voice markers (`V:1`) during formatting.

---

## Phase 1: Extend FormatterConfig and Directive Parsing

### Overview

We extend the `FormatterConfig` type to include a voice marker style preference, and we add parsing for the `%%abcls-fmt voice-markers=inline|infoline` directive.

### File Changes

#### 1. `parse/types/Expr2.ts`

Add the new type and update `FormatterConfig`:

```typescript
// Add after line 168 (after isInstructionInfo function)
export type VoiceMarkerStyle = 'inline' | 'infoline';

// Update FormatterConfig (lines 173-176)
export type FormatterConfig = {
  systemComments: boolean;
  voiceMarkerStyle: VoiceMarkerStyle | null;
};

// Update DEFAULT_FORMATTER_CONFIG (lines 178-180)
export const DEFAULT_FORMATTER_CONFIG: FormatterConfig = {
  systemComments: false,
  voiceMarkerStyle: null,
};
```

#### 2. `parse/parsers/infoLines/parseDirective.ts`

Extend `checkFormatterDirective()` to handle the new option. Currently (lines 27-49), the function only checks for `system-comments`. We need to also handle `voice-markers=inline|infoline`.

Update logic in `checkFormatterDirective()`:

```
// After checking for "system-comments" (around line 37)

if first value is KV with key "voice-markers"
  valueToken = KV.value
  if valueToken.lexeme is "inline" or "infoline"
    if headerContext == "file"
      ctx.abcContext.formatterConfig.voiceMarkerStyle = valueToken.lexeme
    else
      ctx.abcContext.tuneFormatterConfig.voiceMarkerStyle = valueToken.lexeme
```

Because the directive parser already creates `KV` objects for `key=value` patterns (via `prsKV` at line 162), the value `voice-markers=inline` will be parsed as a `KV` node. We need to check if the first value is a `KV` instance with key `voice-markers`.

Imports needed: `KV` is already imported at line 2.

### Testing

#### Example-based tests (`parse/tests/formatter-config.spec.ts`)

Add tests for the new directive:

1. `%%abcls-fmt voice-markers=inline` in file header sets `formatterConfig.voiceMarkerStyle` to `'inline'`
2. `%%abcls-fmt voice-markers=infoline` in file header sets `formatterConfig.voiceMarkerStyle` to `'infoline'`
3. `%%abcls-fmt voice-markers=inline` in tune header sets `tuneFormatterConfig.voiceMarkerStyle` to `'inline'`
4. `%%abcls-fmt voice-markers=infoline` in tune header sets `tuneFormatterConfig.voiceMarkerStyle` to `'infoline'`
5. No directive leaves `voiceMarkerStyle` as `null` (default)
6. Invalid value (e.g., `voice-markers=unknown`) leaves `voiceMarkerStyle` as `null`

#### Property-based tests (`parse/analyzers/directive-analyzer.pbt.spec.ts` or new file)

Property: For any generated `%%abcls-fmt voice-markers=<value>` directive where `<value>` is one of `['inline', 'infoline']`, the resulting config's `voiceMarkerStyle` equals `<value>`.

Generator:
```
fc.constantFrom('inline', 'infoline')
```

### To Do

1. Add `VoiceMarkerStyle` type to `Expr2.ts`
2. Update `FormatterConfig` type to include `voiceMarkerStyle: VoiceMarkerStyle | null`
3. Update `DEFAULT_FORMATTER_CONFIG` to include `voiceMarkerStyle: null`
4. Update `checkFormatterDirective()` in `parseDirective.ts` to parse `voice-markers=inline|infoline`
5. Add example-based tests for the new directive parsing
6. Add property-based test for directive parsing
7. Final verification: build and tests both pass
8. Call the code review agent. Address any feedback.
9. Commit once the build passes and all tests pass.

---

## Phase 2: Implement VoiceMarkerStyleVisitor

### Overview

We create a new visitor that transforms voice markers in the tune body. The visitor traverses the tune body's systems and converts voice markers between inline (`[V:1]`) and infoline (`V:1`) forms based on the target style.

### AST Structure Context

Understanding the AST structure is essential for this phase:

- `Tune_Body` has `sequence: System[]` where `System = Array<Expr | Token>`
- A `System` can contain: `Info_line`, `Music_code`, `Token` (EOL, WS), `Comment`, etc.
- `Music_code` has `contents: Array<Expr | Token>` which can contain `Inline_field`
- `Info_line` has `key: Token`, `value: Token[]`, `value2?: Expr[]`
- `Inline_field` has `leftBracket?: Token`, `rightBracket?: Token`, `field: Token`, `text: Token[]`, `value2?: Expr[]`

### File Changes

#### 1. New file: `parse/Visitors/VoiceMarkerStyleVisitor.ts`

```typescript
import { ABCContext } from "../parsers/Context";
import { Token, TT } from "../parsers/scan2";
import {
  Expr,
  Info_line,
  Inline_field,
  Music_code,
  System,
  Tune_Body,
  VoiceMarkerStyle,
} from "../types/Expr2";

export class VoiceMarkerStyleVisitor {
  ctx: ABCContext;
  targetStyle: VoiceMarkerStyle;

  constructor(ctx: ABCContext, targetStyle: VoiceMarkerStyle) { ... }

  transformTuneBody(tuneBody: Tune_Body): Tune_Body { ... }
  transformSystem(system: System): System { ... }
  convertInfoLinesToInline(system: System): System { ... }
  convertInlineToInfoLines(system: System): System { ... }

  // Helper functions
  isVoiceInfoLine(node: Expr | Token): node is Info_line { ... }
  isVoiceInlineField(node: Expr | Token): node is Inline_field { ... }
  extractInfoLineContent(infoLine: Info_line): Array<Expr | Token> { ... }
  extractInlineFieldContent(inlineField: Inline_field): Array<Expr | Token> { ... }
  createInlineField(content: Array<Expr | Token>): Inline_field { ... }
  createInfoLine(content: Array<Expr | Token>): Info_line { ... }
  createEOLToken(): Token { ... }
  createWSToken(): Token { ... }
}
```

### Conversion Algorithms

#### infoline to inline (`convertInfoLinesToInline`)

Input structure: `[Info_line(V:1), EOL, Music_code(CDEF|)]`
Output structure: `[Music_code([Inline_field(V:1), WS, CDEF|])]`

The EOL token following the V: info line is removed because the info line is replaced by an inline field that gets prepended to the music content on the same line.

```
for each element in system
  if element is Info_line with V: key
    content = extractInfoLineContent(element)
    inlineField = createInlineField(content)

    skip any following EOL/WS tokens

    if next element is Music_code
      prepend inlineField + WS to Music_code.contents
    else
      add inlineField to result (standalone)
  else if element is EOL immediately after a converted V: info line
    skip (already handled above)
  else
    add element to result
return result
```

#### inline to infoline (`convertInlineToInfoLines`)

Input structure: `[Music_code([Inline_field(V:1), WS, CDEF|])]`
Output structure: `[Info_line(V:1), EOL, Music_code(CDEF|)]`

An EOL token is inserted after the newly created info line.

```
for each element in system
  if element is Music_code
    scan Music_code.contents for Inline_field with V: field

    for each voice inline field found at start of Music_code
      content = extractInlineFieldContent(inlineField)
      infoLine = createInfoLine(content)
      add infoLine to result
      add EOL token to result
      remove inlineField (and trailing WS) from Music_code.contents

    if Music_code still has contents
      add modified Music_code to result
  else
    add element to result
return result
```

### Edge Cases

1. Voice info line at end of system with no following music: convert to inline field standalone
2. Voice inline field in middle of Music_code (not at start): leave as-is (only convert inline fields that start a music section)
3. Multiple consecutive voice markers: convert each one
4. Voice markers with parameters (e.g., `V:1 clef=treble`): preserve all parameters during conversion

### Testing

#### Example-based tests (`parse/Visitors/VoiceMarkerStyleVisitor.spec.ts`)

New test file with the following cases:

infoline to inline conversion:
1. `V:1\nCDEF|` becomes `[V:1] CDEF|`
2. `V:1 clef=treble\nCDEF|` becomes `[V:1 clef=treble] CDEF|` (parameters preserved)
3. `V:1\nV:2\nCDEF|` becomes `[V:1] [V:2] CDEF|` (consecutive markers)
4. `V:1\n` (no following music) becomes `[V:1]`

inline to infoline conversion:
1. `[V:1] CDEF|` becomes `V:1\nCDEF|`
2. `[V:1 clef=treble] CDEF|` becomes `V:1 clef=treble\nCDEF|` (parameters preserved)
3. `[V:1] [V:2] CDEF|` becomes `V:1\nV:2\nCDEF|` (consecutive markers)
4. `CDEF [V:1] GAB|` remains `CDEF [V:1] GAB|` (mid-music inline field unchanged)

Preservation (null config):
1. Input with infoline markers returns unchanged
2. Input with inline markers returns unchanged

#### Property-based tests (`parse/Visitors/VoiceMarkerStyleVisitor.pbt.spec.ts`)

Properties:

1. Roundtrip conservation: Converting infoline to inline to infoline (or vice versa) preserves voice content
   ```
   for any tune with voice markers
     inline = convert(tune, 'inline')
     back = convert(inline, 'infoline')
     voiceContent(tune) == voiceContent(back)
   ```

2. Voice count preservation: The number of voice markers is unchanged after conversion
   ```
   for any tune with voice markers
     converted = convert(tune, targetStyle)
     countVoiceMarkers(tune) == countVoiceMarkers(converted)
   ```

3. Music content preservation: All non-voice-marker music content is preserved
   ```
   for any tune
     converted = convert(tune, targetStyle)
     extractMusicContent(tune) == extractMusicContent(converted)
   ```

Generator: Use existing tune body generators, or create a generator that produces systems with voice markers in various positions.

### To Do

1. Create `parse/Visitors/VoiceMarkerStyleVisitor.ts`
2. Implement `VoiceMarkerStyleVisitor` class with constructor
3. Implement `transformTuneBody()` and `transformSystem()` methods
4. Implement `convertInfoLinesToInline()` method
5. Implement `convertInlineToInfoLines()` method
6. Implement helper functions for content extraction and node creation
7. Export `VoiceMarkerStyleVisitor` from `parse/Visitors/index.ts` (if exists) or `parse/index.ts`
8. Create `parse/Visitors/VoiceMarkerStyleVisitor.spec.ts` with example-based tests
9. Create `parse/Visitors/VoiceMarkerStyleVisitor.pbt.spec.ts` with property-based tests
10. Final verification: build and tests both pass
11. Call the code review agent. Address any feedback.
12. Commit once the build passes and all tests pass.

---

## Phase 3: Integrate Visitor into Formatter

### Overview

We integrate the `VoiceMarkerStyleVisitor` into the `AbcFormatter` class. When `formatterConfig.voiceMarkerStyle` is not null, the formatter calls the visitor to transform voice markers as the first step, before rules resolution and alignment.

### File Changes

#### 1. `parse/Visitors/Formatter2.ts`

Add import for the new visitor:

```typescript
// Add to imports (around line 1-50)
import { VoiceMarkerStyleVisitor } from "./VoiceMarkerStyleVisitor";
```

Modify the `format()` method (lines 181-191) to call the visitor first:

```typescript
format(ast: Tune): string {
  this.no_format = false;

  // 1. Transform voice markers if configured
  let tuneToFormat = ast;
  if (ast.formatterConfig.voiceMarkerStyle !== null && ast.tune_body) {
    const visitor = new VoiceMarkerStyleVisitor(this.ctx, ast.formatterConfig.voiceMarkerStyle);
    const transformedBody = visitor.transformTuneBody(ast.tune_body);
    tuneToFormat = new Tune(
      ast.id,
      ast.tune_header,
      transformedBody,
      ast.linear,
      ast.formatterConfig
    );
  }

  // 2. Rules resolution phase
  const withRules = resolveRules(tuneToFormat, this.ctx);

  // 3. Align multi-voices tunes
  const alignedTune = alignTune(withRules, this.ctx, this);

  // 4. Print using visitor
  return this.stringify(alignedTune, false);
}
```

The `Tune` constructor signature (from `Expr2.ts`) is:
```typescript
constructor(
  id: number,
  tune_header: Tune_header,
  tune_body: Tune_Body | null,
  linear?: boolean,
  formatterConfig?: FormatterConfig
)
```

#### 2. Consider `formatFile()` method (lines 165-180)

The `formatFile()` method iterates over tunes and calls `format()` for each. Because `format()` now handles voice marker transformation, no changes are needed to `formatFile()`.

However, we should verify that file-level `formatterConfig` is properly inherited by tunes. Currently (in `parse2.ts`), each tune gets its own `formatterConfig` from the context. If a file-level directive is set, it should propagate to tunes.

If not already handled, we may need to ensure that when a tune does not have its own `%%abcls-fmt voice-markers=...` directive, it inherits from the file-level config. This inheritance logic may already exist for `systemComments`.

### Inheritance Logic Check

Looking at `parse2.ts`, we need to verify:
- When parsing a tune, the tune's `formatterConfig` is initialized from `ctx.abcContext.tuneFormatterConfig`
- Before parsing each tune, `ctx.abcContext.tuneFormatterConfig` is reset to a copy of `ctx.abcContext.formatterConfig` (file-level)

If this pattern exists for `systemComments`, it will work for `voiceMarkerStyle` automatically because we're adding to the same `FormatterConfig` type.

### Testing

#### Example-based tests (`parse/tests/fmt2_voice_markers.spec.ts`)

End-to-end formatting tests:

1. Format tune with `%%abcls-fmt voice-markers=inline` converts infoline to inline:
   ```
   Input:
   X:1
   %%abcls-fmt voice-markers=inline
   K:C
   V:1
   CDEF|

   Output:
   X:1
   %%abcls-fmt voice-markers=inline
   K:C
   [V:1] CDEF|
   ```

2. Format tune with `%%abcls-fmt voice-markers=infoline` converts inline to infoline:
   ```
   Input:
   X:1
   %%abcls-fmt voice-markers=infoline
   K:C
   [V:1] CDEF|

   Output:
   X:1
   %%abcls-fmt voice-markers=infoline
   K:C
   V:1
   CDEF|
   ```

3. Format tune without directive preserves original form (infoline stays infoline):
   ```
   Input:
   X:1
   K:C
   V:1
   CDEF|

   Output:
   X:1
   K:C
   V:1
   CDEF|
   ```

4. Format tune without directive preserves original form (inline stays inline):
   ```
   Input:
   X:1
   K:C
   [V:1] CDEF|

   Output:
   X:1
   K:C
   [V:1] CDEF|
   ```

5. File-level directive applies to all tunes:
   ```
   Input:
   %%abcls-fmt voice-markers=inline

   X:1
   K:C
   V:1
   CDEF|

   X:2
   K:G
   V:2
   GABG|

   Output:
   %%abcls-fmt voice-markers=inline

   X:1
   K:C
   [V:1] CDEF|

   X:2
   K:G
   [V:2] GABG|
   ```

6. Tune-level directive overrides file-level:
   ```
   Input:
   %%abcls-fmt voice-markers=inline

   X:1
   %%abcls-fmt voice-markers=infoline
   K:C
   [V:1] CDEF|

   Output:
   %%abcls-fmt voice-markers=inline

   X:1
   %%abcls-fmt voice-markers=infoline
   K:C
   V:1
   CDEF|
   ```

#### Property-based tests (`parse/tests/fmt2_voice_markers.pbt.spec.ts`)

Properties:

1. Formatting is idempotent: formatting a tune twice produces the same result
   ```
   for any tune with voice-markers directive
     formatted1 = format(tune)
     formatted2 = format(parse(formatted1))
     formatted1 == formatted2
   ```

2. Voice content preservation through format roundtrip:
   ```
   for any tune with voice markers
     formatted = format(tune)
     reparsed = parse(formatted)
     extractVoiceIds(tune) == extractVoiceIds(reparsed)
   ```

Generator: Generate tunes with voice markers in various configurations and with/without the formatter directive.

### To Do

1. Add import for `VoiceMarkerStyleVisitor` in `Formatter2.ts`
2. Modify `format()` method to call the visitor as the first step when `voiceMarkerStyle` is not null
3. Verify file-to-tune config inheritance works correctly in `parse2.ts` (add if missing)
4. Create `parse/tests/fmt2_voice_markers.spec.ts` with example-based tests
5. Create `parse/tests/fmt2_voice_markers.pbt.spec.ts` with property-based tests
6. Final verification: build and tests both pass
7. Call the code review agent. Address any feedback.
8. Commit once the build passes and all tests pass.
