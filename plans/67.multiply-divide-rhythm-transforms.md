# Plan 67: Implement Multiply/Divide Rhythm Transforms

## Table of Contents

1. [Outline](#outline)
2. [Phase 1: Implement Transforms in Editor](#phase-1-implement-transforms-in-editor)
3. [Phase 2: Register in Server and Add Kakoune Commands](#phase-2-register-in-server-and-add-kakoune-commands)

---

## Outline

### Overview

Re-implement the multiply/divide rhythm transforms that were removed in January 2026 when the ABCt2 transform system replaced the old visitor-based system. The new implementation will use the CSTree/Selection-based architecture.

### Background

The original implementation used `RhythmVisitor` with:
- `duplicateLength(expr: Rhythm)` - multiplies rhythm by 2
- `divideLength(expr: Rhythm)` - divides rhythm by 2
- `rhythmToRational()` and `rationalToRhythm()` for conversion

The new implementation will reuse existing utilities in `editor/src/transforms/rhythm.ts` which already has `rhythmToRational` and `rationalToRhythm`.

### Original Implementation Reference

From commit `8d07d4b`, the core logic was:

```typescript
private rhythmToRational(expr: Rhythm): IRational {
  let numerator = 1;
  let denominator = 1;
  if (expr.numerator) {
    numerator = parseInt(expr.numerator.lexeme);
  }
  if (expr.separator) {
    const slashCount = expr.separator.lexeme.length;
    if (expr.denominator) {
      denominator = parseInt(expr.denominator.lexeme);
    } else {
      denominator = Math.pow(2, slashCount);
    }
  }
  return createRational(numerator, denominator);
}

private duplicateLength(expr: Rhythm): Rhythm {
  const rational = this.rhythmToRational(expr);
  const multiplied = multiplyRational(rational, createRational(2, 1));
  return this.rationalToRhythm(multiplied, expr);
}

private divideLength(expr: Rhythm): Rhythm {
  const rational = this.rhythmToRational(expr);
  const divided = divideRational(rational, createRational(2, 1));
  return this.rationalToRhythm(divided, expr);
}
```

### Phases

- Phase 1: Implement `multiplyRhythm` and `divideRhythm` transforms in the editor package
- Phase 2: Register transforms in the server and add Kakoune commands

### Files to Modify/Create

- `editor/src/transforms/multiplyRhythm.ts` (new)
- `editor/src/transforms/divideRhythm.ts` (new)
- `editor/src/transforms/index.ts` (add exports)
- `abc-lsp-server/src/transformLookup.ts` (register transforms)
- `abc-kak/rc/abc-transforms.kak` (add commands)

### Test Cases from Original Implementation

Multiply (double length):

| Input | Expected |
|-------|----------|
| `a` | `a2` |
| `a2` | `a4` |
| `a/` | `a` |
| `a/2` | `a` |
| `a//` | `a/` |
| `a/4` | `a/` |
| `a///` | `a/4` |

Divide (halve length):

| Input | Expected |
|-------|----------|
| `a,2` | `a,` |
| `a4` | `a2` |
| `a/` | `a/4` |
| `a/2` | `a/4` |
| `a//` | `a/8` |
| `a` | `a/` |
| `^a''` | `^a''/` |

---

## Phase 1: Implement Transforms in Editor

### Goal

Create `multiplyRhythm` and `divideRhythm` transform functions that operate on a Selection and multiply/divide the rhythm of each selected note, chord, or rest by a given factor.

### Implementation

#### 1. Create `editor/src/transforms/multiplyRhythm.ts`

```typescript
import { ABCContext, IRational, createRational } from "abc-parser";
import { Selection, Cursor } from "../selection";
import { TAGS } from "../csTree/types";
import {
  findRhythmChild,
  replaceRhythm,
  removeChild
} from "./treeUtils";
import {
  rhythmToRational,
  rationalToRhythm,
  extractBrokenToken
} from "./rhythm";

// Inline if not exported from abc-parser
function multiplyRational(a: IRational, b: IRational): IRational {
  return createRational(a.numerator * b.numerator, a.denominator * b.denominator);
}

/**
 * Multiply the rhythm of selected notes/chords/rests by the given factor.
 *
 * @param selection - The current selection containing cursors on rhythm-bearing nodes
 * @param factor - The multiplier (default 2)
 * @param ctx - The ABC context for generating IDs
 * @returns A new Selection with modified rhythms
 */
export function multiplyRhythm(
  selection: Selection,
  factor: number = 2,
  ctx: ABCContext
): Selection {
  const newCursors: Cursor[] = [];
  const multiplier = createRational(factor, 1);

  for (const cursor of selection.cursors) {
    const node = cursor.node;

    // Only process rhythm-bearing nodes (Note, Chord, Rest, Spacer)
    if (
      node.tag !== TAGS.Note &&
      node.tag !== TAGS.Chord &&
      node.tag !== TAGS.Rest &&
      node.tag !== TAGS.Spacer
    ) {
      newCursors.push(cursor);
      continue;
    }

    const rhythmResult = findRhythmChild(node);

    if (rhythmResult === null) {
      // No rhythm exists - create one representing the multiplied default (1 * factor)
      const newRhythm = rationalToRhythm(multiplier, ctx, null);
      if (newRhythm !== null) {
        replaceRhythm(node, newRhythm);
      }
    } else {
      // Extract broken token before modifying
      const brokenToken = extractBrokenToken(rhythmResult.node);

      // Get current rhythm as rational
      const currentRational = rhythmToRational(rhythmResult.node);

      // Multiply by factor
      const newRational = multiplyRational(currentRational, multiplier);

      // Convert back to rhythm node
      const newRhythm = rationalToRhythm(newRational, ctx, brokenToken);

      if (newRhythm === null) {
        // Result is 1/1, remove rhythm entirely
        removeChild(node, rhythmResult.node, rhythmResult.prev);
      } else {
        replaceRhythm(node, newRhythm);
      }
    }

    newCursors.push(cursor);
  }

  return new Selection(newCursors);
}
```

#### 2. Create `editor/src/transforms/divideRhythm.ts`

```typescript
import { ABCContext, IRational, createRational } from "abc-parser";
import { Selection, Cursor } from "../selection";
import { TAGS } from "../csTree/types";
import {
  findRhythmChild,
  replaceRhythm,
  removeChild
} from "./treeUtils";
import {
  rhythmToRational,
  rationalToRhythm,
  extractBrokenToken
} from "./rhythm";

// Inline if not exported from abc-parser
function divideRational(a: IRational, b: IRational): IRational {
  return createRational(a.numerator * b.denominator, a.denominator * b.numerator);
}

/**
 * Divide the rhythm of selected notes/chords/rests by the given factor.
 *
 * @param selection - The current selection containing cursors on rhythm-bearing nodes
 * @param factor - The divisor (default 2)
 * @param ctx - The ABC context for generating IDs
 * @returns A new Selection with modified rhythms
 */
export function divideRhythm(
  selection: Selection,
  factor: number = 2,
  ctx: ABCContext
): Selection {
  const newCursors: Cursor[] = [];
  const divisor = createRational(factor, 1);

  for (const cursor of selection.cursors) {
    const node = cursor.node;

    // Only process rhythm-bearing nodes (Note, Chord, Rest, Spacer)
    if (
      node.tag !== TAGS.Note &&
      node.tag !== TAGS.Chord &&
      node.tag !== TAGS.Rest &&
      node.tag !== TAGS.Spacer
    ) {
      newCursors.push(cursor);
      continue;
    }

    const rhythmResult = findRhythmChild(node);

    if (rhythmResult === null) {
      // No rhythm exists - create one representing the divided default (1 / factor)
      const newRational = createRational(1, factor);
      const newRhythm = rationalToRhythm(newRational, ctx, null);
      if (newRhythm !== null) {
        replaceRhythm(node, newRhythm);
      }
    } else {
      // Extract broken token before modifying
      const brokenToken = extractBrokenToken(rhythmResult.node);

      // Get current rhythm as rational
      const currentRational = rhythmToRational(rhythmResult.node);

      // Divide by factor
      const newRational = divideRational(currentRational, divisor);

      // Convert back to rhythm node
      const newRhythm = rationalToRhythm(newRational, ctx, brokenToken);

      if (newRhythm === null) {
        // Result is 1/1, remove rhythm entirely
        removeChild(node, rhythmResult.node, rhythmResult.prev);
      } else {
        replaceRhythm(node, newRhythm);
      }
    }

    newCursors.push(cursor);
  }

  return new Selection(newCursors);
}
```

#### 3. Update `editor/src/transforms/index.ts`

Add exports:

```typescript
export { multiplyRhythm } from "./multiplyRhythm";
export { divideRhythm } from "./divideRhythm";
```

#### 4. Verify `abc-parser` exports `multiplyRational` and `divideRational`

Check if these are exported from abc-parser. If not, the implementation inlines the logic as shown above.

### Testing

Create `editor/src/transforms/multiplyRhythm.spec.ts` and `editor/src/transforms/divideRhythm.spec.ts`.

#### Test Cases for `multiplyRhythm`

```typescript
describe("multiplyRhythm", () => {
  const cases = [
    ["a", "a2"],      // default -> doubled
    ["a2", "a4"],     // 2 -> 4
    ["a/", "a"],      // 1/2 -> 1
    ["a/2", "a"],     // 1/2 -> 1
    ["a//", "a/"],    // 1/4 -> 1/2
    ["a/4", "a/"],    // 1/4 -> 1/2
    ["a///", "a/4"],  // 1/8 -> 1/4
  ];

  cases.forEach(([input, expected]) => {
    it(`should multiply ${input} to ${expected}`, () => {
      // Parse input, create selection, call multiplyRhythm, format result
    });
  });
});
```

#### Test Cases for `divideRhythm`

```typescript
describe("divideRhythm", () => {
  const cases = [
    ["a,2", "a,"],     // 2 -> 1 (with comma octave marker)
    ["a4", "a2"],      // 4 -> 2
    ["a/", "a/4"],     // 1/2 -> 1/4
    ["a/2", "a/4"],    // 1/2 -> 1/4
    ["a//", "a/8"],    // 1/4 -> 1/8
    ["a", "a/"],       // 1 -> 1/2
    ["^a''", "^a''/"], // with sharp and octave marks
  ];

  cases.forEach(([input, expected]) => {
    it(`should divide ${input} to ${expected}`, () => {
      // Parse input, create selection, call divideRhythm, format result
    });
  });
});
```

### To Do

- Verify `multiplyRational` and `divideRational` are exported from abc-parser (or inline them)
- Create `editor/src/transforms/multiplyRhythm.ts`
- Create `editor/src/transforms/divideRhythm.ts`
- Update `editor/src/transforms/index.ts` with new exports
- Create test file `editor/src/transforms/multiplyRhythm.spec.ts`
- Create test file `editor/src/transforms/divideRhythm.spec.ts`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Register in Server and Add Kakoune Commands

### Goal

Expose the new `multiplyRhythm` and `divideRhythm` transforms via the LSP server and add corresponding Kakoune commands.

### Implementation

#### 1. Update `abc-lsp-server/src/transformLookup.ts`

Add imports:

```typescript
import {
  // ... existing imports ...
  multiplyRhythm,
  divideRhythm,
} from "editor";
```

Add to `TRANSFORM_MAP`:

```typescript
const TRANSFORM_MAP: Record<string, TransformFn> = {
  // ... existing transforms ...
  multiplyRhythm: (sel, ctx, ...args) => multiplyRhythm(sel, args[0] as number ?? 2, ctx),
  divideRhythm: (sel, ctx, ...args) => divideRhythm(sel, args[0] as number ?? 2, ctx),
};
```

#### 2. Update `abc-kak/rc/abc-transforms.kak`

Add new section after Rhythm Transform Commands (or create new section):

```kak
# ============================================================================
# Rhythm Length Commands
# ============================================================================

define-command abc-multiply-rhythm -params 0..1 \
    -docstring "abc-multiply-rhythm [factor]: Multiply rhythm length by factor (default 2)" %{
    evaluate-commands %sh{
        factor="${1:-2}"
        printf '%s\n' "abc-transform-impl multiplyRhythm '[${factor}]'"
    }
}

define-command abc-divide-rhythm -params 0..1 \
    -docstring "abc-divide-rhythm [factor]: Divide rhythm length by factor (default 2)" %{
    evaluate-commands %sh{
        factor="${1:-2}"
        printf '%s\n' "abc-transform-impl divideRhythm '[${factor}]'"
    }
}
```

### Testing

#### Running Kakoune commands from the shell (CI/testing)

Because `kak -ui dummy` does not support `execute-keys` (it hangs), we must use a real headless daemon session instead:

```sh
# Start a real headless daemon
kak -d -s "$session" &
sleep 0.3

# Send commands via kak -p
kak -p "$session" << 'CMDS'
edit /path/to/file.kak
evaluate-commands -buffer /path/to/file.kak %{
    execute-keys '...'
    nop %sh{ echo "$kak_selection" > /tmp/output }
}
quit!
CMDS

# Read output from file (kak -p is one-way, no stdout)
cat /tmp/output
```

Key points:
- `kak -d -s session` starts a real daemon (not `-ui dummy`)
- `evaluate-commands -buffer <file>` provides the context needed for `execute-keys`
- Output must be written to a file because `kak -p` cannot return data

#### Test Cases

1. Select a note `a`, run `abc-multiply-rhythm`, verify result is `a2`
2. Select a note `a2`, run `abc-divide-rhythm`, verify result is `a`
3. Select a note `a`, run `abc-divide-rhythm 4`, verify result is `a/4`
4. Select multiple notes, verify each gets transformed

### To Do

- Add `multiplyRhythm` and `divideRhythm` imports to `transformLookup.ts`
- Register both transforms in `TRANSFORM_MAP`
- Add `abc-multiply-rhythm` command to `abc-transforms.kak`
- Add `abc-divide-rhythm` command to `abc-transforms.kak`
- Test both commands manually in Kakoune using `kak -d`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
