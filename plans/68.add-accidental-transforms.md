# Plan 68: Add Sharp/Flat Accidental Transforms

## Table of Contents

1. [Outline](#outline)
2. [Phase 1: Implement Transforms in Editor](#phase-1-implement-transforms-in-editor)
3. [Phase 2: Register in Server and Add Kakoune Commands](#phase-2-register-in-server-and-add-kakoune-commands)

---

## Outline

### Overview

Add transforms to modify the accidentals of selected notes - adding sharps or flats. These will be new transforms in the editor package, exposed via the LSP server and Kakoune plugin.

### Commands to Add

| Command | Description |
|---------|-------------|
| `addSharp` | Add a sharp accidental to selected notes (or sharpen existing accidental) |
| `addFlat` | Add a flat accidental to selected notes (or flatten existing accidental) |

### Behavior

The transforms should handle the accidental progression:

For `addSharp`:
- No accidental → `^` (sharp)
- `_` (flat) → natural (remove accidental)
- `=` (natural) → `^` (sharp)
- `^` (sharp) → `^^` (double sharp)
- `__` (double flat) → `_` (flat)
- `^^` (double sharp) → no change (already maximum)

For `addFlat`:
- No accidental → `_` (flat)
- `^` (sharp) → natural (remove accidental)
- `=` (natural) → `_` (flat)
- `_` (flat) → `__` (double flat)
- `^^` (double sharp) → `^` (sharp)
- `__` (double flat) → no change (already maximum)

### Phases

- Phase 1: Implement `addSharp` and `addFlat` transforms in the editor package
- Phase 2: Register transforms in the server and add Kakoune commands

### Files to Modify/Create

- `editor/src/transforms/addAccidental.ts` (new)
- `editor/src/transforms/index.ts` (add exports)
- `abc-lsp-server/src/transformLookup.ts` (register transforms)
- `abc-kak/rc/abc-transforms.kak` (add commands)

---

## Phase 1: Implement Transforms in Editor

### Goal

Create `addSharp` and `addFlat` transform functions that modify the accidentals of selected notes.

### Implementation

#### 1. Create `editor/src/transforms/addAccidental.ts`

```typescript
import { ABCContext, Token, TT } from "abc-parser";
import { Selection, Cursor } from "../selection";
import { CSNode, TAGS, isTokenNode, getTokenData } from "../csTree/types";
import { findChildByTag, replaceChild, removeChild, insertBefore } from "./treeUtils";

/**
 * Find the accidental token in a Note node.
 * Returns the token node and its predecessor for removal/replacement.
 */
function findAccidentalChild(
  noteNode: CSNode
): { node: CSNode; prev: CSNode | null } | null {
  let prev: CSNode | null = null;
  let current = noteNode.firstChild;

  while (current !== null) {
    if (isTokenNode(current)) {
      const tokenType = getTokenData(current).tokenType;
      if (
        tokenType === TT.SHARP ||
        tokenType === TT.FLAT ||
        tokenType === TT.NATURAL ||
        tokenType === TT.DBL_SHARP ||
        tokenType === TT.DBL_FLAT
      ) {
        return { node: current, prev };
      }
    }
    prev = current;
    current = current.nextSibling;
  }
  return null;
}

/**
 * Find the pitch token in a Note node (the letter A-G or a-g).
 */
function findPitchChild(noteNode: CSNode): CSNode | null {
  let current = noteNode.firstChild;
  while (current !== null) {
    if (isTokenNode(current)) {
      const tokenType = getTokenData(current).tokenType;
      if (tokenType === TT.PITCH) {
        return current;
      }
    }
    current = current.nextSibling;
  }
  return null;
}

/**
 * Get the current accidental state of a note.
 */
function getAccidentalState(
  noteNode: CSNode
): "none" | "sharp" | "flat" | "natural" | "dblsharp" | "dblflat" {
  const accResult = findAccidentalChild(noteNode);
  if (accResult === null) return "none";

  const tokenType = getTokenData(accResult.node).tokenType;
  switch (tokenType) {
    case TT.SHARP:
      return "sharp";
    case TT.FLAT:
      return "flat";
    case TT.NATURAL:
      return "natural";
    case TT.DBL_SHARP:
      return "dblsharp";
    case TT.DBL_FLAT:
      return "dblflat";
    default:
      return "none";
  }
}

/**
 * Create an accidental token node.
 */
function createAccidentalNode(
  type: "sharp" | "flat" | "natural" | "dblsharp" | "dblflat",
  ctx: ABCContext
): CSNode {
  let tokenType: TT;
  let lexeme: string;

  switch (type) {
    case "sharp":
      tokenType = TT.SHARP;
      lexeme = "^";
      break;
    case "flat":
      tokenType = TT.FLAT;
      lexeme = "_";
      break;
    case "natural":
      tokenType = TT.NATURAL;
      lexeme = "=";
      break;
    case "dblsharp":
      tokenType = TT.DBL_SHARP;
      lexeme = "^^";
      break;
    case "dblflat":
      tokenType = TT.DBL_FLAT;
      lexeme = "__";
      break;
  }

  const token = new Token(tokenType, lexeme, ctx.generateId());
  return {
    tag: TAGS.Token,
    firstChild: null,
    nextSibling: null,
    data: token,
  } as CSNode;
}

/**
 * Apply sharp accidental logic to a single note node.
 */
function applySharpToNote(noteNode: CSNode, ctx: ABCContext): void {
  const currentState = getAccidentalState(noteNode);
  const accResult = findAccidentalChild(noteNode);
  const pitchNode = findPitchChild(noteNode);

  switch (currentState) {
    case "none":
      if (pitchNode) {
        const sharpNode = createAccidentalNode("sharp", ctx);
        insertBefore(noteNode, pitchNode, sharpNode);
      }
      break;

    case "flat":
      if (accResult) {
        removeChild(noteNode, accResult.node, accResult.prev);
      }
      break;

    case "natural":
      if (accResult) {
        const sharpNode = createAccidentalNode("sharp", ctx);
        replaceChild(noteNode, accResult.node, sharpNode, accResult.prev);
      }
      break;

    case "sharp":
      if (accResult) {
        const dblSharpNode = createAccidentalNode("dblsharp", ctx);
        replaceChild(noteNode, accResult.node, dblSharpNode, accResult.prev);
      }
      break;

    case "dblflat":
      if (accResult) {
        const flatNode = createAccidentalNode("flat", ctx);
        replaceChild(noteNode, accResult.node, flatNode, accResult.prev);
      }
      break;

    case "dblsharp":
      // Already maximum, no change
      break;
  }
}

/**
 * Apply flat accidental logic to a single note node.
 */
function applyFlatToNote(noteNode: CSNode, ctx: ABCContext): void {
  const currentState = getAccidentalState(noteNode);
  const accResult = findAccidentalChild(noteNode);
  const pitchNode = findPitchChild(noteNode);

  switch (currentState) {
    case "none":
      if (pitchNode) {
        const flatNode = createAccidentalNode("flat", ctx);
        insertBefore(noteNode, pitchNode, flatNode);
      }
      break;

    case "sharp":
      if (accResult) {
        removeChild(noteNode, accResult.node, accResult.prev);
      }
      break;

    case "natural":
      if (accResult) {
        const flatNode = createAccidentalNode("flat", ctx);
        replaceChild(noteNode, accResult.node, flatNode, accResult.prev);
      }
      break;

    case "flat":
      if (accResult) {
        const dblFlatNode = createAccidentalNode("dblflat", ctx);
        replaceChild(noteNode, accResult.node, dblFlatNode, accResult.prev);
      }
      break;

    case "dblsharp":
      if (accResult) {
        const sharpNode = createAccidentalNode("sharp", ctx);
        replaceChild(noteNode, accResult.node, sharpNode, accResult.prev);
      }
      break;

    case "dblflat":
      // Already maximum, no change
      break;
  }
}

/**
 * Add a sharp to selected notes.
 *
 * Progression:
 * - none → sharp
 * - flat → natural (cancels out)
 * - natural → sharp
 * - sharp → dblsharp
 * - dblflat → flat
 * - dblsharp → (no change, already maximum)
 *
 * When a chord is selected, all notes within the chord are modified.
 */
export function addSharp(selection: Selection, ctx: ABCContext): Selection {
  const newCursors: Cursor[] = [];

  for (const cursor of selection.cursors) {
    const node = cursor.node;

    if (node.tag === TAGS.Note) {
      applySharpToNote(node, ctx);
    } else if (node.tag === TAGS.Chord) {
      // Apply to all notes within the chord
      let child = node.firstChild;
      while (child !== null) {
        if (child.tag === TAGS.Note) {
          applySharpToNote(child, ctx);
        }
        child = child.nextSibling;
      }
    }

    newCursors.push(cursor);
  }

  return new Selection(newCursors);
}

/**
 * Add a flat to selected notes.
 *
 * Progression:
 * - none → flat
 * - sharp → natural (cancels out)
 * - natural → flat
 * - flat → dblflat
 * - dblsharp → sharp
 * - dblflat → (no change, already maximum)
 *
 * When a chord is selected, all notes within the chord are modified.
 */
export function addFlat(selection: Selection, ctx: ABCContext): Selection {
  const newCursors: Cursor[] = [];

  for (const cursor of selection.cursors) {
    const node = cursor.node;

    if (node.tag === TAGS.Note) {
      applyFlatToNote(node, ctx);
    } else if (node.tag === TAGS.Chord) {
      // Apply to all notes within the chord
      let child = node.firstChild;
      while (child !== null) {
        if (child.tag === TAGS.Note) {
          applyFlatToNote(child, ctx);
        }
        child = child.nextSibling;
      }
    }

    newCursors.push(cursor);
  }

  return new Selection(newCursors);
}
```

#### 2. Update `editor/src/transforms/index.ts`

Add exports:

```typescript
export { addSharp, addFlat } from "./addAccidental";
```

### Testing

Create `editor/src/transforms/addAccidental.spec.ts`.

#### Test Cases for `addSharp`

| Input | Expected | Description |
|-------|----------|-------------|
| `C` | `^C` | No accidental → sharp |
| `_C` | `C` | Flat → natural (removed) |
| `=C` | `^C` | Natural → sharp |
| `^C` | `^^C` | Sharp → double sharp |
| `__C` | `_C` | Double flat → flat |
| `^^C` | `^^C` | Double sharp → no change |

#### Test Cases for `addFlat`

| Input | Expected | Description |
|-------|----------|-------------|
| `C` | `_C` | No accidental → flat |
| `^C` | `C` | Sharp → natural (removed) |
| `=C` | `_C` | Natural → flat |
| `_C` | `__C` | Flat → double flat |
| `^^C` | `^C` | Double sharp → sharp |
| `__C` | `__C` | Double flat → no change |

#### Additional Test Cases

| Input | Expected | Description |
|-------|----------|-------------|
| `^C,` | `^^C,` | Note with octave marker |
| `^C2` | `^^C2` | Note with rhythm |
| `[CEG]` | `[^C^E^G]` | Full chord selected - all notes get accidental |
| `[C^EG]` + addSharp | `[^C^^E^G]` | Chord with mixed accidentals |

### To Do

- Create `editor/src/transforms/addAccidental.ts`
- Update `editor/src/transforms/index.ts` with new exports
- Create test file `editor/src/transforms/addAccidental.spec.ts`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Register in Server and Add Kakoune Commands

### Goal

Expose the new `addSharp` and `addFlat` transforms via the LSP server and add corresponding Kakoune commands.

### Implementation

#### 1. Update `abc-lsp-server/src/transformLookup.ts`

Add imports:

```typescript
import {
  // ... existing imports ...
  addSharp,
  addFlat,
} from "editor";
```

Add to `TRANSFORM_MAP`:

```typescript
const TRANSFORM_MAP: Record<string, TransformFn> = {
  // ... existing transforms ...
  addSharp: (sel, ctx) => addSharp(sel, ctx),
  addFlat: (sel, ctx) => addFlat(sel, ctx),
};
```

#### 2. Update `abc-kak/rc/abc-transforms.kak`

Add new section:

```kak
# ============================================================================
# Accidental Commands
# ============================================================================

define-command abc-add-sharp \
    -docstring "Add sharp accidental to selected notes (or sharpen existing)" %{
    abc-transform-impl addSharp
}

define-command abc-add-flat \
    -docstring "Add flat accidental to selected notes (or flatten existing)" %{
    abc-transform-impl addFlat
}
```

### Testing

#### Running Kakoune commands from the shell (CI/testing)

Because `kak -ui dummy` does not support `execute-keys` (it hangs), we must use a real headless daemon session instead:

```sh
# Start a real headless daemon
kak -d -s "$session" &
sleep 0.3

# Send commands via kak -p
kak -p "$session" << 'CMDS'
edit /path/to/file.kak
evaluate-commands -buffer /path/to/file.kak %{
    execute-keys '...'
    nop %sh{ echo "$kak_selection" > /tmp/output }
}
quit!
CMDS

# Read output from file (kak -p is one-way, no stdout)
cat /tmp/output
```

Key points:
- `kak -d -s session` starts a real daemon (not `-ui dummy`)
- `evaluate-commands -buffer <file>` provides the context needed for `execute-keys`
- Output must be written to a file because `kak -p` cannot return data

#### Test Cases

1. Select a note `C`, run `abc-add-sharp`, verify result is `^C`
2. Select a note `^C`, run `abc-add-flat`, verify result is `C` (cancelled out)
3. Select a chord `[CEG]`, run `abc-add-sharp`, verify result is `[^C^E^G]`
4. Select multiple notes, verify each gets the accidental applied

### To Do

- Add `addSharp` and `addFlat` imports to `transformLookup.ts`
- Register both transforms in `TRANSFORM_MAP`
- Add `abc-add-sharp` command to `abc-transforms.kak`
- Add `abc-add-flat` command to `abc-transforms.kak`
- Test both commands manually in Kakoune using `kak -d`
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
