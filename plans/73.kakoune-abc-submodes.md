# Plan 73: Kakoune ABC Submodes Implementation

## Table of Contents

1. [Outline](#outline)
2. [Phase 1: Define User Mode Infrastructure](#phase-1-define-user-mode-infrastructure)
3. [Phase 2: Implement Selection Mode](#phase-2-implement-selection-mode)
4. [Phase 3: Implement Transform Mode](#phase-3-implement-transform-mode)
5. [Phase 4: Inside/Around Submode](#phase-4-insidearound-submode)

---

## Outline

### Overview

This plan implements the keybinding scheme described in plan 65 by creating two Kakoune user-modes that expose ABC selectors and transforms through single-key shortcuts with mnemonic mappings.

### Architecture

The implementation adds a new file `abc-kak/rc/abc-modes.kak` that defines:

1. Two primary user modes (`abc-select` and `abc-transform`)
2. An inside/around submode for text-object-style selectors
3. Count-aware wrapper commands for transforms that accept numeric parameters
4. Entry commands that users can bind to their preferred prefix keys

### Design Decisions

1. Flat mode structure: Because Kakoune's user-mode system is inherently flat (no nested menus like Vim's which-key), all keybindings in each mode are single-key or two-key sequences (for inside/around).

2. Count prefix via `%val{count}`: Kakoune provides the count value through `%val{count}` which returns 0 when no count was specified. We create wrapper commands that read this value and pass it to the underlying transform commands with appropriate defaults (1 for pitch transforms, 2 for rhythm/explode transforms).

3. Alt modifier for variants: Kakoune supports `<a-x>` for Alt+x keybindings within user modes, which we use for harmonize variants (`<a-p>` for diatonic harmonize vs `p` for chromatic transpose).

4. Separate inside/around submode: Because we cannot chain `i` then `c` within a single user-mode without an intermediate step, we define an `abc-select-inside` and `abc-select-around` submode that the `i` and `a` keys enter.

5. User-configurable entry points: The plugin provides entry commands (`abc-enter-select-mode`, `abc-enter-transform-mode`) but does not bind them to any keys. Users configure their preferred prefix keys in their `kakrc`.

### Phases

- Phase 1: Create the user mode infrastructure and entry commands
- Phase 2: Implement Selection Mode with type, rhythm, structure, and chord position selectors
- Phase 3: Implement Transform Mode with count-aware wrapper commands for pitch, rhythm, voice, dynamics, explode, and convert transforms
- Phase 4: Implement the inside/around submode for delimiter-based selectors

### Files to Create/Modify

- `abc-kak/rc/abc-modes.kak` (new) - Main mode definitions, count-aware wrappers, and mappings
- `abc-kak/rc/abc.kak` (modify) - Add source statement for the new file

### Dependencies

All transform and selector commands referenced by plan 65 have been implemented:
- Harmonize octave commands (plan 66)
- Multiply/divide rhythm (plan 67)
- Add sharp/flat accidentals (plan 68)

---

## Phase 1: Define User Mode Infrastructure

### Goal

Create the basic user-mode structure and entry commands.

### Implementation

#### 1. Create `abc-kak/rc/abc-modes.kak`

```kak
# ABC User Modes
#
# This file defines user-modes for ABC-aware selection and transformation.
# Users bind the entry commands to their preferred prefix keys in their kakrc.
#
# Example usage in kakrc:
#   hook global WinSetOption filetype=abc %{
#       map buffer user s ':abc-enter-select-mode<ret>' -docstring 'ABC select'
#       map buffer user t ':abc-enter-transform-mode<ret>' -docstring 'ABC transform'
#   }

# ============================================================================
# User Mode Declarations
# ============================================================================

declare-user-mode abc-select
declare-user-mode abc-transform
declare-user-mode abc-select-inside
declare-user-mode abc-select-around

# ============================================================================
# Entry Commands
# ============================================================================

define-command abc-enter-select-mode \
    -docstring "Enter ABC selection mode for structural selection" %{
    enter-user-mode abc-select
}

define-command abc-enter-transform-mode \
    -docstring "Enter ABC transform mode for applying transformations" %{
    enter-user-mode abc-transform
}
```

#### 2. Modify `abc-kak/rc/abc.kak`

Add at the end of the file, after the existing source statements:

```kak
source "%val{source}/abc-modes.kak"
```

The `%val{source}` expansion resolves to the directory containing the current file, so this will correctly source `abc-modes.kak` from the same `rc/` directory.

### Testing

Example-based tests:
- Verify that `abc-enter-select-mode` enters user mode (Kakoune waits for mode input)
- Verify that `abc-enter-transform-mode` enters user mode
- Verify that pressing `<esc>` exits the mode without error

Property-based tests:
- None for this phase (mode infrastructure is purely structural)

### To Do

- Create `abc-kak/rc/abc-modes.kak` with mode declarations and entry commands
- Modify `abc-kak/rc/abc.kak` to source the new file
- Verify manual testing by starting Kakoune and entering the modes
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Implement Selection Mode

### Goal

Populate the `abc-select` user mode with keybindings for type, rhythm, structure, and chord position selectors.

### Implementation

Add to `abc-kak/rc/abc-modes.kak`:

```kak
# ============================================================================
# Selection Mode Mappings
# ============================================================================

# --- Type Selectors ---
map global abc-select c ':abc-select-chords<ret>'          -docstring 'chords'
map global abc-select n ':abc-select-notes<ret>'           -docstring 'notes'
map global abc-select N ':abc-select-non-chord-notes<ret>' -docstring 'non-chord notes'
map global abc-select C ':abc-select-chord-notes<ret>'     -docstring 'chord notes'
map global abc-select z ':abc-select-rests<ret>'           -docstring 'rests'

# --- Rhythm Selectors ---
map global abc-select r ':abc-select-rhythm<ret>'          -docstring 'rhythm expressions'
map global abc-select R ':abc-select-rhythm-parent<ret>'   -docstring 'rhythm parents'

# --- Structure Selectors ---
map global abc-select x ':abc-select-tune<ret>'            -docstring 'tune'
map global abc-select m ':abc-select-measures<ret>'        -docstring 'measures'
map global abc-select s ':abc-select-system<ret>'          -docstring 'system'
map global abc-select v ':abc-select-voices<ret>'          -docstring 'voices (prompts)'

# --- Chord Position Selectors ---
map global abc-select t ':abc-select-top<ret>'             -docstring 'top note'
map global abc-select T ':abc-select-all-but-top<ret>'     -docstring 'all but top'
map global abc-select b ':abc-select-bottom<ret>'          -docstring 'bottom note'
map global abc-select B ':abc-select-all-but-bottom<ret>'  -docstring 'all but bottom'

# --- Nth from Top (1-9) ---
map global abc-select 1 ':abc-select-nth-from-top 1<ret>'  -docstring '1st from top'
map global abc-select 2 ':abc-select-nth-from-top 2<ret>'  -docstring '2nd from top'
map global abc-select 3 ':abc-select-nth-from-top 3<ret>'  -docstring '3rd from top'
map global abc-select 4 ':abc-select-nth-from-top 4<ret>'  -docstring '4th from top'
map global abc-select 5 ':abc-select-nth-from-top 5<ret>'  -docstring '5th from top'
map global abc-select 6 ':abc-select-nth-from-top 6<ret>'  -docstring '6th from top'
map global abc-select 7 ':abc-select-nth-from-top 7<ret>'  -docstring '7th from top'
map global abc-select 8 ':abc-select-nth-from-top 8<ret>'  -docstring '8th from top'
map global abc-select 9 ':abc-select-nth-from-top 9<ret>'  -docstring '9th from top'

# --- Inside/Around Entry Points ---
map global abc-select i ':enter-user-mode abc-select-inside<ret>' -docstring 'inside...'
map global abc-select a ':enter-user-mode abc-select-around<ret>' -docstring 'around...'
```

### Keybinding Reference

| Key | Command | Description |
|-----|---------|-------------|
| `c` | `abc-select-chords` | Select all chord nodes |
| `n` | `abc-select-notes` | Select all note nodes |
| `N` | `abc-select-non-chord-notes` | Select notes not inside chords |
| `C` | `abc-select-chord-notes` | Select notes inside chords |
| `z` | `abc-select-rests` | Select all rest nodes |
| `r` | `abc-select-rhythm` | Select rhythm expressions |
| `R` | `abc-select-rhythm-parent` | Select notes/chords/rests with explicit rhythm |
| `x` | `abc-select-tune` | Select individual tunes |
| `m` | `abc-select-measures` | Select all measures |
| `s` | `abc-select-system` | Expand selection to entire system(s) |
| `v` | `abc-select-voices` | Select by voice ID (prompts) |
| `t` | `abc-select-top` | Select top note of each chord |
| `T` | `abc-select-all-but-top` | Select all notes except top |
| `b` | `abc-select-bottom` | Select bottom note of each chord |
| `B` | `abc-select-all-but-bottom` | Select all notes except bottom |
| `1-9` | `abc-select-nth-from-top N` | Select Nth note from top |
| `i` | (enters inside submode) | Prefix for inside selectors |
| `a` | (enters around submode) | Prefix for around selectors |

### Testing

Example-based tests:
- `c` in selection mode calls `abc-select-chords`
- `n` calls `abc-select-notes`
- `t` calls `abc-select-top`
- `3` calls `abc-select-nth-from-top 3`

Property-based tests:
- Verify that all mapped keys have corresponding commands that exist

### To Do

- Add type selector mappings (c, n, N, C, z)
- Add rhythm selector mappings (r, R)
- Add structure selector mappings (x, m, s, v)
- Add chord position selector mappings (t, T, b, B, 1-9)
- Add inside/around entry points (i, a)
- Test each mapping manually in Kakoune
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: Implement Transform Mode

### Goal

Populate the `abc-transform` user mode with keybindings for pitch, rhythm, voice, dynamics, explode, and convert transforms. All transforms that accept numeric parameters are implemented with count-aware wrapper commands that read `%val{count}`.

### Implementation

Add to `abc-kak/rc/abc-modes.kak`:

#### 1. Count-Aware Wrapper Commands

These wrapper commands read Kakoune's count register and pass the value to the underlying transform commands. Commands default to 1 for pitch transforms and 2 for rhythm/explode transforms when no count is specified.

```kak
# ============================================================================
# Count-Aware Transform Wrappers
# ============================================================================

# --- Octave Transforms (default: 1 octave) ---

define-command -hidden abc-transform-octave-up %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-transpose $((count * 12))"
    }
}

define-command -hidden abc-transform-octave-down %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-transpose $((-count * 12))"
    }
}

define-command -hidden abc-transform-harmonize-octave-up %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-harmonize $((count * 7))"
    }
}

define-command -hidden abc-transform-harmonize-octave-down %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-harmonize $((-count * 7))"
    }
}

# --- Semitone Transforms (default: 1 semitone) ---

define-command -hidden abc-transform-transpose-up %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-transpose $count"
    }
}

define-command -hidden abc-transform-transpose-down %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-transpose $((-count))"
    }
}

# --- Diatonic Transforms (default: 1 step) ---

define-command -hidden abc-transform-harmonize-up %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-harmonize $count"
    }
}

define-command -hidden abc-transform-harmonize-down %{
    evaluate-commands %sh{
        count="${kak_count:-1}"
        if [ "$count" = "0" ]; then count=1; fi
        printf '%s\n' "abc-harmonize $((-count))"
    }
}

# --- Rhythm Transforms (default: factor of 2) ---

define-command -hidden abc-transform-multiply-rhythm %{
    evaluate-commands %sh{
        count="${kak_count:-2}"
        if [ "$count" = "0" ]; then count=2; fi
        printf '%s\n' "abc-multiply-rhythm $count"
    }
}

define-command -hidden abc-transform-divide-rhythm %{
    evaluate-commands %sh{
        count="${kak_count:-2}"
        if [ "$count" = "0" ]; then count=2; fi
        printf '%s\n' "abc-divide-rhythm $count"
    }
}

# --- Explode Transform (default: 2 parts) ---

define-command -hidden abc-transform-explode %{
    evaluate-commands %sh{
        count="${kak_count:-2}"
        if [ "$count" = "0" ]; then count=2; fi
        printf '%s\n' "abc-explode $count"
    }
}
```

#### 2. Transform Mode Mappings

```kak
# ============================================================================
# Transform Mode Mappings
# ============================================================================

# --- Pitch Transforms: Octave ---
map global abc-transform o ':abc-transform-octave-up<ret>'           -docstring '[count] octave up'
map global abc-transform O ':abc-transform-octave-down<ret>'         -docstring '[count] octave down'
map global abc-transform <a-o> ':abc-transform-harmonize-octave-up<ret>'   -docstring '[count] harmonize octave up'
map global abc-transform <a-O> ':abc-transform-harmonize-octave-down<ret>' -docstring '[count] harmonize octave down'

# --- Pitch Transforms: Semitone/Diatonic ---
map global abc-transform p ':abc-transform-transpose-up<ret>'        -docstring '[count] transpose up (semitone)'
map global abc-transform P ':abc-transform-transpose-down<ret>'      -docstring '[count] transpose down'
map global abc-transform <a-p> ':abc-transform-harmonize-up<ret>'    -docstring '[count] harmonize up (diatonic)'
map global abc-transform <a-P> ':abc-transform-harmonize-down<ret>'  -docstring '[count] harmonize down'

# --- Pitch Transforms: Accidentals ---
map global abc-transform + ':abc-add-sharp<ret>'                -docstring 'add sharp'
map global abc-transform - ':abc-add-flat<ret>'                 -docstring 'add flat'
map global abc-transform e ':abc-enharmonize<ret>'              -docstring 'enharmonize'

# --- Rhythm Transforms ---
map global abc-transform * ':abc-transform-multiply-rhythm<ret>'     -docstring '[count] multiply length'
map global abc-transform / ':abc-transform-divide-rhythm<ret>'       -docstring '[count] divide length'

# --- Voice Transforms ---
map global abc-transform v ':abc-voice-info-to-inline<ret>'     -docstring 'V:1 to [V:1]'
map global abc-transform V ':abc-voice-inline-to-info<ret>'     -docstring '[V:1] to V:1'
map global abc-transform <a-v> ':abc-insert-voice-line<ret>'    -docstring 'insert voice line'
map global abc-transform <a-V> ':abc-add-voice<ret>'            -docstring 'add voice'

# --- Dynamics Transforms ---
map global abc-transform <lt> ':abc-wrap-crescendo<ret>'        -docstring 'wrap crescendo'
map global abc-transform <gt> ':abc-wrap-decrescendo<ret>'      -docstring 'wrap decrescendo'

# --- Explode Transform ---
map global abc-transform x ':abc-transform-explode<ret>'             -docstring '[count] explode chords'

# --- Convert Transforms ---
map global abc-transform r ':abc-to-rest<ret>'                  -docstring 'to rest'
map global abc-transform R ':abc-consolidate-rests<ret>'        -docstring 'consolidate rests'
```

Note: `<lt>` and `<gt>` are Kakoune's escape sequences for `<` and `>` characters in mappings.

### Keybinding Reference

| Key | Command | Default | Description |
|-----|---------|---------|-------------|
| `[count] o` | `abc-transform-octave-up` | 1 | Transpose up by count octaves |
| `[count] O` | `abc-transform-octave-down` | 1 | Transpose down by count octaves |
| `[count] <a-o>` | `abc-transform-harmonize-octave-up` | 1 | Harmonize up by count octaves |
| `[count] <a-O>` | `abc-transform-harmonize-octave-down` | 1 | Harmonize down by count octaves |
| `[count] p` | `abc-transform-transpose-up` | 1 | Transpose up by count semitones |
| `[count] P` | `abc-transform-transpose-down` | 1 | Transpose down by count semitones |
| `[count] <a-p>` | `abc-transform-harmonize-up` | 1 | Harmonize up by count diatonic steps |
| `[count] <a-P>` | `abc-transform-harmonize-down` | 1 | Harmonize down by count diatonic steps |
| `+` | `abc-add-sharp` | - | Add sharp accidental |
| `-` | `abc-add-flat` | - | Add flat accidental |
| `e` | `abc-enharmonize` | - | Convert to enharmonic equivalent |
| `[count] *` | `abc-transform-multiply-rhythm` | 2 | Multiply note length by count |
| `[count] /` | `abc-transform-divide-rhythm` | 2 | Divide note length by count |
| `v` | `abc-voice-info-to-inline` | - | Convert V:1 to [V:1] |
| `V` | `abc-voice-inline-to-info` | - | Convert [V:1] to V:1 |
| `<a-v>` | `abc-insert-voice-line` | - | Insert voice line (prompts) |
| `<a-V>` | `abc-add-voice` | - | Add new voice (prompts) |
| `<` | `abc-wrap-crescendo` | - | Wrap in crescendo markers |
| `>` | `abc-wrap-decrescendo` | - | Wrap in decrescendo markers |
| `[count] x` | `abc-transform-explode` | 2 | Explode chords into count parts |
| `r` | `abc-to-rest` | - | Convert to rest |
| `R` | `abc-consolidate-rests` | - | Consolidate consecutive rests |

### Testing

#### Example-based tests: Count-aware pitch transforms

| Input | Action | Expected | Description |
|-------|--------|----------|-------------|
| `C` | `o` | `c` | Octave up (default 1) |
| `C` | `2o` | `c'` | 2 octaves up |
| `c` | `O` | `C` | Octave down (default 1) |
| `c'` | `2O` | `C` | 2 octaves down |
| `C` | `p` | `^C` | Transpose up 1 semitone |
| `C` | `7p` | `G` | Transpose up 7 semitones |
| `G` | `P` | `^F` | Transpose down 1 semitone |
| `G` | `5P` | `D` | Transpose down 5 semitones |
| `C` | `<a-o>` | `[Cc]` | Harmonize octave up (default 1) |
| `C` | `2<a-o>` | `[Cc']` | Harmonize 2 octaves up |
| `C` | `<a-p>` | `[CD]` | Harmonize 1 diatonic step up |
| `C` | `3<a-p>` | `[CE]` | Harmonize 3 diatonic steps up (a third) |
| `E` | `<a-P>` | `[ED]` | Harmonize 1 diatonic step down |

#### Example-based tests: Accidental transforms

| Input | Action | Expected | Description |
|-------|--------|----------|-------------|
| `C` | `+` | `^C` | Add sharp |
| `^C` | `+` | `^^C` | Sharp to double sharp |
| `C` | `-` | `_C` | Add flat |
| `_C` | `-` | `__C` | Flat to double flat |
| `^C` | `e` | `_D` | Enharmonize sharp to flat |

#### Example-based tests: Count-aware rhythm transforms

| Input | Action | Expected | Description |
|-------|--------|----------|-------------|
| `C` | `*` | `C2` | Multiply by 2 (default) |
| `C` | `4*` | `C4` | Multiply by 4 |
| `C2` | `/` | `C` | Divide by 2 (default) |
| `C4` | `4/` | `C` | Divide by 4 |
| `C` | `/` | `C/` | Divide by 2 when no rhythm |

#### Example-based tests: Count-aware explode transform

| Input | Action | Expected | Description |
|-------|--------|----------|-------------|
| `[CEG]` | `x` | Two voices with `[CE]` and `G` | Explode into 2 parts (default) |
| `[CEGB]` | `3x` | Three voices | Explode into 3 parts |
| `[CEG]` | `4x` | Three voices (capped at chord size) | Explode into 4 parts |

#### Example-based tests: Voice transforms

| Input | Action | Expected | Description |
|-------|--------|----------|-------------|
| `V:1` | `v` | `[V:1]` | Info to inline |
| `[V:1]` | `V` | `V:1` | Inline to info |

#### Example-based tests: Dynamics transforms

| Input | Action | Expected | Description |
|-------|--------|----------|-------------|
| `CDE` | `<` (with selection) | `!<(!CDE!<!` | Wrap crescendo |
| `CDE` | `>` (with selection) | `!>(!CDE!>!` | Wrap decrescendo |

#### Example-based tests: Convert transforms

| Input | Action | Expected | Description |
|-------|--------|----------|-------------|
| `C` | `r` | `z` | Note to rest |
| `C2` | `r` | `z2` | Note with rhythm to rest |
| `[CEG]` | `r` | `z` | Chord to rest |
| `z z z` | `R` | `z3` | Consolidate consecutive rests |

#### Property-based tests

| Property | Description |
|----------|-------------|
| `No` then `NO` = identity | For any note and count N, transposing N octaves up then N octaves down returns the original |
| `Np` then `NP` = identity | For any note and count N, transposing N semitones up then down returns the original |
| `N*` then `N/` = identity | For any rhythm and count N, multiplying then dividing by N returns the original |
| `+` then `-` cancels | For a note without accidental, adding sharp then flat returns the original |

### To Do

- Add count-aware wrapper commands (abc-transform-octave-up, abc-transform-octave-down, etc.)
- Add pitch transform mappings (o, O, a-o, a-O, p, P, a-p, a-P, +, -, e)
- Add rhythm transform mappings (*, /)
- Add voice transform mappings (v, V, a-v, a-V)
- Add dynamics transform mappings (<, >)
- Add explode transform mapping (x)
- Add convert transform mappings (r, R)
- Test each mapping manually in Kakoune, including count prefix behavior
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 4: Inside/Around Submode

### Goal

Implement the `abc-select-inside` and `abc-select-around` submodes for text-object-style selectors that work on delimited constructs (chords, grace groups, inline fields, groupings).

### Implementation

Add to `abc-kak/rc/abc-modes.kak`:

```kak
# ============================================================================
# Inside/Around Submodes
# ============================================================================

# --- Inside Submode ---
map global abc-select-inside c ':abc-select-inside-chord<ret>'        -docstring 'inside chord'
map global abc-select-inside g ':abc-select-inside-grace-group<ret>'  -docstring 'inside grace group'
map global abc-select-inside f ':abc-select-inside-inline-field<ret>' -docstring 'inside inline field'
map global abc-select-inside p ':abc-select-inside-grouping<ret>'     -docstring 'inside grouping'

# --- Around Submode ---
map global abc-select-around c ':abc-select-around-chord<ret>'        -docstring 'around chord'
map global abc-select-around g ':abc-select-around-grace-group<ret>'  -docstring 'around grace group'
map global abc-select-around f ':abc-select-around-inline-field<ret>' -docstring 'around inline field'
map global abc-select-around p ':abc-select-around-grouping<ret>'     -docstring 'around grouping'
```

### Keybinding Reference

| Keys | Command | Description |
|------|---------|-------------|
| `ic` | `abc-select-inside-chord` | Select contents inside chord brackets |
| `ac` | `abc-select-around-chord` | Select entire chord including brackets |
| `ig` | `abc-select-inside-grace-group` | Select contents inside grace braces |
| `ag` | `abc-select-around-grace-group` | Select entire grace group including braces |
| `if` | `abc-select-inside-inline-field` | Select contents inside inline field |
| `af` | `abc-select-around-inline-field` | Select entire inline field |
| `ip` | `abc-select-inside-grouping` | Select contents inside grouping parens |
| `ap` | `abc-select-around-grouping` | Select entire grouping including parens |

### Testing

#### Example-based tests: Inside selectors

| Input | Cursor position | Action | Expected selection |
|-------|-----------------|--------|-------------------|
| `[CEG]` | On `E` | `ic` | `CEG` |
| `{abc}def` | On `b` | `ig` | `abc` |
| `[K:Am]` | On `K` | `if` | `K:Am` |
| `(CDE)` | On `D` | `ip` | `CDE` |

#### Example-based tests: Around selectors

| Input | Cursor position | Action | Expected selection |
|-------|-----------------|--------|-------------------|
| `[CEG]` | On `E` | `ac` | `[CEG]` |
| `{abc}def` | On `b` | `ag` | `{abc}` |
| `[K:Am]` | On `K` | `af` | `[K:Am]` |
| `(CDE)` | On `D` | `ap` | `(CDE)` |

#### Property-based tests

| Property | Description |
|----------|-------------|
| Around contains inside | For any delimited construct, the "around" selection length is always greater than the "inside" selection length by the delimiter size |
| Inside excludes delimiters | For any delimited construct, the "inside" selection never includes the opening or closing delimiter characters |

### To Do

- Add inside submode mappings (c, g, f, p)
- Add around submode mappings (c, g, f, p)
- Test the two-key sequences (i+c, a+c, i+g, a+g, i+f, a+f, i+p, a+p) manually in Kakoune
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
