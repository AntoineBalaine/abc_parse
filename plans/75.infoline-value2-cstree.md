# Plan 75: Populate value2 in CSTree to AST Conversion for Info_line

## Table of Contents

1. [Outline](#outline)
2. [Phase 1: Update fromAst to preserve value2 expressions](#phase-1-update-fromast-to-preserve-value2-expressions)
3. [Phase 2: Update toAst to reconstruct value2 from children](#phase-2-update-toast-to-reconstruct-value2-from-children)

---

## Outline

### Problem Statement

When an AST is converted to CSTree (for editor operations) and back to AST, the `Info_line.value2` expressions are lost. This happens because:

1. `fromAst.ts`: `visitInfoLineExpr` only stores `[expr.key, ...expr.value]`, ignoring `value2`
2. `toAst.ts`: `buildInfoLine` creates `Info_line(id, children as Token[])` without `value2`

### Design Decision

`value2` takes precedence over `value`. The goal is to phase out `value` (the token array) in favor of `value2` (the expression array). When `value2` is available, we use it exclusively.

### Goals

1. Preserve `value2` expressions when converting AST to CSTree
2. Reconstruct `value2` when converting CSTree back to AST
3. Ensure roundtrip consistency: AST -> CSTree -> AST preserves `value2`

---

## Phase 1: Update fromAst to preserve value2 expressions

### File: `editor/src/csTree/fromAst.ts`

### Current Code (lines 103-105)

```typescript
visitInfoLineExpr(expr: Info_line): ChildList {
  return [expr.key, ...expr.value];
}
```

### Updated Code

```typescript
visitInfoLineExpr(expr: Info_line): ChildList {
  // Prefer value2 (structured expressions) over value (raw tokens)
  if (expr.value2 && expr.value2.length > 0) {
    return [expr.key, ...expr.value2];
  }
  return [expr.key, ...expr.value];
}
```

### Explanation

Because `value2` contains structured expressions (KV, Binary, Unary, Grouping, AbsolutePitch, or Token), we prefer it when available. The `fromAst` function will recursively convert these expressions to CSTree nodes, preserving the structure.

### Testing

#### Example-based tests

Add to `editor/tests/csTree.spec.ts` (or create if it doesn't exist):

Test 1: Info_line with value2 containing KV expressions
- Input: Info_line with `value2 = [KV(key="clef", equals="=", value="treble")]`
- Expected: CSTree has Info_line node with children: [key token, KV node]
- Verify: KV node has children [key token, equals token, value token]

Test 2: Info_line with value2 containing Binary expression
- Input: Info_line for `M:4/4` with `value2 = [Binary(4, "/", 4)]`
- Expected: CSTree has Info_line node with children: [key token, Binary node]

Test 3: Info_line without value2 falls back to value
- Input: Info_line with only `value` tokens, no `value2`
- Expected: CSTree has Info_line node with children: [key token, ...value tokens]

#### Property-based tests

Property: When value2 is present, CSTree child count equals 1 + value2.length
- Generate random Info_line with value2
- Convert to CSTree
- Verify child count matches

### To Do

1. Update `visitInfoLineExpr` in `editor/src/csTree/fromAst.ts`
2. Add example-based tests for value2 preservation in `editor/tests/csTree.spec.ts`
3. Add property-based test for child count
4. Run `npm run test` to verify all tests pass
5. Final verification: build and tests both pass
6. Call the code review agent. Address any feedback.
7. Commit once the build passes and all tests pass.

---

## Phase 2: Update toAst to reconstruct value2 from children

### File: `editor/src/csTree/toAst.ts`

### Current Code (lines 343-345)

```typescript
function buildInfoLine(id: number, children: Array<Expr | Token>): Info_line {
  return new Info_line(id, children as Token[]);
}
```

### Updated Code

```typescript
function buildInfoLine(id: number, children: Array<Expr | Token>): Info_line {
  const key = children[0] as Token;
  const rest = children.slice(1);

  // Check if we have expression children (KV, Binary, Unary, etc.)
  const hasExpressions = rest.some(child => !(child instanceof Token));

  if (hasExpressions) {
    // Build with value2 (expressions take precedence)
    // Extract tokens for the value array (for backward compatibility during transition)
    const tokens = extractTokensFromExpressions(rest);
    return new Info_line(id, [key, ...tokens], undefined, rest as Array<Expr>);
  }

  // Fallback: all children are tokens, use value only
  return new Info_line(id, children as Token[]);
}

/**
 * Extract all tokens from an array of expressions/tokens for the value array.
 * This is used during the transition period to maintain backward compatibility.
 */
function extractTokensFromExpressions(items: Array<Expr | Token>): Token[] {
  const tokens: Token[] = [];
  for (const item of items) {
    if (item instanceof Token) {
      tokens.push(item);
    } else {
      // Recursively extract tokens from expression
      tokens.push(...getTokensFromExpr(item));
    }
  }
  return tokens;
}

/**
 * Recursively extract all tokens from an expression.
 */
function getTokensFromExpr(expr: Expr): Token[] {
  if (expr instanceof KV) {
    const tokens: Token[] = [];
    if (expr.key) {
      if (expr.key instanceof Token) {
        tokens.push(expr.key);
      } else {
        tokens.push(...getTokensFromExpr(expr.key));
      }
    }
    if (expr.equals) tokens.push(expr.equals);
    if (expr.value instanceof Token) {
      tokens.push(expr.value);
    } else {
      tokens.push(...getTokensFromExpr(expr.value));
    }
    return tokens;
  }
  if (expr instanceof Binary) {
    const tokens: Token[] = [];
    if (expr.left instanceof Token) {
      tokens.push(expr.left);
    } else {
      tokens.push(...getTokensFromExpr(expr.left));
    }
    tokens.push(expr.operator);
    if (expr.right instanceof Token) {
      tokens.push(expr.right);
    } else {
      tokens.push(...getTokensFromExpr(expr.right));
    }
    return tokens;
  }
  if (expr instanceof Unary) {
    const tokens: Token[] = [expr.operator];
    if (expr.operand instanceof Token) {
      tokens.push(expr.operand);
    } else {
      tokens.push(...getTokensFromExpr(expr.operand));
    }
    return tokens;
  }
  if (expr instanceof Grouping) {
    const tokens: Token[] = [];
    if (expr.leftParen) tokens.push(expr.leftParen);
    tokens.push(...getTokensFromExpr(expr.expression));
    if (expr.rightParen) tokens.push(expr.rightParen);
    return tokens;
  }
  if (expr instanceof AbsolutePitch) {
    const tokens: Token[] = [expr.noteLetter];
    if (expr.alteration) tokens.push(expr.alteration);
    if (expr.octave) tokens.push(expr.octave);
    return tokens;
  }
  return [];
}
```

### Required Imports

No new imports needed. `KV`, `Binary`, `Unary`, `Grouping`, `AbsolutePitch` are already imported.

### Explanation

The updated `buildInfoLine` function:

1. Extracts the key (first child) and the rest of the children
2. Checks if any of the rest are expressions (not just tokens)
3. If expressions are present:
   - Populates `value2` with the expression children
   - Extracts tokens from expressions to populate `value` (for backward compatibility)
4. If only tokens are present, falls back to the original behavior

The `extractTokensFromExpressions` and `getTokensFromExpr` helper functions recursively extract all tokens from expressions. This ensures that `value` (the token array) remains populated for any code that still relies on it during the transition period.

### Testing

#### Example-based tests

Add to `editor/tests/csTree.spec.ts`:

Test 1: CSTree with KV children produces Info_line with value2
- Create CSTree: Info_line node with children [V: token, KV node]
- Convert to AST
- Verify: Info_line.value2 contains the KV expression
- Verify: Info_line.value contains the flattened tokens

Test 2: Roundtrip preserves value2
- Start with AST: Info_line with value2 = [KV("clef", "=", "treble")]
- Convert to CSTree
- Convert back to AST
- Verify: value2 is preserved with same structure

Test 3: CSTree with only tokens produces Info_line without value2
- Create CSTree: Info_line node with only token children
- Convert to AST
- Verify: Info_line.value2 is undefined
- Verify: Info_line.value contains the tokens

Test 4: Complex roundtrip with multiple KV expressions
- Input: `V:RH clef=treble octave=-2`
- value2 = [KV("RH"), KV("clef", "=", "treble"), KV("octave", "=", Unary("-", "2"))]
- Roundtrip and verify structure preservation

#### Property-based tests

Property: Roundtrip preserves value2 expression count
- Generate random Info_line with value2
- Roundtrip through CSTree
- Verify value2.length is preserved

Property: Roundtrip preserves KV structure
- Generate random KV expressions
- Create Info_line with value2
- Roundtrip
- Verify each KV has same key/equals/value structure

### To Do

1. Update `buildInfoLine` in `editor/src/csTree/toAst.ts`
2. Add helper functions `extractTokensFromExpressions` and `getTokensFromExpr` to `editor/src/csTree/toAst.ts`
3. Add example-based tests for value2 reconstruction in `editor/tests/csTree.spec.ts`
4. Add example-based tests for roundtrip preservation
5. Add property-based tests for roundtrip
6. Run `npm run test` to verify all tests pass
7. Final verification: build and tests both pass
8. Call the code review agent. Address any feedback.
9. Commit once the build passes and all tests pass.
