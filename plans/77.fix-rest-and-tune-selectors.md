# Fix Rest and Tune Selectors (Bugs 1 and 2)

## Table of Contents

- Outline
- Phase 1: Fix `isRest()` to include MultiMeasureRest
- Phase 2: Fix `selectTune()` to select ancestor Tune nodes

---

## Outline

### Phase 1: Fix `isRest()` to include MultiMeasureRest

The `isRest()` function in `editor/src/csTree/types.ts` only checks for `TAGS.Rest`. Because `selectRests()` in `typeSelectors.ts` uses `isRest()` as its predicate, invisible multi-measure rests (X rests) are never matched.

Changes:
- Update `isRest()` to also check for `TAGS.MultiMeasureRest`

Testing:
- Example-based: ABC input with `X4` (4-bar invisible rest), verify it gets selected by `selectRests()`
- Property-based: Any tree containing MultiMeasureRest nodes should have those nodes in the output of `selectRests()`

Manual testing:
- Use the Kakoune headless testing methodology from the skill to verify `hz` selects X rests in the editor

### Phase 2: Fix `selectTune()` to select ancestor Tune nodes

The current `selectTune()` logic requires `nowInScope && node.tag === TAGS.Tune`, which means a Tune is only selected if the cursor is already on the Tune node itself. The intended behavior is: if the cursor is on any descendant of a Tune, we should select that Tune.

The fix requires changing the algorithm from "walk and check if Tune is in scope" to "for each cursor, find the ancestor Tune and select it".

Changes:
- Rewrite `selectTune()` in `structureSelectors.ts` to find ancestor Tune for each cursor position
- Add a helper function to find the nearest ancestor with a given tag (or reuse existing tree utilities if available)

Testing:
- Example-based: ABC input with cursor on a note inside a tune, verify the entire Tune is selected
- Example-based: ABC input with multiple tunes, cursor in second tune, verify only that tune is selected
- Property-based: For any cursor position inside a Tune, `selectTune()` should return exactly one cursor containing the Tune's id

Manual testing:
- Use the Kakoune headless testing methodology to verify `hx` selects the entire tune when cursor is on a note

---

Copy this plan file into the plans directory. After each phase:
- Final verification: build and tests both pass.
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 1: Fix `isRest()` to include MultiMeasureRest

### Problem

The `isRest()` function in `editor/src/csTree/types.ts:86-88` only checks for `TAGS.Rest`:

```typescript
export function isRest(node: CSNode): boolean {
  return node.tag === TAGS.Rest;
}
```

Because `selectRests()` in `editor/src/selectors/typeSelectors.ts:21-23` uses `isRest()` as its predicate:

```typescript
export function selectRests(input: Selection): Selection {
  return fanOutByPredicate(input, isRest, "all");
}
```

Invisible multi-measure rests (`X4`) and visible multi-measure rests (`Z4`) are never matched by the rest selector.

### Changes

File: `editor/src/csTree/types.ts`

Update the `isRest()` function at line 86-88:

```typescript
// Before:
export function isRest(node: CSNode): boolean {
  return node.tag === TAGS.Rest;
}

// After:
export function isRest(node: CSNode): boolean {
  return node.tag === TAGS.Rest || node.tag === TAGS.MultiMeasureRest;
}
```

No import changes are needed because `TAGS` is already defined in the same file.

### Testing

File: `editor/tests/typeSelectors.spec.ts`

Add example-based tests in the `describe("examples")` block after the existing rest test (around line 148):

```typescript
it("C | X4 | D| — selectRests produces 1 cursor (invisible multi-measure rest)", () => {
  const sel = toSelection("X:1\nK:C\nC | X4 | D|\n");
  const rests = selectRests(sel);
  expect(rests.cursors.length).to.equal(1);
  const id = [...rests.cursors[0]][0];
  const node = findById(rests.root, id);
  expect(node!.tag).to.equal(TAGS.MultiMeasureRest);
});

it("C | Z4 | D| — selectRests produces 1 cursor (visible multi-measure rest)", () => {
  const sel = toSelection("X:1\nK:C\nC | Z4 | D|\n");
  const rests = selectRests(sel);
  expect(rests.cursors.length).to.equal(1);
});

it("z2 X2 Z2| — selectRests produces 3 cursors (regular + invisible + visible)", () => {
  const sel = toSelection("X:1\nK:C\nz2 X2 Z2|\n");
  const rests = selectRests(sel);
  expect(rests.cursors.length).to.equal(3);
});
```

Add property-based test in the `describe("properties")` block:

```typescript
it("every cursor in selectRests result contains exactly 1 ID of a Rest or MultiMeasureRest CSNode", () => {
  fc.assert(
    fc.property(genAbcTune, (abc) => {
      const sel = toSelection(abc);
      const result = selectRests(sel);
      for (const cursor of result.cursors) {
        if (cursor.size !== 1) return false;
        const id = [...cursor][0];
        const node = findById(result.root, id);
        if (!node || (node.tag !== TAGS.Rest && node.tag !== TAGS.MultiMeasureRest)) return false;
      }
      return true;
    })
  );
});
```

### Manual Testing (Kakoune Headless)

Use the Kakoune headless testing methodology to verify that `hz` selects X rests:

1. Create a test ABC file with an invisible multi-measure rest (`X4`)
2. Position cursor on or near the X rest
3. Execute `hz` (rest selector)
4. Verify the selection covers the X rest

If the TypeScript test infrastructure in `abc-kak/test/` is functional, we can use `KakouneSession` to automate this. Otherwise, manual testing is required.

### To Do

- Update `isRest()` in `editor/src/csTree/types.ts` to include `TAGS.MultiMeasureRest`
- Add example-based tests in `editor/tests/typeSelectors.spec.ts`
- Add property-based test in `editor/tests/typeSelectors.spec.ts`
- Attempt Kakoune headless test; if infrastructure fails, perform manual test
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Fix `selectTune()` to select ancestor Tune nodes

### Problem

The current `selectTune()` in `editor/src/selectors/structureSelectors.ts` walks the tree and checks:

```typescript
if (nowInScope && current.tag === TAGS.Tune) {
  ctx.outputCursors.push(new Set([current.id]));
}
```

This only matches when the cursor is directly on a Tune node. When the cursor is on a descendant (e.g., a Note inside the Tune), the Tune is never selected because the Tune node itself is not in the cursor's scope.

The intended behavior: if the cursor contains any node that is a descendant of a Tune, we should select that Tune.

### Approach

We need a new helper function `findAncestorByTag(root, targetId, tag)` that:
1. Walks from root tracking an ancestor stack
2. When it finds the node matching `targetId`, looks back in the stack for the first ancestor with the specified tag
3. Returns that ancestor node, or null if none found

Then rewrite `selectTune()` to:
1. For each cursor, collect the node IDs
2. For each node ID, find the ancestor Tune using `findAncestorByTag`
3. Deduplicate Tune IDs (multiple cursors may be in the same Tune)
4. Return one cursor per unique Tune

### Changes

#### File: `editor/src/selectors/treeWalk.ts`

Add a new function `findAncestorByTag`:

```typescript
interface FindAncestorCtx {
  targetId: number;
  ancestorTag: string;
  result: CSNode | null;
}

function walkForAncestor(ctx: FindAncestorCtx, node: CSNode | null, ancestors: CSNode[]): boolean {
  let current = node;
  while (current !== null) {
    if (current.id === ctx.targetId) {
      // Found target, search ancestors backwards for matching tag
      for (let i = ancestors.length - 1; i >= 0; i--) {
        if (ancestors[i].tag === ctx.ancestorTag) {
          ctx.result = ancestors[i];
          return true;
        }
      }
      return true; // Found target but no matching ancestor
    }
    if (current.firstChild) {
      ancestors.push(current);
      if (walkForAncestor(ctx, current.firstChild, ancestors)) {
        return true;
      }
      ancestors.pop();
    }
    current = current.nextSibling;
  }
  return false;
}

/**
 * Finds the nearest ancestor of the node with the given ID that has the specified tag.
 * Returns null if the target node is not found or has no ancestor with that tag.
 */
export function findAncestorByTag(root: CSNode, targetId: number, tag: string): CSNode | null {
  const ctx: FindAncestorCtx = { targetId, ancestorTag: tag, result: null };
  walkForAncestor(ctx, root, []);
  return ctx.result;
}
```

#### File: `editor/src/selectors/structureSelectors.ts`

Rewrite the file to use the new approach:

```typescript
import { CSNode, TAGS } from "../csTree/types";
import { Selection } from "../selection";
import { findAncestorByTag } from "./treeWalk";

export function selectTune(input: Selection): Selection {
  const seenTuneIds = new Set<number>();
  const outputCursors: Set<number>[] = [];

  for (const cursor of input.cursors) {
    for (const nodeId of cursor) {
      const tuneAncestor = findAncestorByTag(input.root, nodeId, TAGS.Tune);
      if (tuneAncestor !== null && !seenTuneIds.has(tuneAncestor.id)) {
        seenTuneIds.add(tuneAncestor.id);
        outputCursors.push(new Set([tuneAncestor.id]));
      }
    }
  }

  return { root: input.root, cursors: outputCursors };
}
```

The old `TuneWalkCtx` interface and `walk` function are removed entirely.

### Testing

#### File: `editor/tests/structureSelectors.spec.ts`

Update existing tests and add new ones. The existing property-based test should continue to pass. Add example-based tests for the cursor-inside-tune case:

```typescript
it("cursor on a note inside a tune — selectTune returns that tune", () => {
  const sel = toSelection("X:1\nK:C\nCDE|\n");
  // Select just the first note (C) using a range selector or by creating a scoped selection
  const notes = selectNotes(sel);
  // notes.cursors[0] contains the C note
  const scopedSel = { root: sel.root, cursors: [notes.cursors[0]] };
  const result = selectTune(scopedSel);
  expect(result.cursors.length).to.equal(1);
  const tuneId = [...result.cursors[0]][0];
  const node = findById(result.root, tuneId);
  expect(node!.tag).to.equal(TAGS.Tune);
});

it("multiple cursors in same tune — selectTune returns one cursor", () => {
  const sel = toSelection("X:1\nK:C\nCDE|\n");
  const notes = selectNotes(sel);
  // All 3 notes are in the same tune
  const result = selectTune(notes);
  expect(result.cursors.length).to.equal(1);
});

it("cursors in different tunes — selectTune returns one cursor per tune", () => {
  const sel = toSelection("X:1\nK:C\nC|\n\nX:2\nK:G\nG|\n");
  const notes = selectNotes(sel);
  // 2 notes, each in a different tune
  const result = selectTune(notes);
  expect(result.cursors.length).to.equal(2);
});
```

Add property-based test for the new behavior:

```typescript
it("for any note selection, selectTune returns cursors only containing Tune IDs", () => {
  fc.assert(
    fc.property(genAbcMultiTune, (abc) => {
      const sel = toSelection(abc);
      const notes = selectNotes(sel);
      const tunes = selectTune(notes);
      for (const cursor of tunes.cursors) {
        if (cursor.size !== 1) return false;
        const id = [...cursor][0];
        const node = findById(tunes.root, id);
        if (!node || node.tag !== TAGS.Tune) return false;
      }
      return true;
    })
  );
});
```

#### File: `editor/tests/treeWalk.spec.ts`

Add tests for the new `findAncestorByTag` function:

```typescript
describe("findAncestorByTag", () => {
  it("returns the Tune ancestor for a Note inside a Tune", () => {
    const root = toCSTree("X:1\nK:C\nCDE|\n");
    const notes = findByTag(root, TAGS.Note);
    const noteId = notes[0].id;
    const ancestor = findAncestorByTag(root, noteId, TAGS.Tune);
    expect(ancestor).to.not.be.null;
    expect(ancestor!.tag).to.equal(TAGS.Tune);
  });

  it("returns null when node has no ancestor of that tag", () => {
    const root = toCSTree("X:1\nK:C\nCDE|\n");
    const tunes = findByTag(root, TAGS.Tune);
    // Tune has no Tune ancestor (it is a Tune, but not inside another Tune)
    const ancestor = findAncestorByTag(root, tunes[0].id, TAGS.Tune);
    expect(ancestor).to.be.null;
  });

  it("returns null when targetId is not found", () => {
    const root = toCSTree("X:1\nK:C\nCDE|\n");
    const ancestor = findAncestorByTag(root, 999999, TAGS.Tune);
    expect(ancestor).to.be.null;
  });
});
```

### Manual Testing (Kakoune Headless)

Use the Kakoune headless testing methodology to verify that `hx` selects the tune when cursor is on a note:

1. Create a test ABC file with notes inside a tune
2. Position cursor on a note
3. Execute `hx` (tune selector)
4. Verify the selection expands to cover the entire tune

If the TypeScript test infrastructure in `abc-kak/test/` is functional, we can use `KakouneSession` to automate this. Otherwise, manual testing is required.

### To Do

- Add `findAncestorByTag` function in `editor/src/selectors/treeWalk.ts`
- Rewrite `selectTune()` in `editor/src/selectors/structureSelectors.ts` to use the new approach
- Add tests for `findAncestorByTag` in `editor/tests/treeWalk.spec.ts`
- Update tests in `editor/tests/structureSelectors.spec.ts`
- Attempt Kakoune headless test; if infrastructure fails, perform manual test
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.
