# Kakoune Plugin Integration Testing with tmux

## Table of Contents

1. [Overview](#overview)
2. [Sources](#sources)
3. [Outline](#outline)
4. [Phase 1: Update KakouneSession to use tmux](#phase-1-update-kakounesession-to-use-tmux)
5. [Phase 2: Verify LSP integration with minimal tests](#phase-2-verify-lsp-integration-with-minimal-tests)

---

## Overview

Modify the abc-kak test infrastructure to use tmux instead of `kak -d`, enabling full LSP lifecycle testing for selectors and transforms.

## Sources

The following files from the kak-lsp repository informed this design:

- `test/lib.sh` - Core test infrastructure showing tmux session creation, kakoune startup inside tmux, kak-lsp initialization, and cleanup
- `test/run` - Test runner showing how tests are executed
- `test/gopls-goto-definition.sh` - Example integration test showing the full flow from file creation to command execution to assertion

Repository: https://github.com/kakoune-lsp/kakoune-lsp/tree/master/test

## Outline

### Phase 1: Update KakouneSession to use tmux

Replace the `kak -d` daemon approach with tmux-based session management. This provides a pseudo-TTY and window context required for LSP hooks to fire.

Reference: `test/lib.sh` from kak-lsp (functions `test_tmux_kak_start`, `test_cleanup`, `test_tmux`)

Changes:
- Add tmuxSocket property
- Modify `start()` to create tmux session and launch kak inside it
- Add `loadKakLsp()` method
- Add `loadAbcPlugin()` method
- Add `editAndWaitForLsp()` method with socket waiting
- Add `commandAndQuery()` method for selector/transform testing
- Modify `cleanup()` to kill tmux server

Testing:
- Example: session starts and kak responds to commands
- Example: cleanup properly terminates tmux and kak
- Property: multiple sequential sessions do not interfere with each other


### Phase 2: Verify LSP integration with minimal tests

Add one test for selectors and one test for transforms to verify the full LSP lifecycle works through the test infrastructure. These are not thorough tests of selector/transform behavior; they only prove the mechanism works.

Reference: `test/gopls-goto-definition.sh` from kak-lsp (pattern of file creation, command execution, result capture)

Changes:
- Add one selector test (e.g., voice selector)
- Add one transform test (e.g., transpose)

Testing:
- Example: selector returns valid selection descriptors (proves socket communication works)
- Example: transform modifies buffer content (proves edit application works)

---

## Phase 1: Update KakouneSession to use tmux

### Reference

`test/lib.sh` from kak-lsp repository, specifically:
- `test_tmux()` - wrapper that manages tmux socket path
- `test_tmux_kak_start()` - creates tmux session, starts kakoune inside it
- `test_cleanup()` - kills kakoune, tmux, removes temp files

### File to modify

`abc-kak/test/helpers/kakoune-session.ts`

### Target implementation

```typescript
import { execSync, spawn, ChildProcess } from 'child_process';
import { readFileSync, unlinkSync, existsSync } from 'fs';
import { dirname, join } from 'path';
import { createConnection } from 'net';

function computeSocketPath(): string {
  const xdgRuntimeDir = process.env.XDG_RUNTIME_DIR;
  if (xdgRuntimeDir) {
    return join(xdgRuntimeDir, 'abc-lsp.sock');
  }
  const user = process.env.USER || process.env.USERNAME || 'unknown';
  return join('/tmp', `abc-lsp-${user}`, 'lsp.sock');
}

async function waitForSocket(socketPath: string, timeout: number): Promise<void> {
  const start = Date.now();
  while (Date.now() - start < timeout) {
    if (existsSync(socketPath)) {
      const ready = await checkSocketReady(socketPath);
      if (ready) return;
    }
    await new Promise((r) => setTimeout(r, 100));
  }
  throw new Error(`Socket not ready after ${timeout}ms: ${socketPath}`);
}

function checkSocketReady(socketPath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const client = createConnection(socketPath, () => {
      client.destroy();
      resolve(true);
    });
    client.on('error', () => resolve(false));
    client.setTimeout(500, () => {
      client.destroy();
      resolve(false);
    });
  });
}

function randomId(): string {
  return Math.random().toString(36).substring(2, 8);
}

export class KakouneSession {
  session: string;
  tmuxSocket: string;
  resultFifo: string;
  currentBuffer: string | null = null;
  kakLspProcess: ChildProcess | null = null;
  socketPath: string;

  constructor() {
    // Include random component to prevent session name collisions in parallel test runs
    this.session = `test-${process.pid}-${Date.now()}-${randomId()}`;
    this.tmuxSocket = `/tmp/tmux-${this.session}.sock`;
    this.resultFifo = `/tmp/kak-result-${this.session}.fifo`;
    this.socketPath = computeSocketPath();
  }

  start(): void {
    // Remove stale FIFO if it exists from a previous crashed run
    if (existsSync(this.resultFifo)) {
      unlinkSync(this.resultFifo);
    }

    execSync(`mkfifo ${this.resultFifo}`);
    execSync(`tmux -S ${this.tmuxSocket} new-session -d -x 80 -y 24 -s ${this.session}`);
    execSync(`tmux -S ${this.tmuxSocket} send-keys -t ${this.session} 'kak -s ${this.session}' Enter`);
    execSync('sleep 0.3');

    // Verify kakoune started successfully by querying the session name
    try {
      const sessionName = this.query('$kak_session');
      if (sessionName.trim() !== this.session) {
        throw new Error(`Kakoune session mismatch: expected ${this.session}, got ${sessionName.trim()}`);
      }
    } catch (e) {
      this.cleanup();
      throw new Error(`Kakoune failed to start: ${e}`);
    }
  }

  loadKakLsp(): void {
    // Pre-flight check: verify kak-lsp is available
    try {
      execSync('which kak-lsp', { encoding: 'utf-8' });
    } catch {
      throw new Error('kak-lsp is not installed or not in PATH');
    }

    const kakLspScript = execSync('kak-lsp', { encoding: 'utf-8' });
    this.send(kakLspScript);
    this.kakLspProcess = spawn('kak-lsp', ['--session', this.session], {
      detached: true,
      stdio: 'ignore',
    });
    execSync('sleep 0.3');
  }

  loadAbcPlugin(): void {
    const rcDir = join(dirname(dirname(__dirname)), 'rc');
    const filesToSource = ['abc.kak', 'abc-selectors.kak', 'abc-transforms.kak', 'abc-modes.kak'];

    for (const file of filesToSource) {
      const filePath = join(rcDir, file);
      if (existsSync(filePath)) {
        this.send(`source ${filePath}`);
      }
    }

    const clientPath = join(dirname(dirname(__dirname)), 'dist', 'abc-kak-client.js');
    const serverPath = join(dirname(dirname(__dirname)), 'dist', 'server.js');

    this.send(`set-option global abc_client_path ${clientPath}`);
    this.send(`set-option global abc_server_path ${serverPath}`);
    this.send(`set-option global abc_socket_path ${this.socketPath}`);
  }

  send(commands: string): void {
    execSync(`kak -p ${this.session}`, { input: commands });
  }

  edit(filePath: string): void {
    this.send(`edit ${filePath}`);
    this.currentBuffer = filePath;
  }

  async editAndWaitForLsp(filePath: string, timeout = 5000): Promise<void> {
    this.send(`edit ${filePath}`);
    this.currentBuffer = filePath;
    await waitForSocket(this.socketPath, timeout);
  }

  executeKeys(keys: string): void {
    if (this.currentBuffer) {
      this.send(`evaluate-commands -buffer ${this.currentBuffer} %{ execute-keys '${keys}' }`);
    } else {
      this.send(`execute-keys '${keys}'`);
    }
  }

  query(kakExpr: string, buffer?: string): string {
    const writeCmd = `nop %sh{ printf '%s' "${kakExpr}" > ${this.resultFifo} }`;
    if (buffer) {
      this.send(`evaluate-commands -buffer ${buffer} %{ ${writeCmd} }`);
    } else {
      this.send(writeCmd);
    }
    return readFileSync(this.resultFifo, 'utf-8');
  }

  executeAndQuery(keys: string, kakExpr: string): string {
    if (!this.currentBuffer) {
      throw new Error('No buffer set. Call edit() first.');
    }
    const cmd = `evaluate-commands -buffer ${this.currentBuffer} %{
      execute-keys '${keys}'
      nop %sh{ printf '%s' "${kakExpr}" > ${this.resultFifo} }
    }`;
    this.send(cmd);
    return readFileSync(this.resultFifo, 'utf-8');
  }

  commandAndQuery(command: string, kakExpr: string): string {
    if (!this.currentBuffer) {
      throw new Error('No buffer set. Call edit() first.');
    }
    const cmd = `evaluate-commands -buffer ${this.currentBuffer} %{
      try %{
        ${command}
      } catch %{
        echo -debug "Command error: %val{error}"
      }
      nop %sh{ printf '%s' "${kakExpr}" > ${this.resultFifo} }
    }`;
    this.send(cmd);
    try {
      const result = execSync(`timeout 5 cat ${this.resultFifo}`, { encoding: 'utf-8' });
      return result;
    } catch (e) {
      throw new Error(`FIFO read timed out after command: ${command}`);
    }
  }

  getSelection(): string {
    return this.query('$kak_selection', this.currentBuffer ?? undefined);
  }

  getSelections(): string[] {
    const raw = this.query('$kak_selections', this.currentBuffer ?? undefined);
    return raw.split(':');
  }

  getSelectionsDesc(): string {
    return this.query('$kak_selections_desc', this.currentBuffer ?? undefined);
  }

  cleanup(): void {
    try {
      this.send('quit!');
    } catch {
      // Session may already be closed
    }
    if (this.kakLspProcess) {
      this.kakLspProcess.kill();
      this.kakLspProcess = null;
    }
    try {
      execSync(`tmux -S ${this.tmuxSocket} kill-server`);
    } catch {
      // tmux may already be gone
    }
    try {
      unlinkSync(this.resultFifo);
    } catch {
      // FIFO may not exist
    }
    try {
      unlinkSync(this.tmuxSocket);
    } catch {
      // tmux socket may not exist
    }
    // Clean up LSP socket to prevent interference with subsequent test runs
    try {
      unlinkSync(this.socketPath);
    } catch {
      // LSP socket may not exist or may be owned by another process
    }
  }
}
```

### Testing

Example-based tests (in the test file):
1. Basic session test: start session, send command, verify response
2. Cleanup test: after cleanup, tmux session no longer exists

Property-based test:
1. Run 5 sequential test sessions; verify no socket/fifo collisions

### To do

1. Replace entire content of `abc-kak/test/helpers/kakoune-session.ts` with target implementation above
2. Verify existing basic tests still pass (navigation tests that do not use LSP)
3. Final verification: build and tests both pass
4. Call the code review agent. Address any feedback.
5. Commit once the build passes and all tests pass.

---

## Phase 2: Verify LSP integration with minimal tests

### Reference

`test/gopls-goto-definition.sh` from kak-lsp repository:
- Pattern of creating a test file with specific content
- Opening the file in kakoune
- Executing commands that trigger LSP features
- Capturing and asserting on the result

### File to modify

`abc-kak/test/abc-selectors.test.ts`

### Target implementation

```typescript
import { expect } from 'chai';
import { writeFileSync, unlinkSync } from 'fs';
import { KakouneSession } from './helpers/kakoune-session';

describe('abc-kak selectors', () => {
  let kak: KakouneSession;
  let testFile: string;

  beforeEach(() => {
    kak = new KakouneSession();
    testFile = `/tmp/test-${kak.session}.abc`;
    kak.start();
  });

  afterEach(() => {
    kak.cleanup();
    try {
      unlinkSync(testFile);
    } catch {
      // File may not exist
    }
  });

  describe('basic navigation (no LSP)', () => {
    it('selects a single note', () => {
      writeFileSync(testFile, `X:1\nT:Test\nK:C\nCDEFGABc\n`);
      kak.edit(testFile);
      const selection = kak.executeAndQuery('gg3j', '$kak_selection');
      expect(selection).to.equal('C');
    });

    it('can navigate to a specific position', () => {
      writeFileSync(testFile, `X:1\nT:Test\nK:C\n[V:1] CDEFGABc\n`);
      kak.edit(testFile);
      const selection = kak.executeAndQuery('gg3j6l', '$kak_selection');
      expect(selection).to.equal('C');
    });
  });

  describe('LSP integration', function () {
    this.timeout(15000);

    beforeEach(() => {
      kak.loadKakLsp();
      kak.loadAbcPlugin();
    });

    it('selector returns valid selection descriptors', async () => {
      const input = `X:1
T:Test
M:4/4
L:1/4
V:1 name=A clef=treble
V:2 name=B clef=bass
K:C
[V:1] CDEF | GABc
[V:2] FGAB | cdef
`;
      writeFileSync(testFile, input);

      await kak.editAndWaitForLsp(testFile);
      kak.executeKeys('%');

      const selectionsDesc = kak.commandAndQuery('abc-select-voices 1', '$kak_selections_desc');

      // Verify we got valid selection descriptors (not the default 1.1,1.1)
      expect(selectionsDesc).to.not.equal('1.1,1.1');
      // Verify format matches kakoune selection descriptor pattern
      expect(selectionsDesc).to.match(/^\d+\.\d+,\d+\.\d+/);
    });

    it('transform modifies buffer content', async () => {
      const input = `X:1
T:Test
K:C
CDEF
`;
      writeFileSync(testFile, input);

      await kak.editAndWaitForLsp(testFile);
      kak.executeKeys('gg3jx');  // select first note C

      // Verify we selected the correct note before running transform
      const initialSelection = kak.getSelection();
      expect(initialSelection).to.equal('C');

      kak.commandAndQuery('abc-transpose 12', '$kak_selection');

      // Read the buffer content to verify the note was transposed
      const bufferContent = kak.query('%val{selection}');
      // C transposed by 12 semitones should become c (one octave up)
      expect(bufferContent).to.include('c');
    });
  });
});
```

### Testing

These tests are the verification themselves:
- Example 1: selector test proves socket communication works (server receives request, returns ranges, kakoune applies selection)
- Example 2: transform test proves edit application works (server receives request, returns edits, kakoune applies them)

### To do

1. Replace entire content of `abc-kak/test/abc-selectors.test.ts` with target implementation above
2. Run tests to verify both basic navigation tests and LSP integration tests pass
3. Final verification: build and tests both pass
4. Call the code review agent. Address any feedback.
5. Commit once the build passes and all tests pass.

