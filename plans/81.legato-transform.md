# Legato Transform

## Table of Contents

1. [Outline](#outline)
2. [Specification](#specification)
3. [Phase 1: Consolidation Utility Extraction](#phase-1-consolidation-utility-extraction)
4. [Phase 2: Core Legato Transform Implementation](#phase-2-core-legato-transform-implementation)
5. [Phase 3: Language Server and VSCode Integration](#phase-3-language-server-and-vscode-integration)

## Outline

The legato transform fills rests and y-spacers between notes or chords with tied copies of the preceding note or chord. This creates a sustained, connected (legato) sound where previously there were gaps. The transform works in three steps: (1) iterate through the selection left-to-right, (2) replace rests/y-spacers with tied copies of the last seen note/chord, and (3) consolidate the resulting tied sequences within each bar.

Phase 1 extracts the shared consolidation logic from the existing `consolidateRests` transform into a utility module, so that both `consolidateRests` and the new `legato` transform can reuse it.

Phase 2 implements the core legato algorithm: iterating through cursors, tracking the current source note/chord, cloning it when a rest or y-spacer is encountered, adding ties, and then consolidating tied sequences within bars.

Phase 3 integrates the transform into the language server (via `transformLookup.ts`) and the VSCode extension (via `transformCommands.ts` and `package.json`).

## Specification

### Transform: `legato`

### Sources
Notes and Chords can serve as the source for filling rests.

### Cannot be sources
Grace groups, multi-measure rests, rests, and y-spacers cannot serve as sources.

### Targets
Rests and y-spacers are the targets that get replaced by tied copies of the source.

### Algorithm Pseudo-code

```
for each cursor in selection:
  currentSource = null
  replacements = []

  for each element in cursor (left-to-right, descending into beams):
    if element is voice marker:
      currentSource = null  // voice markers are boundaries
      continue

    if element is Note or Chord:
      currentSource = element
      continue

    if element is Rest or YSpacer AND currentSource exists:
      // Replace rest with tied copy of currentSource
      newNode = clone(currentSource)
      newNode.rhythm = element.rhythm
      addTie(currentSource)  // tie on the source
      replacements.push({old: element, new: newNode})
      currentSource = newNode  // chain continues

  apply replacements
  consolidate tied notes within each bar (same pitch only, octave matters)
```

### Examples

| Input | After Replacement | After Consolidation |
|-------|-------------------|---------------------|
| `CzD` | `C-C-D` | `C2D` |
| `CzzzD` | `C-C-C-C-D` | `C4D` |
| `C z \| z z D` | `C-C- \| C-C-D` | `C2- \| C2D` |
| `[CE] z G` | `[CE]-[CE]-G` | `[CE]2 G` |
| `C z z z \|` (end) | `C4 \|` (no trailing tie) | `C4 \|` |
| Selection `C z z` with `D` after (outside selection) | `C3` (no tie to outside) | `C3` |

### Boundary conditions

1. Voice markers reset the current source because different voices are musically independent.
2. Multi-measure rests (Z) reset the current source because they represent multiple bars of silence and should not be filled.
3. Bar lines do not reset the current source, but the consolidation phase treats bar lines as boundaries (ties across bars are preserved, but consolidation only combines tied notes within the same bar).
4. Selection boundaries are respected: if a rest is outside the cursor set, it is not transformed.
5. Grace groups do not act as boundaries and do not reset the current source. They are preserved in the output as-is. However, grace groups between tied notes prevent consolidation because the consolidation algorithm only consolidates adjacent notes in the sibling chain.

### Node traversal notes

1. System wrapper nodes have synthetic IDs. The traversal must descend into System nodes without checking selection membership, otherwise tune body content will be skipped.
2. The `collectSelectedNodes` and `collectNotesAndChordsInOrder` functions must return nodes in document order (left-to-right, depth-first). This ordering is critical for the consolidation and trailing tie removal to work correctly.
3. Because `getNodeRhythm` returns `{1, 1}` for nodes without a Rhythm child, y-spacers with no explicit rhythm will default to unit length, which is the expected behavior.

---

## Phase 1: Consolidation Utility Extraction

### Goal

We need to extract the tied-note consolidation logic from `consolidateRests` into a shared utility module so that both `consolidateRests` and the new `legato` transform can reuse it. Because the consolidation algorithm for tied notes differs from the one for rests (tied notes compare pitch identity, not just duration), we will create a new module with the common infrastructure and a configurable predicate.

### Background

The existing `consolidateRests` transform consolidates consecutive identical rests into a single rest with doubled duration. For the legato transform, we need a similar consolidation for tied notes: if we have `C-C-C-D`, we want to produce `C3 D` (or `C2-C-D` depending on power-of-two constraints).

The consolidation logic shares these elements:
- Iterating left-to-right through siblings
- Skipping whitespace to find the next meaningful sibling
- Checking for bar lines and voice markers as boundaries
- Checking that durations are equal and that the result is a power-of-two
- Summing durations and updating the rhythm of the first element
- Removing the second element from the tree

The difference is in what constitutes "same" elements:
- For rests: same rest type (`z` vs `x`) and same duration
- For tied notes: the first element must have a tie, and both must have identical pitch (including octave)

### Approach

Because the differences are significant (comparing rest types vs comparing pitches, and the tie requirement), we will implement a separate consolidation function for tied notes rather than trying to parameterize the existing rest consolidation. However, we will extract the common helper functions into a shared utility module.

### Files to Create/Modify

| File | Action |
|------|--------|
| `editor/src/transforms/consolidationUtils.ts` | Create: shared utilities |
| `editor/src/transforms/consolidateTiedNotes.ts` | Create: new consolidation for tied notes |
| `editor/src/transforms/consolidateRests.ts` | Modify: import from consolidationUtils |
| `editor/src/transforms/index.ts` | Add exports |
| `editor/tests/consolidateTiedNotes.spec.ts` | Create: tests for tied note consolidation |

### consolidationUtils.ts

This module will contain the shared helper functions.

```typescript
// editor/src/transforms/consolidationUtils.ts

import { CSNode, TAGS, isTokenNode, getTokenData } from "../csTree/types";
import { IRational, TT } from "abc-parser";

/**
 * Checks if a number is a power of two.
 */
export function isPowerOfTwo(n: number): boolean {
  return n > 0 && (n & (n - 1)) === 0;
}

/**
 * Checks if a rational is a power-of-two ratio (2^n / 2^m for integers n, m >= 0).
 */
export function isPowerOfTwoRational(r: IRational): boolean {
  return isPowerOfTwo(r.numerator) && isPowerOfTwo(r.denominator);
}

/**
 * Checks if two rationals are equal.
 */
export function equalRational(a: IRational, b: IRational): boolean {
  return a.numerator === b.numerator && a.denominator === b.denominator;
}

/**
 * Skips whitespace nodes to find the next meaningful sibling.
 */
export function nextMeaningfulSibling(node: CSNode): CSNode | null {
  let current = node.nextSibling;
  while (current !== null) {
    if (isTokenNode(current)) {
      const tokenData = getTokenData(current);
      if (tokenData.tokenType === TT.WS) {
        current = current.nextSibling;
        continue;
      }
    }
    return current;
  }
  return null;
}

/**
 * Checks if a node is an inline field containing a voice directive [V:...].
 */
export function isVoiceChangingField(node: CSNode): boolean {
  if (node.tag !== TAGS.Inline_field) {
    return false;
  }
  let current = node.firstChild;
  while (current !== null) {
    if (isTokenNode(current)) {
      const tokenData = getTokenData(current);
      if (tokenData.tokenType === TT.INF_HDR && tokenData.lexeme.startsWith("V")) {
        return true;
      }
    }
    current = current.nextSibling;
  }
  return false;
}
```

### consolidateTiedNotes.ts

This module implements the consolidation of tied notes with identical pitch.

```typescript
// editor/src/transforms/consolidateTiedNotes.ts

import { Selection } from "../selection";
import { CSNode, TAGS, isNote, isChord, isBarLine, isTokenNode, getTokenData, isBeam } from "../csTree/types";
import { ABCContext, IRational, addRational, TT } from "abc-parser";
import { findNodesById } from "./types";
import { getNodeRhythm, rationalToRhythm } from "./rhythm";
import { findParent, removeChild, replaceRhythm, findTieChild, findChildByTag } from "./treeUtils";
import { isPowerOfTwoRational, equalRational, nextMeaningfulSibling, isVoiceChangingField } from "./consolidationUtils";

/**
 * Extracts the pitch lexeme string from a Note node.
 * The lexeme includes the note letter, accidental, and octave markers.
 * Example outputs: "C,", "^F", "_B'".
 * Returns null if pitch cannot be extracted.
 */
function getPitchLexeme(noteNode: CSNode): string | null {
  const pitchResult = findChildByTag(noteNode, TAGS.Pitch);
  if (!pitchResult) return null;

  const pitchNode = pitchResult.node;
  let identity = "";
  let current = pitchNode.firstChild;
  while (current !== null) {
    if (isTokenNode(current)) {
      identity += getTokenData(current).lexeme;
    }
    current = current.nextSibling;
  }
  return identity || null;
}

/**
 * Checks if a Note node has a tie token.
 */
function hasTie(node: CSNode): boolean {
  return findTieChild(node) !== null;
}

/**
 * Checks if two notes have identical pitch (same letter, accidental, octave).
 */
function samePitch(a: CSNode, b: CSNode): boolean {
  const pitchA = getPitchLexeme(a);
  const pitchB = getPitchLexeme(b);
  return pitchA !== null && pitchB !== null && pitchA === pitchB;
}

/**
 * Extracts pitch identities for all notes in a chord.
 * Returns sorted array of pitch identity strings.
 */
function getChordPitchLexemes(chordNode: CSNode): string[] {
  const identities: string[] = [];
  let child = chordNode.firstChild;
  while (child !== null) {
    if (child.tag === TAGS.Note) {
      const identity = getPitchLexeme(child);
      if (identity) {
        identities.push(identity);
      }
    }
    child = child.nextSibling;
  }
  return identities.sort();
}

/**
 * Checks if two chords have identical pitch content.
 */
function sameChordPitches(a: CSNode, b: CSNode): boolean {
  const pitchesA = getChordPitchLexemes(a);
  const pitchesB = getChordPitchLexemes(b);
  if (pitchesA.length !== pitchesB.length) return false;
  for (let i = 0; i < pitchesA.length; i++) {
    if (pitchesA[i] !== pitchesB[i]) return false;
  }
  return true;
}

/**
 * Removes the tie token from a node (Note or Chord).
 */
function removeTie(node: CSNode): void {
  const tieResult = findTieChild(node);
  if (tieResult) {
    if (tieResult.prev === null) {
      node.firstChild = tieResult.node.nextSibling;
    } else {
      tieResult.prev.nextSibling = tieResult.node.nextSibling;
    }
    tieResult.node.nextSibling = null;
  }
}

/**
 * Collects nodes from a sibling chain that match the specified IDs.
 * Recursively descends into Beam and System nodes.
 *
 * The traversal is left-to-right, depth-first, which produces document order.
 * This ordering is critical for the consolidation pass to work correctly.
 */
function collectSelectedNodes(
  startNode: CSNode | null,
  selectedIds: Set<number>,
  result: CSNode[]
): void {
  let current = startNode;
  while (current !== null) {
    if (selectedIds.has(current.id)) {
      result.push(current);
    }
    // We descend into Beam and System nodes to find their children.
    // System nodes have synthetic IDs, so we descend without checking membership.
    if (isBeam(current) || current.tag === TAGS.System) {
      collectSelectedNodes(current.firstChild, selectedIds, result);
    }
    current = current.nextSibling;
  }
}

/**
 * Performs a single pass of tied note consolidation within one bar.
 * Returns true if any consolidation was performed.
 *
 * Consolidation only occurs between adjacent notes/chords in the sibling chain.
 * Grace notes and other elements between tied notes prevent consolidation because
 * `nextMeaningfulSibling` will return the grace group, not the next note.
 */
function consolidateBarPass(
  barNodes: CSNode[],
  consumedIds: Set<number>,
  ctx: ABCContext,
  root: CSNode,
  cursor: Set<number>
): boolean {
  let changed = false;

  for (const node of barNodes) {
    if (consumedIds.has(node.id)) continue;
    if (!isNote(node) && !isChord(node)) continue;
    if (!hasTie(node)) continue;

    const rhythm1 = getNodeRhythm(node);
    const next = nextMeaningfulSibling(node);

    if (next === null) continue;
    if (isBarLine(next) || isVoiceChangingField(next)) continue;

    // Check if next is the same type and has same pitch content
    if (isNote(node) && isNote(next)) {
      if (!samePitch(node, next)) continue;
    } else if (isChord(node) && isChord(next)) {
      if (!sameChordPitches(node, next)) continue;
    } else {
      continue; // Different types, cannot consolidate
    }

    const rhythm2 = getNodeRhythm(next);
    if (!equalRational(rhythm1, rhythm2)) continue;

    const summed = addRational(rhythm1, rhythm2);
    if (!isPowerOfTwoRational(summed)) continue;

    // Perform the consolidation
    const newRhythm = rationalToRhythm(summed, ctx);
    replaceRhythm(node, newRhythm);

    // If next has a tie, preserve it on node; otherwise remove tie from node
    if (hasTie(next)) {
      // Keep the tie on node (it was already there)
    } else {
      // Remove the tie from node since the chain ends here
      removeTie(node);
    }

    // Remove the next node from the tree
    const parentResult = findParent(root, next);
    if (parentResult !== null) {
      removeChild(parentResult.parent, parentResult.prev, next);
    }

    consumedIds.add(next.id);
    cursor.delete(next.id);
    changed = true;
  }

  return changed;
}

/**
 * Splits nodes into groups separated by bar lines.
 */
function splitByBarLines(nodes: CSNode[]): CSNode[][] {
  const bars: CSNode[][] = [];
  let currentBar: CSNode[] = [];

  for (const node of nodes) {
    if (isBarLine(node)) {
      if (currentBar.length > 0) {
        bars.push(currentBar);
        currentBar = [];
      }
    } else {
      currentBar.push(node);
    }
  }

  if (currentBar.length > 0) {
    bars.push(currentBar);
  }

  return bars;
}

/**
 * Consolidates tied notes with identical pitch within each bar.
 *
 * This function finds consecutive tied notes (or chords) with the same pitch
 * and equal power-of-two durations, combining them into a single note with
 * summed duration. The consolidation respects bar boundaries: ties that cross
 * bar lines are preserved, but consolidation only happens within a bar.
 *
 * The transform is idempotent: it loops until no more consolidations are possible.
 */
export function consolidateTiedNotes(selection: Selection, ctx: ABCContext): Selection {
  const consumedIds = new Set<number>();

  for (const cursor of selection.cursors) {
    // Collect all selected nodes in document order
    const nodes: CSNode[] = [];
    collectSelectedNodes(selection.root.firstChild, cursor, nodes);

    // Split into bars
    const bars = splitByBarLines(nodes);

    // Consolidate each bar until no changes
    for (const barNodes of bars) {
      let changed = true;
      while (changed) {
        changed = consolidateBarPass(barNodes, consumedIds, ctx, selection.root, cursor);
      }
    }
  }

  return selection;
}
```

### Changes to consolidateRests.ts

We need to update the import statements to use the shared utilities.

```typescript
// At the top of consolidateRests.ts, change:

// Old imports of local functions:
// function isPowerOfTwo(n: number): boolean { ... }
// function isPowerOfTwoRational(r: IRational): boolean { ... }
// function equalRational(a: IRational, b: IRational): boolean { ... }
// function nextMeaningfulSibling(node: CSNode): CSNode | null { ... }
// function isVoiceChangingField(node: CSNode): boolean { ... }

// New import:
import { isPowerOfTwo, isPowerOfTwoRational, equalRational, nextMeaningfulSibling, isVoiceChangingField } from "./consolidationUtils";

// Remove the local definitions of these functions.
```

### Changes to index.ts

```typescript
// Add to editor/src/transforms/index.ts:

export { consolidateTiedNotes } from "./consolidateTiedNotes";
export { isPowerOfTwo, isPowerOfTwoRational, equalRational, nextMeaningfulSibling, isVoiceChangingField } from "./consolidationUtils";
```

### Testing

Create `editor/tests/consolidateTiedNotes.spec.ts`.

Example-based tests:
- `C-C |` consolidates to `C2 |` (tie removed)
- `C-C-C |` consolidates to `C2-C |` (only first pair consolidates since result must be power-of-two)
- `C-D |` stays unchanged (different pitches)
- `C,-C |` stays unchanged (different octaves)
- `[CE]-[CE] |` consolidates to `[CE]2 |`
- `[CE]-[EC] |` consolidates to `[CE]2 |` (sorted comparison normalizes order)
- `C-C | C-C |` consolidates within bars: `C2 | C2 |`
- `C- | C |` cross-bar tie preserved, no consolidation across bar (tie on first C remains)
- `C-C2 |` stays unchanged (different durations)
- `C-C-C-C |` consolidates to `C4 |` (multiple passes: C2-C-C -> C2-C2 -> C4)
- Bar line inside beam acts as boundary: notes before and after bar line consolidate separately
- `C-{B}C |` stays unchanged (grace notes between tied notes prevent consolidation)

Property-based tests:
- Idempotence: applying twice yields the same result as once
- Total duration preserved: sum of note durations before equals sum after
- Note/chord count is non-increasing
- Pitch content is preserved (no pitch changes)
- No orphaned ties: every note with a tie has a following note with the same pitch in the same bar

### To Do List for Phase 1

1. Create `editor/src/transforms/consolidationUtils.ts` with the shared helper functions.
2. Create `editor/src/transforms/consolidateTiedNotes.ts` with the tied note consolidation logic.
3. Update `editor/src/transforms/consolidateRests.ts` to import from `consolidationUtils` and remove duplicate function definitions.
4. Update `editor/src/transforms/index.ts` to export the new functions.
5. Create `editor/tests/consolidateTiedNotes.spec.ts` with example-based and property-based tests.
6. Final verification: build and tests both pass.
7. Call the code review agent. Address any feedback.
8. Commit once the build passes and all tests pass.

---

## Phase 2: Core Legato Transform Implementation

### Goal

We will implement the core `legato` transform that replaces rests and y-spacers with tied copies of the preceding note or chord, then consolidates the result using the `consolidateTiedNotes` function created in Phase 1.

### Files to Create/Modify

| File | Action |
|------|--------|
| `editor/src/transforms/legato.ts` | Create: main transform implementation |
| `editor/src/transforms/index.ts` | Modify: add export for legato |
| `editor/src/index.ts` | Modify: add legato to transforms export block |
| `editor/tests/legato.spec.ts` | Create: example-based and property-based tests |

### Dependencies from Phase 1

This phase depends on the following exports from Phase 1:
- `isVoiceChangingField` from `editor/src/transforms/consolidationUtils.ts`
- `consolidateTiedNotes` from `editor/src/transforms/consolidateTiedNotes.ts`

### Algorithm

The legato transform works in three stages:

```
Stage 1: Replacement Pass
  for each cursor in selection.cursors:
    currentSource = null
    replacements = []

    traverse tree left-to-right, descending into Beams:
      for each node:
        skip if node.id not in cursor (selection boundary)

        if node is voice marker [V:...]:
          currentSource = null
          continue

        if node is Note or Chord:
          currentSource = node
          continue

        if node is Rest (not MultiMeasureRest) or YSpacer:
          if currentSource is not null:
            cloned = structuredClone(currentSource)
            reassign fresh IDs to cloned subtree
            copy rhythm from node (rest/y-spacer) to cloned
            add tie token to currentSource (if not already present)
            record replacement: {old: node, new: cloned}
            currentSource = cloned (chain continues)

    apply all replacements to tree
    update cursor: remove old IDs, add new IDs

Stage 2: Consolidation
  call consolidateTiedNotes(selection, ctx)

Stage 3: Trailing Tie Removal
  for each cursor:
    find last note/chord in cursor (document order)
    if it has a tie and no following note/chord is in cursor:
      remove the tie token
```

### File: editor/src/transforms/legato.ts

Create this file with the following content.

#### Imports

```typescript
import { Selection } from "../selection";
import { CSNode, TAGS, isNote, isChord, isYSpacer, isBeam, createCSNode } from "../csTree/types";
import { ABCContext, TT } from "abc-parser";
import { findParent, replaceChild, findTieChild, replaceRhythm, appendChild, removeChild } from "./treeUtils";
import { getNodeRhythm, rationalToRhythm } from "./rhythm";
import { isVoiceChangingField } from "./consolidationUtils";
import { consolidateTiedNotes } from "./consolidateTiedNotes";
import { reassignIds } from "./lineUtils";
```

The imports are:
- `Selection` from `../selection`: the type representing the selection structure with root and cursors
- `CSNode`, `TAGS`, `isNote`, `isChord`, `isYSpacer`, `isBeam`, `createCSNode` from `../csTree/types`: CSTree node type and type guards
- `ABCContext`, `TT` from `abc-parser`: the context for ID generation and token type enum
- `findParent`, `replaceChild`, `findTieChild`, `replaceRhythm`, `appendChild`, `removeChild` from `./treeUtils`: tree manipulation utilities
- `getNodeRhythm`, `rationalToRhythm` from `./rhythm`: rhythm extraction and creation
- `isVoiceChangingField` from `./consolidationUtils`: Phase 1 utility for detecting voice markers
- `consolidateTiedNotes` from `./consolidateTiedNotes`: Phase 1 consolidation function
- `reassignIds` from `./lineUtils`: assigns fresh IDs to a cloned subtree

#### Type Definitions

```typescript
interface ReplacementRecord {
  old: CSNode;
  new: CSNode;
  parent: CSNode;
  prev: CSNode | null;
}

interface LegatoContext {
  currentSource: CSNode | null;
  replacements: ReplacementRecord[];
  selectedIds: Set<number>;
  ctx: ABCContext;
  root: CSNode;
}
```

The `ReplacementRecord` stores information needed to perform a node replacement in the tree. The `LegatoContext` is passed through the traversal to accumulate state.

#### Helper Functions

```typescript
function isRegularRest(node: CSNode): boolean {
  // We only target regular rests (TAGS.Rest), not multi-measure rests (TAGS.MultiMeasureRest).
  // Because multi-measure rests represent multiple bars of silence, filling them with tied notes
  // would be semantically incorrect.
  return node.tag === TAGS.Rest;
}

function isSource(node: CSNode): boolean {
  return isNote(node) || isChord(node);
}

function isTarget(node: CSNode): boolean {
  return isRegularRest(node) || isYSpacer(node);
}

function cloneNode(node: CSNode, ctx: ABCContext): CSNode {
  // We use structuredClone for a deep copy, then reassign fresh IDs to avoid ID collisions.
  const cloned = structuredClone(node);
  reassignIds(cloned, ctx);
  return cloned;
}

function addTieToNode(node: CSNode, ctx: ABCContext): void {
  // If the node already has a tie, we do nothing.
  if (findTieChild(node) !== null) {
    return;
  }

  const tieToken = createCSNode(TAGS.Token, ctx.generateId(), {
    type: "token",
    lexeme: "-",
    tokenType: TT.TIE,
    line: 0,
    position: 0,
  });

  appendChild(node, tieToken);
}

function copyRhythmFromTarget(target: CSNode, clone: CSNode, ctx: ABCContext): void {
  // The clone inherits the rhythm of the target (rest or y-spacer) it replaces.
  // This ensures the musical duration is preserved.
  const targetRhythm = getNodeRhythm(target);
  const newRhythmNode = rationalToRhythm(targetRhythm, ctx);
  replaceRhythm(clone, newRhythmNode);
}
```

#### Traversal Function

```typescript
function isMultiMeasureRest(node: CSNode): boolean {
  return node.tag === TAGS.MultiMeasureRest;
}

function traverseSiblings(startNode: CSNode | null, legatoCtx: LegatoContext): void {
  let current = startNode;

  while (current !== null) {
    const next = current.nextSibling;

    // System nodes have synthetic IDs, so we descend into them without checking selection membership.
    // This is necessary because tune body content is wrapped in System nodes.
    if (current.tag === TAGS.System) {
      traverseSiblings(current.firstChild, legatoCtx);
      current = next;
      continue;
    }

    // We only process nodes that are in the selection.
    if (!legatoCtx.selectedIds.has(current.id)) {
      current = next;
      continue;
    }

    // Voice markers reset the current source because different voices are musically independent.
    if (isVoiceChangingField(current)) {
      legatoCtx.currentSource = null;
      current = next;
      continue;
    }

    // Multi-measure rests reset the current source because they represent multiple bars
    // of silence and should not be filled. They act as boundaries similar to voice markers.
    if (isMultiMeasureRest(current)) {
      legatoCtx.currentSource = null;
      current = next;
      continue;
    }

    // Notes and chords become the current source for subsequent rest filling.
    if (isSource(current)) {
      legatoCtx.currentSource = current;
      current = next;
      continue;
    }

    // Rests and y-spacers get replaced if we have a source to copy from.
    if (isTarget(current) && legatoCtx.currentSource !== null) {
      const cloned = cloneNode(legatoCtx.currentSource, legatoCtx.ctx);
      copyRhythmFromTarget(current, cloned, legatoCtx.ctx);
      addTieToNode(legatoCtx.currentSource, legatoCtx.ctx);

      const parentResult = findParent(legatoCtx.root, current);
      if (parentResult !== null) {
        legatoCtx.replacements.push({
          old: current,
          new: cloned,
          parent: parentResult.parent,
          prev: parentResult.prev,
        });
      }

      // The clone becomes the new source so that subsequent rests are tied to it.
      legatoCtx.currentSource = cloned;
      current = next;
      continue;
    }

    // We descend into Beam nodes to process their children.
    if (isBeam(current)) {
      traverseSiblings(current.firstChild, legatoCtx);
      current = next;
      continue;
    }

    current = next;
  }
}
```

#### Replacement Application

```typescript
function applyReplacements(replacements: ReplacementRecord[], cursor: Set<number>): void {
  for (const { old, new: newNode, parent, prev } of replacements) {
    replaceChild(parent, prev, old, newNode);
    cursor.delete(old.id);
    cursor.add(newNode.id);
  }
}
```

#### Trailing Tie Removal

Because the transform adds ties to chain notes together, we may end up with a trailing tie on the last note in the selection that has no target to connect to. We need to remove such ties.

```typescript
function collectNotesAndChordsInOrder(root: CSNode, cursor: Set<number>): CSNode[] {
  // We collect notes and chords in document order using recursive traversal.
  // The traversal is left-to-right, depth-first, which produces document order.
  const result: CSNode[] = [];

  function traverse(node: CSNode | null): void {
    while (node !== null) {
      if (cursor.has(node.id) && isSource(node)) {
        result.push(node);
      }
      // Descend into children (handles Beam, System, and other container nodes)
      if (node.firstChild !== null) {
        traverse(node.firstChild);
      }
      node = node.nextSibling;
    }
  }

  traverse(root.firstChild);
  return result;
}

function removeTrailingTie(cursor: Set<number>, root: CSNode): void {
  const notesAndChords = collectNotesAndChordsInOrder(root, cursor);

  if (notesAndChords.length === 0) {
    return;
  }

  // The last element in the document-ordered array has no successors in the cursor
  // by definition, so if it has a tie, that tie is trailing and should be removed.
  const last = notesAndChords[notesAndChords.length - 1];
  const tieResult = findTieChild(last);

  if (tieResult !== null) {
    // Remove the tie because this is the last note in the selection
    if (tieResult.prev === null) {
      last.firstChild = tieResult.node.nextSibling;
    } else {
      tieResult.prev.nextSibling = tieResult.node.nextSibling;
    }
    tieResult.node.nextSibling = null;
  }
}
```

#### Main Export Function

```typescript
/**
 * The legato transform fills rests and y-spacers between notes or chords
 * with tied copies of the preceding note or chord. This creates a sustained,
 * connected (legato) sound where previously there were gaps.
 *
 * The transform operates in three stages:
 * 1. Replacement: iterate through the selection left-to-right, replacing
 *    rests and y-spacers with tied copies of the preceding note/chord.
 * 2. Consolidation: consolidate consecutive tied notes with identical pitch
 *    within each bar.
 * 3. Trailing tie removal: remove any tie on the last note in the selection
 *    if it has no successor to connect to.
 *
 * Boundary conditions:
 * - Voice markers [V:...] reset the chain because different voices are independent.
 * - Bar lines do not reset the chain, but consolidation only operates within bars.
 * - Multi-measure rests are not replaced (they represent multiple bars of silence).
 * - Selection boundaries are respected: nodes outside the cursor are not modified.
 */
export function legato(selection: Selection, ctx: ABCContext): Selection {
  // Stage 1: Replacement pass
  for (const cursor of selection.cursors) {
    const legatoCtx: LegatoContext = {
      currentSource: null,
      replacements: [],
      selectedIds: cursor,
      ctx,
      root: selection.root,
    };

    traverseSiblings(selection.root.firstChild, legatoCtx);
    applyReplacements(legatoCtx.replacements, cursor);
  }

  // Stage 2: Consolidation
  consolidateTiedNotes(selection, ctx);

  // Stage 3: Trailing tie removal
  for (const cursor of selection.cursors) {
    removeTrailingTie(cursor, selection.root);
  }

  return selection;
}
```

### File: editor/src/transforms/index.ts

Add the following export at the end of the file, after the existing exports:

```typescript
export { legato } from "./legato";
```

### File: editor/src/index.ts

In the transforms export block (around line 49-96), add `legato` to the list. The block currently ends with `divideRhythm`. Add `legato` after it:

```typescript
export {
  // ... existing exports ...
  divideRhythm,
  legato,
} from "./transforms";
```

### Testing

Create the file `editor/tests/legato.spec.ts`.

#### Test File Structure

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import * as fc from "fast-check";
import { toCSTreeWithContext, formatSelection, findByTag } from "./helpers";
import { TAGS, isTokenNode, getTokenData } from "../src/csTree/types";
import { Selection } from "../src/selection";
import { legato } from "../src/transforms/legato";
import { getNodeRhythm } from "../src/transforms/rhythm";
import { addRational, createRational, IRational, TT } from "abc-parser";
```

#### Helper Functions for Tests

```typescript
function selectAll(root: any, tags: string[]): Set<number> {
  const ids = new Set<number>();
  for (const tag of tags) {
    const nodes = findByTag(root, tag);
    for (const node of nodes) {
      ids.add(node.id);
    }
  }
  return ids;
}

function sumDurations(root: any): IRational {
  // Sum durations of all notes, rests, chords, and y-spacers
  const nodes = [
    ...findByTag(root, TAGS.Note),
    ...findByTag(root, TAGS.Rest),
    ...findByTag(root, TAGS.Chord),
    ...findByTag(root, TAGS.YSPACER),
  ];
  let sum = createRational(0, 1);
  for (const node of nodes) {
    sum = addRational(sum, getNodeRhythm(node));
  }
  return sum;
}

function countByTag(root: any, tag: string): number {
  return findByTag(root, tag).length;
}

function hasTie(node: any): boolean {
  let current = node.firstChild;
  while (current !== null) {
    if (isTokenNode(current) && getTokenData(current).tokenType === TT.TIE) {
      return true;
    }
    current = current.nextSibling;
  }
  return false;
}

function getPitchFromNote(node: any): string | null {
  // Extract pitch string from a Note node for comparison
  let current = node.firstChild;
  while (current !== null) {
    if (current.tag === TAGS.Pitch) {
      let pitch = "";
      let child = current.firstChild;
      while (child !== null) {
        if (isTokenNode(child)) {
          pitch += getTokenData(child).lexeme;
        }
        child = child.nextSibling;
      }
      return pitch || null;
    }
    current = current.nextSibling;
  }
  return null;
}
```

#### Example-Based Tests

```typescript
describe("legato", () => {
  describe("example-based tests", () => {
    it("single rest after note: C z D becomes C2 D", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      expect(formatted).to.contain("C2");
      expect(formatted).to.contain("D");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("multiple rests after note: C z z z D becomes C4 D", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z z z D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      expect(formatted).to.contain("C4");
      expect(formatted).to.contain("D");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("rest at bar boundary: C z | z z D produces tied notes across bars", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z | z z D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // The result should have a tie across the bar line
      expect(formatted).to.match(/C2-\s*\|/);
      expect(formatted).to.contain("D");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("chord with rest: [CE] z G becomes [CE]2 G", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\n[CE] z G|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Chord, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      expect(formatted).to.contain("[CE]2");
      expect(formatted).to.contain("G");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("chord to chord: [CE] z [CG] becomes [CE]2 [CG]", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\n[CE] z [CG]|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Chord, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      expect(formatted).to.contain("[CE]2");
      expect(formatted).to.contain("[CG]");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("rest at end with no following note: C z z z | becomes C4 | (no trailing tie)", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z z z|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      expect(formatted).to.contain("C4");
      // No trailing tie since there is no following note
      expect(formatted).not.to.match(/C4-/);
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("y-spacer as target: C y D becomes C2 D", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC y D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.YSPACER])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      expect(formatted).to.contain("C2");
      expect(formatted).to.contain("D");
      expect(countByTag(root, TAGS.YSPACER)).to.equal(0);
    });

    it("no source before rest: z C stays unchanged", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nz C|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // The rest should remain because there was no preceding note
      expect(countByTag(root, TAGS.Rest)).to.equal(1);
      expect(formatted).to.match(/z\s+C/);
    });

    it("grace group is not a source: {B}C z D becomes {B}C2 D (C is the source)", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\n{B}C z D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest, TAGS.Grace_group])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // The grace group B should still be present, and C should fill the rest
      expect(formatted).to.contain("{B}");
      expect(formatted).to.contain("C2");
      expect(formatted).to.contain("D");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("multi-measure rest is not a target: C Z D stays unchanged for Z", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC Z D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.MultiMeasureRest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // Multi-measure rest Z should not be replaced
      expect(formatted).to.contain("Z");
    });

    it("multi-measure rest resets source: C Z z D leaves z unchanged", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC Z z D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.MultiMeasureRest, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // The Z resets the source, so the z after Z should remain as a rest
      expect(formatted).to.contain("Z");
      expect(countByTag(root, TAGS.Rest)).to.equal(1);
    });

    it("selection ends mid-bar: C z with D outside becomes C2 (no trailing tie)", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z D|\n");
      // Select only C and z, not D
      const notes = findByTag(root, TAGS.Note);
      const rests = findByTag(root, TAGS.Rest);
      const sel: Selection = {
        root,
        cursors: [new Set([notes[0].id, rests[0].id])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // Should become C2 with no trailing tie since D is not in selection
      expect(formatted).to.contain("C2");
      expect(formatted).not.to.match(/C2-/);
    });

    it("empty selection is a no-op", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z D|\n");
      const sel: Selection = {
        root,
        cursors: [new Set()],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // Tree should be unchanged
      expect(countByTag(root, TAGS.Rest)).to.equal(1);
      expect(formatted).to.match(/C\s+z\s+D/);
    });

    it("selection boundary respected: only selected rests are replaced", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z z D|\n");
      // Select only the first note and first rest
      const notes = findByTag(root, TAGS.Note);
      const rests = findByTag(root, TAGS.Rest);
      const sel: Selection = {
        root,
        cursors: [new Set([notes[0].id, rests[0].id])],
      };
      legato(sel, ctx);
      // Only the first rest should be replaced; the second rest remains
      expect(countByTag(root, TAGS.Rest)).to.equal(1);
    });

    it("different duration rests: C z z/2 D partially consolidates", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z z/2 D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // The two unit-length tied Cs consolidate to C2, but the half-length C remains tied
      expect(formatted).to.contain("C2");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });

    it("rest with explicit duration: C z2 D becomes C3 D", () => {
      const { root, ctx } = toCSTreeWithContext("X:1\nK:C\nC z2 D|\n");
      const sel: Selection = {
        root,
        cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
      };
      legato(sel, ctx);
      const formatted = formatSelection(sel);
      // The rest has duration 2, so C (duration 1) + z2 (duration 2) = C3
      expect(formatted).to.contain("C3");
      expect(formatted).to.contain("D");
      expect(countByTag(root, TAGS.Rest)).to.equal(0);
    });
  });
```

#### Property-Based Tests

```typescript
  describe("property-based tests", () => {
    const genNoteOrRest = fc.constantFrom("C", "D", "E", "z");
    const genSequence = fc.array(genNoteOrRest, { minLength: 2, maxLength: 8 });

    it("idempotence: applying legato twice yields the same result as once", () => {
      fc.assert(
        fc.property(genSequence, (elements) => {
          const source = "X:1\nK:C\n" + elements.join(" ") + "|\n";
          const { root: root1, ctx: ctx1 } = toCSTreeWithContext(source);
          const sel1: Selection = {
            root: root1,
            cursors: [selectAll(root1, [TAGS.Note, TAGS.Rest])],
          };
          legato(sel1, ctx1);
          const afterOnce = formatSelection(sel1);

          const { root: root2, ctx: ctx2 } = toCSTreeWithContext(afterOnce);
          const sel2: Selection = {
            root: root2,
            cursors: [selectAll(root2, [TAGS.Note, TAGS.Rest])],
          };
          legato(sel2, ctx2);
          const afterTwice = formatSelection(sel2);

          expect(afterTwice).to.equal(afterOnce);
        }),
        { numRuns: 100 }
      );
    });

    it("total duration is preserved", () => {
      fc.assert(
        fc.property(genSequence, (elements) => {
          const source = "X:1\nK:C\n" + elements.join(" ") + "|\n";
          const { root, ctx } = toCSTreeWithContext(source);

          const durationBefore = sumDurations(root);

          const sel: Selection = {
            root,
            cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
          };
          legato(sel, ctx);

          const durationAfter = sumDurations(root);

          expect(durationAfter.numerator * durationBefore.denominator).to.equal(
            durationBefore.numerator * durationAfter.denominator
          );
        }),
        { numRuns: 100 }
      );
    });

    it("rest count is non-increasing", () => {
      fc.assert(
        fc.property(genSequence, (elements) => {
          const source = "X:1\nK:C\n" + elements.join(" ") + "|\n";
          const { root, ctx } = toCSTreeWithContext(source);

          const restCountBefore = countByTag(root, TAGS.Rest);

          const sel: Selection = {
            root,
            cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
          };
          legato(sel, ctx);

          const restCountAfter = countByTag(root, TAGS.Rest);

          expect(restCountAfter).to.be.at.most(restCountBefore);
        }),
        { numRuns: 100 }
      );
    });

    it("note count is non-decreasing", () => {
      fc.assert(
        fc.property(genSequence, (elements) => {
          const source = "X:1\nK:C\n" + elements.join(" ") + "|\n";
          const { root, ctx } = toCSTreeWithContext(source);

          const noteCountBefore = countByTag(root, TAGS.Note);

          const sel: Selection = {
            root,
            cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
          };
          legato(sel, ctx);

          const noteCountAfter = countByTag(root, TAGS.Note);

          // Notes either stay the same or increase (rests become notes)
          expect(noteCountAfter).to.be.at.least(noteCountBefore);
        }),
        { numRuns: 100 }
      );
    });

    it("pitch content is preserved: every pitch in output appears in input", () => {
      fc.assert(
        fc.property(genSequence, (elements) => {
          const source = "X:1\nK:C\n" + elements.join(" ") + "|\n";
          const { root, ctx } = toCSTreeWithContext(source);

          // Collect pitches before
          const pitchesBefore = new Set<string>();
          for (const note of findByTag(root, TAGS.Note)) {
            const pitch = getPitchFromNote(note);
            if (pitch) pitchesBefore.add(pitch);
          }

          const sel: Selection = {
            root,
            cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
          };
          legato(sel, ctx);

          // Collect pitches after
          const pitchesAfter = new Set<string>();
          for (const note of findByTag(root, TAGS.Note)) {
            const pitch = getPitchFromNote(note);
            if (pitch) pitchesAfter.add(pitch);
          }

          // Every pitch in output should have been in input
          for (const pitch of pitchesAfter) {
            expect(pitchesBefore.has(pitch)).to.be.true;
          }
        }),
        { numRuns: 100 }
      );
    });

    it("no orphaned ties in single-bar sequences", () => {
      fc.assert(
        fc.property(genSequence, (elements) => {
          const source = "X:1\nK:C\n" + elements.join(" ") + "|\n";
          const { root, ctx } = toCSTreeWithContext(source);

          const sel: Selection = {
            root,
            cursors: [selectAll(root, [TAGS.Note, TAGS.Rest])],
          };
          legato(sel, ctx);

          // Check that every note with a tie has a following note
          const notes = findByTag(root, TAGS.Note);
          for (let i = 0; i < notes.length; i++) {
            if (hasTie(notes[i])) {
              // There should be a following note
              expect(i).to.be.lessThan(notes.length - 1);
            }
          }
        }),
        { numRuns: 100 }
      );
    });
  });
});
```

### To Do List for Phase 2

1. Create the file `editor/src/transforms/legato.ts` with the complete transform implementation as specified above, including all imports, type definitions, helper functions, traversal logic, replacement logic, trailing tie removal, and the main `legato` export function.

2. Update `editor/src/transforms/index.ts` by adding the line `export { legato } from "./legato";` at the end of the file.

3. Update `editor/src/index.ts` by adding `legato,` to the transforms export block (after `divideRhythm,`).

4. Create the file `editor/tests/legato.spec.ts` with the complete test suite as specified above, including imports, helper functions, example-based tests (12 test cases), and property-based tests (4 properties).

5. Final verification: run `npm run build` and `npm run test` from the repository root to ensure the build succeeds and all tests pass.

6. Call the code review agent on the changes. Address any feedback by fixing issues and re-running tests.

7. Commit once the build passes and all tests pass. Use commit message format: `legato: implement core transform` with a body describing that this is Phase 2 of the legato transform plan.

---

## Phase 3: Language Server and VSCode Integration

### Goal

Register the `legato` transform in the language server and add a VSCode command.

### Files to Modify

| File | Action |
|------|--------|
| `abc-lsp-server/src/transformLookup.ts` | Add legato to imports and TRANSFORM_MAP |
| `abc-lsp-server/src/server.ts` | Add legato to TRANSFORM_NODE_TAGS |
| `vscode-extension/src/transformCommands.ts` | Add legato to simpleTransforms array |
| `vscode-extension/package.json` | Register command |

### Changes to transformLookup.ts

```typescript
// Add to imports:
import {
  // ... existing imports ...
  legato,
} from "editor";

// Add to TRANSFORM_MAP:
const TRANSFORM_MAP: Record<string, TransformFn> = {
  // ... existing entries ...
  legato: (sel, ctx) => legato(sel, ctx),
};
```

### Changes to transformCommands.ts

```typescript
// Add to simpleTransforms array:
const simpleTransforms: Array<[string, string]> = [
  // ... existing entries ...
  ["abc.legato", "legato"],
];
```

### Changes to package.json

```json
{
  "contributes": {
    "commands": [
      // ... existing commands ...
      {
        "command": "abc.legato",
        "title": "ABC: Legato"
      }
    ]
  }
}
```

### Changes to server.ts

Because the legato transform needs to see Notes, Chords, Rests, and YSpacers in order to process them, we need to add an entry to `TRANSFORM_NODE_TAGS`:

```typescript
// Add to TRANSFORM_NODE_TAGS in server.ts:
const TRANSFORM_NODE_TAGS: Record<string, string[]> = {
  // ... existing entries ...
  legato: [TAGS.Note, TAGS.Chord, TAGS.Rest, TAGS.YSPACER],
};
```

This ensures that when a user selects a range, all Notes, Chords, Rests, and YSpacers within that range are included in the selection for the legato transform to process.

### Testing

Manual integration testing:
1. Select a passage containing notes and rests
2. Invoke "ABC: Legato" command
3. Verify rests are replaced with tied copies
4. Verify consolidation occurs within bars

### To Do List for Phase 3

1. Update `abc-lsp-server/src/transformLookup.ts` to import and register `legato`.
2. Update `abc-lsp-server/src/server.ts` to add `legato` to `TRANSFORM_NODE_TAGS` with the value `[TAGS.Note, TAGS.Chord, TAGS.Rest, TAGS.YSPACER]`.
3. Update `vscode-extension/src/transformCommands.ts` to add the command to `simpleTransforms`.
4. Update `vscode-extension/package.json` to register the command.
5. Final verification: build and tests both pass.
6. Call the code review agent. Address any feedback.
7. Commit once the build passes and all tests pass.
