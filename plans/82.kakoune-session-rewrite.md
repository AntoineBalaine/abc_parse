# Rewrite KakouneSession to Match kak-lsp Test Infrastructure

## Table of Contents

1. [Overview](#overview)
2. [Reference Implementation](#reference-implementation)
3. [Key Patterns from kak-lsp](#key-patterns-from-kak-lsp)
4. [Hook Flow and Verification Points](#hook-flow-and-verification-points)
5. [Phase 1: Fresh HOME and Environment Setup](#phase-1-fresh-home-and-environment-setup)
6. [Phase 2: Startup with -e Flag and kak-lsp](#phase-2-startup-with--e-flag-and-kak-lsp)
7. [Phase 3: Verification Methods and Test Updates](#phase-3-verification-methods-and-test-updates)

---

## Overview

The current `KakouneSession` implementation attempts to inject configuration into kakoune after startup via `kak -p`. This approach is unreliable because hooks need to be established before buffers are opened. The kak-lsp test infrastructure uses a different pattern: it creates a fresh HOME directory with a pre-written kakrc, then starts kakoune with `-n -e` to load that configuration at startup time.

This plan rewrites `KakouneSession` to follow the kak-lsp pattern exactly, including kak-lsp integration.

## Key Patterns from kak-lsp

The following patterns from kak-lsp test infrastructure must be adopted:

1. **Prerequisite checks** - Tests check for required commands before running (e.g., `command -v kak-lsp`)

2. **Trap-based cleanup** - Use `process.on('exit', ...)` to ensure cleanup runs on any exit, not just normal test completion

3. **Atomic startup with file edit** - The `start()` method accepts an optional file path to edit, appended to the `-e` flag for atomicity

4. **Cleanup waits for kakoune exit** - Poll until kakoune is fully stopped before killing tmux

5. **Conditional XDG variables** - Only set XDG_CONFIG_HOME and XDG_RUNTIME_DIR if they're already defined in the environment

6. **Fixed session name** - Use `session` instead of random names (simpler, one test at a time)

## Reference Implementation

Local path: `/Users/antoine/Documents/personnel/experiments/abc/kakoune-lsp/test/lib.sh`

GitHub: https://github.com/kakoune-lsp/kakoune-lsp/blob/master/test/lib.sh

Key functions to review:
- `test_tmux_kak_start()` (lines 48-62): Kakoune startup sequence
- `test_tmux()` (lines 69-77): tmux invocation with relative socket
- `test_cleanup()` (lines 104-115): Cleanup sequence
- Lines 17-46: Environment setup (fresh HOME, kakrc creation, XDG variables)

## Hook Flow and Verification Points

When opening an `.abc` or `.abcx` file, the following hooks fire in sequence. Each step must be verified using FIFO-based queries via `kak -p`. The same hooks handle both extensions because `abc.kak` uses regex patterns like `filetype=(?:abc|abcx)`.

```
1. edit test.abc (or test.abcx)
   ↓
2. BufCreate hook fires (abc.kak line 56 for .abc, line 61 for .abcx)
   → Sets filetype to "abc" or "abcx"
   → VERIFY: query '$kak_opt_filetype' == 'abc' (or 'abcx')

3. BufSetOption filetype=(?:abc|abcx) hook fires (abc.kak line 68)
   → Configures lsp_servers for abc-lsp
   → VERIFY: query '$kak_opt_lsp_servers' contains 'abc-lsp'

4. WinSetOption filetype=(?:abc|abcx) hook fires (abc.kak line 79)
   → Calls lsp-enable-window
   → Sets up semantic token hooks
   → VERIFY: query '%opt{lsp_diagnostic_count}' exists (lsp is enabled)

5. kak-lsp starts abc-lsp
   → VERIFY: check *debug* buffer contains "Starting language server abc-lsp"
   → OR: wait for abc-lsp socket to exist

6. Selectors/transforms work
   → VERIFY: run abc-select-notes, check selections changed
```

---

## Phase 1: Fresh HOME and Environment Setup

### Goal

Create a fresh HOME directory structure before starting kakoune, matching the kak-lsp pattern exactly.

### Required imports

```typescript
import { execSync } from 'child_process';
import { existsSync, mkdirSync, writeFileSync, unlinkSync, readdirSync } from 'fs';
import { join, dirname } from 'path';
```

### Changes to `abc-kak/test/helpers/kakoune-session.ts`

#### New properties

```typescript
testHome: string;           // Fresh HOME directory (from mktemp -d)
testEnv: NodeJS.ProcessEnv; // Environment variables for all execSync calls
session: string = 'session'; // Fixed session name (matches kak-lsp pattern)
cleanupRegistered: boolean = false; // Track if process exit handler is registered
resultFifo: string;         // Path to FIFO for kakoune query results
currentBuffer: string | undefined; // Currently open buffer path
```

#### Static method: `checkPrerequisites()`

Because this check must run before any instance is created, it is a static method that tests call explicitly before constructing a `KakouneSession`:

```typescript
static checkPrerequisites(): void {
  // Check required commands (matches kak-lsp's # REQUIRES pattern)
  try {
    execSync('command -v tmux', { stdio: 'ignore' });
  } catch {
    throw new Error('tmux is required but not installed');
  }

  try {
    execSync('command -v kak', { stdio: 'ignore' });
  } catch {
    throw new Error('kakoune is required but not installed');
  }

  try {
    execSync('command -v kak-lsp', { stdio: 'ignore' });
  } catch {
    throw new Error('kak-lsp is required but not installed');
  }

  // Check required build artifacts
  const abcKakDir = dirname(dirname(__dirname)); // abc-kak/test/helpers -> abc-kak
  const clientPath = join(abcKakDir, 'dist', 'abc-kak-client.js');
  const serverPath = join(abcKakDir, 'dist', 'server.js');

  if (!existsSync(clientPath)) {
    throw new Error(`abc-kak-client.js not found at ${clientPath}. Run 'npm run build' first.`);
  }
  if (!existsSync(serverPath)) {
    throw new Error(`server.js not found at ${serverPath}. Run 'npm run build' first.`);
  }
}
```

#### New method: `createTestEnvironment()`

This method creates the directory structure and FIFO:

```
testHome/
  .config/
    kak/
      kakrc
    kak-lsp/
      (empty, but directory must exist)
  .tmux.conf
  kak-result.fifo
  xdg_runtime_dir/    (mode 700, if XDG_RUNTIME_DIR was set)
```

Complete implementation:

```typescript
createTestEnvironment(): void {
  // Create fresh HOME directory
  this.testHome = execSync('mktemp -d', { encoding: 'utf-8' }).trim();

  // Validate that testHome was created and is empty (safety check)
  if (!existsSync(this.testHome)) {
    throw new Error(`Failed to create testHome directory: ${this.testHome}`);
  }
  const contents = readdirSync(this.testHome);
  if (contents.length > 0) {
    throw new Error(`testHome is not empty: ${this.testHome}`);
  }

  // Compute paths
  const abcKakDir = dirname(dirname(__dirname)); // abc-kak/test/helpers -> abc-kak
  const clientPath = join(abcKakDir, 'dist', 'abc-kak-client.js');
  const serverPath = join(abcKakDir, 'dist', 'server.js');
  const socketPath = join(this.testHome, 'abc-lsp.sock');

  // Create directory structure
  const kakConfigDir = join(this.testHome, '.config', 'kak');
  const kakLspConfigDir = join(this.testHome, '.config', 'kak-lsp');
  mkdirSync(kakConfigDir, { recursive: true });
  mkdirSync(kakLspConfigDir, { recursive: true });

  // Generate kakrc content with computed absolute paths
  const kakrc = `# Load kak-lsp commands
evaluate-commands %sh{kak-lsp}

# Debug output for troubleshooting
set-option global lsp_debug true

# Enable LSP when a window is displayed
hook global -once WinDisplay .* lsp-enable

# Source abc plugin files
source "${join(abcKakDir, 'rc', 'abc.kak')}"
source "${join(abcKakDir, 'rc', 'abc-selectors.kak')}"
source "${join(abcKakDir, 'rc', 'abc-transforms.kak')}"
source "${join(abcKakDir, 'rc', 'abc-modes.kak')}"

# Override abc plugin options with test-specific paths
set-option global abc_client_path "${clientPath}"
set-option global abc_server_path "${serverPath}"
set-option global abc_socket_path "${socketPath}"
`;

  writeFileSync(join(kakConfigDir, 'kakrc'), kakrc);

  // Create .tmux.conf
  writeFileSync(join(this.testHome, '.tmux.conf'), 'set -sg escape-time 25\n');

  // Build environment variables conditionally (matches kak-lsp pattern)
  this.testEnv = {
    ...process.env,
    HOME: this.testHome,
    TMPDIR: this.testHome,
  };

  // Only override XDG variables if they're already set in the environment
  if (process.env.XDG_CONFIG_HOME !== undefined) {
    this.testEnv.XDG_CONFIG_HOME = join(this.testHome, '.config');
  }
  if (process.env.XDG_RUNTIME_DIR !== undefined) {
    const xdgRuntime = join(this.testHome, 'xdg_runtime_dir');
    mkdirSync(xdgRuntime, { mode: 0o700 });
    this.testEnv.XDG_RUNTIME_DIR = xdgRuntime;
  }

  // Create FIFO for query results (done here so it's ready before start())
  this.resultFifo = join(this.testHome, 'kak-result.fifo');
  execSync(`mkfifo ${this.resultFifo}`, { cwd: this.testHome, env: this.testEnv });
}
```

#### Updated constructor

Because `resultFifo` is now created inside `createTestEnvironment()`, the constructor is simpler:

```typescript
constructor() {
  this.session = 'session';  // Fixed name, matches kak-lsp
  this.createTestEnvironment();
  this.registerCleanupHandler();
}

registerCleanupHandler(): void {
  if (this.cleanupRegistered) return;
  this.cleanupRegistered = true;

  // Trap-based cleanup: runs on any exit (matches kak-lsp's trap EXIT)
  process.on('exit', () => {
    this.cleanup();
  });
}
```

#### Updated cleanup()

Must follow the kak-lsp cleanup sequence exactly, with a force-kill fallback if polling times out:

```typescript
cleanup(): void {
  // Guard against cleanup being called multiple times
  if (!this.testHome || !existsSync(this.testHome)) {
    return;
  }

  // 1. Send kill! to kakoune
  try {
    execSync(`echo 'kill!' | kak -p ${this.session}`, {
      cwd: this.testHome,
      env: this.testEnv
    });
  } catch {
    // Kakoune may already be gone
  }

  // 2. Wait for kakoune to exit (poll with timeout, matches test_sleep_until)
  const start = Date.now();
  let kakouneExited = false;
  while (Date.now() - start < 10000) {  // 10 second timeout
    try {
      execSync(`kak -c ${this.session} -ui dummy -e quit`, {
        cwd: this.testHome,
        env: this.testEnv,
        stdio: 'ignore'
      });
      // If we get here, kakoune is still running
      execSync('sleep 0.1');
    } catch {
      // Connection failed = kakoune is stopped
      kakouneExited = true;
      break;
    }
  }

  // 3. Force-kill if polling timed out (kakoune is hung)
  if (!kakouneExited) {
    try {
      // Find and kill the kakoune process by session name
      execSync(`pkill -f "kak -s ${this.session}"`, { stdio: 'ignore' });
    } catch {
      // Process may not exist
    }
  }

  // 4. Small delay
  execSync('sleep 0.1');

  // 5. Kill tmux server
  try {
    execSync('tmux -S .tmux-socket kill-server', {
      cwd: this.testHome,
      env: this.testEnv,
      stdio: 'ignore'
    });
  } catch {
    // tmux may already be gone
  }

  // 6. Small delay
  execSync('sleep 0.1');

  // 7. Remove entire testHome directory
  try {
    execSync(`rm -rf ${this.testHome}`);
  } catch {
    // Best effort removal
  }
}
```

### Testing

Example-based tests:
1. Verify `testHome` directory is created with correct structure (`.config/kak/kakrc` exists)
2. Verify kakrc contains expected content (check for `evaluate-commands %sh{kak-lsp}`)
3. Verify kakrc contains abc plugin sources (check for `source.*abc.kak`)
4. Verify `.tmux.conf` contains exactly `set -sg escape-time 25`
5. Verify `xdg_runtime_dir` has mode 700 when `XDG_RUNTIME_DIR` is set in environment
6. Verify `resultFifo` is created in `testHome` directory
7. Verify cleanup removes entire directory (call cleanup, then check `existsSync(testHome) === false`)
8. Verify `checkPrerequisites()` throws when `tmux` is not found (mock `execSync`)
9. Verify `checkPrerequisites()` throws when build artifacts are missing

Property-based tests:

1. Sequential sessions leave no state behind

   Invariants:
   - For N sequential sessions (N in [2, 5]):
     - Each session gets a unique `testHome` path
     - After cleanup, `existsSync(testHome) === false`
     - No `/tmp/*` directories matching the testHome pattern remain after final cleanup

   ```typescript
   it('sequential sessions leave no state behind', () => {
     const paths: string[] = [];
     for (let i = 0; i < 3; i++) {
       const kak = new KakouneSession();
       paths.push(kak.testHome);
       // All paths must be unique
       expect(new Set(paths).size).to.equal(paths.length);
       kak.cleanup();
       // Directory must be removed
       expect(existsSync(kak.testHome)).to.be.false;
     }
   });
   ```

2. Cleanup is idempotent

   Invariant:
   - Calling `cleanup()` multiple times does not throw

   ```typescript
   it('cleanup is idempotent', () => {
     const kak = new KakouneSession();
     kak.cleanup();
     // Second call should not throw
     expect(() => kak.cleanup()).to.not.throw();
   });
   ```

### To do

1. Add required imports (`execSync`, `existsSync`, `mkdirSync`, `writeFileSync`, `unlinkSync`, `readdirSync`, `join`, `dirname`)
2. Add properties to `KakouneSession`: `testHome`, `testEnv`, `cleanupRegistered`, `resultFifo`, `currentBuffer`
3. Change `session` to fixed value `'session'`
4. Add static `checkPrerequisites()` method to verify tmux, kak, kak-lsp, and build artifacts
5. Implement `createTestEnvironment()` method with:
   - Fresh HOME via `mktemp -d` with empty validation
   - Computed paths using `dirname(dirname(__dirname))`
   - Generated kakrc content with absolute paths
   - `.tmux.conf` with escape-time
   - Conditional XDG variable setup
   - FIFO creation (`resultFifo`)
6. Add `registerCleanupHandler()` for trap-based cleanup via `process.on('exit')`
7. Update constructor to call `createTestEnvironment()` and `registerCleanupHandler()`
8. Update `cleanup()` to:
   - Guard against multiple calls (check `testHome` exists)
   - Send `kill!` to kakoune
   - Poll until kakoune exits (10s timeout)
   - Force-kill via `pkill` if polling times out
   - Kill tmux server
   - Remove `testHome` recursively
9. Write example-based tests for environment setup
10. Write property-based tests for sequential sessions and idempotent cleanup
11. Final verification: build and tests both pass
12. Call the code review agent. Address any feedback.
13. Commit once the build passes and all tests pass.

---

## Phase 2: Startup with -e Flag and kak-lsp

### Goal

Start kakoune with the `-e` flag to load configuration at startup, matching the kak-lsp pattern.

### Reference

See `test_tmux_kak_start()` in `/Users/antoine/Documents/personnel/experiments/abc/kakoune-lsp/test/lib.sh` (lines 48-62).

### Changes to `abc-kak/test/helpers/kakoune-session.ts`

#### Updated `start()` method

The method accepts an optional command to execute atomically at startup (matches kak-lsp's `test_tmux_kak_start` which accepts `$@`). Because FIFO is already created by `createTestEnvironment()`, we just need to start tmux and kakoune:

```typescript
start(initialCommand?: string): void {
  // Start tmux session (must run from testHome for relative socket)
  execSync(
    'tmux -S .tmux-socket -f .tmux.conf new-session -d -x 80 -y 24 /bin/sh',
    { cwd: this.testHome, env: this.testEnv }
  );

  // macOS workaround: dimensions may not apply on new-session
  try {
    execSync('tmux -S .tmux-socket resize-window -x 80 -y 24',
      { cwd: this.testHome, env: this.testEnv });
  } catch {}

  // Build the startup command (matches kak-lsp lib.sh exactly)
  const autoload = `
    find -L "$kak_runtime/autoload" -type f -name "*.kak" |
    sed "s/.*/try %{ source & } catch %{ echo -debug Autoload: could not load & }/"
  `;
  const loadDefaultConfig = `
    evaluate-commands %sh{${autoload}}
    source "$HOME/.config/kak/kakrc"
  `;

  // Append initial command if provided (atomic startup + edit)
  const fullConfig = initialCommand
    ? `${loadDefaultConfig}; ${initialCommand}`
    : loadDefaultConfig;

  // Escape single quotes for shell
  const escapedConfig = fullConfig.replace(/'/g, "'\\''");

  // Start kakoune with -n -e
  execSync(
    `tmux -S .tmux-socket send-keys "kak -s ${this.session} -n -e '${escapedConfig}'" Enter`,
    { cwd: this.testHome, env: this.testEnv }
  );

  // Sleep for synchronization (1s local, 10s CI)
  const sleepDuration = process.env.CI ? 10 : 1;
  execSync(`sleep ${sleepDuration}`, { cwd: this.testHome, env: this.testEnv });

  // Verify kakoune started
  const sessionName = this.query('$kak_session');
  if (sessionName.trim() !== this.session) {
    this.cleanup();
    throw new Error(`Kakoune session mismatch: expected ${this.session}, got ${sessionName.trim()}`);
  }

  // If initial command opened a file, track it
  if (initialCommand && initialCommand.startsWith('edit ')) {
    this.currentBuffer = initialCommand.substring(5).trim();
  }
}
```

Usage example for atomic startup with file edit:
```typescript
kak.start(`edit ${testFile}`);  // Opens file atomically at startup
```

#### Updated `send()` method

```typescript
send(commands: string): void {
  execSync(`kak -p ${this.session}`, {
    input: commands,
    cwd: this.testHome,
    env: this.testEnv
  });
}
```

#### Updated `sendKeys()` method

```typescript
sendKeys(keys: string): void {
  execSync(
    `tmux -S .tmux-socket send-keys -t ${this.session} '${keys}' Enter`,
    { cwd: this.testHome, env: this.testEnv }
  );
  // Small delay for kakoune to process
  execSync('sleep 0.1', { cwd: this.testHome, env: this.testEnv });
}
```

#### Updated `edit()` method

Filetype is now set automatically by BufCreate hook, so no manual setting needed:

```typescript
edit(filePath: string): void {
  this.sendKeys(`: edit ${filePath}`);
  this.currentBuffer = filePath;
}
```

#### Remove methods

- Remove `loadKakLsp()` - kak-lsp is loaded via kakrc at startup
- Remove `loadAbcPlugin()` - abc plugin is loaded via kakrc at startup

### Testing

Example-based tests:
1. Start session and verify `$kak_session` matches expected name
2. Verify kak-lsp commands exist by querying for `lsp-status` (no error)
3. Verify abc plugin loaded by checking `abc-select-notes` command exists
4. Verify atomic startup with edit command opens the file (check `$kak_bufname`)
5. Verify startup without edit command opens scratch buffer

Property-based tests:

1. Sequential start/cleanup cycles complete without error

   Invariants:
   - For N cycles (N in [3, 5]):
     - `start()` does not throw
     - `query('$kak_session')` returns `'session'`
     - `cleanup()` does not throw
     - After cleanup, `existsSync(testHome) === false`

   ```typescript
   it('sequential start/cleanup cycles complete without error', () => {
     for (let i = 0; i < 5; i++) {
       const kak = new KakouneSession();
       expect(() => kak.start()).to.not.throw();
       expect(kak.query('$kak_session').trim()).to.equal('session');
       kak.cleanup();
       expect(existsSync(kak.testHome)).to.be.false;
     }
   });
   ```

### To do

1. Update `start(initialCommand?: string)` with:
   - Exact kak-lsp startup sequence
   - Optional command appended to `-e` for atomic startup
   - Track `currentBuffer` if command is an edit
2. Update `send()` to use `{ cwd: this.testHome, env: this.testEnv }`
3. Update `sendKeys()` to use `{ cwd: this.testHome, env: this.testEnv }`
4. Update `edit()` to remove manual filetype setting
5. Remove `loadKakLsp()` method
6. Remove `loadAbcPlugin()` method
7. Final verification: build and tests both pass
8. Call the code review agent. Address any feedback.
9. Commit once the build passes and all tests pass.

---

## Phase 3: Verification Methods and Test Updates

### Goal

Add FIFO-based verification methods to check each step of the hook flow, and update tests to use them.

### Changes to `abc-kak/test/helpers/kakoune-session.ts`

#### New verification methods

```typescript
verifyFiletype(expected: string): void {
  const actual = this.query('$kak_opt_filetype');
  if (actual.trim() !== expected) {
    throw new Error(`Filetype verification failed: expected '${expected}', got '${actual.trim()}'`);
  }
}

verifyLspServersConfigured(): void {
  const servers = this.query('$kak_opt_lsp_servers');
  if (!servers.includes('abc-lsp')) {
    throw new Error(`lsp_servers not configured for abc-lsp. Got: ${servers}`);
  }
}

verifyLspEnabled(): void {
  // If lsp-enable-window ran, lsp_diagnostic_count option exists
  try {
    this.query('%opt{lsp_diagnostic_count}');
  } catch {
    throw new Error('LSP not enabled: lsp_diagnostic_count option not found');
  }
}

getDebugBuffer(): string {
  // Switch to debug buffer, get content, switch back
  const content = this.query('%val{selection}', '*debug*');
  return content;
}

verifyAbcLspStarted(): void {
  const debug = this.getDebugBuffer();
  if (!debug.includes('Starting language server abc-lsp') &&
      !debug.includes('abc-lsp')) {
    throw new Error(`abc-lsp not started. Debug buffer: ${debug}`);
  }
}

verifyHookFlow(): void {
  // Verify all hooks in the abc file loading flow fired correctly
  // Both .abc and .abcx files use the same hooks (see abc.kak BufSetOption regex)
  if (this.currentBuffer?.endsWith('.abc')) {
    this.verifyFiletype('abc');
    this.verifyLspServersConfigured();
    this.verifyLspEnabled();
  } else if (this.currentBuffer?.endsWith('.abcx')) {
    this.verifyFiletype('abcx');
    this.verifyLspServersConfigured();
    this.verifyLspEnabled();
  }
}
```

#### New method: `editAndVerify()`

Opens a file and verifies each step of the hook flow. Handles both `.abc` and `.abcx` files:

```typescript
editAndVerify(filePath: string): void {
  this.sendKeys(`: edit ${filePath}`);
  this.currentBuffer = filePath;

  // Allow hooks to fire
  execSync('sleep 0.3', { cwd: this.testHome, env: this.testEnv });

  // Verify hook flow for abc-related files
  if (filePath.endsWith('.abc')) {
    this.verifyFiletype('abc');
    this.verifyLspServersConfigured();
    this.verifyLspEnabled();
  } else if (filePath.endsWith('.abcx')) {
    this.verifyFiletype('abcx');
    this.verifyLspServersConfigured();
    this.verifyLspEnabled();
  }
}
```

#### Remove properties and methods no longer needed

- Remove `kakLspProcess` property
- Remove `socketPath` property (abc-lsp socket is now in testHome)
- Remove `editAndWaitForLsp()` method (replaced by `editAndVerify()`)

### Changes to `abc-kak/test/abc-selectors.test.ts`

#### Updated test structure

Uses atomic startup with file edit for efficiency:

```typescript
describe('abc-kak selectors', () => {
  let kak: KakouneSession;
  let testFile: string;

  beforeEach(() => {
    kak = new KakouneSession();
    testFile = join(kak.testHome, 'test.abc');
  });

  afterEach(() => {
    kak.cleanup();
  });

  describe('environment setup', () => {
    it('sets filetype when opening .abc file', () => {
      writeFileSync(testFile, 'X:1\nT:Test\nK:C\nCDEF\n');
      kak.start(`edit ${testFile}`);  // Atomic startup + edit
      kak.verifyFiletype('abc');
    });

    it('configures lsp_servers for abc-lsp', () => {
      writeFileSync(testFile, 'X:1\nT:Test\nK:C\nCDEF\n');
      kak.start(`edit ${testFile}`);
      kak.verifyLspServersConfigured();
    });

    it('enables LSP', () => {
      writeFileSync(testFile, 'X:1\nT:Test\nK:C\nCDEF\n');
      kak.start(`edit ${testFile}`);
      kak.verifyLspEnabled();
    });
  });

  describe('selectors', () => {
    it('abc-select-notes returns valid selection descriptors', () => {
      writeFileSync(testFile, 'X:1\nT:Test\nK:C\nCDEF\n');
      kak.start(`edit ${testFile}`);
      kak.verifyHookFlow();  // Verify all hooks fired

      kak.executeKeys('%');  // Select all
      const result = kak.commandAndQuery('abc-select-notes', '$kak_selections_desc');

      expect(result).to.not.equal('1.1,1.1');
      expect(result).to.match(/^\d+\.\d+,\d+\.\d+/);
    });
  });

  describe('transforms', () => {
    it('abc-transpose modifies buffer content', () => {
      writeFileSync(testFile, 'X:1\nT:Test\nK:C\nCDEF\n');
      kak.start(`edit ${testFile}`);
      kak.verifyHookFlow();

      kak.executeKeys('gg3j');  // Go to first note
      const before = kak.getSelection();
      expect(before).to.equal('C');

      kak.send(`evaluate-commands -buffer ${testFile} %{ abc-transpose 12 }`);
      execSync('sleep 0.3');  // Allow transform to complete

      kak.executeKeys('gg3j');
      const after = kak.getSelection();
      expect(after).to.equal('c');  // C + 12 semitones = c
    });
  });
});
```

#### Remove

- Remove `lspAvailable` flag
- Remove conditional test skipping
- Remove debug logging from previous troubleshooting

### Testing

Example-based tests:
1. `verifyFiletype()` throws when filetype is wrong
2. `verifyLspServersConfigured()` throws when abc-lsp not in config
3. `verifyLspEnabled()` throws when LSP not enabled
4. `editAndVerify()` succeeds for valid `.abc` file
5. `editAndVerify()` succeeds for valid `.abcx` file
6. `verifyHookFlow()` sets correct filetype for `.abc` vs `.abcx`
7. Selector command returns valid selections
8. Transform command modifies content

Property-based tests:

1. Verification methods are consistent across multiple calls

   Invariants:
   - Calling `verifyFiletype('abc')` twice returns without error (state is stable)
   - Calling `verifyLspServersConfigured()` twice returns without error

   ```typescript
   it('verification methods are consistent across multiple calls', () => {
     const kak = new KakouneSession();
     const testFile = join(kak.testHome, 'test.abc');
     writeFileSync(testFile, 'X:1\nK:C\nCDEF\n');
     kak.start(`edit ${testFile}`);

     // First call
     kak.verifyFiletype('abc');
     kak.verifyLspServersConfigured();

     // Second call should produce same result
     kak.verifyFiletype('abc');
     kak.verifyLspServersConfigured();

     kak.cleanup();
   });
   ```

2. Both .abc and .abcx files trigger LSP configuration

   Invariants:
   - For both extensions, `lsp_servers` contains `'abc-lsp'`
   - For both extensions, `lsp_diagnostic_count` option exists

   ```typescript
   it('both .abc and .abcx files trigger LSP configuration', () => {
     for (const ext of ['.abc', '.abcx']) {
       const kak = new KakouneSession();
       const testFile = join(kak.testHome, `test${ext}`);
       writeFileSync(testFile, 'X:1\nK:C\nCDEF\n');
       kak.start(`edit ${testFile}`);

       kak.verifyLspServersConfigured();
       kak.verifyLspEnabled();

       kak.cleanup();
     }
   });
   ```

### To do

1. Add verification methods:
   - `verifyFiletype(expected: string)`
   - `verifyLspServersConfigured()`
   - `verifyLspEnabled()`
   - `getDebugBuffer()`
   - `verifyAbcLspStarted()`
   - `verifyHookFlow()` (handles both `.abc` and `.abcx` files)
2. Add `editAndVerify()` method (handles both `.abc` and `.abcx` files)
3. Remove `kakLspProcess`, `socketPath` properties
4. Remove `editAndWaitForLsp()` method
5. Update `abc-selectors.test.ts` with new test structure using atomic startup
6. Add tests for `.abcx` files alongside `.abc` tests
7. Remove `lspAvailable` flag and conditional skipping
8. Remove debug logging from previous troubleshooting
9. Write example-based tests for verification methods
10. Write property-based tests for verification consistency and extension handling
11. Final verification: build and tests both pass
12. Call the code review agent. Address any feedback.
13. Commit once the build passes and all tests pass.

---

## Summary

After implementing all three phases:

1. `KakouneSession` creates a fresh, isolated test environment matching kak-lsp exactly
2. Static `checkPrerequisites()` verifies tmux, kak, kak-lsp, and build artifacts before tests run
3. `createTestEnvironment()` computes all paths at runtime with validated testHome directory
4. FIFO is created during environment setup, before `start()` is called
5. Kakoune starts with all configuration loaded via `-e` flag
6. Atomic startup with file edit prevents race conditions
7. kak-lsp is properly integrated and enables LSP for both `.abc` and `.abcx` files
8. Fixed session name (`session`) simplifies debugging
9. Conditional XDG variables work correctly on macOS
10. Trap-based cleanup ensures resources are freed on any exit
11. Cleanup includes force-kill fallback if polling times out
12. Cleanup is idempotent (guards against multiple calls)
13. Each step of the hook flow can be verified via FIFO queries
14. Verification methods handle both `.abc` and `.abcx` file extensions
15. Tests include concrete property-based test invariants
16. The approach exactly matches the proven kak-lsp test infrastructure
