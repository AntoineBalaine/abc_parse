# Plan: ABCLS Directive Auto-Completion

## Table of Contents
1. Outline
2. Phase 1: Completion Infrastructure
3. Phase 2: Directive Name Completion
4. Phase 3: Option Value Completion
5. Verification

---

## Outline

### Goal
Add auto-completion support for ABCLS directives (`%%abcls-fmt`, `%%abcls-parse`, `%%abcls-voices`) in the LSP server so users get help as they type.

### Scope

In scope:
- Completion triggers on `%%` at the start of a line
- Directive name completion: `abcls-fmt`, `abcls-parse`, `abcls-voices`
- Option completion for `%%abcls-parse`: `linear`
- Option completion for `%%abcls-fmt`: `system-comments`, `voice-markers=inline`, `voice-markers=infoline`
- Mode completion for `%%abcls-voices`: `show`, `hide`

Out of scope:
- Context-aware voice ID suggestions for `%%abcls-voices`
- Standard ABC directive completion (only ABCLS directives for now)
- Multi-option completion for `%%abcls-fmt` (only first option is offered)
- Completions do not depend on the document's parsed state (offered statically)

### Design Decisions

1. Completion only triggers when `%%` appears at the very start of a line (no leading whitespace)
2. Because ABC directive names are case-insensitive, we use case-insensitive matching but preserve lowercase in suggestions
3. We use the full label as `insertText` because LSP clients handle replacement of the trigger/prefix
4. After selecting `show` or `hide` for `%%abcls-voices`, no further completions are offered

### Files to Modify

1. `abc-lsp-server/src/completions.ts` - Add directive completion definitions and helper functions
2. `abc-lsp-server/src/server.ts` - Modify completion handler logic
3. `abc-lsp-server/src/completions.spec.ts` (new) - Add tests

### Phases

Phase 1: Completion Infrastructure
- Add `%` as a trigger character
- Create helper to detect directive completion context
- Add directive completion definitions

Phase 2: Directive Name Completion
- Implement logic to detect `%%` at line start
- Return directive name completions when appropriate

Phase 3: Option Value Completion
- Implement context detection for each directive type
- Return appropriate options based on directive context

### Testing Strategy
- Example-based tests for each completion scenario
- Unit tests for context detection helper
- Regression test for existing decoration completion

---

## Phase 1: Completion Infrastructure

### 1.1 Add Directive Completion Definitions

File: `abc-lsp-server/src/completions.ts`

Add new type and constants after `DECORATION_SYMBOLS`:

```typescript
export type DirectiveCompletion = {
  label: string;
  documentation: string;
};

export const ABCLS_DIRECTIVES: DirectiveCompletion[] = [
  {
    label: "abcls-fmt",
    documentation: "Formatter configuration directive. Options: system-comments, voice-markers=inline/infoline",
  },
  {
    label: "abcls-parse",
    documentation: "Parser configuration directive. Options: linear",
  },
  {
    label: "abcls-voices",
    documentation: "Voice filtering directive. Syntax: show/hide <voiceIds...>",
  },
];

export const ABCLS_PARSE_OPTIONS: DirectiveCompletion[] = [
  {
    label: "linear",
    documentation: "Enable linear (interleaved voice) parsing mode",
  },
];

export const ABCLS_FMT_OPTIONS: DirectiveCompletion[] = [
  {
    label: "system-comments",
    documentation: "Insert empty comment lines between systems in linear tunes",
  },
  {
    label: "voice-markers=inline",
    documentation: "Convert voice markers to inline [V:id] style",
  },
  {
    label: "voice-markers=infoline",
    documentation: "Convert voice markers to info line V:id style",
  },
];

export const ABCLS_VOICES_OPTIONS: DirectiveCompletion[] = [
  {
    label: "show",
    documentation: "Include only the specified voices in output",
  },
  {
    label: "hide",
    documentation: "Exclude the specified voices from output",
  },
];
```

### 1.2 Add Trigger Character

File: `abc-lsp-server/src/server.ts`

Update the completion provider configuration at line 181:

```typescript
triggerCharacters: ["!", "%"],
```

### 1.3 Add Context Detection Helper

File: `abc-lsp-server/src/completions.ts`

Add a discriminated union type and helper function:

```typescript
export type DirectiveCompletionContext =
  | { type: "none" }
  | { type: "directive-name"; prefix: string }
  | { type: "abcls-parse-options"; prefix: string }
  | { type: "abcls-fmt-options"; prefix: string }
  | { type: "abcls-voices-options"; prefix: string };

/**
 * Determines the type of directive completion needed based on the line content
 * and cursor position. Because textBeforeCursor is the text from the start of
 * the line up to the cursor, the regex /^%%/ only matches when %% appears at
 * the very beginning of the line with no preceding whitespace.
 */
export function getDirectiveCompletionContext(
  lineText: string,
  charPosition: number
): DirectiveCompletionContext {
  const textBeforeCursor = lineText.slice(0, charPosition);

  // Check if we're after %% at line start (no leading whitespace allowed)
  if (!textBeforeCursor.match(/^%%/)) {
    return { type: "none" };
  }

  // Extract what's after %%
  const afterPercent = textBeforeCursor.slice(2);

  // Check for specific directive contexts (case-insensitive)
  // We trim the captured prefix to handle multiple spaces gracefully
  const abclsParseMatch = afterPercent.match(/^abcls-parse\s+(.*)$/i);
  if (abclsParseMatch) {
    return { type: "abcls-parse-options", prefix: abclsParseMatch[1].trim() };
  }

  const abclsFmtMatch = afterPercent.match(/^abcls-fmt\s+(.*)$/i);
  if (abclsFmtMatch) {
    return { type: "abcls-fmt-options", prefix: abclsFmtMatch[1].trim() };
  }

  const abclsVoicesMatch = afterPercent.match(/^abcls-voices\s+(.*)$/i);
  if (abclsVoicesMatch) {
    return { type: "abcls-voices-options", prefix: abclsVoicesMatch[1].trim() };
  }

  // If just %% or %%<partial>, offer directive names
  return { type: "directive-name", prefix: afterPercent };
}
```

### 1.4 Tests for Phase 1

File: `abc-lsp-server/src/completions.spec.ts` (new file)

```typescript
import { expect } from "chai";
import { describe, it } from "mocha";
import { getDirectiveCompletionContext } from "./completions";

describe("getDirectiveCompletionContext", () => {
  describe("non-directive lines", () => {
    it("returns none for music content", () => {
      const result = getDirectiveCompletionContext("C D E F", 4);
      expect(result.type).to.equal("none");
    });

    it("returns none for %% mid-line", () => {
      const result = getDirectiveCompletionContext("C D %% E", 6);
      expect(result.type).to.equal("none");
    });

    it("returns none for %% with leading whitespace", () => {
      const result = getDirectiveCompletionContext("  %%", 4);
      expect(result.type).to.equal("none");
    });
  });

  describe("directive name context", () => {
    it("returns directive-name with empty prefix after %%", () => {
      const result = getDirectiveCompletionContext("%%", 2);
      expect(result.type).to.equal("directive-name");
      if (result.type === "directive-name") {
        expect(result.prefix).to.equal("");
      }
    });

    it("returns directive-name with partial prefix", () => {
      const result = getDirectiveCompletionContext("%%abc", 5);
      expect(result.type).to.equal("directive-name");
      if (result.type === "directive-name") {
        expect(result.prefix).to.equal("abc");
      }
    });

    it("returns directive-name for full directive without space", () => {
      const result = getDirectiveCompletionContext("%%abcls-fmt", 11);
      expect(result.type).to.equal("directive-name");
      if (result.type === "directive-name") {
        expect(result.prefix).to.equal("abcls-fmt");
      }
    });
  });

  describe("abcls-parse options context", () => {
    it("returns abcls-parse-options after directive name and space", () => {
      const result = getDirectiveCompletionContext("%%abcls-parse ", 14);
      expect(result.type).to.equal("abcls-parse-options");
      if (result.type === "abcls-parse-options") {
        expect(result.prefix).to.equal("");
      }
    });

    it("handles multiple spaces between directive and option", () => {
      const result = getDirectiveCompletionContext("%%abcls-parse   ", 16);
      expect(result.type).to.equal("abcls-parse-options");
      if (result.type === "abcls-parse-options") {
        expect(result.prefix).to.equal("");
      }
    });

    it("is case-insensitive for directive name", () => {
      const result = getDirectiveCompletionContext("%%ABCLS-PARSE ", 14);
      expect(result.type).to.equal("abcls-parse-options");
    });
  });

  describe("abcls-fmt options context", () => {
    it("returns abcls-fmt-options after directive name and space", () => {
      const result = getDirectiveCompletionContext("%%abcls-fmt ", 12);
      expect(result.type).to.equal("abcls-fmt-options");
    });

    it("includes partial option prefix", () => {
      const result = getDirectiveCompletionContext("%%abcls-fmt sys", 15);
      expect(result.type).to.equal("abcls-fmt-options");
      if (result.type === "abcls-fmt-options") {
        expect(result.prefix).to.equal("sys");
      }
    });
  });

  describe("abcls-voices options context", () => {
    it("returns abcls-voices-options after directive name and space", () => {
      const result = getDirectiveCompletionContext("%%abcls-voices ", 15);
      expect(result.type).to.equal("abcls-voices-options");
    });
  });
});
```

### To Do - Phase 1
- Add `DirectiveCompletion` type and constant arrays to `completions.ts`
- Add `getDirectiveCompletionContext` helper function to `completions.ts`
- Add `%` to trigger characters in `server.ts` (line 181)
- Create `completions.spec.ts` with tests for context detection
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 2: Directive Name Completion

### 2.1 Add Directive Completion Helper Function

File: `abc-lsp-server/src/completions.ts`

Add import at the top of the file:

```typescript
import { CompletionItem, CompletionItemKind } from "vscode-languageserver";
```

Add the following function after `getDirectiveCompletionContext`:

```typescript
/**
 * Creates completion items from a directive options array, filtering by prefix.
 * This consolidated helper is used for all directive option completions.
 */
export function getDirectiveCompletions(
  options: DirectiveCompletion[],
  prefix: string,
  kind: CompletionItemKind
): CompletionItem[] {
  return options
    .filter((d) => d.label.toLowerCase().startsWith(prefix.toLowerCase()))
    .map((directive, index) => ({
      label: directive.label,
      kind,
      documentation: directive.documentation,
      insertText: directive.label,
      data: { type: "directive-completion", index },
    }));
}
```

### 2.2 Update Completion Handler

File: `abc-lsp-server/src/server.ts`

Add import for the new functions (update existing import from `./completions`):

```typescript
import {
  DECORATION_SYMBOLS,
  getDirectiveCompletionContext,
  getDirectiveCompletions,
  ABCLS_DIRECTIVES,
  ABCLS_PARSE_OPTIONS,
  ABCLS_FMT_OPTIONS,
  ABCLS_VOICES_OPTIONS,
} from "./completions";
```

Refactor the `onCompletion` handler (lines 414-443) to check directive completion first before decoration completion:

```typescript
connection.onCompletion((textDocumentPosition: TextDocumentPositionParams): CompletionItem[] => {
  const uri = textDocumentPosition.textDocument.uri;
  const doc = abcServer.abcDocuments.get(uri);
  if (!doc) {
    return [];
  }

  const position = textDocumentPosition.position;
  const lineText = doc.document.getText().split("\n")[position.line] || "";
  const charPosition = position.character;

  // Check for directive completion first (takes precedence)
  const directiveContext = getDirectiveCompletionContext(lineText, charPosition);
  if (directiveContext.type === "directive-name") {
    return getDirectiveCompletions(ABCLS_DIRECTIVES, directiveContext.prefix, CompletionItemKind.Keyword);
  }

  // Existing decoration completion logic (only if not in directive context)
  const char = abcServer.findCharInDoc(uri, charPosition, position.line);
  if (char === "!") {
    return DECORATION_SYMBOLS.map((symbol, index) => ({
      data: index + 1,
      documentation: symbol.documentation,
      kind: CompletionItemKind.Text,
      insertText: symbol.label.replace(/[!]/g, ""),
      label: symbol.label,
    }));
  }

  return [];
});
```

### 2.3 Tests for Phase 2

Add to `completions.spec.ts`:

```typescript
import {
  getDirectiveCompletionContext,
  getDirectiveCompletions,
  ABCLS_DIRECTIVES,
} from "./completions";
import { CompletionItemKind } from "vscode-languageserver";

describe("getDirectiveCompletions", () => {
  describe("directive name completions", () => {
    it("returns all directives when prefix is empty", () => {
      const result = getDirectiveCompletions(ABCLS_DIRECTIVES, "", CompletionItemKind.Keyword);
      expect(result).to.have.length(3);
      expect(result.map((r) => r.label)).to.include.members([
        "abcls-fmt",
        "abcls-parse",
        "abcls-voices",
      ]);
    });

    it("filters by prefix case-insensitively", () => {
      const result = getDirectiveCompletions(ABCLS_DIRECTIVES, "abcls-f", CompletionItemKind.Keyword);
      expect(result).to.have.length(1);
      expect(result[0].label).to.equal("abcls-fmt");
    });

    it("returns empty array for non-matching prefix", () => {
      const result = getDirectiveCompletions(ABCLS_DIRECTIVES, "xyz", CompletionItemKind.Keyword);
      expect(result).to.have.length(0);
    });

    it("sets correct completion item kind", () => {
      const result = getDirectiveCompletions(ABCLS_DIRECTIVES, "", CompletionItemKind.Keyword);
      expect(result.every((r) => r.kind === CompletionItemKind.Keyword)).to.be.true;
    });

    it("uses full label as insertText", () => {
      const result = getDirectiveCompletions(ABCLS_DIRECTIVES, "abcls-f", CompletionItemKind.Keyword);
      expect(result[0].insertText).to.equal("abcls-fmt");
    });
  });
});
```

### To Do - Phase 2
- Add `CompletionItem` and `CompletionItemKind` import to `completions.ts`
- Add `getDirectiveCompletions` helper function to `completions.ts`
- Update imports in `server.ts` to include new completion functions and constants
- Refactor `onCompletion` handler in `server.ts` to call directive completion logic
- Add tests for directive completions
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Phase 3: Option Value Completion

### 3.1 Extend Completion Handler with Switch Statement

File: `abc-lsp-server/src/server.ts`

Update the `onCompletion` handler to use a switch statement that handles all directive context types:

```typescript
connection.onCompletion((textDocumentPosition: TextDocumentPositionParams): CompletionItem[] => {
  const uri = textDocumentPosition.textDocument.uri;
  const doc = abcServer.abcDocuments.get(uri);
  if (!doc) {
    return [];
  }

  const position = textDocumentPosition.position;
  const lineText = doc.document.getText().split("\n")[position.line] || "";
  const charPosition = position.character;

  // Check for directive completion (takes precedence)
  const directiveContext = getDirectiveCompletionContext(lineText, charPosition);

  switch (directiveContext.type) {
    case "directive-name":
      return getDirectiveCompletions(ABCLS_DIRECTIVES, directiveContext.prefix, CompletionItemKind.Keyword);
    case "abcls-parse-options":
      return getDirectiveCompletions(ABCLS_PARSE_OPTIONS, directiveContext.prefix, CompletionItemKind.Value);
    case "abcls-fmt-options":
      return getDirectiveCompletions(ABCLS_FMT_OPTIONS, directiveContext.prefix, CompletionItemKind.Value);
    case "abcls-voices-options":
      return getDirectiveCompletions(ABCLS_VOICES_OPTIONS, directiveContext.prefix, CompletionItemKind.Value);
    case "none":
      // Fall through to decoration completion
      break;
  }

  // Existing decoration completion logic
  const char = abcServer.findCharInDoc(uri, charPosition, position.line);
  if (char === "!") {
    return DECORATION_SYMBOLS.map((symbol, index) => ({
      data: index + 1,
      documentation: symbol.documentation,
      kind: CompletionItemKind.Text,
      insertText: symbol.label.replace(/[!]/g, ""),
      label: symbol.label,
    }));
  }

  return [];
});
```

### 3.2 Tests for Phase 3

Add to `completions.spec.ts`:

```typescript
import {
  getDirectiveCompletionContext,
  getDirectiveCompletions,
  ABCLS_DIRECTIVES,
  ABCLS_PARSE_OPTIONS,
  ABCLS_FMT_OPTIONS,
  ABCLS_VOICES_OPTIONS,
} from "./completions";
import { CompletionItemKind } from "vscode-languageserver";

describe("option value completions", () => {
  describe("abcls-parse options", () => {
    it("returns linear option", () => {
      const result = getDirectiveCompletions(ABCLS_PARSE_OPTIONS, "", CompletionItemKind.Value);
      expect(result).to.have.length(1);
      expect(result[0].label).to.equal("linear");
    });

    it("filters by partial prefix", () => {
      const result = getDirectiveCompletions(ABCLS_PARSE_OPTIONS, "lin", CompletionItemKind.Value);
      expect(result).to.have.length(1);
      expect(result[0].label).to.equal("linear");
    });

    it("returns empty for non-matching prefix", () => {
      const result = getDirectiveCompletions(ABCLS_PARSE_OPTIONS, "xyz", CompletionItemKind.Value);
      expect(result).to.have.length(0);
    });
  });

  describe("abcls-fmt options", () => {
    it("returns all fmt options", () => {
      const result = getDirectiveCompletions(ABCLS_FMT_OPTIONS, "", CompletionItemKind.Value);
      expect(result).to.have.length(3);
      expect(result.map((r) => r.label)).to.include.members([
        "system-comments",
        "voice-markers=inline",
        "voice-markers=infoline",
      ]);
    });

    it("filters voice-markers options by prefix", () => {
      const result = getDirectiveCompletions(ABCLS_FMT_OPTIONS, "voice", CompletionItemKind.Value);
      expect(result).to.have.length(2);
      expect(result.every((r) => r.label.startsWith("voice"))).to.be.true;
    });

    it("uses Value kind for options", () => {
      const result = getDirectiveCompletions(ABCLS_FMT_OPTIONS, "", CompletionItemKind.Value);
      expect(result.every((r) => r.kind === CompletionItemKind.Value)).to.be.true;
    });
  });

  describe("abcls-voices options", () => {
    it("returns show and hide options", () => {
      const result = getDirectiveCompletions(ABCLS_VOICES_OPTIONS, "", CompletionItemKind.Value);
      expect(result).to.have.length(2);
      expect(result.map((r) => r.label)).to.include.members(["show", "hide"]);
    });

    it("filters to show only", () => {
      const result = getDirectiveCompletions(ABCLS_VOICES_OPTIONS, "s", CompletionItemKind.Value);
      expect(result).to.have.length(1);
      expect(result[0].label).to.equal("show");
    });

    it("filters to hide only", () => {
      const result = getDirectiveCompletions(ABCLS_VOICES_OPTIONS, "h", CompletionItemKind.Value);
      expect(result).to.have.length(1);
      expect(result[0].label).to.equal("hide");
    });
  });
});
```

### To Do - Phase 3
- Update `onCompletion` handler in `server.ts` to use switch statement for all context types
- Add tests for each option type (parse, fmt, voices)
- Final verification: build and tests both pass
- Call the code review agent. Address any feedback.
- Commit once the build passes and all tests pass.

---

## Verification

### Manual Testing

1. Open an ABC file in VS Code with the ABC LSP extension
2. Type `%%` at the start of a new line - should see `abcls-fmt`, `abcls-parse`, `abcls-voices`
3. Type `%%abcls-fmt ` - should see `system-comments`, `voice-markers=inline`, `voice-markers=infoline`
4. Type `%%abcls-parse ` - should see `linear`
5. Type `%%abcls-voices ` - should see `show`, `hide`
6. Verify partial prefix filtering works (e.g., `%%abcls-f` shows only `abcls-fmt`)
7. Verify existing decoration completion still works (type `!` in tune body)

### Automated Testing

```bash
cd workspace/abc_parse
npm run test
```

All new tests in `abc-lsp-server/src/completions.spec.ts` should pass.
