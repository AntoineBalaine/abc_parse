# ABCT Language Specification

A domain-specific language for transforming ABC music notation scores.

## Table of Contents

1. [Philosophy](#philosophy)
2. [Operators](#operators)
3. [Location References](#location-references)
4. [Selectors](#selectors)
5. [Grammar](#grammar)
6. [Semantics](#semantics)
7. [Diagnostics](#diagnostics)
8. [LSP Integration](#lsp-integration)
9. [Examples](#examples)

---

## Philosophy

- Unix-style: input, transform, output (stdout by default)
- Functional pipelines operating on AST via visitors
- Lens-based focusing: select, transform, reintegrate
- LSP-friendly for real-time preview

---

## Operators

| Operator  | Meaning                                           |
| --------- | ------------------------------------------------- |
| `\|`      | Pipe: pass output forward (context lost)          |
| `\|=`     | Update: focus, transform, reintegrate, pass whole |
| `+`       | Concatenate ABC fragments                         |
| `@`       | Selector (semantic or positional)                 |
| `=`       | Variable binding (suppresses output)              |
| `<<...>>` | Inline ABC literal                                |

Comparison operators: `>`, `<`, `>=`, `<=`, `==`, `!=`

Logical operators: `and`, `or`, `not`

---

## Location References

Quickfix list (qflist) format:

```
file.abc                    # whole file
file.abc:10                 # line 10
file.abc:10:5               # line 10, column 5
file.abc:10:5-15            # line 10, columns 5-15
file.abc:10:5-12:20         # line 10 col 5 to line 12 col 20
```

---

## Selectors

After `@`, either full word or single char:

| Full           | Short | Matches                       |
| -------------- | ----- | ----------------------------- |
| `@chords`      | `@c`  | chord groups `[...]`          |
| `@notes`       | `@n`  | individual notes              |
| `@rests`       | `@r`  | rests                         |
| `@bars`        | `@b`  | bar lines, measure boundaries |
| `@voices`      | `@v`  | voice sections                |
| `@decorations` | `@d`  | ornaments, decorations        |
| `@measures`    | `@m`  | measure ranges                |

Combined with locations:

```
file.abc:10:5-15@chords     # chords within that range
file.abc@c                  # all chords in file
```

Voice and measure selection:

```
@V:melody                   # voice named "melody"
@V:1                        # voice index 1
@M:5-8                      # measures 5 through 8
```

---

## Grammar

Precedence from lowest to highest: `|`, `+`, `|=`, `or`, `and`, `not`, comparisons, application.

```
# Program structure
program       = statement*
statement     = assignment | expr

assignment    = identifier '=' expr

# Expression hierarchy (lowest to highest precedence)
expr          = pipeline

pipeline      = concat_term ('|' concat_term)*

concat_term   = update_term ('+' update_term)*

update_term   = selector ('|=' application)?
              | application

selector      = '@' selector_path

application   = logical+

# Logical and comparison operators
logical       = or_term
or_term       = and_term ('or' and_term)*
and_term      = not_term ('and' not_term)*
not_term      = 'not' not_term | comparison
comparison    = atom (cmp_op atom)?
cmp_op        = '>=' | '<=' | '==' | '!=' | '>' | '<'

# Atoms
atom          = '(' expr ')'
              | '[' list_items? ']'
              | abc_literal
              | file_ref
              | number
              | identifier

# Compound constructs
file_ref      = path (':' location)? ('@' selector_path)?
selector_path = identifier (':' (identifier | number | range))?
location      = line (':' col range_end?)?
range_end     = '-' col | '-' line ':' col
range         = number '-' number
list_items    = expr (',' expr)*

# Literals
abc_literal   = '<<' abc_content '>>'

# Terminals (regex notation)
abc_content   = /([^>]|>[^>])*/
path          = /[a-zA-Z0-9_./-]+\.[a-zA-Z0-9]+/
identifier    = /[a-zA-Z_][a-zA-Z0-9_]*/
number        = /-?[0-9]+(\/[0-9]+)?/
line          = /[0-9]+/
col           = /[0-9]+/
```

Comments: `#` introduces a line comment.

Notes:
- `file_ref` is distinguished from `identifier` by having a file extension (`.abc`) or path separators
- `number` includes fractions like `1/2` for duration comparisons
- `application` is one or more `logical` terms (function name followed by arguments)

---

## Semantics

### The Two Pipe Operators

`|` (pipe): extracts and passes forward. Context is lost.

```
src.abc | @chords | transpose 2
```

Output: just the transposed chords (not the whole file).

`|=` (update): focuses, transforms, reintegrates. Context is preserved.

```
src.abc | @chords |= transpose 2
```

Output: the whole file with chords transposed in place.

### Precedence

`|=` binds to a single transform expression. For multiple transforms, use parentheses:

```
@chords |= f | g           # means: (@chords |= f) | g
@chords |= (f | g)         # means: @chords |= (f | g)
```

### Output Summary

| Expression                        | Output                                |
| --------------------------------- | ------------------------------------- |
| `src.abc`                         | whole AST                             |
| `src.abc \| @chords`              | extracted chords only                 |
| `src.abc \| @chords \| f`         | transformed chords only               |
| `src.abc \| @chords \|= f`        | whole AST, chords updated             |
| `src.abc \| @chords \|= f \| g`   | g applied to whole AST                |
| `src.abc \| @chords \|= (f \| g)` | whole AST, chords updated by f then g |

### Empty Selections

When a selector matches nothing:

- With `|=`: no-op, returns AST unchanged (warning emitted)
- With `|`: returns empty (warning emitted)

### Evaluation

- The last expression in the program is the output
- Assignments do not produce output
- Multiple matches: transforms apply to each matching node

### Visitor Model

Visitors and transform functions accept an error reporter as an argument:

```
update(ast, selector, transform, errorReporter):
  for node in ast:
    if selector.matches(node):
      node.replace_with(transform(node, errorReporter))
  return ast
```

### Voice Distribution

The `distribute` function maps multi-part output to voices:

```
@chords |= (choralis 4 | distribute [V:S, V:A, V:T, V:B])
```

Modes: `replace` (default, warns if exists), `merge`, `create` (error if exists).

### Replacement Semantics

- Replace: splits notes at boundaries, removes tie destinations (with warning)
- Merge: adds new content as chord notes
- Duration calculations use the existing time map logic from the multi-voice formatter

---

## Diagnostics

Diagnostics are reported to stderr (CLI) or LSP diagnostic channel (IDE).

Severity levels: `error` (stops pipeline), `warning` (continues), `info`.

Visitors and transform functions accept the error reporter as an argument, allowing transforms to emit diagnostics during execution.

---

## LSP Integration

Standard features: diagnostics, formatting, hover, completion, go to definition.

Syntax highlighting uses semantic tokens.

Custom commands:

| Command                  | Description                                  |
| ------------------------ | -------------------------------------------- |
| `abct.evaluate`          | Evaluate entire file, return ABC             |
| `abct.evaluateToLine`    | Evaluate up to line n (step-by-step preview) |
| `abct.evaluateSelection` | Evaluate selected expression                 |
| `abct.previewSelector`   | Highlight matching nodes in source ABC       |

---

## Examples

### Basic Extraction vs Update

Extract chords (outputs chords only):

```
src.abc | @chords
```

Update chords in place (outputs whole file):

```
src.abc | @chords |= transpose 2
```

### Chaining Transforms

Single transform per selection:

```
src.abc | @chords |= choralis 4 | @bass |= transpose -12
```

Multiple transforms on same selection (parentheses required):

```
src.abc | @chords |= (choralis 4 | drop2 | spread 2)
```

### Nested Selections

Update notes within chords:

```
src.abc | @chords |= (@notes |= transpose 2)
```

### Extract, Transform, Discard Context

Get just the transformed chords (not the whole file):

```
src.abc | @chords | choralis 4 | drop2
```

### Mixed Pipeline

Update chords, then apply a transform to the whole result:

```
src.abc | @chords |= choralis 4 | transpose 2
```

This transposes everything (because `| transpose 2` operates on the whole AST after `|=` completes).

### Variables and Step-by-Step

```
input = song.abc
step1 = input | @chords |= choralis 4
step2 = step1 | @chords |= drop2
result = step2 | @bass |= transpose -12
result
```

### Voice Distribution

```
src.abc | @chords |= (choralis 4 | distribute [V:soprano, V:alto, V:tenor, V:bass])
```

### Inline Patch

Replace a range with literal ABC:

```
src.abc | @1:5-20 |= <<[CEG][FAc][GBd]>>
```

### Filtering (Extract Subset)

Extract only melody voice:

```
src.abc | @V:melody
```

Extract measures 5-12 of melody:

```
src.abc | @V:melody | @M:5-12
```

### Combining Files

```
intro.abc + verse.abc + chorus.abc | @chords |= choralis 4
```

### Complex Arrangement

```
source = lead_sheet.abc

# Voice lead chords and distribute to strings
strings = source | @chords |= (choralis 4 | drop2 | distribute [V:vln1, V:vln2, V:vla, V:vc])

# Transpose melody for trumpet
trumpet = source | @V:melody | transpose 2

# Bass line from chord roots
bass = source | @chords | roots | transpose -12

# Combine (outputs concatenated result)
strings + trumpet + bass
```

### Conditional-like Patterns

Apply transform only to long notes (using filter):

```
src.abc | @notes |= (filter (duration > 1/2) | transpose 2)
```

### Debugging

Insert debug to inspect intermediate values:

```
src.abc | @chords |= (choralis 4 | debug | drop2)
```
